{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"node_modules/hexo-theme-next/source/css/main.styl","path":"css/main.styl","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/css/noscript.styl","path":"css/noscript.styl","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/bookmark.js","path":"js/bookmark.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/comments-buttons.js","path":"js/comments-buttons.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/config.js","path":"js/config.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/next-boot.js","path":"js/next-boot.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/motion.js","path":"js/motion.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/comments.js","path":"js/comments.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/schedule.js","path":"js/schedule.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/pjax.js","path":"js/pjax.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/utils.js","path":"js/utils.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/images/avatar.gif","path":"images/avatar.gif","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/images/logo.svg","path":"images/logo.svg","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/images/logo-algolia-nebula-blue-full.svg","path":"images/logo-algolia-nebula-blue-full.svg","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/schemes/muse.js","path":"js/schemes/muse.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/fancybox.js","path":"js/third-party/fancybox.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/rating.js","path":"js/third-party/rating.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/pace.js","path":"js/third-party/pace.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/quicklink.js","path":"js/third-party/quicklink.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/chat/tidio.js","path":"js/third-party/chat/tidio.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/chat/gitter.js","path":"js/third-party/chat/gitter.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/chat/chatra.js","path":"js/third-party/chat/chatra.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/analytics/baidu-analytics.js","path":"js/third-party/analytics/baidu-analytics.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/math/katex.js","path":"js/third-party/math/katex.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/math/mathjax.js","path":"js/third-party/math/mathjax.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/analytics/growingio.js","path":"js/third-party/analytics/growingio.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/comments/disqus.js","path":"js/third-party/comments/disqus.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/analytics/google-analytics.js","path":"js/third-party/analytics/google-analytics.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/comments/changyan.js","path":"js/third-party/comments/changyan.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/comments/livere.js","path":"js/third-party/comments/livere.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/comments/isso.js","path":"js/third-party/comments/isso.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/comments/gitalk.js","path":"js/third-party/comments/gitalk.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/comments/disqusjs.js","path":"js/third-party/comments/disqusjs.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/comments/utterances.js","path":"js/third-party/comments/utterances.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/search/algolia-search.js","path":"js/third-party/search/algolia-search.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/statistics/firestore.js","path":"js/third-party/statistics/firestore.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/search/local-search.js","path":"js/third-party/search/local-search.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/statistics/lean-analytics.js","path":"js/third-party/statistics/lean-analytics.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/tags/mermaid.js","path":"js/third-party/tags/mermaid.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/tags/pdf.js","path":"js/third-party/tags/pdf.js","modified":1,"renderable":1},{"_id":"source/atom.xml","path":"atom.xml","modified":1,"renderable":0},{"_id":"source/sitemap.xml","path":"sitemap.xml","modified":1,"renderable":0},{"_id":"source/坑.txt","path":"坑.txt","modified":1,"renderable":0},{"_id":"source/uploads/avatar.jpg","path":"uploads/avatar.jpg","modified":1,"renderable":0}],"Cache":[{"_id":"source/atom.xml","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1639015009432},{"_id":"source/sitemap.xml","hash":"b38832fd6016e0bc76a290b2861caefa2c1f31c5","modified":1639015009432},{"_id":"source/坑.txt","hash":"f69c9194e8b0d1d3a94374b9345bb308e76e26f5","modified":1644461823023},{"_id":"source/_drafts/JavaScript变量的作用域.md","hash":"2d5d391bf8811e3490ca211f422f777c29adfcef","modified":1639015009388},{"_id":"source/_drafts/前端性能优化.md","hash":"4c2f2e599165986d72671e157120b4a412eb47e3","modified":1639015009388},{"_id":"source/_drafts/sass预处理.md","hash":"8738b8efa66040ba634122bf3663479fecd362b4","modified":1644214676770},{"_id":"source/_drafts/nuxt打包文件hash.md","hash":"34c1aae866f090fbc42e26c25a4d171d69412565","modified":1641982419245},{"_id":"source/_drafts/uni-app-projec笔记.md","hash":"71d74c66378671e9ca4e8e1b4c37a21d94a119e7","modified":1642990733315},{"_id":"source/_drafts/对象的方法.md","hash":"396add17a93e9aa31712bdb9f734bd3cc726d32f","modified":1642586491256},{"_id":"source/about/index.md","hash":"6ccb27e33f6f842e947554c8912578e004fed9eb","modified":1639015009432},{"_id":"source/schedule/index.md","hash":"1943a488710b98d02b8c1d2774595767710baee5","modified":1639015009432},{"_id":"source/categories/index.md","hash":"7438470a49505f9f0e55151a7937121538e01d7c","modified":1639015009432},{"_id":"source/_drafts/请求跨域.md","hash":"e35ccf7640a2df1dc2ccd55faf63deb7cce98cd0","modified":1639015009388},{"_id":"source/_drafts/React/react学习.md","hash":"a0979c91cbfcab2f9886ea80071ed7168571f212","modified":1644838765072},{"_id":"source/_drafts/JQuery/JQuery学习.md","hash":"924f197455b8da7b787f80ad7d29347f07af6eee","modified":1644200469154},{"_id":"source/tags/index.md","hash":"439295aeeb138fecd88594c6427914c3d6b8c242","modified":1639015009432},{"_id":"source/_drafts/Vue/vue3迁移指南.md","hash":"e9097e686d2978ecde8f14c927a487a46bfbcdc0","modified":1644200469154},{"_id":"source/_drafts/随笔/nginx的使用.md","hash":"9e89e161556deea4096163ff6e9247e8553edb07","modified":1644200469165},{"_id":"source/_drafts/router/router基础.md","hash":"2b2ed5d083c731786727675b5577490e632807ec","modified":1644485166693},{"_id":"source/_drafts/elementUI源码/elementUI源码分析(一).md","hash":"fec3fdf204c48e7ead9fe3e5e2839c3b5ef6b401","modified":1644286321025},{"_id":"source/_drafts/webpack/webpack学习一.md","hash":"2104098db9cd06949a1fc002604eb1eb8283d5b7","modified":1644200469165},{"_id":"source/_drafts/router/router进阶.md","hash":"9955547e390e1e8c6139c2a91fa4d9078a90d7b9","modified":1644835196847},{"_id":"source/_drafts/随笔/npm-package上传.md","hash":"eaf6ae825af3eeb7b46f08103f901fdb08dfa70b","modified":1642990733312},{"_id":"source/_drafts/随笔/JavaScript定时器.md","hash":"aea638b96a7daa8ec02c37dd805602c1d991d216","modified":1642993827235},{"_id":"source/_drafts/随笔/jet-brains文件内容的正则查找和替换.md","hash":"470b77283b0a42360897caffbcca4c2a50d66532","modified":1641883623759},{"_id":"source/_drafts/随笔/字体图标的制作方法.md","hash":"ddb0e6a28e7c5461063181e70cca90e577f9b747","modified":1644200469165},{"_id":"source/_drafts/随笔/vue-css外部引入.md","hash":"149d5ce0a7989982da118574b6d0b3fd76e9a71b","modified":1642668819392},{"_id":"source/_drafts/随笔/css-hover和focus顺序.md","hash":"b07246959bf4b096841829d530a7c5d441ba60c0","modified":1644200469165},{"_id":"source/_drafts/随笔/html标签的data-属性.md","hash":"f03e13493ddbe1d271ca2264bbbb2e59014809b7","modified":1644200469165},{"_id":"source/_posts/CSS/CSS伪类和伪元素.md","hash":"6a6fd99344a0b2b6aec9a567aead642d404c6333","modified":1639015009388},{"_id":"source/_drafts/随笔/媒体查询.md","hash":"af29c99181135c5c0ab66c03c0bae65f78f9da39","modified":1642670707254},{"_id":"source/_posts/CSS/外边距合并.md","hash":"5ab5e313a340822416e6883a5619c6f33538c393","modified":1639015009388},{"_id":"source/_posts/CSS/border-radius的原理和使用.md","hash":"3824c0eeb74912f3762a23af73a489dd46e15938","modified":1639015009388},{"_id":"source/_posts/CSS/CSS-flex.md","hash":"b50f13b1d7ac81f9c20125561fc515213e442b75","modified":1639015009388},{"_id":"source/_posts/CSS/CSS-元素选择器.md","hash":"084ebccb46651fc92002672adf931a194bcf887e","modified":1639015009388},{"_id":"source/_posts/CSS/rem.md","hash":"46f493410313ba74d28b82e7011be51f75939692","modified":1639015009388},{"_id":"source/_posts/CSS/水平垂直居中方法.md","hash":"399a0d0b8dbabaf10bfba92497e2995a1958fb54","modified":1639015009388},{"_id":"source/_posts/JavaScript/call-apply-bind实现.md","hash":"762a2a923e151b6fbd8ebb105474716b475628dc","modified":1639015009404},{"_id":"source/_posts/CSS/margin使用百分号值.md","hash":"b02bc78f71a487caac74c7b886c3741e3df0bf83","modified":1639015009388},{"_id":"source/_posts/JavaScript/WebWorker.md","hash":"af837fe83724ecc22d6b880700a41c680057b34a","modified":1639015009404},{"_id":"source/_posts/JavaScript/JavaScript-parseInt函数.md","hash":"2e348fac1288e054a6f69da0bb07cf63634b8f7b","modified":1639015009404},{"_id":"source/_posts/JavaScript/eval函数.md","hash":"d3f3d8125200def27e893eb5c86de855928fab91","modified":1639015009404},{"_id":"source/_posts/JavaScript/数组的方法.md","hash":"855d739db34ede61405a5083ba73d7c4b5f8cafe","modified":1639015009404},{"_id":"source/_posts/JavaScript/JavaScript浅拷贝和深拷贝.md","hash":"ab0fd2c652a6e1480e0f3c28fa28dcd01e1599ea","modified":1639015009404},{"_id":"source/_posts/JavaScript/JavaScript-map函数.md","hash":"79d981a8108e32e3af107aa3f7dbe484bed3ab8a","modified":1639015009404},{"_id":"source/_posts/HTML/HTML-标签的title.md","hash":"05ea340a7f369e2e269a36fa508680dafda613eb","modified":1639015009388},{"_id":"source/_posts/HTML/块环境上下文.md","hash":"557b2bcc0e4d5bb7b555e466689527c44396003c","modified":1639015009404},{"_id":"source/_posts/Vue/Vue生命周期.md","hash":"7a5a5c17265cc822520fbe51babe23d41cadb10e","modified":1639015009404},{"_id":"source/_posts/Vue/VueRouter两种模式.md","hash":"68c6b2a4fae7a36c32334de7abc56f1b87ef0885","modified":1639015009404},{"_id":"source/_posts/Vue/vue2和vue3的区别.md","hash":"2de7708e384b19d729bad98d8305e9d70190c5fd","modified":1639015009420},{"_id":"source/_posts/Vue/Vue-methods使用箭头函数.md","hash":"5d7c796b22d9ea7035d6bf51153377aa4b538fca","modified":1639015009404},{"_id":"source/_posts/其他/HTTP和HTTPS.md","hash":"feb6037f123e57d1a727e8f11d525d00d7a2cb68","modified":1639015009420},{"_id":"source/_posts/Node JS/Node JS 读取文件.md","hash":"c0a56758acb7dfdcb6191ae2ef3f371d190001bf","modified":1639015009404},{"_id":"source/_posts/Node JS/JavaScript事件循环.md","hash":"b9b67c9f55e32dbee9f858f9babbe957688431f0","modified":1639015009404},{"_id":"source/_posts/其他/Cookie、SessionStorage、LocalStorage的区别.md","hash":"fbe992fc80c1e2045b2b7605127686f02edccd11","modified":1639015009420},{"_id":"source/_posts/其他/状态码.md","hash":"55827f51e740efffdfda8ae808447200f9cab9de","modified":1639015009432},{"_id":"source/_posts/其他/TCP.md","hash":"0e7ccb545a490f15c1f876b278ff8c6b8bf5b8f9","modified":1639015009420},{"_id":"source/_posts/Node JS/NodeJS下载和npm安装.md","hash":"4ce05d8b1738ed17bc8a24c8ffcf29b2c89cace5","modified":1642668858464},{"_id":"source/_posts/随笔/RESTful.md","hash":"1e3fbe81e86733b81e81c77d73e51d3e98db7afc","modified":1639015009432},{"_id":"source/_posts/其他/HTTP概述.md","hash":"320100c59d29df12f2e37b1996a54a9fc0e0e93c","modified":1639015009420},{"_id":"source/_posts/随笔/fetch发送2次请求的原因.md","hash":"eb603feca78e2102c280f487a841c740ce59c8e0","modified":1639015009432},{"_id":"source/_posts/其他/浏览器缓存策略.md","hash":"a38781d7a1bea541b69ae0ee9a1281b8276015a6","modified":1639015009432},{"_id":"source/_posts/随笔/next.md","hash":"abd411e60eac277c40f12335241b81ff9338395a","modified":1639015009432},{"_id":"source/_drafts/debug/zyyx/vue3-slots和-refs.md","hash":"a09215bb50f92ea38966df1f2312fa6f9c387d19","modified":1639027730079},{"_id":"source/_posts/随笔/hexo.md","hash":"eb6a5a4838491be529dc62ef89719cf30257fa37","modified":1639015009432},{"_id":"source/_posts/随笔/Git常用命令.md","hash":"0efaae20eaacb46f67d0ebedf86197792341a1cd","modified":1639015009432},{"_id":"source/_drafts/debug/zyyx/vue3-getElement伪数组.md","hash":"c5e4606e8cb36e37f705cd10edf3eeadea139f22","modified":1639028815368},{"_id":"source/_posts/随笔/浏览器的回流和重绘.md","hash":"a32d9ad790db93f7bd5db6b81903f42894fb5bce","modified":1639015009432},{"_id":"source/_drafts/debug/zyyx/vue3-ref数组.md","hash":"29d734c2c680e73a29dcdda2e8b033c38f6a6cf1","modified":1639028604501},{"_id":"source/_drafts/debug/zyyx/vue3-nextTick.md","hash":"3e2a6398797993d2037481aef79e141f8e46010a","modified":1639028071487},{"_id":"source/_drafts/debug/zyyx/vue3-v-if和v-show.md","hash":"2f103310b481e4535b81416601f180386d7d0a55","modified":1639015827034},{"_id":"source/_drafts/Vue/Vue2-教程/Vue2-教程-可复用性和组合.md","hash":"cfedd6a24f03b0d2706d077a5ae1f06145503123","modified":1644200469154},{"_id":"source/_drafts/Vue/Vue2-教程/Vue2-教程-工具.md","hash":"b41bf4315075a5f5487ed800e16aade1950f1868","modified":1644200469154},{"_id":"source/_drafts/router/源码/router3源码.md","hash":"85f7fb88d582e77dcf4ff4575b0fc0b17fb27091","modified":1644580758727},{"_id":"source/_drafts/Vue/Vue2-教程/Vue2-教程-内在.md","hash":"8e8be7fe7cf7603cbd0526821551c432d83f31a3","modified":1644201286044},{"_id":"source/_drafts/Vue/Vue2-教程/Vue2-教程-过渡和动画.md","hash":"4785588b5252f9385b83c80c6eccd1c9000d1de7","modified":1644201259740},{"_id":"source/_drafts/Vue/Vue2-教程/Vue2-教程-规模化.md","hash":"52099138dbe9b353065443ada7bf73a1ed1b3b89","modified":1644200469154},{"_id":"source/_drafts/随笔/npm-package上传/image-20220122231048580.png","hash":"5632bbb295c70bbaea6ed05fe39b474b50e00cfd","modified":1642990733314},{"_id":"source/_drafts/随笔/jet-brains文件内容的正则查找和替换/image-20220111144213336.png","hash":"32a1acaeefaf109119ef87340f104c4b16349b51","modified":1641883333339},{"_id":"source/_drafts/webpack/webpack学习一/image-20220202191750607.png","hash":"c1287b7c5750fdf92900bdca7c9cbee942538f22","modified":1644200469165},{"_id":"source/_drafts/随笔/jet-brains文件内容的正则查找和替换/image-20220111144559970-16418835623721.png","hash":"0fe2fc23569a973da53804604325b60c3a041e5d","modified":1641883562378},{"_id":"source/_posts/CSS/CSS-flex/image-20211027212431340.png","hash":"39b09cfcbc2f8e4eddfc28ccbbb13f69125c21df","modified":1639015009388},{"_id":"source/_posts/CSS/CSS-flex/image-20211027211015004.png","hash":"34990f8f3cbc5fe8dc9261c3c893d2c3f7f2a4a3","modified":1639015009388},{"_id":"source/_drafts/随笔/jet-brains文件内容的正则查找和替换/image-20220111144559970.png","hash":"0fe2fc23569a973da53804604325b60c3a041e5d","modified":1641883559973},{"_id":"source/_drafts/随笔/jet-brains文件内容的正则查找和替换/image-20220111144549850.png","hash":"c7eea402117cc46592858483ad3b4d20b557f8a5","modified":1641883549851},{"_id":"source/_posts/CSS/CSS-flex/image-20211027210947232.png","hash":"bf81c523b1fcf15c0b6fdded03d3e483cf6b2026","modified":1639015009388},{"_id":"source/_posts/CSS/CSS-flex/image-20211027213217557.png","hash":"2f7de6cc1f1d274b5a44a3779f50593ba652cbd9","modified":1639015009388},{"_id":"source/_posts/CSS/外边距合并/image-20211021103824947.png","hash":"fde159d717951f48d21cc843c4460a7a57a40692","modified":1639015009388},{"_id":"source/_posts/CSS/外边距合并/image-20211020224237425.png","hash":"c38bca6d5f3213bc626ab420adda37161fb5e173","modified":1639015009388},{"_id":"source/_posts/CSS/border-radius的原理和使用/image-20211025104342522.png","hash":"500505d2a73e790555ab1a4e6cfce52c3395113b","modified":1639015009388},{"_id":"source/_posts/CSS/外边距合并/image-20211020224217218.png","hash":"b187be05b0dbde99993c1386de0c34c0280f643c","modified":1639015009388},{"_id":"source/_posts/CSS/CSS-flex/image-20211027214029980.png","hash":"0cd8cdac133cc8d76ae78e7b3b558d6730055085","modified":1639015009388},{"_id":"source/_posts/JavaScript/ES6/async和await的基本使用.md","hash":"7ae1309b37a4704e93ccff224170f56e97a52a15","modified":1639015009404},{"_id":"source/_posts/CSS/border-radius的原理和使用/image-20211025155459099.png","hash":"a83bf7f718c7f04009881c0c6350bd55edfee672","modified":1639015009388},{"_id":"source/_posts/CSS/border-radius的原理和使用/image-20211025104917514.png","hash":"a8fdd5ad0499d195a9437ad22e34dc3aa9ce9f08","modified":1639015009388},{"_id":"source/_posts/JavaScript/概念/JavaScript-冒泡和捕获.md","hash":"549f9e0e4d2d46d507374cc36db3f93937a6d4f7","modified":1639015009404},{"_id":"source/_posts/JavaScript/ES6/JavaScript箭头函数.md","hash":"d1afc42d0c7a5fedb1e5b643101c2210a80a5e02","modified":1639015009404},{"_id":"source/_posts/JavaScript/概念/函数柯里化.md","hash":"2ee0ba69d4d864066c78e26e6ab14db872a3cd95","modified":1639015009404},{"_id":"source/_posts/JavaScript/ES6/JavaScript-ES6解构.md","hash":"ae4a06883bf2d64799c9cad6475d6e93d71389f4","modified":1639015009404},{"_id":"source/_posts/JavaScript/ES6/ES6随笔1.md","hash":"8ef25b1ffaea776f30d71d1d363750c0686b8048","modified":1639015009404},{"_id":"source/_posts/JavaScript/概念/数据类型判断.md","hash":"2a38ac221aa8fb7b88103e18b1fca0cf3d9ecc17","modified":1639015009404},{"_id":"source/_posts/JavaScript/概念/JavaScript原型链.md","hash":"cfd9b5ef327385d4ce9a3ce36f7c1cdd0eb12ccd","modified":1639015009404},{"_id":"source/_posts/JavaScript/概念/数组的emptyItems.md","hash":"b0beac72fe54b4711bb4bbae773cde760bcfad8d","modified":1639015009404},{"_id":"source/_posts/JavaScript/概念/迭代器.md","hash":"3b509de86b6b52ccdcefb734d6a1ad65de0fa001","modified":1642751161580},{"_id":"source/_posts/JavaScript/随笔/if in 用法.md","hash":"7f8ebe84b420ba62f0a156547176304cb765061a","modified":1644822660610},{"_id":"source/_posts/HTML/块环境上下文/image-20211022161542404.png","hash":"11a9d691555352c1eb281b44692504a7c4a0b694","modified":1639015009404},{"_id":"source/_posts/HTML/HTML-标签的title/image-20211030223916508.png","hash":"aaf82386c2b210b59485b6ffb94b8a471a1d3963","modified":1639015009403},{"_id":"source/_posts/JavaScript/概念/高阶函数.md","hash":"4675422a5dd25f074bff727ebe5d4ece4bfb15a0","modified":1639015009404},{"_id":"source/_posts/JavaScript/概念/JavaScript类型转换.md","hash":"0d84cad3cc5a64c200adc20322a6b431229eea98","modified":1639015009404},{"_id":"source/_posts/JavaScript/随笔/js遍历对象的方法.md","hash":"a96af131a099734585e46472c92b8bc4a1da1bf2","modified":1644822660610},{"_id":"source/_posts/HTML/块环境上下文/image-20211022110540794.png","hash":"a355acd642404c3a7f119e4d2ca3bb14d978ee6d","modified":1639015009404},{"_id":"source/_posts/Vue/Vue生命周期/lifecycle.png","hash":"53345be1363e09b3e43e34d27c030c4f376b060a","modified":1639015009404},{"_id":"source/_posts/Node JS/JavaScript事件循环/image-20211107211640084.png","hash":"baac3f40a26378e3399a7a3ecfb094227d73fb91","modified":1639015009404},{"_id":"source/_posts/Vue/Vue生命周期/lifecycle9.jpg","hash":"ea85b53c2ea6a92284e7bec52620fd65b3687b3c","modified":1639015009420},{"_id":"source/_posts/其他/HTTP概述/image-20211024100324347.png","hash":"f7fec974df9c56a7b7815b913a07b54af72c87c0","modified":1639015009420},{"_id":"source/_posts/Vue/Vue2教程/Vue2-教程-深入了解组件.md","hash":"5782111d7c703b0aa9f22f8a792f6b8e9508b525","modified":1638499086179},{"_id":"source/_posts/随笔/next/image-20211018110937363.png","hash":"e33626d3447b1c540912566a42211dd65ef806d4","modified":1639015009432},{"_id":"source/_posts/随笔/浏览器的回流和重绘/painted and re-render.jpg","hash":"e5fa9cac965abb215a05d9ee03059441a573e680","modified":1639015009432},{"_id":"source/_posts/Node JS/NodeJS下载和npm安装/image-20211228140948410-16406717947501.png","hash":"0439ce9a1f18c52dfebe6afa3a919b8eb7f9668e","modified":1640671794756},{"_id":"source/_drafts/Vue/Vue2-教程/Vue2-教程-内在/image-20211214103613477.png","hash":"cdeea2221f4ff03d1bc0309846fbd1dba1bc24ba","modified":1644200469154},{"_id":"source/_drafts/Vue/Vue2-教程/Vue2-教程-过渡和动画/image-20211203152116522.png","hash":"b17af8eebb47c876248f856635beb1b7e5cac285","modified":1644200469154},{"_id":"source/_drafts/Vue/Vue2-教程/Vue2-教程-过渡和动画/image-20211203154333481.png","hash":"58d59fab936f987c1f7736f573f5bc0cf301b882","modified":1644200469154},{"_id":"source/_drafts/router/源码/router3源码/image-20220211173522407.png","hash":"1dbd0a5bea2d9b6e26a025f9c4fc249077d04941","modified":1644572122412},{"_id":"source/_drafts/router/源码/router4/router4源码.md","hash":"f1d9b7e813f0e8cf8b7ca86f3bf9613faaf05853","modified":1644822660609},{"_id":"source/_drafts/router/源码/router3源码/image-20220211174408513.png","hash":"978d48bb37f23f3a7eb7de4e327a5630d29d1ad3","modified":1644572648524},{"_id":"source/_drafts/router/源码/router3源码/image-20220211175816841.png","hash":"d6dde08028a5d6e2e787cfe7f064a9d178c66a60","modified":1644573496856},{"_id":"source/_drafts/router/源码/router3源码/image-20220211173002676.png","hash":"610815f1d24edf7435f0249be4ec9a9a7c995070","modified":1644571802684},{"_id":"source/_drafts/router/源码/router3源码/image-20220211175019270.png","hash":"ed196da2ae36972d119f713500c2e7c1ea670280","modified":1644573019280},{"_id":"source/_drafts/router/源码/router3源码/image-20220211175554195.png","hash":"9f7f9466c36a223fae8cc914d49d449227dc03c8","modified":1644573354205},{"_id":"source/_drafts/router/源码/router3源码/image-20220211180402862.png","hash":"bd9c78da56a44ea2386ed6015340b67bbbc283b9","modified":1644573842883},{"_id":"source/_drafts/router/源码/router3源码/image-20220211185433641.png","hash":"0dce47cc150304618b09cc60357284c35815d4a7","modified":1644576873648},{"_id":"source/_drafts/router/源码/router3源码/image-20220211184544135.png","hash":"8d6bdfcf1ff273909e5821c5566e07acea438f78","modified":1644576344148},{"_id":"source/_drafts/router/源码/router3源码/image-20220211190158819.png","hash":"d894942552b23c6136d8ad6482c3e2baede81718","modified":1644577318830},{"_id":"source/_drafts/router/源码/router3源码/image-20220211191050870.png","hash":"0919813f3ad10fadeecdb651aee45f44309a79a4","modified":1644577850887},{"_id":"source/_posts/JavaScript/概念/JavaScript原型链/image-20211110101346723.png","hash":"93762b483e0e557337e9e624a7d7b07789b42419","modified":1639015009404},{"_id":"source/_posts/JavaScript/概念/JavaScript原型链/image-20211110100356010.png","hash":"136541b9bb45661a522e9c05135c25ed38bebe5c","modified":1639015009404},{"_id":"source/_posts/Vue/Vue2教程/Vue2-教程-基础使用/lifecycle.png","hash":"53345be1363e09b3e43e34d27c030c4f376b060a","modified":1639015009404},{"_id":"source/_posts/JavaScript/概念/JavaScript类型转换/image-20211019105728109.png","hash":"1d245a7f45d02b2ba8c51b3ee8fd3ac25aa03009","modified":1639015009404},{"_id":"source/uploads/avatar.jpg","hash":"5f4ab51a8d0af1455145ce56be7e01f6736f8a5c","modified":1639015009432},{"_id":"source/_posts/Vue/Vue2教程/Vue2-教程-基础使用/image-20211105095952701.png","hash":"0ca710835c8a45962fd69153462961a59bab075a","modified":1639015009404},{"_id":"source/_drafts/webpack/webpack学习一/image-20220202191945426.png","hash":"f291459ce253a59bf765a1e04278c38e1d852544","modified":1644200469165},{"_id":"source/_posts/Vue/Vue2教程/Vue2-教程-基础使用.md","hash":"d16a16a66d8091ec35145883d157f512f260da03","modified":1639015009404},{"_id":"source/_posts/其他/TCP/image-20211106102234899.png","hash":"9fa19fb8051342a48b1b3a2e4be0a5919285efea","modified":1639015009420},{"_id":"source/_posts/其他/TCP/image-20211106102459740.png","hash":"50dbf1cf3c1c331688bb8d376b1ed9d6302d6f04","modified":1639015009430},{"_id":"source/_posts/其他/TCP/image-20211106102433477.png","hash":"9ac8637d32e1c1c3cba0368425ed67333f61b644","modified":1639015009420},{"_id":"source/_posts/其他/TCP/image-20211106102310315.png","hash":"9ab8ce6c9f390dc32264a876d806fe8c700a0ee1","modified":1639015009420},{"_id":"source/_posts/随笔/next/image-20211018110658046.png","hash":"b131a9bdba8d0e200391d37d321d6080625995bc","modified":1639015009432},{"_id":"source/_posts/随笔/next/image-20211018105920422.png","hash":"e341d7152de219128a727e35346895e097fb2264","modified":1639015009432},{"_id":"source/_drafts/router/源码/router3源码/image-20220211173238506.png","hash":"abc67f304118412d2ce3db9b71962be662a7bb63","modified":1644571958525},{"_id":"source/_drafts/router/源码/router3源码/image-20220211190859440.png","hash":"27a3279eeb6e210eaa227ebb3936c0d34824ff9b","modified":1644577739458},{"_id":"source/_posts/JavaScript/概念/JavaScript-冒泡和捕获/image-20210907141230550.png","hash":"811c784be4ff3b10f97e204b4134683fe82af25f","modified":1639015009404},{"_id":"source/_posts/其他/HTTP概述/image-20211024104204389.png","hash":"0f667867be62f3e6c81582c5ce4d48f26e960852","modified":1639015009420},{"_id":"source/_posts/其他/TCP/image-20211106103554196.png","hash":"76622b090956f9630d2d779042effb7bcf271fbe","modified":1639015009432},{"_id":"source/_posts/其他/TCP/image-20211106102333564.png","hash":"2b43d26ca2bf1052f0570578cbac54cfecd8b42b","modified":1639015009420},{"_id":"source/_posts/其他/TCP/image-20211106102538627.png","hash":"e28b7868d0523bbe2205983e121dd1ea45873c91","modified":1639015009432},{"_id":"source/_posts/JavaScript/概念/JavaScript原型链/290701352241158.jpg","hash":"5c2fdb4880a69ec4a76137d5fcc56ee42a0aebf7","modified":1639015009404},{"_id":"node_modules/hexo-theme-next/_vendors.yml","hash":"5949493e1390c34e094aee96489db37b4c3ad2ee","modified":1639015666595},{"_id":"node_modules/hexo-theme-next/package.json","hash":"0fdce9f5b80e6757be715953a19c46acfa00f2e7","modified":1639015666064},{"_id":"node_modules/hexo-theme-next/LICENSE.md","hash":"68fc9a03d50fd4b5ea97092b05967d1819dea2c4","modified":1639015666098},{"_id":"node_modules/hexo-theme-next/languages/README.md","hash":"b2567e32805dda79601157351a07e5ca9fe01315","modified":1639015666175},{"_id":"node_modules/hexo-theme-next/_config.yml","hash":"0689d3281f35901334994480668a066d9b7b3fae","modified":1639015666594},{"_id":"node_modules/hexo-theme-next/README.md","hash":"fab15a85d9d8d90ecd8879525b9b74fb1c197978","modified":1639015666177},{"_id":"node_modules/hexo-theme-next/languages/de.yml","hash":"4be7b8b76c81bf1853eb36d2e874b17546a0e792","modified":1639015666597},{"_id":"node_modules/hexo-theme-next/languages/ar.yml","hash":"bca66db21c015dbd32970d8708b898518a773e1e","modified":1639015666596},{"_id":"node_modules/hexo-theme-next/languages/en.yml","hash":"814d81c27fed736055ee300e0a6505b26ff4313c","modified":1639015666598},{"_id":"node_modules/hexo-theme-next/languages/fr.yml","hash":"b15dc05afdc94de02e5d3fee4f8d3dc5594dd37e","modified":1639015666740},{"_id":"node_modules/hexo-theme-next/languages/es.yml","hash":"651e3b33d86a7cdb9fd7895ca28279f8b1a24faa","modified":1639015666600},{"_id":"node_modules/hexo-theme-next/languages/it.yml","hash":"c1eeab4992c76bfd436bb205ce58b1cfeef55ee6","modified":1639015666747},{"_id":"node_modules/hexo-theme-next/languages/ja.yml","hash":"d48c4157e0e02e847aac7b513580d3364c81948c","modified":1639015666749},{"_id":"node_modules/hexo-theme-next/languages/nl.yml","hash":"ecb8e39c6225f3c068a5fdd569ee7dafd5c41a1f","modified":1639015666761},{"_id":"node_modules/hexo-theme-next/languages/fa.yml","hash":"6456d40dd42f44101d9d6e7054e9884e9163f948","modified":1639015666739},{"_id":"node_modules/hexo-theme-next/languages/id.yml","hash":"14e794db4eca36b257994d81eb513e61d1edcbd6","modified":1639015666742},{"_id":"node_modules/hexo-theme-next/languages/pt-BR.yml","hash":"a1f27b3a592fc58f17d247f5563ff4a90a3da5f2","modified":1639015666773},{"_id":"node_modules/hexo-theme-next/languages/pt.yml","hash":"63a3e1e728ba5e6e22150de7331bb8a654f34960","modified":1639015666776},{"_id":"node_modules/hexo-theme-next/languages/ko.yml","hash":"6387357ac2dd498e8b8d630d27050a59180d7e8f","modified":1639015666752},{"_id":"node_modules/hexo-theme-next/languages/ru.yml","hash":"e9af1afe529ca747a04b801401d394b2ad696fde","modified":1639015666779},{"_id":"node_modules/hexo-theme-next/languages/tr.yml","hash":"0bebba73d6f06c7dad61f80c0d7ad5f6f1791a01","modified":1639015666781},{"_id":"node_modules/hexo-theme-next/languages/si.yml","hash":"615d18d044f44df476d6bfbf73f7b0edc2632168","modified":1639015666780},{"_id":"node_modules/hexo-theme-next/languages/uk.yml","hash":"7dd24580c0865c5a7bc4d391855045366a598936","modified":1639015666787},{"_id":"node_modules/hexo-theme-next/languages/zh-CN.yml","hash":"5a3ab21210304efef736e96bad254f789f42c567","modified":1639015666789},{"_id":"node_modules/hexo-theme-next/languages/vi.yml","hash":"c669c34da544a563ceae3e196addc9df6a78e024","modified":1639015666788},{"_id":"node_modules/hexo-theme-next/languages/zh-HK.yml","hash":"f195bb0502ffe66e850077a1af1033455ea65f93","modified":1639015666790},{"_id":"node_modules/hexo-theme-next/languages/zh-TW.yml","hash":"92256b90028de9a1e79c6bc0e5885b93e7fb4b17","modified":1639015666791},{"_id":"node_modules/hexo-theme-next/docs/AUTHORS.md","hash":"a648823121563c34a177ae91f5a774b5e29f01a0","modified":1639015666072},{"_id":"node_modules/hexo-theme-next/docs/LICENSE.txt","hash":"f5b14f791b7cfa1d16da981d929152e088a5d1b8","modified":1639015666591},{"_id":"node_modules/hexo-theme-next/docs/AGPL3.md","hash":"0d2b8c5fa8a614723be0767cc3bca39c49578036","modified":1639015666070},{"_id":"node_modules/hexo-theme-next/layout/_layout.njk","hash":"20e4160cd0deb4fa272cc3aed0f43520b3cf4a9c","modified":1639015666181},{"_id":"node_modules/hexo-theme-next/layout/archive.njk","hash":"d759f4d2cf5ddc6875ea250113a00662c1caf6d1","modified":1639015666200},{"_id":"node_modules/hexo-theme-next/layout/post.njk","hash":"6abeb85fb3e4c382ed4bb6049b12a807e6226e67","modified":1639015666321},{"_id":"node_modules/hexo-theme-next/scripts/filters/locals.js","hash":"0cd7da6755459d60779f0a7ccf311e26e184d55d","modified":1639015665981},{"_id":"node_modules/hexo-theme-next/scripts/events/index.js","hash":"1ce12eda88fa5df7e76ec7b78b8463fc6618410c","modified":1639015665854},{"_id":"node_modules/hexo-theme-next/layout/tag.njk","hash":"6cd707f846bfd6becbcfb060c26958bb4015c31f","modified":1639015666335},{"_id":"node_modules/hexo-theme-next/layout/category.njk","hash":"0a590e87af50e57b15fc37695c9a3bf4a97c3d92","modified":1639015666235},{"_id":"node_modules/hexo-theme-next/layout/index.njk","hash":"37ec3d1bcd20b8ac1d18e0d68f990450890b46cd","modified":1639015666286},{"_id":"node_modules/hexo-theme-next/scripts/filters/minify.js","hash":"0af64049db8188d5f8cc226b353e0d7909819feb","modified":1639015666003},{"_id":"node_modules/hexo-theme-next/scripts/filters/post.js","hash":"ab8bb12e4d55640b1ac4252514468ce37ebcb0b0","modified":1639015666039},{"_id":"node_modules/hexo-theme-next/scripts/filters/default-injects.js","hash":"872f01cb10e422a648ea505436532e776e92926b","modified":1639015665746},{"_id":"node_modules/hexo-theme-next/layout/page.njk","hash":"9cd3eca2c468bb46c7c5bf391bea4b025af178f6","modified":1639015666302},{"_id":"node_modules/hexo-theme-next/scripts/helpers/font.js","hash":"3394185a7f0393c16ce52c8028f90da3e9239c55","modified":1639015665802},{"_id":"node_modules/hexo-theme-next/scripts/helpers/engine.js","hash":"b9785bc737470e9b8e910e7da9e8c45c2ead58fa","modified":1639015665769},{"_id":"node_modules/hexo-theme-next/scripts/helpers/next-config.js","hash":"9a07f2d979fc8fe0c5e07d48304187b9b03ea7ff","modified":1639015666018},{"_id":"node_modules/hexo-theme-next/scripts/helpers/next-url.js","hash":"a11b71ba0c5012e2cdcab31c15439156b215563e","modified":1639015666020},{"_id":"node_modules/hexo-theme-next/scripts/helpers/next-vendors.js","hash":"afdd6a188a74c188f0dd154fac70efd4080ca262","modified":1639015666029},{"_id":"node_modules/hexo-theme-next/scripts/tags/caniuse.js","hash":"935a311142a409c1896b3ae3f01fe7a9e2db1134","modified":1639015665545},{"_id":"node_modules/hexo-theme-next/scripts/tags/button.js","hash":"c6ad2ed544fbb25ecb5d820c36e76302504271b7","modified":1639015665539},{"_id":"node_modules/hexo-theme-next/scripts/tags/label.js","hash":"8a73348186113bae0a51ea2f891c1bb882fab05a","modified":1639015665934},{"_id":"node_modules/hexo-theme-next/scripts/tags/center-quote.js","hash":"92c19d796bdb3320df9caea59bf52df7a95d9da9","modified":1639015665552},{"_id":"node_modules/hexo-theme-next/scripts/tags/index.js","hash":"17f9451ce1f10f78437f52218757d38d4e1591b0","modified":1639015665869},{"_id":"node_modules/hexo-theme-next/scripts/tags/group-pictures.js","hash":"79102d9e9bccff6224e77a77c4d2d363094ae3df","modified":1639015665828},{"_id":"node_modules/hexo-theme-next/scripts/tags/mermaid.js","hash":"4fb01ca650fa8b256b8d48f50dc1b18350bd3d6d","modified":1639015665993},{"_id":"node_modules/hexo-theme-next/scripts/tags/note.js","hash":"7b94ddb46b7d4b0fe815f2fbe4bd375f07f55363","modified":1639015666031},{"_id":"node_modules/hexo-theme-next/scripts/tags/pdf.js","hash":"344636b6fd7e27e8831c1e194039afc0d61931cd","modified":1639015666034},{"_id":"node_modules/hexo-theme-next/scripts/tags/link-grid.js","hash":"18a483c2d5afd701f6080ffdddf2d1321370336c","modified":1639015665955},{"_id":"node_modules/hexo-theme-next/scripts/tags/tabs.js","hash":"0eabe51da40b4b13e16419c8fe02452d9a4fef73","modified":1639015666045},{"_id":"node_modules/hexo-theme-next/scripts/tags/video.js","hash":"2ee926448583be8f95af1f2884ae2c9c4830151d","modified":1639015666062},{"_id":"node_modules/hexo-theme-next/docs/zh-CN/CONTRIBUTING.md","hash":"a089f7a8368ab0b7d7b9b7ec0ac3767a453435df","modified":1639015666096},{"_id":"node_modules/hexo-theme-next/docs/zh-CN/README.md","hash":"02bafc6ee86263790603861e356596f0c916e392","modified":1639015666167},{"_id":"node_modules/hexo-theme-next/docs/zh-CN/CODE_OF_CONDUCT.md","hash":"7a06d443f374bd1e84294067a0ac796afd9fbe60","modified":1639015666090},{"_id":"node_modules/hexo-theme-next/docs/ru/README.md","hash":"87edab5a3eb7577a409c01df3f1631de40f8956f","modified":1639015666099},{"_id":"node_modules/hexo-theme-next/source/css/_mixins.styl","hash":"acef5acc728f24cb657be8d7010d836b4d556b0e","modified":1639015666379},{"_id":"node_modules/hexo-theme-next/source/css/main.styl","hash":"78ce791cc4ac95386cf6839ca72f5f7b51f86ee9","modified":1639015666515},{"_id":"node_modules/hexo-theme-next/source/css/_colors.styl","hash":"2d464c451fac10669c0c0d25b1694c7cf85bd25e","modified":1639015666353},{"_id":"node_modules/hexo-theme-next/source/css/noscript.styl","hash":"76bba5d7916e9930e68215a0fce3a7d81c44510f","modified":1639015666530},{"_id":"node_modules/hexo-theme-next/source/js/bookmark.js","hash":"0f563ffbf05fad30e854e413ab17ff7164ab5a53","modified":1639015665533},{"_id":"node_modules/hexo-theme-next/layout/_macro/post-collapse.njk","hash":"1a30d751871dabfa80940042ddb1f77d07d830b9","modified":1639015666308},{"_id":"node_modules/hexo-theme-next/source/js/comments-buttons.js","hash":"1a7344440321713426a0b2ab17e276b5bdf85ade","modified":1639015665596},{"_id":"node_modules/hexo-theme-next/source/js/config.js","hash":"4c4ebbe3b3f3841a26f9d5af6d0ba8bc6da01c54","modified":1639015665719},{"_id":"node_modules/hexo-theme-next/layout/_macro/post.njk","hash":"b106599106285ecd4c0c1e0ed11c46a36b5a69d5","modified":1639015666319},{"_id":"node_modules/hexo-theme-next/source/js/motion.js","hash":"6d4bd07a6f8e1b4083119dca0acb5b289533b619","modified":1639015666005},{"_id":"node_modules/hexo-theme-next/source/js/comments.js","hash":"66ae2e26ea36a41b72c638ea8b220296638ae952","modified":1639015665599},{"_id":"node_modules/hexo-theme-next/layout/_macro/sidebar.njk","hash":"eb786e8b35e354287cda345c524cd35ec955f692","modified":1639015666330},{"_id":"node_modules/hexo-theme-next/source/js/next-boot.js","hash":"48497e2156a10155dc42311633a110c9685692c9","modified":1639015666016},{"_id":"node_modules/hexo-theme-next/source/js/pjax.js","hash":"0523cb1946907687c53999e2ce7cfe1831da6476","modified":1639015666037},{"_id":"node_modules/hexo-theme-next/source/js/schedule.js","hash":"2b43e2d576a308289880befc27580dbb2aa34439","modified":1639015666043},{"_id":"node_modules/hexo-theme-next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1639015666345},{"_id":"node_modules/hexo-theme-next/source/images/avatar.gif","hash":"2dbc3e2f2d624b2ca1afe6edc2ca17307f1950c8","modified":1639015665506},{"_id":"node_modules/hexo-theme-next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1639015666344},{"_id":"node_modules/hexo-theme-next/source/js/utils.js","hash":"370d417d76a897f09c11a49d2c8c8b723921bd9a","modified":1639015666051},{"_id":"node_modules/hexo-theme-next/source/images/logo.svg","hash":"2cb74fd3ea2635e015eabc58a8d488aed6cf6417","modified":1639015666590},{"_id":"node_modules/hexo-theme-next/layout/_scripts/index.njk","hash":"6668878a0f9a1166c6a879755f54a08d942da870","modified":1639015666281},{"_id":"node_modules/hexo-theme-next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1639015666347},{"_id":"node_modules/hexo-theme-next/layout/_scripts/vendors.njk","hash":"be80b9fe415a9a09d74c28e230995fd292dfc123","modified":1639015666340},{"_id":"node_modules/hexo-theme-next/source/images/logo-algolia-nebula-blue-full.svg","hash":"b85e274207b1392782476a0430feac98db1e7da0","modified":1639015666589},{"_id":"node_modules/hexo-theme-next/layout/_partials/comments.njk","hash":"c12f8a7497596441503f2541d2f746f2ee7dd594","modified":1639015666250},{"_id":"node_modules/hexo-theme-next/layout/_partials/footer.njk","hash":"19713f472972caac33ae5fbcfe9105da61257de4","modified":1639015666266},{"_id":"node_modules/hexo-theme-next/layout/_partials/languages.njk","hash":"e43f22198cccb5f6e306b1ce0d28d12a4fb891f8","modified":1639015666289},{"_id":"node_modules/hexo-theme-next/layout/_third-party/quicklink.njk","hash":"0efed71ed530447718c4ea5bbd5fc8695b0b0d5f","modified":1639015666324},{"_id":"node_modules/hexo-theme-next/layout/_partials/pagination.njk","hash":"9876dbfc15713c7a47d4bcaa301f4757bd978269","modified":1639015666303},{"_id":"node_modules/hexo-theme-next/layout/_third-party/index.njk","hash":"d41eeb262978e34de4679d8971a9e7ac5d90ecbc","modified":1639015666283},{"_id":"node_modules/hexo-theme-next/layout/_third-party/pace.njk","hash":"d7ad5714079f7f65446f880baf14722435ca9061","modified":1639015666300},{"_id":"node_modules/hexo-theme-next/layout/_third-party/fancybox.njk","hash":"844559f46e2ff1c8be234d5763703106e2072a7b","modified":1639015666257},{"_id":"node_modules/hexo-theme-next/scripts/events/lib/config.js","hash":"b0ced2583fdd505da3ef27a9db9c55cc7b936732","modified":1639015665713},{"_id":"node_modules/hexo-theme-next/layout/_third-party/rating.njk","hash":"1bcdbc7fde26d6d9ef4e7fa43ffcff5a9506b20e","modified":1639015666325},{"_id":"node_modules/hexo-theme-next/layout/_partials/widgets.njk","hash":"852a750524decf1efa587cd52b09e387ed8315de","modified":1639015666341},{"_id":"node_modules/hexo-theme-next/scripts/events/lib/utils.js","hash":"b281be775b693f9bf32766c8f6ef703c72ac9b00","modified":1639015666049},{"_id":"node_modules/hexo-theme-next/scripts/events/lib/highlight.js","hash":"6aec7b2c38c50989a23bfaa0d560e75c7f553e12","modified":1639015665841},{"_id":"node_modules/hexo-theme-next/scripts/events/lib/injects.js","hash":"d987709267a1bc6e5014411e9983d7c49c102c16","modified":1639015665881},{"_id":"node_modules/hexo-theme-next/scripts/filters/comment/default-config.js","hash":"93ee5f9109dad885dc38c49bcee630c10f9dce6e","modified":1639015665730},{"_id":"node_modules/hexo-theme-next/scripts/events/lib/vendors.js","hash":"08dac57e15c9f06c7cf54884b045f2362595f9d2","modified":1639015666060},{"_id":"node_modules/hexo-theme-next/scripts/filters/comment/changyan.js","hash":"aa05e6b3d613a756178b8ba06832ad27499d4c14","modified":1639015665566},{"_id":"node_modules/hexo-theme-next/scripts/filters/comment/common.js","hash":"2486f3e0150c753e5f3af1a3665d074704b8ee2c","modified":1639015665604},{"_id":"node_modules/hexo-theme-next/scripts/filters/comment/disqus.js","hash":"7f71d6b271ba65ff333d5682e7575711d368c0d2","modified":1639015665749},{"_id":"node_modules/hexo-theme-next/scripts/filters/comment/gitalk.js","hash":"7bb7dafdd7f6bca8464b54e17e552ce7f1714195","modified":1639015665811},{"_id":"node_modules/hexo-theme-next/scripts/filters/comment/disqusjs.js","hash":"135b87d151055eefdbc711d9e704b112b3214a84","modified":1639015665754},{"_id":"node_modules/hexo-theme-next/scripts/filters/comment/isso.js","hash":"ff8b5b5145220a17d0ecd9508ba9bd2d3b2da47d","modified":1639015665901},{"_id":"node_modules/hexo-theme-next/scripts/filters/comment/utterances.js","hash":"d3bded697bc32dace689d2a6dfb6eb7514169d15","modified":1639015666053},{"_id":"node_modules/hexo-theme-next/scripts/filters/comment/livere.js","hash":"5a07d8bb52bc1d51a624ca8db54be144566c306b","modified":1639015665962},{"_id":"node_modules/hexo-theme-next/source/css/_variables/Muse.styl","hash":"e3be898f5ebcf435a26542653a9297ff2c71aeb0","modified":1639015666526},{"_id":"node_modules/hexo-theme-next/source/css/_variables/Gemini.styl","hash":"96e0a7c2a65ce68215e17e369085b2ea2f1334f2","modified":1639015666443},{"_id":"node_modules/hexo-theme-next/source/css/_variables/Mist.styl","hash":"e1fbf169b9b6a194b518240cbd06ec3c48b83d61","modified":1639015666522},{"_id":"node_modules/hexo-theme-next/source/css/_variables/Pisces.styl","hash":"c65536a128b9bc9dbe2fbb1b235a3cded2891002","modified":1639015666541},{"_id":"node_modules/hexo-theme-next/source/js/third-party/rating.js","hash":"4e92c2d107ba47b47826829f9668030d5ea9bfb8","modified":1639015666042},{"_id":"node_modules/hexo-theme-next/source/css/_variables/base.styl","hash":"c6b3c031d23b2a093e025c75b7cab6bc0379c6ea","modified":1639015666416},{"_id":"node_modules/hexo-theme-next/source/js/third-party/fancybox.js","hash":"c098d14e65dd170537134358d4b8359ad0539c2c","modified":1639015665791},{"_id":"node_modules/hexo-theme-next/source/js/third-party/pace.js","hash":"0ef04218b93561ba4d0ff420d556c3d90a756d32","modified":1639015666032},{"_id":"node_modules/hexo-theme-next/source/js/third-party/quicklink.js","hash":"6f58cd7aa8f6f1ab92d5a96551add293f4e55312","modified":1639015666040},{"_id":"node_modules/hexo-theme-next/source/js/schemes/muse.js","hash":"62f4638674c92dfb72454fee38751d0227d3d225","modified":1639015666015},{"_id":"node_modules/hexo-theme-next/layout/_partials/header/sub-menu.njk","hash":"75a158a5b54a3a76ee6590f5e0e2dd4a9f0be869","modified":1639015666334},{"_id":"node_modules/hexo-theme-next/layout/_partials/head/head-unique.njk","hash":"9167e429a459686c9fc140790124a46d677e6b15","modified":1639015666275},{"_id":"node_modules/hexo-theme-next/layout/_partials/header/index.njk","hash":"53895b3af95667edc5bf5d7356f8a2b4fe091447","modified":1639015666278},{"_id":"node_modules/hexo-theme-next/layout/_partials/header/menu.njk","hash":"c9390824b57f23b7c8a5c23a9834514123673766","modified":1639015666298},{"_id":"node_modules/hexo-theme-next/layout/_partials/header/menu-item.njk","hash":"b46f412c0b4f775fd329d50357f722f5d7c1a3ba","modified":1639015666296},{"_id":"node_modules/hexo-theme-next/layout/_partials/header/brand.njk","hash":"ffb6c69a9c90793cbe9bf0544b55f7a41c016d8f","modified":1639015666214},{"_id":"node_modules/hexo-theme-next/layout/_partials/post/post-followme.njk","hash":"154df0bb323c332d8c25343f258ee865e5553423","modified":1639015666312},{"_id":"node_modules/hexo-theme-next/layout/_partials/head/head.njk","hash":"d3c094aaef1431fbc9df333529a7b1789ccd134c","modified":1639015666276},{"_id":"node_modules/hexo-theme-next/layout/_partials/post/post-footer.njk","hash":"bde2c7356d9362972bde41cc206d5816f8ed714d","modified":1639015666314},{"_id":"node_modules/hexo-theme-next/layout/_partials/sidebar/site-overview.njk","hash":"5c01e380ba843f8016d8fa4593432430f5bd3584","modified":1639015666332},{"_id":"node_modules/hexo-theme-next/layout/_partials/post/post-reward.njk","hash":"002b51d0cae3f2e2e008bdc58be90c728282de5b","modified":1639015666318},{"_id":"node_modules/hexo-theme-next/layout/_partials/post/post-copyright.njk","hash":"133942922e34abae9e4de7ea5591d77c0caa4b37","modified":1639015666311},{"_id":"node_modules/hexo-theme-next/layout/_partials/page/schedule.njk","hash":"ca2ccf3cf1874c45712f192ad45dea96fbd9920d","modified":1639015666328},{"_id":"node_modules/hexo-theme-next/layout/_partials/post/post-meta.njk","hash":"471dcbe22d0dbe043dcf25a1a1c17ca76aa9a548","modified":1639015666315},{"_id":"node_modules/hexo-theme-next/layout/_partials/page/categories.njk","hash":"17156d99941f28a225951ffdcfa9a115e20dc2d2","modified":1639015666233},{"_id":"node_modules/hexo-theme-next/layout/_partials/page/tags.njk","hash":"a18d1598e36cc72f2b0b24c3cc3c5990dfaa3254","modified":1639015666336},{"_id":"node_modules/hexo-theme-next/layout/_partials/page/breadcrumb.njk","hash":"edb3bb6d644b7407673c5ef3a426a244e98fcf89","modified":1639015666225},{"_id":"node_modules/hexo-theme-next/layout/_partials/search/algolia-search.njk","hash":"efb2b6f19df02ba5ae623a1f274fff52aed21e6f","modified":1639015666189},{"_id":"node_modules/hexo-theme-next/layout/_partials/search/localsearch.njk","hash":"661f7acae43f0be694266323320f977d84119abe","modified":1639015666292},{"_id":"node_modules/hexo-theme-next/layout/_partials/post/post-related.njk","hash":"7384e6390067ef2a84e7310d6adb3f6104ed62e2","modified":1639015666316},{"_id":"node_modules/hexo-theme-next/layout/_third-party/comments/disqus.njk","hash":"9375b19a89b7fa9474e558d085af5448d4c5c50c","modified":1639015666252},{"_id":"node_modules/hexo-theme-next/layout/_partials/search/index.njk","hash":"8f6f256ab3b351ffc80f1f3f1d9834e9a7cfac31","modified":1639015666279},{"_id":"node_modules/hexo-theme-next/layout/_partials/page/page-header.njk","hash":"7ed4f102a1825195cff8d7995bf9219f323a9034","modified":1639015666301},{"_id":"node_modules/hexo-theme-next/layout/_third-party/comments/changyan.njk","hash":"d1c950f8fbdf85e7a3eae5463767a89e858e8220","modified":1639015666243},{"_id":"node_modules/hexo-theme-next/layout/_third-party/comments/isso.njk","hash":"64cc3bdaf644fd32c0d0a247f29f5b6904da9af3","modified":1639015666287},{"_id":"node_modules/hexo-theme-next/layout/_third-party/comments/disqusjs.njk","hash":"0749cb6902baecdfd01f779a2a2513f6d2f6a823","modified":1639015666255},{"_id":"node_modules/hexo-theme-next/layout/_third-party/comments/gitalk.njk","hash":"b63b7e2ede0d3e66e732fa1a06bda9b19e1e85d4","modified":1639015666268},{"_id":"node_modules/hexo-theme-next/layout/_third-party/comments/livere.njk","hash":"3b13b09fba84ec6000886890a6710736a2b8fafe","modified":1639015666291},{"_id":"node_modules/hexo-theme-next/layout/_third-party/analytics/baidu-analytics.njk","hash":"6215309aee028dcb734452beec448c5afb6c63fc","modified":1639015666210},{"_id":"node_modules/hexo-theme-next/layout/_third-party/comments/utterances.njk","hash":"5a94032bc3512a10ad4328fc19ec07b819a1d687","modified":1639015666339},{"_id":"node_modules/hexo-theme-next/layout/_third-party/analytics/index.njk","hash":"2d36a481a70d5f450f1f166dc556ac1218b18537","modified":1639015666282},{"_id":"node_modules/hexo-theme-next/layout/_third-party/analytics/cloudflare.njk","hash":"c978e9efd472c4825f93b83524b11f1c4f7efaab","modified":1639015666247},{"_id":"node_modules/hexo-theme-next/layout/_third-party/chat/chatra.njk","hash":"d7263fca16d0278ccf1f6aa1c6df6902a6344a09","modified":1639015666245},{"_id":"node_modules/hexo-theme-next/layout/_third-party/chat/gitter.njk","hash":"f8cc14b7aa949999a1faaeb7855e2f20b59a386d","modified":1639015666269},{"_id":"node_modules/hexo-theme-next/layout/_third-party/analytics/growingio.njk","hash":"8afaa772c390bd9d53a5cff9645ac3168334eb98","modified":1639015666272},{"_id":"node_modules/hexo-theme-next/layout/_third-party/analytics/google-analytics.njk","hash":"d89066ff53879693f023e540d59c86137172c529","modified":1639015666270},{"_id":"node_modules/hexo-theme-next/layout/_third-party/chat/tidio.njk","hash":"02aab857c27fc103216029be991688b12a73a525","modified":1639015666338},{"_id":"node_modules/hexo-theme-next/layout/_third-party/tags/mermaid.njk","hash":"099e031f52fb8e47b3af5b2684737efc9e643ee7","modified":1639015666299},{"_id":"node_modules/hexo-theme-next/layout/_third-party/math/mathjax.njk","hash":"3677017fd4572b158311f5f5d870590ab25184e0","modified":1639015666294},{"_id":"node_modules/hexo-theme-next/layout/_third-party/tags/pdf.njk","hash":"2c81984cc4f5123103460442f6e046f5b6c97127","modified":1639015666304},{"_id":"node_modules/hexo-theme-next/layout/_third-party/math/katex.njk","hash":"d82c24136bbd3443b85f07f5579845833b594684","modified":1639015666288},{"_id":"node_modules/hexo-theme-next/layout/_third-party/statistics/index.njk","hash":"568ddf7955d11d93fb5e842b403a7ac8b1b7fdb1","modified":1639015666285},{"_id":"node_modules/hexo-theme-next/layout/_third-party/statistics/firestore.njk","hash":"d32ebe94560fa95824478ebbff531bffc47b194d","modified":1639015666264},{"_id":"node_modules/hexo-theme-next/layout/_third-party/statistics/busuanzi-counter.njk","hash":"a4bc501da0f22f7e420f0ca47e83988ce90b1368","modified":1639015666231},{"_id":"node_modules/hexo-theme-next/layout/_third-party/statistics/lean-analytics.njk","hash":"2446e748cdc102c78492216319ac02148db7daf6","modified":1639015666290},{"_id":"node_modules/hexo-theme-next/layout/_third-party/math/index.njk","hash":"abf37fc55aa86702118e8fdf5bf2d389dd589aa0","modified":1639015666284},{"_id":"node_modules/hexo-theme-next/layout/_third-party/search/algolia-search.njk","hash":"24ed76e0c72a25ac152820c750a05826a706b6f4","modified":1639015666193},{"_id":"node_modules/hexo-theme-next/layout/_third-party/search/localsearch.njk","hash":"e45ea3542cdc9ed7ec8447b5e6f35df4c5e82758","modified":1639015666293},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/comments.styl","hash":"e4fecc889ba3317a64e9abba5842c79dff9b7827","modified":1639015666438},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/index.styl","hash":"fe1868f47681e00a33a96199302be85377282f63","modified":1639015666462},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/tables.styl","hash":"e840b23d33023e6d45e018f6e84b683dd56efd8d","modified":1639015666583},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/buttons.styl","hash":"a042571d85ff7265f799004239a45f36b716b8a6","modified":1639015666436},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/index.styl","hash":"523fb7b653b87ae37fc91fc8813e4ffad87b0d7e","modified":1639015666506},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/back-to-top.styl","hash":"bab653bcf226311381e8411a0492202f1bf1fce9","modified":1639015666407},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/reading-progress.styl","hash":"90a86045a33c1bae49fc2f6fa1e1b53170c7f77b","modified":1639015666566},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/base.styl","hash":"2e58cb90a77d3dd16e02b8949808b4b16453828c","modified":1639015666410},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/index.styl","hash":"8e34df131830d4fa3725e4590a672ba1cf1903e5","modified":1639015666493},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/toggles.styl","hash":"572a41499391677d84b16d8dbd6a996a3d5ce041","modified":1639015666586},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/pagination.styl","hash":"b5c7782368889fa9fd93807d28ff2daf270e3703","modified":1639015666537},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/normalize.styl","hash":"b56367ea676ea8e8783ea89cd4ab150c7da7a060","modified":1639015666528},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/mobile.styl","hash":"64775c729512b30b144ab5ae9dc4a4dfd4e13f35","modified":1639015666524},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Gemini/index.styl","hash":"fd49b521d67eaccc629f77b4e095cb7310327565","modified":1639015666509},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Muse/_header.styl","hash":"06080fd963c904d96c00eff098a284e337953013","modified":1639015666362},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Mist/index.styl","hash":"ab16a3dcdc0393b9b582ef59dcc13db9320e917c","modified":1639015666510},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Mist/_header.styl","hash":"4817e77577896ab5c0da434549917ee703a3f4cf","modified":1639015666355},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Mist/_layout.styl","hash":"5604ac1e161099a4d3e5657d53507268866dc717","modified":1639015666366},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Mist/_menu.styl","hash":"357b899ac0f0dfbbbebf1ea972030c7cefa463ce","modified":1639015666369},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Muse/_layout.styl","hash":"82a29572dd90451f75358a2ee2522b87304a0bb8","modified":1639015666367},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Pisces/_header.styl","hash":"b741ab96e73370711c63a6581159f2ea8b5bfa1b","modified":1639015666364},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Mist/_posts-expand.styl","hash":"b332868d76d9f1651efd65abfc0d3c9d699b1a45","modified":1639015666381},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Muse/_sub-menu.styl","hash":"c48ccd8d6651fe1a01faff8f01179456d39ba9b1","modified":1639015666389},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Muse/index.styl","hash":"6ad168288b213cec357e9b5a97674ff2ef3a910c","modified":1639015666511},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Muse/_sidebar.styl","hash":"944364893bd7160d954c10ba931af641c91515a4","modified":1639015666382},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Pisces/_sub-menu.styl","hash":"778ed2ad5643b93970c95626b325defeb586733f","modified":1639015666395},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Muse/_menu.styl","hash":"8a70d51d8f7cd113e5fbc9f0e70c46a072f282c8","modified":1639015666372},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Pisces/index.styl","hash":"8000075b227749a7495eaf417cac6ccfbe441580","modified":1639015666512},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Pisces/_layout.styl","hash":"6eee86c8f0175d6c09e434053516cd8556f78d44","modified":1639015666368},{"_id":"node_modules/hexo-theme-next/source/js/third-party/chat/gitter.js","hash":"cc38c94125f90dadde11b5ebac7d8bf99a1a08a2","modified":1639015665819},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Pisces/_menu.styl","hash":"72dc825c50357402c342d62ab60fc0c478ab6bc1","modified":1639015666373},{"_id":"node_modules/hexo-theme-next/source/js/third-party/chat/tidio.js","hash":"b0079f6a4601e06ca6fe46e83a2f5af553e9bc3c","modified":1639015666047},{"_id":"node_modules/hexo-theme-next/source/js/third-party/chat/chatra.js","hash":"c32180522788c10e51df1803aa6842ef0432ddc9","modified":1639015665593},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Pisces/_sidebar.styl","hash":"d9141e6e14a56b5952488101e9a8388c2170e270","modified":1639015666385},{"_id":"node_modules/hexo-theme-next/source/js/third-party/math/katex.js","hash":"83c54ee536e487a1031783443fe0cb63b1b4767e","modified":1639015665929},{"_id":"node_modules/hexo-theme-next/source/js/third-party/analytics/growingio.js","hash":"78dd3cf04082b7dbe6246e404b2aa8e726922402","modified":1639015665833},{"_id":"node_modules/hexo-theme-next/source/js/third-party/analytics/baidu-analytics.js","hash":"f629acc46ff40c071ffd31b77d5c7616f0fdd778","modified":1639015665525},{"_id":"node_modules/hexo-theme-next/source/js/third-party/analytics/google-analytics.js","hash":"59684383385059dc4f8a1ff85dbbeb703bcdbcb5","modified":1639015665822},{"_id":"node_modules/hexo-theme-next/source/js/third-party/comments/changyan.js","hash":"8c8ebec444c727b704ea41ad88b0b96ed2e4b8d4","modified":1639015665574},{"_id":"node_modules/hexo-theme-next/source/js/third-party/comments/disqus.js","hash":"e1cc671b0d524864fd445e3ab4ade9ee6d07e565","modified":1639015665752},{"_id":"node_modules/hexo-theme-next/source/js/third-party/math/mathjax.js","hash":"5c749b9c1c3bb738122d0516211ecff6496d4907","modified":1639015665984},{"_id":"node_modules/hexo-theme-next/source/js/third-party/comments/isso.js","hash":"753a873b6f566aff5ba77ca23f91b78eb880ca64","modified":1639015665922},{"_id":"node_modules/hexo-theme-next/source/js/third-party/comments/livere.js","hash":"2247d88c934c765c43013337860774aaa99f0b31","modified":1639015665972},{"_id":"node_modules/hexo-theme-next/source/js/third-party/comments/disqusjs.js","hash":"b6c58f098473b526d6a3cd35655caf34b77f7cff","modified":1639015665760},{"_id":"node_modules/hexo-theme-next/source/js/third-party/tags/pdf.js","hash":"af78c22f0e61c8c8aa8794e585e0d632c6d4fcb8","modified":1639015666036},{"_id":"node_modules/hexo-theme-next/source/js/third-party/comments/utterances.js","hash":"f67f90eb03e284c82da2b8cf2f1e31801813c16d","modified":1639015666056},{"_id":"node_modules/hexo-theme-next/source/js/third-party/search/algolia-search.js","hash":"ac401e3736d56a3c9cb85ab885744cce0b813c55","modified":1639015665513},{"_id":"node_modules/hexo-theme-next/source/js/third-party/comments/gitalk.js","hash":"0ec038cf83e8ec067534f16a54041e47a3c1e59a","modified":1639015665815},{"_id":"node_modules/hexo-theme-next/source/js/third-party/statistics/lean-analytics.js","hash":"5a928990856b8e456f0663cf3b6b406733672e39","modified":1639015665944},{"_id":"node_modules/hexo-theme-next/source/js/third-party/search/local-search.js","hash":"45c485f82258d246f37deb66884bd2643323ef3a","modified":1639015665975},{"_id":"node_modules/hexo-theme-next/source/js/third-party/statistics/firestore.js","hash":"0960f16107ed61452fb0dffc6ed22dc143de34ef","modified":1639015665800},{"_id":"node_modules/hexo-theme-next/source/js/third-party/tags/mermaid.js","hash":"3dc4628efa6debd6490fc0ebddff2424a7b319d8","modified":1639015665997},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/highlight/copy-code.styl","hash":"83ee4993710fc8daa1c8dbfccd5d5091fd244c30","modified":1639015666442},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/highlight/index.styl","hash":"0b3e2696eca39781c3524b2c5a2555ebc616e6e8","modified":1639015666500},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/post/index.styl","hash":"d0805a763176b3c0003967401644f41dfe3bc9e8","modified":1639015666468},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/post/post-gallery.styl","hash":"aa366d37389760c8595529b850f461569577a1c5","modified":1639015666550},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/post/post-followme.styl","hash":"fc1a7bac6493f24aa50665574f37f3dd954f210c","modified":1639015666547},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/post/post-collapse.styl","hash":"ec37a36e94ba791663607a5022f763915778578f","modified":1639015666546},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/pages/breadcrumb.styl","hash":"8afdc311c6b8db121758371f95cf1c5e77354f42","modified":1639015666433},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/post/post-nav.styl","hash":"9ac6f477177264c26a46e8333b8456720a0444dc","modified":1639015666554},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/post/post-header.styl","hash":"b1c99f34d65f994c89940bb7cdff4e36779ceb5d","modified":1639015666552},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/post/post-body.styl","hash":"ea351936d71e0b6259febac3d7d56d1be6927bf9","modified":1639015666542},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/pages/categories.styl","hash":"b6e2eb1550a7845cb2adf86081a4ab6c7bde1e68","modified":1639015666437},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/post/post-footer.styl","hash":"1d284f3ea03ba9b4feb76b375e539a8e0bccf1c3","modified":1639015666549},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/pages/index.styl","hash":"7504dbc5c70262b048143b2c37d2b5aa2809afa2","modified":1639015666464},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/post/post-widgets.styl","hash":"b6677dc2a2368084ab82bb4f145ac79e5966c150","modified":1639015666556},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/third-party/gitalk.styl","hash":"070737d101e7cd58e997e8c7af09958268c43a21","modified":1639015666451},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/third-party/math.styl","hash":"9d995eb4871a6c273d9d51558676a1fdabf69e72","modified":1639015666516},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/post/post-reward.styl","hash":"07cff69f2d57e6321595f64c16d8b763dc88df6a","modified":1639015666555},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/third-party/utterances.styl","hash":"56d90ae0559caa55b75f3c300ff2711f9ed65fc4","modified":1639015666587},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/third-party/index.styl","hash":"b1bcc5f9357a9f8b8d6f8f285f073aaf3157f9db","modified":1639015666470},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/pages/tag-cloud.styl","hash":"1a81d1a71fcf0699629ce6e72dfd0a15f3a2dd0a","modified":1639015666585},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/pages/schedule.styl","hash":"6b816c2511242ee503fb5f34cd3e4dcdafc06b85","modified":1639015666569},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/tags/group-pictures.styl","hash":"393ff96234e4196b569d4b11496774eb78e147de","modified":1639015666458},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/tags/blockquote-center.styl","hash":"d6418fd2bbfba7b73ddf11ec62db9637fdf5d8af","modified":1639015666424},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/tags/index.styl","hash":"3f76c73a891bbc10679753e702feba9e8a5ffdd2","modified":1639015666507},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/footer/index.styl","hash":"8b9407e5cfd0571ef8de7df19022b268f962fa2f","modified":1639015666478},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/third-party/related-posts.styl","hash":"41ed817e1eb64078074e245e771446ee041e5790","modified":1639015666567},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/tags/label.styl","hash":"debee14539272fbe3835a7d3853af2230baa3501","modified":1639015666513},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/tags/mermaid.styl","hash":"48d35dba575a7c9e8845b16652e76b7d4a4646de","modified":1639015666520},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/third-party/search.styl","hash":"c8e95e8ac4cbdba01cb93e9e0569b45603e41bc6","modified":1639015666570},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/tags/pdf.styl","hash":"b6654a1d7cf82577d8263faffee8af3ad4a5c0e8","modified":1639015666538},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/tags/note.styl","hash":"d27fbf7799695295dd5860a161a13ac4d90c5ba4","modified":1639015666532},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/tags/link-grid.styl","hash":"7f8a7345e6537a62cd9e9a94c8f7065b541d9b04","modified":1639015666514},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/sidebar/index.styl","hash":"cee43480eba028c37d51cb620c2d81486aa24e01","modified":1639015666498},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/sidebar/sidebar-blogroll.styl","hash":"9950c3188a28e1c63b5498b7bdcd14b12ace3e28","modified":1639015666573},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/tags/tabs.styl","hash":"9b34143aec49e390e18f380026a45096f7477722","modified":1639015666584},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/sidebar/sidebar-button.styl","hash":"b926e368f702f8686aaa2eb98d3d2e533418958c","modified":1639015666574},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/sidebar/sidebar-author-links.styl","hash":"52fc98b1435129eb3edb9293ced9e507741f1350","modified":1639015666571},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/sidebar/sidebar-dimmer.styl","hash":"fbdb63c6a8887d19b7137325ba7d6806f728139c","modified":1639015666574},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/sidebar/sidebar-author.styl","hash":"5b38ac4a0f1ade0e681aff0e3366c481d9cf3dcd","modified":1639015666572},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/header/bookmark.styl","hash":"e74f4bb47a101b014ee2a1783c87f3b87323f9a0","modified":1639015666429},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/sidebar/sidebar-toggle.styl","hash":"3103b81fc76b59e1e2c161e2c484625c770ed66f","modified":1639015666577},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/sidebar/site-state.styl","hash":"26dd0adfcb1db6df29c6090c8d7e9b5a43583fb0","modified":1639015666581},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/sidebar/sidebar-nav.styl","hash":"ee94a1a27090ad24e3ed579093088d97ff96d77d","modified":1639015666575},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/header/index.styl","hash":"650ed4ad6df1b6ff04647e7b6d568304e4d3ed2e","modified":1639015666480},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/header/github-banner.styl","hash":"38c64c2d04e46848382bfa246a0e9c508294767b","modified":1639015666455},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/sidebar/sidebar-toc.styl","hash":"021a37cf178440cc341940a299d3bca359996c6b","modified":1639015666576},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/header/site-meta.styl","hash":"9a47c9045e443b8d20932f9c564a3a05fa4c6b51","modified":1639015666579},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/header/menu.styl","hash":"392fd53a8dd4e3f33a853ebb24290a622300e0ff","modified":1639015666518},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/header/site-nav.styl","hash":"bf3ad8b4268f763a1e26377681644887694bc009","modified":1639015666580},{"_id":"source/_posts/其他/HTTP和HTTPS/image-20210831164301870.png","hash":"a8045946c97a2a7c035aa205b6a3abb5cb83f252","modified":1639015009420},{"_id":"source/_drafts/webpack/webpack学习一/image-20220202191837055.png","hash":"7700ea0483502b163d22215c16d39114077795a8","modified":1644200469165},{"_id":"source/_posts/其他/浏览器缓存策略/image-20211023161739229.png","hash":"c8e0fd49b9762d61937e161f5d04d525de0ff2bb","modified":1639015009432},{"_id":"public/about/index.html","hash":"af14c9264fc7bcb31abd67c2077b80ff119752b2","modified":1644890897872},{"_id":"public/categories/index.html","hash":"fcfb305bb5ffd840d9db028e89f47faf2d9ba1c0","modified":1644890897872},{"_id":"public/tags/index.html","hash":"bfae23d1aee89464c1c40bcfb3222411f6fbe0ee","modified":1644890897872},{"_id":"public/schedule/index.html","hash":"a133ba2f5d74834948408964abb158357454b62a","modified":1644890897872},{"_id":"public/2022/02/12/JavaScript/随笔/if in 用法/index.html","hash":"80eb43151b2cf95789be4b2ee194a5667bec1fe0","modified":1644890897872},{"_id":"public/2021/11/13/CSS/CSS伪类和伪元素/index.html","hash":"cfc6bcf819be23f78d6b9b689a607b1f7e722cc9","modified":1644890897872},{"_id":"public/2021/11/13/JavaScript/概念/高阶函数/index.html","hash":"10028450985e5b0b1a9465549ebc3ec382f49267","modified":1644890897872},{"_id":"public/2021/11/12/JavaScript/概念/函数柯里化/index.html","hash":"3eeac6ee4b23d0ef8cbe9982f4e09017e1d2595c","modified":1644890897872},{"_id":"public/2021/11/13/JavaScript/概念/数组的emptyItems/index.html","hash":"fd0feebd57e3fb797ae8934464a9ebc8db0580b3","modified":1644890897872},{"_id":"public/2021/11/06/随笔/fetch发送2次请求的原因/index.html","hash":"80c4e5a359c179ca85f48f0db989709d50dbe36b","modified":1644890897872},{"_id":"public/2021/11/06/随笔/RESTful/index.html","hash":"764176491d243623c5a939bc4b93e7051b931b51","modified":1644890897872},{"_id":"public/2021/11/06/其他/Cookie、SessionStorage、LocalStorage的区别/index.html","hash":"a8e6b64f9e039652150b9fe7dd3286dfdc67ca6d","modified":1644890897872},{"_id":"public/2021/11/06/其他/状态码/index.html","hash":"428d80c8109d9805467b52f83a5d78d2d9718f12","modified":1644890897872},{"_id":"public/2021/10/30/HTML/HTML-标签的title/index.html","hash":"ffe9cc50761b8ae5822653513812d94d99757a74","modified":1644890897872},{"_id":"public/2021/10/31/Vue/Vue-methods使用箭头函数/index.html","hash":"65b22379fb436e68a1c59f6c7f6b3c95cd0a9a84","modified":1644890897872},{"_id":"public/2021/10/25/JavaScript/JavaScript-parseInt函数/index.html","hash":"08a0d8451609a5bdacb52a372288455c25dad370","modified":1644890897872},{"_id":"public/2021/10/20/JavaScript/eval函数/index.html","hash":"4aac1ee72557ada747360942799de9e7fa546750","modified":1644890897872},{"_id":"public/2021/10/19/随笔/Git常用命令/index.html","hash":"2b319e22fa1bb53053f37ecff402990b36eb329e","modified":1644890897872},{"_id":"public/2021/10/17/CSS/水平垂直居中方法/index.html","hash":"de08ea4851b77581420e2fcaa411fba0020d79ea","modified":1644890897872},{"_id":"public/2021/10/16/CSS/rem/index.html","hash":"e91d26676cd5dd7899cde2c08dbb0909d81ecb2d","modified":1644890897872},{"_id":"public/2021/10/14/Node JS/Node JS 读取文件/index.html","hash":"67a6b92c820efad589bdc88c3738f6083b6ca9e4","modified":1644890897872},{"_id":"public/archives/index.html","hash":"beb0a8d4c0de25edf28fbd79a7d5f51c2e07a0b9","modified":1644890897872},{"_id":"public/2021/10/13/CSS/margin使用百分号值/index.html","hash":"6fbe882eec4b8cd577b596f53ddac9d0a9f8c1d7","modified":1644890897872},{"_id":"public/archives/page/2/index.html","hash":"2be0d96e2c311141dce1b6f08e05164ef953fe78","modified":1644890897872},{"_id":"public/archives/page/3/index.html","hash":"814792fc7a6eba4c67d6a0519455ff58598c613c","modified":1644890897872},{"_id":"public/archives/page/4/index.html","hash":"c0be9f2ad575fdce884910f84f51c3d664c0b053","modified":1644890897872},{"_id":"public/archives/page/5/index.html","hash":"7e63532b41a1cd2e262425c1413c1f6aaba528f7","modified":1644890897872},{"_id":"public/archives/page/6/index.html","hash":"2d739faeb97f7205a85506d996d84db7664ba6a8","modified":1644890897872},{"_id":"public/archives/2021/page/2/index.html","hash":"8b40b971289efe9221313277d7d0a8bfcb4662bf","modified":1644890897872},{"_id":"public/archives/2021/index.html","hash":"e594241385d06005df41e19e495e3daafde4a041","modified":1644890897872},{"_id":"public/archives/2021/page/3/index.html","hash":"bae71bc5d2238bb875683b21b85dc7771a947d8f","modified":1644890897872},{"_id":"public/archives/2021/page/4/index.html","hash":"e360c1d09858e371b8c1001ff42d9006b4f6a2de","modified":1644890897872},{"_id":"public/archives/2021/page/5/index.html","hash":"5204962a1243c9c87df8f862aa7a3584016b0151","modified":1644890897872},{"_id":"public/archives/2021/10/index.html","hash":"953e492380549ba59b9dbe82a03c753c17957d31","modified":1644890897872},{"_id":"public/archives/2021/10/page/2/index.html","hash":"5520f1e5b399064dce2c5e7f7be3c8fd976d2ba2","modified":1644890897872},{"_id":"public/archives/2021/10/page/3/index.html","hash":"9bb7ea5956f07faab423e58f9d88c32dcae1614a","modified":1644890897872},{"_id":"public/archives/2021/11/index.html","hash":"927aff1e7c2cf794b6c84c05e1d02185bf0b0e17","modified":1644890897872},{"_id":"public/archives/2021/11/page/3/index.html","hash":"94e34ef37d7bfe48ca795a365359be3b39edbcf7","modified":1644890897872},{"_id":"public/archives/2021/12/index.html","hash":"7edf95a1b9d25905fa2a4860f8d894870e988d7d","modified":1644890897872},{"_id":"public/archives/2021/11/page/2/index.html","hash":"35c8252f1353d318f0f0dde679efa0f623669ec2","modified":1644890897872},{"_id":"public/archives/2022/index.html","hash":"5c17a6212322b19cf29f089a4e57c5f02272d7eb","modified":1644890897872},{"_id":"public/archives/2022/02/index.html","hash":"f750234b796d2b8139930aadd7ea4dae887c52b3","modified":1644890897872},{"_id":"public/archives/2022/01/index.html","hash":"b81fed154b8a4f36afdf30c7a86f7208204000c9","modified":1644890897872},{"_id":"public/categories/JavaScript/index.html","hash":"d360804c5f38827308896cbe90201b9afc5d9557","modified":1644890897872},{"_id":"public/categories/JavaScript/page/3/index.html","hash":"673c35e092f3dce5fb356179b887c72513e2ea51","modified":1644890897872},{"_id":"public/categories/JavaScript/page/2/index.html","hash":"025a01ac34a3e3a7662a6baffa9861daa45894fe","modified":1644890897872},{"_id":"public/categories/随笔/index.html","hash":"1ebb782934f2b9e578ff0ca2ffd8df373890adcb","modified":1644890897872},{"_id":"public/categories/随笔/page/2/index.html","hash":"6e7651bac43181d67fa9764d98b5aefb736d061b","modified":1644890897872},{"_id":"public/categories/JavaScript/随笔/index.html","hash":"5d92c4e866c79f97637f5c69aefb53a9e8e9db3b","modified":1644890897872},{"_id":"public/categories/Vue/index.html","hash":"a051247a2528e3834bc4464e5720c2dfd52fedd7","modified":1644890897872},{"_id":"public/categories/CSS/index.html","hash":"cee88ad13ce023d468f2a32e15df599b02483e2a","modified":1644890897872},{"_id":"public/categories/HTML/index.html","hash":"ec2b7817859ed4d0fa3226204ebf52f4681f11ba","modified":1644890897872},{"_id":"public/categories/Vue/Vue3/index.html","hash":"0b5dc25bbca6706447a6b7a18de55fa7d1c25669","modified":1644890897872},{"_id":"public/categories/CSS/随笔/index.html","hash":"2b029eea68b41a100b187c8524220fb0361edade","modified":1644890897872},{"_id":"public/categories/JavaScript/Global-Objects/index.html","hash":"7d3fb073b73a071423d98288e827155d1d8d8279","modified":1644890897872},{"_id":"public/categories/JavaScript/Array/index.html","hash":"4a8d82e2353ce88fa418da7308643e217c7afde6","modified":1644890897872},{"_id":"public/categories/HTML/随笔/index.html","hash":"7a1bc3032310763d2de262ca818d4b0ea3dd378e","modified":1644890897872},{"_id":"public/categories/Vue/随笔/index.html","hash":"7b760e3dfc5836f7c348106e36b74f9001d6b049","modified":1644890897872},{"_id":"public/categories/Node-JS/index.html","hash":"b1fb138ce8f1c9f6450b252e9f4bcb5808cfe784","modified":1644890897872},{"_id":"public/categories/Vue/VueRouter/index.html","hash":"4ee5f9df0ee82012f2206a8fd91e77a6d41219d0","modified":1644890897872},{"_id":"public/categories/JavaScript/Promise/index.html","hash":"949c3d5780a5e1d41397619c316aa7a7ba13c6fc","modified":1644890897872},{"_id":"public/categories/Vue/Vue2文档/index.html","hash":"751f736d3e00fa930ceb79c81202187228c6d2a2","modified":1644890897872},{"_id":"public/categories/JavaScript/ES6/index.html","hash":"847cacc3202ddda419e59aa9945440518ae1911b","modified":1644890897872},{"_id":"public/categories/Node-JS/fs/index.html","hash":"c917c45994e5bb3c506e1c509f5b70ba732fa2bf","modified":1644890897872},{"_id":"public/categories/JavaScript/概念/index.html","hash":"e58ed0fe3b45ab6d7d90637d58d915682241c18e","modified":1644890897872},{"_id":"public/2021/11/17/随笔/浏览器的回流和重绘/index.html","hash":"5701d8e4defe97b28889588a09599f3218d44e14","modified":1644890897872},{"_id":"public/2022/01/19/JavaScript/随笔/js遍历对象的方法/index.html","hash":"64912f84fc656e598ab82693cf440327d492420a","modified":1644890897872},{"_id":"public/2021/12/28/Node JS/NodeJS下载和npm安装/index.html","hash":"7c60094b4a84a39095da9f79c15d63f470e804ec","modified":1644890897872},{"_id":"public/2021/11/16/Vue/Vue生命周期/index.html","hash":"ba99b4c83085f3003006e54eb97044be6ca93309","modified":1644890897872},{"_id":"public/2021/11/14/JavaScript/概念/迭代器/index.html","hash":"212a476973c4f4470789f4c67b690bdb7a2987d1","modified":1644890897872},{"_id":"public/2021/11/14/JavaScript/数组的方法/index.html","hash":"a2d5c937684185a12cb6218752e51f832a3e9e66","modified":1644890897872},{"_id":"public/2021/11/12/JavaScript/ES6/ES6随笔1/index.html","hash":"08e9469f53669178f56d14b82d023e0500d38c33","modified":1644890897872},{"_id":"public/2021/11/11/JavaScript/ES6/JavaScript-ES6解构/index.html","hash":"33e3b4fe6b5d1a55592c7b8ba4981a022588510d","modified":1644890897872},{"_id":"public/2021/11/10/JavaScript/ES6/JavaScript箭头函数/index.html","hash":"6758fe8bf5bf85b8713b2113dc23b1a95b351d8f","modified":1644890897872},{"_id":"public/2021/11/09/JavaScript/概念/JavaScript原型链/index.html","hash":"3b63dc1f8f6566026119795051ff492496294f2e","modified":1644890897872},{"_id":"public/2021/11/07/Vue/VueRouter两种模式/index.html","hash":"4558fa3479885c0cd10905cca687d07f384e2123","modified":1644890897872},{"_id":"public/2021/11/07/Node JS/JavaScript事件循环/index.html","hash":"77c44b6112768f9b63f4771db7db41adc7ac5886","modified":1644890897872},{"_id":"public/2021/11/07/JavaScript/ES6/async和await的基本使用/index.html","hash":"067485eec29d75ced4a0c6aab57e7b4a2aae3aab","modified":1644890897872},{"_id":"public/2021/11/06/JavaScript/WebWorker/index.html","hash":"8caebf3ed01c997a7a56d8306f7cddfa9ddf6c32","modified":1644890897872},{"_id":"public/2021/11/06/其他/TCP/index.html","hash":"b9d7e5521876c21af0d18c1e1c14cb15ebae2be7","modified":1644890897872},{"_id":"public/2021/11/05/其他/HTTP和HTTPS/index.html","hash":"a312e84e17726209f9e7d98607ca4e4d03f57811","modified":1644890897872},{"_id":"public/2021/10/29/Vue/Vue2教程/Vue2-教程-深入了解组件/index.html","hash":"b2a14d10bf9c41cb9f12bd005b51be20e1d5bd69","modified":1644890897872},{"_id":"public/2021/10/29/Vue/Vue2教程/Vue2-教程-基础使用/index.html","hash":"946a64a8580d6fb8efe3ee6ba1946113e21323af","modified":1644890897872},{"_id":"public/2021/10/25/CSS/CSS-元素选择器/index.html","hash":"66164c296cedf341ac4a08f94592da5826006620","modified":1644890897872},{"_id":"public/2021/10/29/JavaScript/概念/JavaScript-冒泡和捕获/index.html","hash":"985c711ae4fc01ea9b47ca5d0fa8ddb58fdbdbc4","modified":1644890897872},{"_id":"public/2021/10/27/CSS/CSS-flex/index.html","hash":"0c443327ecdb08aa240b6d4b5cac80d8ea86d440","modified":1644890897872},{"_id":"public/2021/10/25/JavaScript/JavaScript-map函数/index.html","hash":"764932bc960b8c27a036937538a2d74d08e27a46","modified":1644890897872},{"_id":"public/2021/10/23/其他/HTTP概述/index.html","hash":"e71689f485edc8c83e91524e6f5604938315a4cc","modified":1644890897872},{"_id":"public/2021/10/24/CSS/border-radius的原理和使用/index.html","hash":"0411fe9f833ae3683f11956e63f7cf8df2116b15","modified":1644890897872},{"_id":"public/2021/10/22/其他/浏览器缓存策略/index.html","hash":"250c741aab402add403c1130590bf51743ea1a2a","modified":1644890897872},{"_id":"public/2021/10/21/HTML/块环境上下文/index.html","hash":"2c7fcb058db43a13ad05835ba418702e37236299","modified":1644890897872},{"_id":"public/2021/10/20/CSS/外边距合并/index.html","hash":"bce12bad1abdc1b9800da666077a149841dd8db8","modified":1644890897872},{"_id":"public/2021/10/19/JavaScript/JavaScript浅拷贝和深拷贝/index.html","hash":"a7e22d131aa52e97af04c119194e19cd3d46e913","modified":1644890897872},{"_id":"public/2021/10/19/JavaScript/概念/JavaScript类型转换/index.html","hash":"b3cc551cdcba01acdaf331d9f13c25aaa9462cec","modified":1644890897872},{"_id":"public/2021/10/17/JavaScript/概念/数据类型判断/index.html","hash":"1fc0820507a885d0ef90e5bc944d81a30844807e","modified":1644890897872},{"_id":"public/2021/10/18/JavaScript/call-apply-bind实现/index.html","hash":"228718e8d890f56e249ce960e873576bba75c871","modified":1644890897872},{"_id":"public/2021/10/16/Vue/vue2和vue3的区别/index.html","hash":"d0084ae5ae02190d8a6a0e571db1c80329dcb20d","modified":1644890897872},{"_id":"public/2021/10/13/随笔/next/index.html","hash":"479b810ae2e4c19da7024798106dc854268a7f40","modified":1644890897872},{"_id":"public/2021/10/13/随笔/hexo/index.html","hash":"e0ea93fc9514c45686315f9a455472268a108029","modified":1644890897872},{"_id":"public/tags/JavaScript/index.html","hash":"69d60f03dad186cd56ec46d85feff76cee942b23","modified":1644890897872},{"_id":"public/tags/JavaScript/page/2/index.html","hash":"4a2b7dd01f343651c42eb227f87f1e382860604d","modified":1644890897872},{"_id":"public/tags/JavaScript/page/3/index.html","hash":"028893e2dd5374fa271ee8710ea789c0b7de038a","modified":1644890897872},{"_id":"public/tags/随笔/index.html","hash":"df7038167f3f09501f20c4b15a89c796a0c60eba","modified":1644890897872},{"_id":"public/tags/随笔/page/3/index.html","hash":"8e77fcc43afe5b4c706bd154e124f25df59783ff","modified":1644890897872},{"_id":"public/tags/Vue/index.html","hash":"bca7f858011eb03c254aeef0a34a46e74d0e3712","modified":1644890897872},{"_id":"public/tags/随笔/page/2/index.html","hash":"80091d90fa41b63b1b8df3a4df97ca4883027140","modified":1644890897872},{"_id":"public/tags/文档/index.html","hash":"574e40d0dd0d99c08dd4b348849076a8a2345470","modified":1644890897872},{"_id":"public/tags/npm/index.html","hash":"f41edb4499c441765b6692c54cae56383c1e3af9","modified":1644890897872},{"_id":"public/tags/CSS/index.html","hash":"5cc03cbebe3f1811856e004c374917974f59b7ad","modified":1644890897872},{"_id":"public/tags/HTML/index.html","hash":"bb2f805ecef3acf18265b054d31d584313e9893c","modified":1644890897872},{"_id":"public/tags/flex/index.html","hash":"ea69f91cba44c1e6d112228636bc632cc43cb681","modified":1644890897872},{"_id":"public/tags/外边距合并/index.html","hash":"627335b975b610b0974efbfceee44b8090d838a1","modified":1644890897872},{"_id":"public/tags/border-radius/index.html","hash":"5e506fb16459c9fa8a6462ff2966dee395cdfed5","modified":1644890897872},{"_id":"public/tags/长度单位/index.html","hash":"0cd6662ef8ba4f44a471b4fd0b8d861c0409fa1a","modified":1644890897872},{"_id":"public/tags/margin/index.html","hash":"4add70b9409e340744f59b950a42953c31c34c57","modified":1644890897872},{"_id":"public/tags/元素选择器/index.html","hash":"c7cae5acd58a8b94afddd5d6503ce6ed28f1793d","modified":1644890897872},{"_id":"public/tags/parseInt/index.html","hash":"ac9dca1aa86806450773770751381cb24e31cfdd","modified":1644890897872},{"_id":"public/tags/深拷贝/index.html","hash":"3f869e60d77a231ff2e3333264f8bdec28bb2619","modified":1644890897872},{"_id":"public/tags/浅拷贝/index.html","hash":"92f9cca4d2ca44ddbfb4c1f056f4fcb6caa10df9","modified":1644890897872},{"_id":"public/tags/call/index.html","hash":"e3935fe9e176d091b451c5ef2bf1316b6b0a2cb7","modified":1644890897872},{"_id":"public/tags/bind/index.html","hash":"e3797275cc96a0cb06dc2d36cddbabb92d6e496c","modified":1644890897872},{"_id":"public/tags/apply/index.html","hash":"58c407b3d324166fad61c16783e9eeb811562b3c","modified":1644890897872},{"_id":"public/tags/WebWorker/index.html","hash":"e3de85f1a03bc7d8632a32cc3d937907502dd81a","modified":1644890897872},{"_id":"public/tags/eval/index.html","hash":"b7f5f963257c7f58210b8994e74dd0d4a80d36f3","modified":1644890897872},{"_id":"public/tags/源码/index.html","hash":"3ce773856cf4183eff28e11ff4022a14411fdcf8","modified":1644890897872},{"_id":"public/tags/Array/index.html","hash":"dc135317408b2a0cca8fd209f8cdc9827661347c","modified":1644890897872},{"_id":"public/tags/map函数/index.html","hash":"2cfdc8c55db02b03f9b7854af56aaff98b79b30f","modified":1644890897872},{"_id":"public/tags/BFC/index.html","hash":"cb36fbfbee6f7641c12e01ac69f3fe3aad1bf073","modified":1644890897872},{"_id":"public/tags/VueRouter/index.html","hash":"ba40a4904a96592b2055e20ab6df4ee0b0a1bcd3","modified":1644890897872},{"_id":"public/tags/Vue3的不同/index.html","hash":"47ba0c602033a857ff184424e07668b2d8ce2875","modified":1644890897872},{"_id":"public/tags/生命周期/index.html","hash":"a84de41cd1ddd72519db330eb61ef9ea00e1688e","modified":1644890897872},{"_id":"public/tags/Node-JS/index.html","hash":"cef068f5bcf3fbc043accfcb7bf41a43d69fc5a7","modified":1644890897872},{"_id":"public/tags/事件循环/index.html","hash":"95ca24bebd9f5dfa9f60a81c10bf5ec65e78ee12","modified":1644890897872},{"_id":"public/tags/fs/index.html","hash":"8b0faaef29d1fe26420112837a1f9c50d80df336","modified":1644890897872},{"_id":"public/tags/NodeJS/index.html","hash":"ad42c99c563ffbb4b7c6890ba75afb6ae1d632bf","modified":1644890897872},{"_id":"public/tags/安装教程/index.html","hash":"cd52292aeec4a03390c18570b3ab4290873ef8b0","modified":1644890897872},{"_id":"public/tags/Cookie/index.html","hash":"711b9fcce93747f151bc5792ede3e9ba0b410c93","modified":1644890897872},{"_id":"public/tags/LocalStorage/index.html","hash":"6d5f2ac14b7036120d77d4de79bbd5c25e21ad1a","modified":1644890897872},{"_id":"public/tags/SessionStorage/index.html","hash":"a99790e4ec10dba1d9bd1dd91e2a3c9d2e4f4f6b","modified":1644890897872},{"_id":"public/tags/TCP/index.html","hash":"674fc1309edc03904fbe8ba7e09b907bc5bb67f7","modified":1644890897872},{"_id":"public/tags/HTTP/index.html","hash":"ff6d7d742ea4e069db8d5c9bba41b0d5e454082c","modified":1644890897872},{"_id":"public/tags/缓存策略/index.html","hash":"68c1df880dc796884db8be81683c85e0b89b2a8c","modified":1644890897872},{"_id":"public/tags/状态码/index.html","hash":"192775f4b6069ec62fe7c2a24d46e023a71b5092","modified":1644890897872},{"_id":"public/tags/RESTful架构/index.html","hash":"906e22632306c5865f3a2f22e8e1e6128d859a05","modified":1644890897872},{"_id":"public/tags/Git/index.html","hash":"89462ad341995ac4eb8324c1458243c2ad669612","modified":1644890897872},{"_id":"public/tags/回流和重绘/index.html","hash":"8f33a77b03512232fcdfa277f14db177a36f1b41","modified":1644890897872},{"_id":"public/tags/Vue2/index.html","hash":"50806015e8e62c653487b1fdfe4a9189fb889174","modified":1644890897872},{"_id":"public/tags/性能/index.html","hash":"d1de1d3826e0f795f7891df7e563700c65306f7e","modified":1644890897872},{"_id":"public/tags/冒泡/index.html","hash":"37bf5ddb98b997dbd388e1c3b930032a7c8e1f20","modified":1644890897872},{"_id":"public/tags/箭头函数/index.html","hash":"702aea5e9767177b30793d5ec5f3e820013b8cda","modified":1644890897872},{"_id":"public/tags/Promise/index.html","hash":"78495a1cbcce5748403d74ba757eee6218022f22","modified":1644890897872},{"_id":"public/tags/捕获/index.html","hash":"82e2245e34030dec204aafdfcc912cd2f940ffaf","modified":1644890897872},{"_id":"public/tags/事件委托/index.html","hash":"6b7dbc76276f9c2ba94809bc655ca6e034bb0081","modified":1644890897872},{"_id":"public/tags/ES6/index.html","hash":"9347e9418d3176c4c2fea4d16c09132e3c7c63a4","modified":1644890897872},{"_id":"public/tags/解构赋值/index.html","hash":"cf9555e481a46a363f310b4bbb15e75c4f81eae2","modified":1644890897872},{"_id":"public/tags/数据类型判断/index.html","hash":"7b3c0e78826419e0852431212043888df5b9f299","modified":1644890897872},{"_id":"public/tags/迭代器/index.html","hash":"dd1f2f9ad1f2d0592bf4b9b032856b471c2ae087","modified":1644890897872},{"_id":"public/tags/原型链/index.html","hash":"ab63af706e71cdf96beb264a27363e02a31e1771","modified":1644890897872},{"_id":"public/tags/类型转换/index.html","hash":"d17bb4b1e1d7dbc737f57666486afa3bb116ad17","modified":1644890897872},{"_id":"public/index.html","hash":"e6bcda3e44216055dfd2813f7ddad59e6f0fd762","modified":1644890897872},{"_id":"public/page/2/index.html","hash":"4de8da46e25f99190ed9af4ec55e5a5221301b85","modified":1644890897872},{"_id":"public/page/4/index.html","hash":"6cedbec057e8dc0dbbc1657767206a8daf9fde11","modified":1644890897872},{"_id":"public/page/3/index.html","hash":"1ff87362d68978275e00904d5ee1939b0d3ae3d9","modified":1644890897872},{"_id":"public/page/6/index.html","hash":"7df4b10b67c41a9fc7b77982a8449fa749c5bc8d","modified":1644890897872},{"_id":"public/page/5/index.html","hash":"87566cd6d006ed4a0a5ac5e073827fcf2579be11","modified":1644890897872},{"_id":"public/atom.xml","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1644890897872},{"_id":"public/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1644890897872},{"_id":"public/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1644890897872},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1644890897872},{"_id":"public/images/avatar.gif","hash":"2dbc3e2f2d624b2ca1afe6edc2ca17307f1950c8","modified":1644890897872},{"_id":"public/坑.txt","hash":"f69c9194e8b0d1d3a94374b9345bb308e76e26f5","modified":1644890897872},{"_id":"public/images/logo-algolia-nebula-blue-full.svg","hash":"b85e274207b1392782476a0430feac98db1e7da0","modified":1644890897872},{"_id":"public/images/logo.svg","hash":"2cb74fd3ea2635e015eabc58a8d488aed6cf6417","modified":1644890897872},{"_id":"public/sitemap.xml","hash":"b38832fd6016e0bc76a290b2861caefa2c1f31c5","modified":1644890897872},{"_id":"public/2021/10/27/CSS/CSS-flex/image-20211027211015004.png","hash":"34990f8f3cbc5fe8dc9261c3c893d2c3f7f2a4a3","modified":1644890897872},{"_id":"public/2021/10/27/CSS/CSS-flex/image-20211027210947232.png","hash":"bf81c523b1fcf15c0b6fdded03d3e483cf6b2026","modified":1644890897872},{"_id":"public/2021/10/27/CSS/CSS-flex/image-20211027213217557.png","hash":"2f7de6cc1f1d274b5a44a3779f50593ba652cbd9","modified":1644890897872},{"_id":"public/2021/10/27/CSS/CSS-flex/image-20211027212431340.png","hash":"39b09cfcbc2f8e4eddfc28ccbbb13f69125c21df","modified":1644890897872},{"_id":"public/2021/10/30/HTML/HTML-标签的title/image-20211030223916508.png","hash":"aaf82386c2b210b59485b6ffb94b8a471a1d3963","modified":1644890897872},{"_id":"public/2021/10/20/CSS/外边距合并/image-20211020224237425.png","hash":"c38bca6d5f3213bc626ab420adda37161fb5e173","modified":1644890897872},{"_id":"public/2021/10/27/CSS/CSS-flex/image-20211027214029980.png","hash":"0cd8cdac133cc8d76ae78e7b3b558d6730055085","modified":1644890897872},{"_id":"public/2021/10/20/CSS/外边距合并/image-20211021103824947.png","hash":"fde159d717951f48d21cc843c4460a7a57a40692","modified":1644890897872},{"_id":"public/2021/10/20/CSS/外边距合并/image-20211020224217218.png","hash":"b187be05b0dbde99993c1386de0c34c0280f643c","modified":1644890897872},{"_id":"public/2021/10/24/CSS/border-radius的原理和使用/image-20211025104342522.png","hash":"500505d2a73e790555ab1a4e6cfce52c3395113b","modified":1644890897872},{"_id":"public/2021/10/24/CSS/border-radius的原理和使用/image-20211025104917514.png","hash":"a8fdd5ad0499d195a9437ad22e34dc3aa9ce9f08","modified":1644890897872},{"_id":"public/2021/10/21/HTML/块环境上下文/image-20211022161542404.png","hash":"11a9d691555352c1eb281b44692504a7c4a0b694","modified":1644890897872},{"_id":"public/2021/10/24/CSS/border-radius的原理和使用/image-20211025155459099.png","hash":"a83bf7f718c7f04009881c0c6350bd55edfee672","modified":1644890897872},{"_id":"public/2021/11/16/Vue/Vue生命周期/lifecycle.png","hash":"53345be1363e09b3e43e34d27c030c4f376b060a","modified":1644890897872},{"_id":"public/2021/11/07/Node JS/JavaScript事件循环/image-20211107211640084.png","hash":"baac3f40a26378e3399a7a3ecfb094227d73fb91","modified":1644890897872},{"_id":"public/2021/10/21/HTML/块环境上下文/image-20211022110540794.png","hash":"a355acd642404c3a7f119e4d2ca3bb14d978ee6d","modified":1644890897872},{"_id":"public/2021/11/16/Vue/Vue生命周期/lifecycle9.jpg","hash":"ea85b53c2ea6a92284e7bec52620fd65b3687b3c","modified":1644890897872},{"_id":"public/2021/10/23/其他/HTTP概述/image-20211024100324347.png","hash":"f7fec974df9c56a7b7815b913a07b54af72c87c0","modified":1644890897872},{"_id":"public/2021/12/28/Node JS/NodeJS下载和npm安装/image-20211228140948410-16406717947501.png","hash":"0439ce9a1f18c52dfebe6afa3a919b8eb7f9668e","modified":1644890897872},{"_id":"public/2021/10/13/随笔/next/image-20211018110937363.png","hash":"e33626d3447b1c540912566a42211dd65ef806d4","modified":1644890897872},{"_id":"public/2021/11/17/随笔/浏览器的回流和重绘/painted and re-render.jpg","hash":"e5fa9cac965abb215a05d9ee03059441a573e680","modified":1644890897872},{"_id":"public/2021/11/09/JavaScript/概念/JavaScript原型链/image-20211110100356010.png","hash":"136541b9bb45661a522e9c05135c25ed38bebe5c","modified":1644890897872},{"_id":"public/2021/10/29/Vue/Vue2教程/Vue2-教程-基础使用/image-20211105095952701.png","hash":"0ca710835c8a45962fd69153462961a59bab075a","modified":1644890897872},{"_id":"public/2021/11/09/JavaScript/概念/JavaScript原型链/image-20211110101346723.png","hash":"93762b483e0e557337e9e624a7d7b07789b42419","modified":1644890897872},{"_id":"public/2021/10/19/JavaScript/概念/JavaScript类型转换/image-20211019105728109.png","hash":"1d245a7f45d02b2ba8c51b3ee8fd3ac25aa03009","modified":1644890897872},{"_id":"public/2021/10/29/Vue/Vue2教程/Vue2-教程-基础使用/lifecycle.png","hash":"53345be1363e09b3e43e34d27c030c4f376b060a","modified":1644890897872},{"_id":"public/css/noscript.css","hash":"54d14cd43dc297950a4a8d39ec9644dd5fc3499f","modified":1644890897872},{"_id":"public/js/bookmark.js","hash":"0f563ffbf05fad30e854e413ab17ff7164ab5a53","modified":1644890897872},{"_id":"public/js/config.js","hash":"4c4ebbe3b3f3841a26f9d5af6d0ba8bc6da01c54","modified":1644890897872},{"_id":"public/js/comments.js","hash":"66ae2e26ea36a41b72c638ea8b220296638ae952","modified":1644890897872},{"_id":"public/js/schedule.js","hash":"2b43e2d576a308289880befc27580dbb2aa34439","modified":1644890897872},{"_id":"public/js/comments-buttons.js","hash":"1a7344440321713426a0b2ab17e276b5bdf85ade","modified":1644890897872},{"_id":"public/js/next-boot.js","hash":"48497e2156a10155dc42311633a110c9685692c9","modified":1644890897872},{"_id":"public/js/utils.js","hash":"370d417d76a897f09c11a49d2c8c8b723921bd9a","modified":1644890897872},{"_id":"public/js/schemes/muse.js","hash":"62f4638674c92dfb72454fee38751d0227d3d225","modified":1644890897872},{"_id":"public/js/third-party/fancybox.js","hash":"c098d14e65dd170537134358d4b8359ad0539c2c","modified":1644890897872},{"_id":"public/js/motion.js","hash":"6d4bd07a6f8e1b4083119dca0acb5b289533b619","modified":1644890897872},{"_id":"public/js/pjax.js","hash":"0523cb1946907687c53999e2ce7cfe1831da6476","modified":1644890897872},{"_id":"public/js/third-party/pace.js","hash":"0ef04218b93561ba4d0ff420d556c3d90a756d32","modified":1644890897872},{"_id":"public/js/third-party/chat/tidio.js","hash":"b0079f6a4601e06ca6fe46e83a2f5af553e9bc3c","modified":1644890897872},{"_id":"public/js/third-party/chat/gitter.js","hash":"cc38c94125f90dadde11b5ebac7d8bf99a1a08a2","modified":1644890897872},{"_id":"public/js/third-party/quicklink.js","hash":"6f58cd7aa8f6f1ab92d5a96551add293f4e55312","modified":1644890897872},{"_id":"public/js/third-party/rating.js","hash":"4e92c2d107ba47b47826829f9668030d5ea9bfb8","modified":1644890897872},{"_id":"public/js/third-party/analytics/google-analytics.js","hash":"59684383385059dc4f8a1ff85dbbeb703bcdbcb5","modified":1644890897872},{"_id":"public/js/third-party/analytics/baidu-analytics.js","hash":"f629acc46ff40c071ffd31b77d5c7616f0fdd778","modified":1644890897872},{"_id":"public/js/third-party/math/katex.js","hash":"83c54ee536e487a1031783443fe0cb63b1b4767e","modified":1644890897872},{"_id":"public/js/third-party/analytics/growingio.js","hash":"78dd3cf04082b7dbe6246e404b2aa8e726922402","modified":1644890897872},{"_id":"public/js/third-party/math/mathjax.js","hash":"5c749b9c1c3bb738122d0516211ecff6496d4907","modified":1644890897872},{"_id":"public/js/third-party/chat/chatra.js","hash":"c32180522788c10e51df1803aa6842ef0432ddc9","modified":1644890897872},{"_id":"public/js/third-party/comments/changyan.js","hash":"8c8ebec444c727b704ea41ad88b0b96ed2e4b8d4","modified":1644890897872},{"_id":"public/js/third-party/comments/livere.js","hash":"2247d88c934c765c43013337860774aaa99f0b31","modified":1644890897872},{"_id":"public/js/third-party/comments/gitalk.js","hash":"0ec038cf83e8ec067534f16a54041e47a3c1e59a","modified":1644890897872},{"_id":"public/js/third-party/comments/disqusjs.js","hash":"b6c58f098473b526d6a3cd35655caf34b77f7cff","modified":1644890897872},{"_id":"public/js/third-party/comments/disqus.js","hash":"e1cc671b0d524864fd445e3ab4ade9ee6d07e565","modified":1644890897872},{"_id":"public/js/third-party/comments/isso.js","hash":"753a873b6f566aff5ba77ca23f91b78eb880ca64","modified":1644890897872},{"_id":"public/js/third-party/search/algolia-search.js","hash":"ac401e3736d56a3c9cb85ab885744cce0b813c55","modified":1644890897872},{"_id":"public/js/third-party/comments/utterances.js","hash":"f67f90eb03e284c82da2b8cf2f1e31801813c16d","modified":1644890897872},{"_id":"public/js/third-party/statistics/firestore.js","hash":"0960f16107ed61452fb0dffc6ed22dc143de34ef","modified":1644890897872},{"_id":"public/js/third-party/search/local-search.js","hash":"45c485f82258d246f37deb66884bd2643323ef3a","modified":1644890897872},{"_id":"public/js/third-party/tags/mermaid.js","hash":"3dc4628efa6debd6490fc0ebddff2424a7b319d8","modified":1644890897872},{"_id":"public/js/third-party/statistics/lean-analytics.js","hash":"5a928990856b8e456f0663cf3b6b406733672e39","modified":1644890897872},{"_id":"public/js/third-party/tags/pdf.js","hash":"af78c22f0e61c8c8aa8794e585e0d632c6d4fcb8","modified":1644890897872},{"_id":"public/css/main.css","hash":"7b74ac07b90e95c2be358435e9eb8b56d53fe2cb","modified":1644890897872},{"_id":"public/uploads/avatar.jpg","hash":"5f4ab51a8d0af1455145ce56be7e01f6736f8a5c","modified":1644890897872},{"_id":"public/2021/11/06/其他/TCP/image-20211106102234899.png","hash":"9fa19fb8051342a48b1b3a2e4be0a5919285efea","modified":1644890897872},{"_id":"public/2021/11/06/其他/TCP/image-20211106102310315.png","hash":"9ab8ce6c9f390dc32264a876d806fe8c700a0ee1","modified":1644890897872},{"_id":"public/2021/11/06/其他/TCP/image-20211106102459740.png","hash":"50dbf1cf3c1c331688bb8d376b1ed9d6302d6f04","modified":1644890897872},{"_id":"public/2021/11/06/其他/TCP/image-20211106102433477.png","hash":"9ac8637d32e1c1c3cba0368425ed67333f61b644","modified":1644890897872},{"_id":"public/2021/10/13/随笔/next/image-20211018105920422.png","hash":"e341d7152de219128a727e35346895e097fb2264","modified":1644890897872},{"_id":"public/2021/10/13/随笔/next/image-20211018110658046.png","hash":"b131a9bdba8d0e200391d37d321d6080625995bc","modified":1644890897872},{"_id":"public/2021/10/29/JavaScript/概念/JavaScript-冒泡和捕获/image-20210907141230550.png","hash":"811c784be4ff3b10f97e204b4134683fe82af25f","modified":1644890897872},{"_id":"public/2021/11/06/其他/TCP/image-20211106102333564.png","hash":"2b43d26ca2bf1052f0570578cbac54cfecd8b42b","modified":1644890897872},{"_id":"public/2021/10/23/其他/HTTP概述/image-20211024104204389.png","hash":"0f667867be62f3e6c81582c5ce4d48f26e960852","modified":1644890897872},{"_id":"public/2021/11/06/其他/TCP/image-20211106103554196.png","hash":"76622b090956f9630d2d779042effb7bcf271fbe","modified":1644890897872},{"_id":"public/2021/11/06/其他/TCP/image-20211106102538627.png","hash":"e28b7868d0523bbe2205983e121dd1ea45873c91","modified":1644890897872},{"_id":"public/2021/11/09/JavaScript/概念/JavaScript原型链/290701352241158.jpg","hash":"5c2fdb4880a69ec4a76137d5fcc56ee42a0aebf7","modified":1644890897872},{"_id":"public/2021/11/05/其他/HTTP和HTTPS/image-20210831164301870.png","hash":"a8045946c97a2a7c035aa205b6a3abb5cb83f252","modified":1644890897872},{"_id":"public/2021/10/22/其他/浏览器缓存策略/image-20211023161739229.png","hash":"c8e0fd49b9762d61937e161f5d04d525de0ff2bb","modified":1644890897872}],"Category":[{"name":"JavaScript","_id":"ckznhkk6y0004ikubgons9neb"},{"name":"css","_id":"ckznhkk71000bikubcfubfkpf"},{"name":"随笔","_id":"ckznhkk73000fikubd9an4ou1"},{"name":"随笔","parent":"ckznhkk6y0004ikubgons9neb","_id":"ckznhkk75000likubemr7ag68"},{"name":"sass","parent":"ckznhkk71000bikubcfubfkpf","_id":"ckznhkk78000wikub8t4374fl"},{"name":"Vue","_id":"ckznhkk7c001bikubgscdb22r"},{"name":"JQuery","_id":"ckznhkk7d001kikub1ak3gy7u"},{"name":"React","_id":"ckznhkk7g001rikub7ddrakzg"},{"name":"elementUI","_id":"ckznhkk7h001zikuba1braor0"},{"name":"router","_id":"ckznhkk7k0028ikubag5ge8yu"},{"name":"webpack","_id":"ckznhkk7m002mikubefwx9ows"},{"name":"CSS","_id":"ckznhkk7o002uikubaq8bhvru"},{"name":"Vue3","parent":"ckznhkk7c001bikubgscdb22r","_id":"ckznhkk7p002zikub9h9tfflb"},{"name":"HTML","_id":"ckznhkk7r0036ikub7ym473i2"},{"name":"Global_Objects","parent":"ckznhkk6y0004ikubgons9neb","_id":"ckznhkk89004xikub0pcwfp1b"},{"name":"随笔","parent":"ckznhkk7o002uikubaq8bhvru","_id":"ckznhkk8d005eikubhhn5410x"},{"name":"Array","parent":"ckznhkk6y0004ikubgons9neb","_id":"ckznhkk8h005uikub0gq41axw"},{"name":"随笔","parent":"ckznhkk7r0036ikub7ym473i2","_id":"ckznhkk8m006jikub9ojpbxy2"},{"name":"随笔","parent":"ckznhkk7c001bikubgscdb22r","_id":"ckznhkk8n006pikubc7ln7d3v"},{"name":"VueRouter","parent":"ckznhkk7c001bikubgscdb22r","_id":"ckznhkk8p0074ikub5o2q9qct"},{"name":"Node JS","_id":"ckznhkk8s007likubczcj53gl"},{"name":"bug","_id":"ckznhkk8t007uikub1fk5e9rc"},{"name":"Vue2","parent":"ckznhkk7c001bikubgscdb22r","_id":"ckznhkk8x008pikub94we9map"},{"name":"Vue2文档","parent":"ckznhkk7c001bikubgscdb22r","_id":"ckznhkk90009bikubg6p84k0l"},{"name":"Promise","parent":"ckznhkk6y0004ikubgons9neb","_id":"ckznhkk91009fikub8hsg1ezb"},{"name":"ES6","parent":"ckznhkk6y0004ikubgons9neb","_id":"ckznhkk91009kikubey4n8rdb"},{"name":"概念","parent":"ckznhkk6y0004ikubgons9neb","_id":"ckznhkk92009qikub3o6vh448"},{"name":"fs","parent":"ckznhkk8s007likubczcj53gl","_id":"ckznhkk92009yikubbp5b0yb9"}],"Data":[],"Page":[{"title":"about","date":"2021-10-16T02:55:53.000Z","type":"about","_content":"","source":"about/index.md","raw":"---\ntitle: about\ndate: 2021-10-16 10:55:53\ntype: \"about\"\n---\n","updated":"2021-12-09T01:56:49.432Z","path":"about/index.html","comments":1,"layout":"page","_id":"ckznhkk6o0000ikub02nm9xnv","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"categories","date":"2021-10-16T02:38:19.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2021-10-16 10:38:19\ntype: \"categories\"\n---\n","updated":"2021-12-09T01:56:49.432Z","path":"categories/index.html","comments":1,"layout":"page","_id":"ckznhkk6w0002ikubhgt89bj8","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"tags","date":"2021-10-15T19:20:23.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2021-10-16 03:20:23\ntype: \"tags\"\n---\n","updated":"2021-12-09T01:56:49.432Z","path":"tags/index.html","comments":1,"layout":"page","_id":"ckznhkk6y0006ikubeizt8abv","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"schedule","date":"2021-10-16T02:56:13.000Z","type":"schedule","_content":"","source":"schedule/index.md","raw":"---\ntitle: schedule\ndate: 2021-10-16 10:56:13\ntype: \"schedule\"\n---\n","updated":"2021-12-09T01:56:49.432Z","path":"schedule/index.html","comments":1,"layout":"page","_id":"ckznhkk6z0008ikubev9f96fj","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"JavaScript变量的作用域","date":"2021-11-10T12:18:30.000Z","_content":"\n\n\n#  JavaScript变量的作用域 Scpoe\n\n作用域的概念，简单来说就是对于一个\n\n\n\na = 1，这个操作等于了在全局变量上进行了创建。如同使用一个普通函数 fn()，一样，这个函数的this指向也是全局的变量。\n\n\n\n* 浏览器和node的一个小区别，在全局变量中，\n\n  * node的全局变量，是一个名为Global 的全局对象，并且使用 var定义的变量不会加入其中，只有直接定义的变量会加入其中。\n\n    * ```\n      var a = 1;\n      b = 2;\n      ```\n\n  * 浏览器的全局变量，是一个window对象，使用var定义的变量和直接定义的变量也会加入其中。\n\n    * ```\n      a = 1;\n      var b = 2;\n      \n      下面定义的不会加入其中。\n      let c = 3;\n      const d = 4;\n      ```\n\n\n\n这里的一个问题，就是你会发现，这里的a为什么是先输出的1.\n\n​\t\t开始我的理解是，先有个a的参数嘛，然后又预定义了一个a，因为这个var是在词法环境的阶段进行了操作。然后再进行了输出，此时就应该是undefined，但是是不对的。\n\n​\t\t**个人认为正确的理解**：首先我们得知道var的定义是在词法环境的创建的时候进行的定义，所以我们就知道了函数的参数其实是在词法环境之后进行的赋值，所以我们是先定义了一个 var a; 此时这个a为undefined，然后便是进行一个参数a的赋值，此时这个a以及被定义了，所以a的赋值是在a的定义之后的。\n\n```\n(function (a) {\n  console.log(a);\n  var a = 4;\n  console.log(a);\n})(1)\n\n1\n4\n```\n\n","source":"_drafts/JavaScript变量的作用域.md","raw":"---\ntitle: JavaScript变量的作用域\ndate: 2021-11-10 20:18:30\ntags:\n - JavaScript\n - 随笔\ncategories:\n - JavaScript\n - 随笔\n---\n\n\n\n#  JavaScript变量的作用域 Scpoe\n\n作用域的概念，简单来说就是对于一个\n\n\n\na = 1，这个操作等于了在全局变量上进行了创建。如同使用一个普通函数 fn()，一样，这个函数的this指向也是全局的变量。\n\n\n\n* 浏览器和node的一个小区别，在全局变量中，\n\n  * node的全局变量，是一个名为Global 的全局对象，并且使用 var定义的变量不会加入其中，只有直接定义的变量会加入其中。\n\n    * ```\n      var a = 1;\n      b = 2;\n      ```\n\n  * 浏览器的全局变量，是一个window对象，使用var定义的变量和直接定义的变量也会加入其中。\n\n    * ```\n      a = 1;\n      var b = 2;\n      \n      下面定义的不会加入其中。\n      let c = 3;\n      const d = 4;\n      ```\n\n\n\n这里的一个问题，就是你会发现，这里的a为什么是先输出的1.\n\n​\t\t开始我的理解是，先有个a的参数嘛，然后又预定义了一个a，因为这个var是在词法环境的阶段进行了操作。然后再进行了输出，此时就应该是undefined，但是是不对的。\n\n​\t\t**个人认为正确的理解**：首先我们得知道var的定义是在词法环境的创建的时候进行的定义，所以我们就知道了函数的参数其实是在词法环境之后进行的赋值，所以我们是先定义了一个 var a; 此时这个a为undefined，然后便是进行一个参数a的赋值，此时这个a以及被定义了，所以a的赋值是在a的定义之后的。\n\n```\n(function (a) {\n  console.log(a);\n  var a = 4;\n  console.log(a);\n})(1)\n\n1\n4\n```\n\n","slug":"JavaScript变量的作用域","published":0,"updated":"2021-12-09T01:56:49.388Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckznhkk6p0001ikub3yy5c6en","content":"<h1 id=\"JavaScript变量的作用域-Scpoe\"><a href=\"#JavaScript变量的作用域-Scpoe\" class=\"headerlink\" title=\"JavaScript变量的作用域 Scpoe\"></a>JavaScript变量的作用域 Scpoe</h1><p>作用域的概念，简单来说就是对于一个</p>\n<p>a = 1，这个操作等于了在全局变量上进行了创建。如同使用一个普通函数 fn()，一样，这个函数的this指向也是全局的变量。</p>\n<ul>\n<li><p>浏览器和node的一个小区别，在全局变量中，</p>\n<ul>\n<li><p>node的全局变量，是一个名为Global 的全局对象，并且使用 var定义的变量不会加入其中，只有直接定义的变量会加入其中。</p>\n<ul>\n<li>```<br>var a = 1;<br>b = 2;<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">* 浏览器的全局变量，是一个window对象，使用var定义的变量和直接定义的变量也会加入其中。</span><br><span class=\"line\"></span><br><span class=\"line\">  * ```</span><br><span class=\"line\">    a = 1;</span><br><span class=\"line\">    var b = 2;</span><br><span class=\"line\">    </span><br><span class=\"line\">    下面定义的不会加入其中。</span><br><span class=\"line\">    let c = 3;</span><br><span class=\"line\">    const d = 4;</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>这里的一个问题，就是你会发现，这里的a为什么是先输出的1.</p>\n<p>​        开始我的理解是，先有个a的参数嘛，然后又预定义了一个a，因为这个var是在词法环境的阶段进行了操作。然后再进行了输出，此时就应该是undefined，但是是不对的。</p>\n<p>​        <strong>个人认为正确的理解</strong>：首先我们得知道var的定义是在词法环境的创建的时候进行的定义，所以我们就知道了函数的参数其实是在词法环境之后进行的赋值，所以我们是先定义了一个 var a; 此时这个a为undefined，然后便是进行一个参数a的赋值，此时这个a以及被定义了，所以a的赋值是在a的定义之后的。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(function (a) &#123;</span><br><span class=\"line\">  console.log(a);</span><br><span class=\"line\">  var a = 4;</span><br><span class=\"line\">  console.log(a);</span><br><span class=\"line\">&#125;)(1)</span><br><span class=\"line\"></span><br><span class=\"line\">1</span><br><span class=\"line\">4</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"JavaScript变量的作用域-Scpoe\"><a href=\"#JavaScript变量的作用域-Scpoe\" class=\"headerlink\" title=\"JavaScript变量的作用域 Scpoe\"></a>JavaScript变量的作用域 Scpoe</h1><p>作用域的概念，简单来说就是对于一个</p>\n<p>a = 1，这个操作等于了在全局变量上进行了创建。如同使用一个普通函数 fn()，一样，这个函数的this指向也是全局的变量。</p>\n<ul>\n<li><p>浏览器和node的一个小区别，在全局变量中，</p>\n<ul>\n<li><p>node的全局变量，是一个名为Global 的全局对象，并且使用 var定义的变量不会加入其中，只有直接定义的变量会加入其中。</p>\n<ul>\n<li>```<br>var a = 1;<br>b = 2;<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">* 浏览器的全局变量，是一个window对象，使用var定义的变量和直接定义的变量也会加入其中。</span><br><span class=\"line\"></span><br><span class=\"line\">  * ```</span><br><span class=\"line\">    a = 1;</span><br><span class=\"line\">    var b = 2;</span><br><span class=\"line\">    </span><br><span class=\"line\">    下面定义的不会加入其中。</span><br><span class=\"line\">    let c = 3;</span><br><span class=\"line\">    const d = 4;</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>这里的一个问题，就是你会发现，这里的a为什么是先输出的1.</p>\n<p>​        开始我的理解是，先有个a的参数嘛，然后又预定义了一个a，因为这个var是在词法环境的阶段进行了操作。然后再进行了输出，此时就应该是undefined，但是是不对的。</p>\n<p>​        <strong>个人认为正确的理解</strong>：首先我们得知道var的定义是在词法环境的创建的时候进行的定义，所以我们就知道了函数的参数其实是在词法环境之后进行的赋值，所以我们是先定义了一个 var a; 此时这个a为undefined，然后便是进行一个参数a的赋值，此时这个a以及被定义了，所以a的赋值是在a的定义之后的。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(function (a) &#123;</span><br><span class=\"line\">  console.log(a);</span><br><span class=\"line\">  var a = 4;</span><br><span class=\"line\">  console.log(a);</span><br><span class=\"line\">&#125;)(1)</span><br><span class=\"line\"></span><br><span class=\"line\">1</span><br><span class=\"line\">4</span><br></pre></td></tr></table></figure>\n\n"},{"layout":"draft","title":"nuxt打包文件hash","date":"2022-01-12T09:56:45.000Z","_content":"\n\n\n#  nuxt 打包文件hash\n\n问题来源\n\n因为项目要读取图片并进行显示，然后，我发现可以在本地运行，但是却在打包之后图片没有显示，仔细一看，人家的打包文件带了hash名，所以你的名字不能命中了\n\n\n\n## 为什么需要hash\n\n既然知道了文件名被hash了，那么我们进一步思考，为什么需要进行hash呢，\n\n对文件名进行一个hash，可以说是一个非常机智的一个方法，因为我们为了能够在网络的传输可以快点，所以我们就想了一个办法，那就是使用缓存，说到缓存，那就不得不说强缓存和协商缓存了。\n\n​\t\t强缓存会直接在文件没有过时的时候不用向服务器进行请求，便可以得到资源，可以减少很多网络的传输，\n\n​\t\t协商缓存会在将文件的etag和last-modified发给服务器，服务器通过比对这两个值来判断文件是否被修改，只要文件没有被修改，那么客户端就会使用本地的资源，这样虽然进行了请求，但是却减少了网络的资源传输\n\n\n\n知道了强缓存和协商缓存，那么，什么是hash呢？\n\n​\t\t在此之前，我们先思考一个问题，对于一个项目，在你上线了之后，出现了bug，需要进行更改，但是此时对应的文件处于强缓存阶段，那么如何才能判断文件是否被修改了，此时就需要使用hash了，因为对于文件发生了更改，hash的名字也会对应发生改变，然后此时就获取到了新的文件。\n\n\n\n说完之后，就是解决 nuxt默认配置的hash了\n\n​\t\t这个其实在 nuxt 官网就已经说完了，我们如果想要取消hash，也只需要将 contenthash:7 改为 name 就会变成名字，而不会携带7位hash了。\n\n```\nhttps://www.nuxtjs.cn/api/configuration-build#filenames\n```\n\n","source":"_drafts/nuxt打包文件hash.md","raw":"---\nlayout: draft\ntitle: nuxt打包文件hash\ndate: 2022-01-12 17:56:45\ntags:\n - webpack\n - 文件hash\n---\n\n\n\n#  nuxt 打包文件hash\n\n问题来源\n\n因为项目要读取图片并进行显示，然后，我发现可以在本地运行，但是却在打包之后图片没有显示，仔细一看，人家的打包文件带了hash名，所以你的名字不能命中了\n\n\n\n## 为什么需要hash\n\n既然知道了文件名被hash了，那么我们进一步思考，为什么需要进行hash呢，\n\n对文件名进行一个hash，可以说是一个非常机智的一个方法，因为我们为了能够在网络的传输可以快点，所以我们就想了一个办法，那就是使用缓存，说到缓存，那就不得不说强缓存和协商缓存了。\n\n​\t\t强缓存会直接在文件没有过时的时候不用向服务器进行请求，便可以得到资源，可以减少很多网络的传输，\n\n​\t\t协商缓存会在将文件的etag和last-modified发给服务器，服务器通过比对这两个值来判断文件是否被修改，只要文件没有被修改，那么客户端就会使用本地的资源，这样虽然进行了请求，但是却减少了网络的资源传输\n\n\n\n知道了强缓存和协商缓存，那么，什么是hash呢？\n\n​\t\t在此之前，我们先思考一个问题，对于一个项目，在你上线了之后，出现了bug，需要进行更改，但是此时对应的文件处于强缓存阶段，那么如何才能判断文件是否被修改了，此时就需要使用hash了，因为对于文件发生了更改，hash的名字也会对应发生改变，然后此时就获取到了新的文件。\n\n\n\n说完之后，就是解决 nuxt默认配置的hash了\n\n​\t\t这个其实在 nuxt 官网就已经说完了，我们如果想要取消hash，也只需要将 contenthash:7 改为 name 就会变成名字，而不会携带7位hash了。\n\n```\nhttps://www.nuxtjs.cn/api/configuration-build#filenames\n```\n\n","slug":"nuxt打包文件hash","published":0,"updated":"2022-01-12T10:13:39.245Z","comments":1,"photos":[],"link":"","_id":"ckznhkk6w0003ikubcq2s8ko9","content":"<h1 id=\"nuxt-打包文件hash\"><a href=\"#nuxt-打包文件hash\" class=\"headerlink\" title=\"nuxt 打包文件hash\"></a>nuxt 打包文件hash</h1><p>问题来源</p>\n<p>因为项目要读取图片并进行显示，然后，我发现可以在本地运行，但是却在打包之后图片没有显示，仔细一看，人家的打包文件带了hash名，所以你的名字不能命中了</p>\n<h2 id=\"为什么需要hash\"><a href=\"#为什么需要hash\" class=\"headerlink\" title=\"为什么需要hash\"></a>为什么需要hash</h2><p>既然知道了文件名被hash了，那么我们进一步思考，为什么需要进行hash呢，</p>\n<p>对文件名进行一个hash，可以说是一个非常机智的一个方法，因为我们为了能够在网络的传输可以快点，所以我们就想了一个办法，那就是使用缓存，说到缓存，那就不得不说强缓存和协商缓存了。</p>\n<p>​        强缓存会直接在文件没有过时的时候不用向服务器进行请求，便可以得到资源，可以减少很多网络的传输，</p>\n<p>​        协商缓存会在将文件的etag和last-modified发给服务器，服务器通过比对这两个值来判断文件是否被修改，只要文件没有被修改，那么客户端就会使用本地的资源，这样虽然进行了请求，但是却减少了网络的资源传输</p>\n<p>知道了强缓存和协商缓存，那么，什么是hash呢？</p>\n<p>​        在此之前，我们先思考一个问题，对于一个项目，在你上线了之后，出现了bug，需要进行更改，但是此时对应的文件处于强缓存阶段，那么如何才能判断文件是否被修改了，此时就需要使用hash了，因为对于文件发生了更改，hash的名字也会对应发生改变，然后此时就获取到了新的文件。</p>\n<p>说完之后，就是解决 nuxt默认配置的hash了</p>\n<p>​        这个其实在 nuxt 官网就已经说完了，我们如果想要取消hash，也只需要将 contenthash:7 改为 name 就会变成名字，而不会携带7位hash了。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://www.nuxtjs.cn/api/configuration-build#filenames</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"nuxt-打包文件hash\"><a href=\"#nuxt-打包文件hash\" class=\"headerlink\" title=\"nuxt 打包文件hash\"></a>nuxt 打包文件hash</h1><p>问题来源</p>\n<p>因为项目要读取图片并进行显示，然后，我发现可以在本地运行，但是却在打包之后图片没有显示，仔细一看，人家的打包文件带了hash名，所以你的名字不能命中了</p>\n<h2 id=\"为什么需要hash\"><a href=\"#为什么需要hash\" class=\"headerlink\" title=\"为什么需要hash\"></a>为什么需要hash</h2><p>既然知道了文件名被hash了，那么我们进一步思考，为什么需要进行hash呢，</p>\n<p>对文件名进行一个hash，可以说是一个非常机智的一个方法，因为我们为了能够在网络的传输可以快点，所以我们就想了一个办法，那就是使用缓存，说到缓存，那就不得不说强缓存和协商缓存了。</p>\n<p>​        强缓存会直接在文件没有过时的时候不用向服务器进行请求，便可以得到资源，可以减少很多网络的传输，</p>\n<p>​        协商缓存会在将文件的etag和last-modified发给服务器，服务器通过比对这两个值来判断文件是否被修改，只要文件没有被修改，那么客户端就会使用本地的资源，这样虽然进行了请求，但是却减少了网络的资源传输</p>\n<p>知道了强缓存和协商缓存，那么，什么是hash呢？</p>\n<p>​        在此之前，我们先思考一个问题，对于一个项目，在你上线了之后，出现了bug，需要进行更改，但是此时对应的文件处于强缓存阶段，那么如何才能判断文件是否被修改了，此时就需要使用hash了，因为对于文件发生了更改，hash的名字也会对应发生改变，然后此时就获取到了新的文件。</p>\n<p>说完之后，就是解决 nuxt默认配置的hash了</p>\n<p>​        这个其实在 nuxt 官网就已经说完了，我们如果想要取消hash，也只需要将 contenthash:7 改为 name 就会变成名字，而不会携带7位hash了。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://www.nuxtjs.cn/api/configuration-build#filenames</span><br></pre></td></tr></table></figure>\n\n"},{"title":"sass预处理","date":"2021-10-27T08:05:34.000Z","_content":"\n\n\n#   安装sass\n\n使用sass，需要安装ruby，然后再安装sass\n\n如果是webpack这种项目的，可以使用 npm 下载包\n\n```\n\"sass\": \"^1.49.0\",\n\"sass-loader\": \"^7.1.0\",\n上面这两个下载了就可以编译了\n\n还有一个是 node-sass，但是这个下载好像需要python环境，而且貌似不需要也可以使用？但是对于这个sass的安装和环境的一些我还是不算很是理解清楚。\n```\n\n\n\n## 第一步，安装 ruby\n\n首先，我们得知道，Sass是基于Ruby开发的，所以要运行Sass都需要一个Ruby环境.\n\n所以下面这个链接就是 ruby 的下载链接，如果下载速度慢，可以使用 迅雷来增加下载速度。\n\n```\nhttp://www.ruby-lang.org/en/downloads/\n```\n\n阿里云盘的链接， 阿里云盘应该挺快.\n\n```\n「rubyinstaller-devkit-2.7.5-1-x64.exe」https://www.aliyundrive.com/s/RXSr5Fh38uz\n点击链接保存，或者复制本段内容，打开「阿里云盘」APP ，无需下载极速在线查看，视频原画倍速播放。\n```\n\n\n\n然后就是安装了\n\n这里也直接给别人的安装链接\n\n```\nhttps://www.cnblogs.com/padding1015/p/7133811.html\n```\n\n**我就提几个重点**\n\n* 要添加到 Path，这样可以直接在cmd里面进行运行。\n\n* 在最后一步之前 finish  **ridk install**  这个去掉，因为没有使用镜像，会比较慢，要引入镜像\n\n  * 参考链接\n\n  * ```\n    https://blog.csdn.net/mscf/article/details/82627951\n    ```\n\n  * 然后也就是 添加镜像，设置 gem 源了\n\n* 我这里记录链接里面的重点，怕到时候链接没了\n\n* ```\n  双击开始安装，选择全部安装；\n  在安装结束时，去除ridk install的选项，因为从默认的原去下载几百兆会非常缓慢；\n  查找Ruby安装目录下的msys64\\etc\\pacman.d，编辑更新源：\n  \n  Server = https://mirrors.tuna.tsinghua.edu.cn/msys2/mingw/i686 加入mirrorlist.mingw32首位\n  Server = https://mirrors.tuna.tsinghua.edu.cn/msys2/mingw/x86_64 加入mirrorlist.mingw64首位\n  Server = https://mirrors.tuna.tsinghua.edu.cn/msys2/msys/$arch 加入mirrorlist.msys首位\n  \n  执行在命令行执行ridk install（如果安装时选择了不加入系统环境变量的，去Ruby安装目录的bin之下执行），一路回车至结束；\n  更新gem源：\n  gem sources --add https://mirrors.tuna.tsinghua.edu.cn/rubygems/ --remove https://rubygems.org/\n  ```\n\n  \n\n\n\n## 然后就是安装sass\n\n先 **gem env** 了解一下安装了路径\n\n```\n参考资料：\nhttps://qastack.cn/programming/19072070/how-to-find-where-gem-files-are-installed\n\nhttps://guides.rubygems.org/command-reference/#gem_environment\n```\n\n```\n注意： INSTALLATION DIRECTORY\n\t\t\tGEM PATHS\n```\n\n\n\n一波团灭\n\n```\ngem install sass\n\n然后准备回车就行了\n```\n\n可能要等一会儿，我开始等了一会儿，没有反应，不知道是不是连接镜像查找的时候太久了。\n\n不出意外是可以成功的，因为国内镜像我们在上一个blog上面设置好了的\n\n\n\n\n\n## 使用\n\n这个，一般搜一下怎么配置就行了\n\n我的是 webstorm，所以好像当时自动配好了\n\n\n\n# 使用 sass\n\n## 嵌套选择\n\n```\n.aaa {\n  xxx\n  \n  .bbb {\n  \tzzz\n  }\n}\n```\n\n上面代码就是嵌套选择，就是代表下面的意思\n\n```\n.aaa {\n\txxx\n}\n.aaa .bbb {\n\tzzz\n}\n```\n\n\n\n## 定义变量\n\n可以定义变量，然后进行使用，所以对于相同属性的，可以直接使用变量，后续的修改也只需要修改一个就行。\n\n```\n$padding-sm: 5px;\n\n.a {\n\tpadding: $padding-sm;\n}\n```\n\n```\n同时 scss 支持在定义变量的时候使用 !default,来进行替换\n\t简单来说就是，如果定义的变量在之前已经定义过了。那么便不会重新赋值。如果是第一次的，那么便会重新赋值。\n```\n\n\n\n## scss使用父元素 &\n\n​\t\tscss  通过使用 & 来代表了父元素\n\n```\n.box {\n\t&:focus { }\n}\n\n.box:focus { }\n```\n\n```\n.box {\n\t&-d { }\n}\n\n.box-d { }\n```\n\n```\n.box h1 {\n\t#b & { }\n}\n\n#b .box h1 { }\n```\n\n​\t\t并且如果使用了 &，那么，解析会有不同\n\n* 正常的解析\n\n```\n.box {\n\ta {}\n}\n\n.box a {}\n```\n\n* 使用了 & 的解析，并不会变成查找 box 的内部，而是直接组成一个整体。\n\n```\n.box {\n\t&-div { }\n}\n\n.box-div { }\n```\n\n\n\n## 混入 mixin\n\n```\n@mixin aa {\n\t@content\n}\n\n@include aa() {\n\tcolor: red;\n}\n```\n\n​\t\t并且混入可以携带参数。\n","source":"_drafts/sass预处理.md","raw":"---\ntitle: sass预处理\ndate: 2021-10-27 16:05:34\ntags:\n - css\n - sass\ncategories:\n - css\n - sass\n---\n\n\n\n#   安装sass\n\n使用sass，需要安装ruby，然后再安装sass\n\n如果是webpack这种项目的，可以使用 npm 下载包\n\n```\n\"sass\": \"^1.49.0\",\n\"sass-loader\": \"^7.1.0\",\n上面这两个下载了就可以编译了\n\n还有一个是 node-sass，但是这个下载好像需要python环境，而且貌似不需要也可以使用？但是对于这个sass的安装和环境的一些我还是不算很是理解清楚。\n```\n\n\n\n## 第一步，安装 ruby\n\n首先，我们得知道，Sass是基于Ruby开发的，所以要运行Sass都需要一个Ruby环境.\n\n所以下面这个链接就是 ruby 的下载链接，如果下载速度慢，可以使用 迅雷来增加下载速度。\n\n```\nhttp://www.ruby-lang.org/en/downloads/\n```\n\n阿里云盘的链接， 阿里云盘应该挺快.\n\n```\n「rubyinstaller-devkit-2.7.5-1-x64.exe」https://www.aliyundrive.com/s/RXSr5Fh38uz\n点击链接保存，或者复制本段内容，打开「阿里云盘」APP ，无需下载极速在线查看，视频原画倍速播放。\n```\n\n\n\n然后就是安装了\n\n这里也直接给别人的安装链接\n\n```\nhttps://www.cnblogs.com/padding1015/p/7133811.html\n```\n\n**我就提几个重点**\n\n* 要添加到 Path，这样可以直接在cmd里面进行运行。\n\n* 在最后一步之前 finish  **ridk install**  这个去掉，因为没有使用镜像，会比较慢，要引入镜像\n\n  * 参考链接\n\n  * ```\n    https://blog.csdn.net/mscf/article/details/82627951\n    ```\n\n  * 然后也就是 添加镜像，设置 gem 源了\n\n* 我这里记录链接里面的重点，怕到时候链接没了\n\n* ```\n  双击开始安装，选择全部安装；\n  在安装结束时，去除ridk install的选项，因为从默认的原去下载几百兆会非常缓慢；\n  查找Ruby安装目录下的msys64\\etc\\pacman.d，编辑更新源：\n  \n  Server = https://mirrors.tuna.tsinghua.edu.cn/msys2/mingw/i686 加入mirrorlist.mingw32首位\n  Server = https://mirrors.tuna.tsinghua.edu.cn/msys2/mingw/x86_64 加入mirrorlist.mingw64首位\n  Server = https://mirrors.tuna.tsinghua.edu.cn/msys2/msys/$arch 加入mirrorlist.msys首位\n  \n  执行在命令行执行ridk install（如果安装时选择了不加入系统环境变量的，去Ruby安装目录的bin之下执行），一路回车至结束；\n  更新gem源：\n  gem sources --add https://mirrors.tuna.tsinghua.edu.cn/rubygems/ --remove https://rubygems.org/\n  ```\n\n  \n\n\n\n## 然后就是安装sass\n\n先 **gem env** 了解一下安装了路径\n\n```\n参考资料：\nhttps://qastack.cn/programming/19072070/how-to-find-where-gem-files-are-installed\n\nhttps://guides.rubygems.org/command-reference/#gem_environment\n```\n\n```\n注意： INSTALLATION DIRECTORY\n\t\t\tGEM PATHS\n```\n\n\n\n一波团灭\n\n```\ngem install sass\n\n然后准备回车就行了\n```\n\n可能要等一会儿，我开始等了一会儿，没有反应，不知道是不是连接镜像查找的时候太久了。\n\n不出意外是可以成功的，因为国内镜像我们在上一个blog上面设置好了的\n\n\n\n\n\n## 使用\n\n这个，一般搜一下怎么配置就行了\n\n我的是 webstorm，所以好像当时自动配好了\n\n\n\n# 使用 sass\n\n## 嵌套选择\n\n```\n.aaa {\n  xxx\n  \n  .bbb {\n  \tzzz\n  }\n}\n```\n\n上面代码就是嵌套选择，就是代表下面的意思\n\n```\n.aaa {\n\txxx\n}\n.aaa .bbb {\n\tzzz\n}\n```\n\n\n\n## 定义变量\n\n可以定义变量，然后进行使用，所以对于相同属性的，可以直接使用变量，后续的修改也只需要修改一个就行。\n\n```\n$padding-sm: 5px;\n\n.a {\n\tpadding: $padding-sm;\n}\n```\n\n```\n同时 scss 支持在定义变量的时候使用 !default,来进行替换\n\t简单来说就是，如果定义的变量在之前已经定义过了。那么便不会重新赋值。如果是第一次的，那么便会重新赋值。\n```\n\n\n\n## scss使用父元素 &\n\n​\t\tscss  通过使用 & 来代表了父元素\n\n```\n.box {\n\t&:focus { }\n}\n\n.box:focus { }\n```\n\n```\n.box {\n\t&-d { }\n}\n\n.box-d { }\n```\n\n```\n.box h1 {\n\t#b & { }\n}\n\n#b .box h1 { }\n```\n\n​\t\t并且如果使用了 &，那么，解析会有不同\n\n* 正常的解析\n\n```\n.box {\n\ta {}\n}\n\n.box a {}\n```\n\n* 使用了 & 的解析，并不会变成查找 box 的内部，而是直接组成一个整体。\n\n```\n.box {\n\t&-div { }\n}\n\n.box-div { }\n```\n\n\n\n## 混入 mixin\n\n```\n@mixin aa {\n\t@content\n}\n\n@include aa() {\n\tcolor: red;\n}\n```\n\n​\t\t并且混入可以携带参数。\n","slug":"sass预处理","published":0,"updated":"2022-02-07T06:17:56.770Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckznhkk6z0007ikub3zkt768q","content":"<h1 id=\"安装sass\"><a href=\"#安装sass\" class=\"headerlink\" title=\"安装sass\"></a>安装sass</h1><p>使用sass，需要安装ruby，然后再安装sass</p>\n<p>如果是webpack这种项目的，可以使用 npm 下载包</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;sass&quot;: &quot;^1.49.0&quot;,</span><br><span class=\"line\">&quot;sass-loader&quot;: &quot;^7.1.0&quot;,</span><br><span class=\"line\">上面这两个下载了就可以编译了</span><br><span class=\"line\"></span><br><span class=\"line\">还有一个是 node-sass，但是这个下载好像需要python环境，而且貌似不需要也可以使用？但是对于这个sass的安装和环境的一些我还是不算很是理解清楚。</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"第一步，安装-ruby\"><a href=\"#第一步，安装-ruby\" class=\"headerlink\" title=\"第一步，安装 ruby\"></a>第一步，安装 ruby</h2><p>首先，我们得知道，Sass是基于Ruby开发的，所以要运行Sass都需要一个Ruby环境.</p>\n<p>所以下面这个链接就是 ruby 的下载链接，如果下载速度慢，可以使用 迅雷来增加下载速度。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http://www.ruby-lang.org/en/downloads/</span><br></pre></td></tr></table></figure>\n\n<p>阿里云盘的链接， 阿里云盘应该挺快.</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">「rubyinstaller-devkit-2.7.5-1-x64.exe」https://www.aliyundrive.com/s/RXSr5Fh38uz</span><br><span class=\"line\">点击链接保存，或者复制本段内容，打开「阿里云盘」APP ，无需下载极速在线查看，视频原画倍速播放。</span><br></pre></td></tr></table></figure>\n\n\n\n<p>然后就是安装了</p>\n<p>这里也直接给别人的安装链接</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://www.cnblogs.com/padding1015/p/7133811.html</span><br></pre></td></tr></table></figure>\n\n<p><strong>我就提几个重点</strong></p>\n<ul>\n<li><p>要添加到 Path，这样可以直接在cmd里面进行运行。</p>\n</li>\n<li><p>在最后一步之前 finish  <strong>ridk install</strong>  这个去掉，因为没有使用镜像，会比较慢，要引入镜像</p>\n<ul>\n<li><p>参考链接</p>\n</li>\n<li><p>```<br><a href=\"https://blog.csdn.net/mscf/article/details/82627951\">https://blog.csdn.net/mscf/article/details/82627951</a></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">  * 然后也就是 添加镜像，设置 gem 源了</span><br><span class=\"line\"></span><br><span class=\"line\">* 我这里记录链接里面的重点，怕到时候链接没了</span><br><span class=\"line\"></span><br><span class=\"line\">* ```</span><br><span class=\"line\">  双击开始安装，选择全部安装；</span><br><span class=\"line\">  在安装结束时，去除ridk install的选项，因为从默认的原去下载几百兆会非常缓慢；</span><br><span class=\"line\">  查找Ruby安装目录下的msys64\\etc\\pacman.d，编辑更新源：</span><br><span class=\"line\">  </span><br><span class=\"line\">  Server = https://mirrors.tuna.tsinghua.edu.cn/msys2/mingw/i686 加入mirrorlist.mingw32首位</span><br><span class=\"line\">  Server = https://mirrors.tuna.tsinghua.edu.cn/msys2/mingw/x86_64 加入mirrorlist.mingw64首位</span><br><span class=\"line\">  Server = https://mirrors.tuna.tsinghua.edu.cn/msys2/msys/$arch 加入mirrorlist.msys首位</span><br><span class=\"line\">  </span><br><span class=\"line\">  执行在命令行执行ridk install（如果安装时选择了不加入系统环境变量的，去Ruby安装目录的bin之下执行），一路回车至结束；</span><br><span class=\"line\">  更新gem源：</span><br><span class=\"line\">  gem sources --add https://mirrors.tuna.tsinghua.edu.cn/rubygems/ --remove https://rubygems.org/</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"然后就是安装sass\"><a href=\"#然后就是安装sass\" class=\"headerlink\" title=\"然后就是安装sass\"></a>然后就是安装sass</h2><p>先 <strong>gem env</strong> 了解一下安装了路径</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">参考资料：</span><br><span class=\"line\">https://qastack.cn/programming/19072070/how-to-find-where-gem-files-are-installed</span><br><span class=\"line\"></span><br><span class=\"line\">https://guides.rubygems.org/command-reference/#gem_environment</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">注意： INSTALLATION DIRECTORY</span><br><span class=\"line\">\t\t\tGEM PATHS</span><br></pre></td></tr></table></figure>\n\n\n\n<p>一波团灭</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gem install sass</span><br><span class=\"line\"></span><br><span class=\"line\">然后准备回车就行了</span><br></pre></td></tr></table></figure>\n\n<p>可能要等一会儿，我开始等了一会儿，没有反应，不知道是不是连接镜像查找的时候太久了。</p>\n<p>不出意外是可以成功的，因为国内镜像我们在上一个blog上面设置好了的</p>\n<h2 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h2><p>这个，一般搜一下怎么配置就行了</p>\n<p>我的是 webstorm，所以好像当时自动配好了</p>\n<h1 id=\"使用-sass\"><a href=\"#使用-sass\" class=\"headerlink\" title=\"使用 sass\"></a>使用 sass</h1><h2 id=\"嵌套选择\"><a href=\"#嵌套选择\" class=\"headerlink\" title=\"嵌套选择\"></a>嵌套选择</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.aaa &#123;</span><br><span class=\"line\">  xxx</span><br><span class=\"line\">  </span><br><span class=\"line\">  .bbb &#123;</span><br><span class=\"line\">  \tzzz</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面代码就是嵌套选择，就是代表下面的意思</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.aaa &#123;</span><br><span class=\"line\">\txxx</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.aaa .bbb &#123;</span><br><span class=\"line\">\tzzz</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"定义变量\"><a href=\"#定义变量\" class=\"headerlink\" title=\"定义变量\"></a>定义变量</h2><p>可以定义变量，然后进行使用，所以对于相同属性的，可以直接使用变量，后续的修改也只需要修改一个就行。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$padding-sm: 5px;</span><br><span class=\"line\"></span><br><span class=\"line\">.a &#123;</span><br><span class=\"line\">\tpadding: $padding-sm;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">同时 scss 支持在定义变量的时候使用 !default,来进行替换</span><br><span class=\"line\">\t简单来说就是，如果定义的变量在之前已经定义过了。那么便不会重新赋值。如果是第一次的，那么便会重新赋值。</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"scss使用父元素-amp\"><a href=\"#scss使用父元素-amp\" class=\"headerlink\" title=\"scss使用父元素 &amp;\"></a>scss使用父元素 &amp;</h2><p>​        scss  通过使用 &amp; 来代表了父元素</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.box &#123;</span><br><span class=\"line\">\t&amp;:focus &#123; &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.box:focus &#123; &#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.box &#123;</span><br><span class=\"line\">\t&amp;-d &#123; &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.box-d &#123; &#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.box h1 &#123;</span><br><span class=\"line\">\t#b &amp; &#123; &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">#b .box h1 &#123; &#125;</span><br></pre></td></tr></table></figure>\n\n<p>​        并且如果使用了 &amp;，那么，解析会有不同</p>\n<ul>\n<li>正常的解析</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.box &#123;</span><br><span class=\"line\">\ta &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.box a &#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>使用了 &amp; 的解析，并不会变成查找 box 的内部，而是直接组成一个整体。</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.box &#123;</span><br><span class=\"line\">\t&amp;-div &#123; &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.box-div &#123; &#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"混入-mixin\"><a href=\"#混入-mixin\" class=\"headerlink\" title=\"混入 mixin\"></a>混入 mixin</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@mixin aa &#123;</span><br><span class=\"line\">\t@content</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@include aa() &#123;</span><br><span class=\"line\">\tcolor: red;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>​        并且混入可以携带参数。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"安装sass\"><a href=\"#安装sass\" class=\"headerlink\" title=\"安装sass\"></a>安装sass</h1><p>使用sass，需要安装ruby，然后再安装sass</p>\n<p>如果是webpack这种项目的，可以使用 npm 下载包</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;sass&quot;: &quot;^1.49.0&quot;,</span><br><span class=\"line\">&quot;sass-loader&quot;: &quot;^7.1.0&quot;,</span><br><span class=\"line\">上面这两个下载了就可以编译了</span><br><span class=\"line\"></span><br><span class=\"line\">还有一个是 node-sass，但是这个下载好像需要python环境，而且貌似不需要也可以使用？但是对于这个sass的安装和环境的一些我还是不算很是理解清楚。</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"第一步，安装-ruby\"><a href=\"#第一步，安装-ruby\" class=\"headerlink\" title=\"第一步，安装 ruby\"></a>第一步，安装 ruby</h2><p>首先，我们得知道，Sass是基于Ruby开发的，所以要运行Sass都需要一个Ruby环境.</p>\n<p>所以下面这个链接就是 ruby 的下载链接，如果下载速度慢，可以使用 迅雷来增加下载速度。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http://www.ruby-lang.org/en/downloads/</span><br></pre></td></tr></table></figure>\n\n<p>阿里云盘的链接， 阿里云盘应该挺快.</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">「rubyinstaller-devkit-2.7.5-1-x64.exe」https://www.aliyundrive.com/s/RXSr5Fh38uz</span><br><span class=\"line\">点击链接保存，或者复制本段内容，打开「阿里云盘」APP ，无需下载极速在线查看，视频原画倍速播放。</span><br></pre></td></tr></table></figure>\n\n\n\n<p>然后就是安装了</p>\n<p>这里也直接给别人的安装链接</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://www.cnblogs.com/padding1015/p/7133811.html</span><br></pre></td></tr></table></figure>\n\n<p><strong>我就提几个重点</strong></p>\n<ul>\n<li><p>要添加到 Path，这样可以直接在cmd里面进行运行。</p>\n</li>\n<li><p>在最后一步之前 finish  <strong>ridk install</strong>  这个去掉，因为没有使用镜像，会比较慢，要引入镜像</p>\n<ul>\n<li><p>参考链接</p>\n</li>\n<li><p>```<br><a href=\"https://blog.csdn.net/mscf/article/details/82627951\">https://blog.csdn.net/mscf/article/details/82627951</a></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">  * 然后也就是 添加镜像，设置 gem 源了</span><br><span class=\"line\"></span><br><span class=\"line\">* 我这里记录链接里面的重点，怕到时候链接没了</span><br><span class=\"line\"></span><br><span class=\"line\">* ```</span><br><span class=\"line\">  双击开始安装，选择全部安装；</span><br><span class=\"line\">  在安装结束时，去除ridk install的选项，因为从默认的原去下载几百兆会非常缓慢；</span><br><span class=\"line\">  查找Ruby安装目录下的msys64\\etc\\pacman.d，编辑更新源：</span><br><span class=\"line\">  </span><br><span class=\"line\">  Server = https://mirrors.tuna.tsinghua.edu.cn/msys2/mingw/i686 加入mirrorlist.mingw32首位</span><br><span class=\"line\">  Server = https://mirrors.tuna.tsinghua.edu.cn/msys2/mingw/x86_64 加入mirrorlist.mingw64首位</span><br><span class=\"line\">  Server = https://mirrors.tuna.tsinghua.edu.cn/msys2/msys/$arch 加入mirrorlist.msys首位</span><br><span class=\"line\">  </span><br><span class=\"line\">  执行在命令行执行ridk install（如果安装时选择了不加入系统环境变量的，去Ruby安装目录的bin之下执行），一路回车至结束；</span><br><span class=\"line\">  更新gem源：</span><br><span class=\"line\">  gem sources --add https://mirrors.tuna.tsinghua.edu.cn/rubygems/ --remove https://rubygems.org/</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"然后就是安装sass\"><a href=\"#然后就是安装sass\" class=\"headerlink\" title=\"然后就是安装sass\"></a>然后就是安装sass</h2><p>先 <strong>gem env</strong> 了解一下安装了路径</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">参考资料：</span><br><span class=\"line\">https://qastack.cn/programming/19072070/how-to-find-where-gem-files-are-installed</span><br><span class=\"line\"></span><br><span class=\"line\">https://guides.rubygems.org/command-reference/#gem_environment</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">注意： INSTALLATION DIRECTORY</span><br><span class=\"line\">\t\t\tGEM PATHS</span><br></pre></td></tr></table></figure>\n\n\n\n<p>一波团灭</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gem install sass</span><br><span class=\"line\"></span><br><span class=\"line\">然后准备回车就行了</span><br></pre></td></tr></table></figure>\n\n<p>可能要等一会儿，我开始等了一会儿，没有反应，不知道是不是连接镜像查找的时候太久了。</p>\n<p>不出意外是可以成功的，因为国内镜像我们在上一个blog上面设置好了的</p>\n<h2 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h2><p>这个，一般搜一下怎么配置就行了</p>\n<p>我的是 webstorm，所以好像当时自动配好了</p>\n<h1 id=\"使用-sass\"><a href=\"#使用-sass\" class=\"headerlink\" title=\"使用 sass\"></a>使用 sass</h1><h2 id=\"嵌套选择\"><a href=\"#嵌套选择\" class=\"headerlink\" title=\"嵌套选择\"></a>嵌套选择</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.aaa &#123;</span><br><span class=\"line\">  xxx</span><br><span class=\"line\">  </span><br><span class=\"line\">  .bbb &#123;</span><br><span class=\"line\">  \tzzz</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面代码就是嵌套选择，就是代表下面的意思</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.aaa &#123;</span><br><span class=\"line\">\txxx</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.aaa .bbb &#123;</span><br><span class=\"line\">\tzzz</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"定义变量\"><a href=\"#定义变量\" class=\"headerlink\" title=\"定义变量\"></a>定义变量</h2><p>可以定义变量，然后进行使用，所以对于相同属性的，可以直接使用变量，后续的修改也只需要修改一个就行。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$padding-sm: 5px;</span><br><span class=\"line\"></span><br><span class=\"line\">.a &#123;</span><br><span class=\"line\">\tpadding: $padding-sm;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">同时 scss 支持在定义变量的时候使用 !default,来进行替换</span><br><span class=\"line\">\t简单来说就是，如果定义的变量在之前已经定义过了。那么便不会重新赋值。如果是第一次的，那么便会重新赋值。</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"scss使用父元素-amp\"><a href=\"#scss使用父元素-amp\" class=\"headerlink\" title=\"scss使用父元素 &amp;\"></a>scss使用父元素 &amp;</h2><p>​        scss  通过使用 &amp; 来代表了父元素</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.box &#123;</span><br><span class=\"line\">\t&amp;:focus &#123; &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.box:focus &#123; &#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.box &#123;</span><br><span class=\"line\">\t&amp;-d &#123; &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.box-d &#123; &#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.box h1 &#123;</span><br><span class=\"line\">\t#b &amp; &#123; &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">#b .box h1 &#123; &#125;</span><br></pre></td></tr></table></figure>\n\n<p>​        并且如果使用了 &amp;，那么，解析会有不同</p>\n<ul>\n<li>正常的解析</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.box &#123;</span><br><span class=\"line\">\ta &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.box a &#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>使用了 &amp; 的解析，并不会变成查找 box 的内部，而是直接组成一个整体。</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.box &#123;</span><br><span class=\"line\">\t&amp;-div &#123; &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.box-div &#123; &#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"混入-mixin\"><a href=\"#混入-mixin\" class=\"headerlink\" title=\"混入 mixin\"></a>混入 mixin</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@mixin aa &#123;</span><br><span class=\"line\">\t@content</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@include aa() &#123;</span><br><span class=\"line\">\tcolor: red;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>​        并且混入可以携带参数。</p>\n"},{"title":"uni-app-projec笔记","date":"2022-01-08T08:44:02.000Z","_content":"\n\n\n# uni-app 项目开发笔记问题\n\n## 不要挂载原型链\n\n将对象挂载在原型链是一个大忌，并且vue2也有警告，因为这样对于维护是一个非常大的问题，使用 forin会将内容显示出来\n\n```\nObject.prototype.a = {}\n```\n\n\n\n## sass的使用\n\n对于根项目的 uni.scss 我们在使用的时候不需要进行引入。\n\n项目的 node_modules vue-cli-plugin-uni/lib/options.js 里面有引入\n\n```\nhttps://uniapp.dcloud.io/collocation/uni-scss\n```\n\n\n\n## tabBar\n\n微信小程序的tabBar可以使用 page.json里面进行配置，不需要自己定义组件\n\n```\nhttps://uniapp.dcloud.io/collocation/pages?id=tabbar\n```\n\n```\n{\n\t\"tabBar\": {\n\t\t\"color\": \"#808080\",\n\t\t\"selectedColor\": \"#007aff\",\n\t\t\"backgroundColor\": \"#f8f8f8\",\n\t\t\"list\": [\n\t\t\t{\n\t\t\t\t\"text\": \"主页\",\n\t\t\t\t\"iconPath\": \"static/img/tab-bar/tab-bar-unselect.png\",\n\t\t\t\t\"selectedIconPath\": \"static/img/tab-bar/tab-bar-select.png\"\n\t\t\t}\n\t\t]\n\t},\n}\n```\n\n几个比较重要的属性\n\n```\n文字颜色\ncolor\nselectedColor\n背景颜色\nbackgroundColor\n\ntab列表，是一个数组\nlist\n```\n\n```\nlist\n是一个数组，每个元素都是对象\n\npagePath\ntext\niconPath\nselectedIconPath\n```\n\n\n\n## 路由 router\n\n微信小程序 没有路由\n\n对应的在 pages.json 的 pages 里面可以进行配置，\n\n```\n\"pages\": [ //pages数组中第一项表示应用启动页，参考：https://uniapp.dcloud.io/collocation/pages\n  {\n    \"path\": \"pages/index/index\",\n    \"style\": {\n      \"navigationBarTitleText\": \"uni-app\"\n    }\n  }\n],\n```\n\n","source":"_drafts/uni-app-projec笔记.md","raw":"---\ntitle: uni-app-projec笔记\ndate: 2022-01-08 16:44:02\ntags:\n - 随笔\n - 项目\n - 微信小程序\n - uniapp\ncategories:\n - 随笔\n---\n\n\n\n# uni-app 项目开发笔记问题\n\n## 不要挂载原型链\n\n将对象挂载在原型链是一个大忌，并且vue2也有警告，因为这样对于维护是一个非常大的问题，使用 forin会将内容显示出来\n\n```\nObject.prototype.a = {}\n```\n\n\n\n## sass的使用\n\n对于根项目的 uni.scss 我们在使用的时候不需要进行引入。\n\n项目的 node_modules vue-cli-plugin-uni/lib/options.js 里面有引入\n\n```\nhttps://uniapp.dcloud.io/collocation/uni-scss\n```\n\n\n\n## tabBar\n\n微信小程序的tabBar可以使用 page.json里面进行配置，不需要自己定义组件\n\n```\nhttps://uniapp.dcloud.io/collocation/pages?id=tabbar\n```\n\n```\n{\n\t\"tabBar\": {\n\t\t\"color\": \"#808080\",\n\t\t\"selectedColor\": \"#007aff\",\n\t\t\"backgroundColor\": \"#f8f8f8\",\n\t\t\"list\": [\n\t\t\t{\n\t\t\t\t\"text\": \"主页\",\n\t\t\t\t\"iconPath\": \"static/img/tab-bar/tab-bar-unselect.png\",\n\t\t\t\t\"selectedIconPath\": \"static/img/tab-bar/tab-bar-select.png\"\n\t\t\t}\n\t\t]\n\t},\n}\n```\n\n几个比较重要的属性\n\n```\n文字颜色\ncolor\nselectedColor\n背景颜色\nbackgroundColor\n\ntab列表，是一个数组\nlist\n```\n\n```\nlist\n是一个数组，每个元素都是对象\n\npagePath\ntext\niconPath\nselectedIconPath\n```\n\n\n\n## 路由 router\n\n微信小程序 没有路由\n\n对应的在 pages.json 的 pages 里面可以进行配置，\n\n```\n\"pages\": [ //pages数组中第一项表示应用启动页，参考：https://uniapp.dcloud.io/collocation/pages\n  {\n    \"path\": \"pages/index/index\",\n    \"style\": {\n      \"navigationBarTitleText\": \"uni-app\"\n    }\n  }\n],\n```\n\n","slug":"uni-app-projec笔记","published":0,"updated":"2022-01-24T02:18:53.315Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckznhkk700009ikubaf8j4l1v","content":"<h1 id=\"uni-app-项目开发笔记问题\"><a href=\"#uni-app-项目开发笔记问题\" class=\"headerlink\" title=\"uni-app 项目开发笔记问题\"></a>uni-app 项目开发笔记问题</h1><h2 id=\"不要挂载原型链\"><a href=\"#不要挂载原型链\" class=\"headerlink\" title=\"不要挂载原型链\"></a>不要挂载原型链</h2><p>将对象挂载在原型链是一个大忌，并且vue2也有警告，因为这样对于维护是一个非常大的问题，使用 forin会将内容显示出来</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Object.prototype.a = &#123;&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"sass的使用\"><a href=\"#sass的使用\" class=\"headerlink\" title=\"sass的使用\"></a>sass的使用</h2><p>对于根项目的 uni.scss 我们在使用的时候不需要进行引入。</p>\n<p>项目的 node_modules vue-cli-plugin-uni/lib/options.js 里面有引入</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://uniapp.dcloud.io/collocation/uni-scss</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"tabBar\"><a href=\"#tabBar\" class=\"headerlink\" title=\"tabBar\"></a>tabBar</h2><p>微信小程序的tabBar可以使用 page.json里面进行配置，不需要自己定义组件</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://uniapp.dcloud.io/collocation/pages?id=tabbar</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">\t&quot;tabBar&quot;: &#123;</span><br><span class=\"line\">\t\t&quot;color&quot;: &quot;#808080&quot;,</span><br><span class=\"line\">\t\t&quot;selectedColor&quot;: &quot;#007aff&quot;,</span><br><span class=\"line\">\t\t&quot;backgroundColor&quot;: &quot;#f8f8f8&quot;,</span><br><span class=\"line\">\t\t&quot;list&quot;: [</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t&quot;text&quot;: &quot;主页&quot;,</span><br><span class=\"line\">\t\t\t\t&quot;iconPath&quot;: &quot;static/img/tab-bar/tab-bar-unselect.png&quot;,</span><br><span class=\"line\">\t\t\t\t&quot;selectedIconPath&quot;: &quot;static/img/tab-bar/tab-bar-select.png&quot;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t]</span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>几个比较重要的属性</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">文字颜色</span><br><span class=\"line\">color</span><br><span class=\"line\">selectedColor</span><br><span class=\"line\">背景颜色</span><br><span class=\"line\">backgroundColor</span><br><span class=\"line\"></span><br><span class=\"line\">tab列表，是一个数组</span><br><span class=\"line\">list</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">list</span><br><span class=\"line\">是一个数组，每个元素都是对象</span><br><span class=\"line\"></span><br><span class=\"line\">pagePath</span><br><span class=\"line\">text</span><br><span class=\"line\">iconPath</span><br><span class=\"line\">selectedIconPath</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"路由-router\"><a href=\"#路由-router\" class=\"headerlink\" title=\"路由 router\"></a>路由 router</h2><p>微信小程序 没有路由</p>\n<p>对应的在 pages.json 的 pages 里面可以进行配置，</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;pages&quot;: [ //pages数组中第一项表示应用启动页，参考：https://uniapp.dcloud.io/collocation/pages</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    &quot;path&quot;: &quot;pages/index/index&quot;,</span><br><span class=\"line\">    &quot;style&quot;: &#123;</span><br><span class=\"line\">      &quot;navigationBarTitleText&quot;: &quot;uni-app&quot;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">],</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"uni-app-项目开发笔记问题\"><a href=\"#uni-app-项目开发笔记问题\" class=\"headerlink\" title=\"uni-app 项目开发笔记问题\"></a>uni-app 项目开发笔记问题</h1><h2 id=\"不要挂载原型链\"><a href=\"#不要挂载原型链\" class=\"headerlink\" title=\"不要挂载原型链\"></a>不要挂载原型链</h2><p>将对象挂载在原型链是一个大忌，并且vue2也有警告，因为这样对于维护是一个非常大的问题，使用 forin会将内容显示出来</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Object.prototype.a = &#123;&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"sass的使用\"><a href=\"#sass的使用\" class=\"headerlink\" title=\"sass的使用\"></a>sass的使用</h2><p>对于根项目的 uni.scss 我们在使用的时候不需要进行引入。</p>\n<p>项目的 node_modules vue-cli-plugin-uni/lib/options.js 里面有引入</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://uniapp.dcloud.io/collocation/uni-scss</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"tabBar\"><a href=\"#tabBar\" class=\"headerlink\" title=\"tabBar\"></a>tabBar</h2><p>微信小程序的tabBar可以使用 page.json里面进行配置，不需要自己定义组件</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://uniapp.dcloud.io/collocation/pages?id=tabbar</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">\t&quot;tabBar&quot;: &#123;</span><br><span class=\"line\">\t\t&quot;color&quot;: &quot;#808080&quot;,</span><br><span class=\"line\">\t\t&quot;selectedColor&quot;: &quot;#007aff&quot;,</span><br><span class=\"line\">\t\t&quot;backgroundColor&quot;: &quot;#f8f8f8&quot;,</span><br><span class=\"line\">\t\t&quot;list&quot;: [</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t&quot;text&quot;: &quot;主页&quot;,</span><br><span class=\"line\">\t\t\t\t&quot;iconPath&quot;: &quot;static/img/tab-bar/tab-bar-unselect.png&quot;,</span><br><span class=\"line\">\t\t\t\t&quot;selectedIconPath&quot;: &quot;static/img/tab-bar/tab-bar-select.png&quot;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t]</span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>几个比较重要的属性</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">文字颜色</span><br><span class=\"line\">color</span><br><span class=\"line\">selectedColor</span><br><span class=\"line\">背景颜色</span><br><span class=\"line\">backgroundColor</span><br><span class=\"line\"></span><br><span class=\"line\">tab列表，是一个数组</span><br><span class=\"line\">list</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">list</span><br><span class=\"line\">是一个数组，每个元素都是对象</span><br><span class=\"line\"></span><br><span class=\"line\">pagePath</span><br><span class=\"line\">text</span><br><span class=\"line\">iconPath</span><br><span class=\"line\">selectedIconPath</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"路由-router\"><a href=\"#路由-router\" class=\"headerlink\" title=\"路由 router\"></a>路由 router</h2><p>微信小程序 没有路由</p>\n<p>对应的在 pages.json 的 pages 里面可以进行配置，</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;pages&quot;: [ //pages数组中第一项表示应用启动页，参考：https://uniapp.dcloud.io/collocation/pages</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    &quot;path&quot;: &quot;pages/index/index&quot;,</span><br><span class=\"line\">    &quot;style&quot;: &#123;</span><br><span class=\"line\">      &quot;navigationBarTitleText&quot;: &quot;uni-app&quot;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">],</span><br></pre></td></tr></table></figure>\n\n"},{"title":"前端性能优化","date":"2021-11-04T12:53:03.000Z","_content":"\n\n\n#  前端性能优化\n\n```\nhttps://zhuanlan.zhihu.com/p/113864878\nhttps://segmentfault.com/a/1190000022205291\n```\n\n\n\n## 请求、网络相关的优化\n\n### 简单来说，就是使用强缓存和协商缓存。在强缓存时间使用了协商缓存可以对文件进行hash操作。\n\n### 进行图片懒加载操作\n\n### 使用防抖/节流\n\n### 组件懒加载\n\n### 文件压缩\n\n\n\n## 页面显示优化\n\n### 对于页面使用重绘回流\n\n### 使用事件委托\n\n\n\n## 代码编写优化\n\n### html，js，css的位置对于DOM树生成的优化。\n\n​\t\t对这些位置进行优化。因为js的请求会影响DOM树的编写，js里对css的修改会先生成cssom树，所以在合适的位置编写位置可以进行考虑。\n\n### 使用 Object.freeze提升性能\n\n​\t\tVue的响应式原理，所以可以考虑对一些方法使用冻结来提升性能。\n\n### 扁平化数据\n\n### Vue的生产环境和运行环境\n\n\n\n\n\n\n\n\n\n\n\n","source":"_drafts/前端性能优化.md","raw":"---\ntitle: 前端性能优化\ndate: 2021-11-04 20:53:03\ntags:\n - 随笔\n - 性能优化\ncategories:\n - 随笔\n---\n\n\n\n#  前端性能优化\n\n```\nhttps://zhuanlan.zhihu.com/p/113864878\nhttps://segmentfault.com/a/1190000022205291\n```\n\n\n\n## 请求、网络相关的优化\n\n### 简单来说，就是使用强缓存和协商缓存。在强缓存时间使用了协商缓存可以对文件进行hash操作。\n\n### 进行图片懒加载操作\n\n### 使用防抖/节流\n\n### 组件懒加载\n\n### 文件压缩\n\n\n\n## 页面显示优化\n\n### 对于页面使用重绘回流\n\n### 使用事件委托\n\n\n\n## 代码编写优化\n\n### html，js，css的位置对于DOM树生成的优化。\n\n​\t\t对这些位置进行优化。因为js的请求会影响DOM树的编写，js里对css的修改会先生成cssom树，所以在合适的位置编写位置可以进行考虑。\n\n### 使用 Object.freeze提升性能\n\n​\t\tVue的响应式原理，所以可以考虑对一些方法使用冻结来提升性能。\n\n### 扁平化数据\n\n### Vue的生产环境和运行环境\n\n\n\n\n\n\n\n\n\n\n\n","slug":"前端性能优化","published":0,"updated":"2021-12-09T01:56:49.388Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckznhkk70000aikubabygek2x","content":"<h1 id=\"前端性能优化\"><a href=\"#前端性能优化\" class=\"headerlink\" title=\"前端性能优化\"></a>前端性能优化</h1><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://zhuanlan.zhihu.com/p/113864878</span><br><span class=\"line\">https://segmentfault.com/a/1190000022205291</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"请求、网络相关的优化\"><a href=\"#请求、网络相关的优化\" class=\"headerlink\" title=\"请求、网络相关的优化\"></a>请求、网络相关的优化</h2><h3 id=\"简单来说，就是使用强缓存和协商缓存。在强缓存时间使用了协商缓存可以对文件进行hash操作。\"><a href=\"#简单来说，就是使用强缓存和协商缓存。在强缓存时间使用了协商缓存可以对文件进行hash操作。\" class=\"headerlink\" title=\"简单来说，就是使用强缓存和协商缓存。在强缓存时间使用了协商缓存可以对文件进行hash操作。\"></a>简单来说，就是使用强缓存和协商缓存。在强缓存时间使用了协商缓存可以对文件进行hash操作。</h3><h3 id=\"进行图片懒加载操作\"><a href=\"#进行图片懒加载操作\" class=\"headerlink\" title=\"进行图片懒加载操作\"></a>进行图片懒加载操作</h3><h3 id=\"使用防抖-节流\"><a href=\"#使用防抖-节流\" class=\"headerlink\" title=\"使用防抖/节流\"></a>使用防抖/节流</h3><h3 id=\"组件懒加载\"><a href=\"#组件懒加载\" class=\"headerlink\" title=\"组件懒加载\"></a>组件懒加载</h3><h3 id=\"文件压缩\"><a href=\"#文件压缩\" class=\"headerlink\" title=\"文件压缩\"></a>文件压缩</h3><h2 id=\"页面显示优化\"><a href=\"#页面显示优化\" class=\"headerlink\" title=\"页面显示优化\"></a>页面显示优化</h2><h3 id=\"对于页面使用重绘回流\"><a href=\"#对于页面使用重绘回流\" class=\"headerlink\" title=\"对于页面使用重绘回流\"></a>对于页面使用重绘回流</h3><h3 id=\"使用事件委托\"><a href=\"#使用事件委托\" class=\"headerlink\" title=\"使用事件委托\"></a>使用事件委托</h3><h2 id=\"代码编写优化\"><a href=\"#代码编写优化\" class=\"headerlink\" title=\"代码编写优化\"></a>代码编写优化</h2><h3 id=\"html，js，css的位置对于DOM树生成的优化。\"><a href=\"#html，js，css的位置对于DOM树生成的优化。\" class=\"headerlink\" title=\"html，js，css的位置对于DOM树生成的优化。\"></a>html，js，css的位置对于DOM树生成的优化。</h3><p>​        对这些位置进行优化。因为js的请求会影响DOM树的编写，js里对css的修改会先生成cssom树，所以在合适的位置编写位置可以进行考虑。</p>\n<h3 id=\"使用-Object-freeze提升性能\"><a href=\"#使用-Object-freeze提升性能\" class=\"headerlink\" title=\"使用 Object.freeze提升性能\"></a>使用 Object.freeze提升性能</h3><p>​        Vue的响应式原理，所以可以考虑对一些方法使用冻结来提升性能。</p>\n<h3 id=\"扁平化数据\"><a href=\"#扁平化数据\" class=\"headerlink\" title=\"扁平化数据\"></a>扁平化数据</h3><h3 id=\"Vue的生产环境和运行环境\"><a href=\"#Vue的生产环境和运行环境\" class=\"headerlink\" title=\"Vue的生产环境和运行环境\"></a>Vue的生产环境和运行环境</h3>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"前端性能优化\"><a href=\"#前端性能优化\" class=\"headerlink\" title=\"前端性能优化\"></a>前端性能优化</h1><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://zhuanlan.zhihu.com/p/113864878</span><br><span class=\"line\">https://segmentfault.com/a/1190000022205291</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"请求、网络相关的优化\"><a href=\"#请求、网络相关的优化\" class=\"headerlink\" title=\"请求、网络相关的优化\"></a>请求、网络相关的优化</h2><h3 id=\"简单来说，就是使用强缓存和协商缓存。在强缓存时间使用了协商缓存可以对文件进行hash操作。\"><a href=\"#简单来说，就是使用强缓存和协商缓存。在强缓存时间使用了协商缓存可以对文件进行hash操作。\" class=\"headerlink\" title=\"简单来说，就是使用强缓存和协商缓存。在强缓存时间使用了协商缓存可以对文件进行hash操作。\"></a>简单来说，就是使用强缓存和协商缓存。在强缓存时间使用了协商缓存可以对文件进行hash操作。</h3><h3 id=\"进行图片懒加载操作\"><a href=\"#进行图片懒加载操作\" class=\"headerlink\" title=\"进行图片懒加载操作\"></a>进行图片懒加载操作</h3><h3 id=\"使用防抖-节流\"><a href=\"#使用防抖-节流\" class=\"headerlink\" title=\"使用防抖/节流\"></a>使用防抖/节流</h3><h3 id=\"组件懒加载\"><a href=\"#组件懒加载\" class=\"headerlink\" title=\"组件懒加载\"></a>组件懒加载</h3><h3 id=\"文件压缩\"><a href=\"#文件压缩\" class=\"headerlink\" title=\"文件压缩\"></a>文件压缩</h3><h2 id=\"页面显示优化\"><a href=\"#页面显示优化\" class=\"headerlink\" title=\"页面显示优化\"></a>页面显示优化</h2><h3 id=\"对于页面使用重绘回流\"><a href=\"#对于页面使用重绘回流\" class=\"headerlink\" title=\"对于页面使用重绘回流\"></a>对于页面使用重绘回流</h3><h3 id=\"使用事件委托\"><a href=\"#使用事件委托\" class=\"headerlink\" title=\"使用事件委托\"></a>使用事件委托</h3><h2 id=\"代码编写优化\"><a href=\"#代码编写优化\" class=\"headerlink\" title=\"代码编写优化\"></a>代码编写优化</h2><h3 id=\"html，js，css的位置对于DOM树生成的优化。\"><a href=\"#html，js，css的位置对于DOM树生成的优化。\" class=\"headerlink\" title=\"html，js，css的位置对于DOM树生成的优化。\"></a>html，js，css的位置对于DOM树生成的优化。</h3><p>​        对这些位置进行优化。因为js的请求会影响DOM树的编写，js里对css的修改会先生成cssom树，所以在合适的位置编写位置可以进行考虑。</p>\n<h3 id=\"使用-Object-freeze提升性能\"><a href=\"#使用-Object-freeze提升性能\" class=\"headerlink\" title=\"使用 Object.freeze提升性能\"></a>使用 Object.freeze提升性能</h3><p>​        Vue的响应式原理，所以可以考虑对一些方法使用冻结来提升性能。</p>\n<h3 id=\"扁平化数据\"><a href=\"#扁平化数据\" class=\"headerlink\" title=\"扁平化数据\"></a>扁平化数据</h3><h3 id=\"Vue的生产环境和运行环境\"><a href=\"#Vue的生产环境和运行环境\" class=\"headerlink\" title=\"Vue的生产环境和运行环境\"></a>Vue的生产环境和运行环境</h3>"},{"layout":"draft","title":"对象的方法","date":"2022-01-19T10:01:31.000Z","_content":"","source":"_drafts/对象的方法.md","raw":"---\nlayout: draft\ntitle: 对象的方法\ndate: 2022-01-19 18:01:31\ntags:\n---\n","slug":"对象的方法","published":0,"updated":"2022-01-19T10:01:31.256Z","comments":1,"photos":[],"link":"","_id":"ckznhkk71000dikubem737f91","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"请求跨域","date":"2021-11-06T05:16:54.000Z","_content":"\n\n\n#  跨域\n\n**什么是同源**\n\n​\t\t如果两个 URL 的 [protocol](https://developer.mozilla.org/zh-CN/docs/Glossary/Protocol)、[port (en-US)](https://developer.mozilla.org/en-US/docs/Glossary/Port) (如果有指定的话)和 [host](https://developer.mozilla.org/zh-CN/docs/Glossary/Host) 都相同的话，则这两个 URL 是*同源*。这个方案也被称为“协议/主机/端口元组”，或者直接是 “元组”。\n\n\n\n跨域就是因为浏览器的安全原因，只能执行同源的脚本。对于不是同源的请求将会产生跨域。\n\n对于前后端分离的开发方式，如果不解决跨域，那么我们将无法获取到返回的数据。\n\n\n\n# 解决办法\n\n## CORS 跨域资源共享\n\n```\nhttps://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS\n```\n\n\n\n​\t\t跨域资源共享分为了简单请求和非简单请求两种。\n\n### 简单请求\n\n当满足下面条件时，就属于简单请求\n\n* 请求方法是下面的方法\n\n```\nGET，HEAD，POST\n```\n\n* 请求头字段，除了是用户代理自动设置的字段(user-agent) 以及在 fetch 规范中为禁用首部名称的首部。还有人为设置的字段\n\n```\nuser-agent 等用户代理的字段\nfetch 规范禁用的首部名称的首部\n允许人为设置的字段。\naccept\naccept-language\ncontent-language\ncontent-type (text/plain， mutipart/form-data， application/x-www-form-urlencoded)\n```\n\n* 对于任意的 XMLHttpRequestUpload 对象没有注册任何事件监听器。\n  * **XMLHttpRequest.upload 属性返回一个** `XMLHttpRequestUpload`对象，用来表示上传的进度。\n* 请求没有使用 ReadableStream 对象\n  * 流操作API\n\n\n\n#### 服务器端如何使用响应头进行响应\n\n​\t\t首先，请求可以使用请求首部字段 origin 表明请求的来源。这个和refer有点相似，但是origin只是指示了请求来源于哪个站点，并没有包含任何路径信息。\n\n​\t\t然后服务器端通过使用 Access-Control-Allow-Origin 响应头进行响应。\n\n​\t\tAccess-Control-Allow-Origin: *， 表明了该资源可以被任何外域访问。如果想只允许 http://www.example 的访问，设置响应头 Access-Control-Allow-Origin: http://www.example 。设置了响应头之后，其他外域不能访问该资源。通过origin来定义是否为外域资源。\n\n​\tAccess-Control-Allow-Origin，访问控制允许源\n\n\n\n### 非简单请求\n\n非简单请求相对于简单请求来说，多了一个预检请求 options。\n\n通过预检请求来获取服务器是否允许实际的请求。\n\n\n\n#### 预检请求\n\n* 使用的请求方式是 OPTIONS\n* 会携带了两个请求首部字段\n  * Access-Control-Request-Method: POST，访问控制请求方式，代表了我实际请求将使用POST方法。\n  * Access-Control-Request-Headers: Content-Type，访问控制请求头，代表了我实际请求将携带这个自定义首部字段。\n* 服务器将根据这两个字段来决定该实际请求是否被允许。\n\n\n\n服务器的响应头设置\n\n* Access-Control-Allow-Origin：http://foo.example\n  * 表示了访问控制允许源，允许哪个源进行访问 http://foo.example\n* Access-Control-Allow-Method：POST，GET，OPTIONS \n  * 访问控制允许方法，比如设置了POST，GET，OPTIONS，表示了允许这三个方法进行访问\n* Access-Control-Allow-Headers：X-PINGOTHER, Content-Type \n  * 访问控制允许头，就是说，允许后面的请求头携带。这里就是说，允许自定义头X-PINGOTHER的携带。对于Content-type的携带，因为Content-Type是默认只允许三个内容进行允许。\n* Access-Control-Max-Age：86400\n  * 表示该响应的有效时间是86400s，表示在时间内不需要在进行一次预检请求。\n\n\n\n去掉对于预检请求的重定向。大部分的浏览器可能对于预检请求的重定向会报告错误。\n\n解决方式，\n\n* 去掉对预检请求的重定向\n* 将实际的请求变换为一个简单请求\n* 或者发出一个简单请求（使用  [Response.url](https://developer.mozilla.org/en-US/docs/Web/API/Response/url) 或 [XHR.responseURL](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/responseURL)）来判断预检请求的地址，然后再发送真正的请求。使用的是真正的地址。 response.url，这个是响应的url，值为重定向之后的最终URL。\n\n\n\n### 跨域请求携带Cookie\n\n​\t\t因为跨域请求不会发送身份凭证信息，所以需要使用一个特殊的请求头标志位\n\n​\t\t [`XMLHttpRequest.withCredentials`](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/withCredentials) 设置这个值为true，那么就会将会发送cookie等信息。\n\n​\t\t当然如果设置了这个之后，服务器端需要设置 Access-Control-Allow-Credentials: true, 否则浏览器将不会将相应内容返回给发送者。\n\n​\t\t同时，对于附带了身份凭证的请求，服务器不能将访问控制允许源设置为*，而需要设置为一个具体的域名。\n\n​\t\t并且记住，这个算是第三方的cookie，因为域名不一样。\n\n\n\n## 使用代理\n\n​\t\t我们可以知道跨域的原因是浏览器的安全策略问题，所以我们可以使用代理的方式来解决跨域的问题。\n\n​\t\t这里的代理有Node的中间件代理和nginx代理\n\n\n\n## 使用 JSONP\n\n​\t\t这个比较简单的理解，因为JSONP简单来说就是利用了一些标签没有同源限制的漏洞进行的操作。比如script等。\n\n\n\n## 使用iframe\n\n\n\n","source":"_drafts/请求跨域.md","raw":"---\ntitle: 请求跨域\ndate: 2021-11-06 13:16:54\ntags:\n - 跨域\n - 随笔\ncategories:\n - 随笔\n---\n\n\n\n#  跨域\n\n**什么是同源**\n\n​\t\t如果两个 URL 的 [protocol](https://developer.mozilla.org/zh-CN/docs/Glossary/Protocol)、[port (en-US)](https://developer.mozilla.org/en-US/docs/Glossary/Port) (如果有指定的话)和 [host](https://developer.mozilla.org/zh-CN/docs/Glossary/Host) 都相同的话，则这两个 URL 是*同源*。这个方案也被称为“协议/主机/端口元组”，或者直接是 “元组”。\n\n\n\n跨域就是因为浏览器的安全原因，只能执行同源的脚本。对于不是同源的请求将会产生跨域。\n\n对于前后端分离的开发方式，如果不解决跨域，那么我们将无法获取到返回的数据。\n\n\n\n# 解决办法\n\n## CORS 跨域资源共享\n\n```\nhttps://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS\n```\n\n\n\n​\t\t跨域资源共享分为了简单请求和非简单请求两种。\n\n### 简单请求\n\n当满足下面条件时，就属于简单请求\n\n* 请求方法是下面的方法\n\n```\nGET，HEAD，POST\n```\n\n* 请求头字段，除了是用户代理自动设置的字段(user-agent) 以及在 fetch 规范中为禁用首部名称的首部。还有人为设置的字段\n\n```\nuser-agent 等用户代理的字段\nfetch 规范禁用的首部名称的首部\n允许人为设置的字段。\naccept\naccept-language\ncontent-language\ncontent-type (text/plain， mutipart/form-data， application/x-www-form-urlencoded)\n```\n\n* 对于任意的 XMLHttpRequestUpload 对象没有注册任何事件监听器。\n  * **XMLHttpRequest.upload 属性返回一个** `XMLHttpRequestUpload`对象，用来表示上传的进度。\n* 请求没有使用 ReadableStream 对象\n  * 流操作API\n\n\n\n#### 服务器端如何使用响应头进行响应\n\n​\t\t首先，请求可以使用请求首部字段 origin 表明请求的来源。这个和refer有点相似，但是origin只是指示了请求来源于哪个站点，并没有包含任何路径信息。\n\n​\t\t然后服务器端通过使用 Access-Control-Allow-Origin 响应头进行响应。\n\n​\t\tAccess-Control-Allow-Origin: *， 表明了该资源可以被任何外域访问。如果想只允许 http://www.example 的访问，设置响应头 Access-Control-Allow-Origin: http://www.example 。设置了响应头之后，其他外域不能访问该资源。通过origin来定义是否为外域资源。\n\n​\tAccess-Control-Allow-Origin，访问控制允许源\n\n\n\n### 非简单请求\n\n非简单请求相对于简单请求来说，多了一个预检请求 options。\n\n通过预检请求来获取服务器是否允许实际的请求。\n\n\n\n#### 预检请求\n\n* 使用的请求方式是 OPTIONS\n* 会携带了两个请求首部字段\n  * Access-Control-Request-Method: POST，访问控制请求方式，代表了我实际请求将使用POST方法。\n  * Access-Control-Request-Headers: Content-Type，访问控制请求头，代表了我实际请求将携带这个自定义首部字段。\n* 服务器将根据这两个字段来决定该实际请求是否被允许。\n\n\n\n服务器的响应头设置\n\n* Access-Control-Allow-Origin：http://foo.example\n  * 表示了访问控制允许源，允许哪个源进行访问 http://foo.example\n* Access-Control-Allow-Method：POST，GET，OPTIONS \n  * 访问控制允许方法，比如设置了POST，GET，OPTIONS，表示了允许这三个方法进行访问\n* Access-Control-Allow-Headers：X-PINGOTHER, Content-Type \n  * 访问控制允许头，就是说，允许后面的请求头携带。这里就是说，允许自定义头X-PINGOTHER的携带。对于Content-type的携带，因为Content-Type是默认只允许三个内容进行允许。\n* Access-Control-Max-Age：86400\n  * 表示该响应的有效时间是86400s，表示在时间内不需要在进行一次预检请求。\n\n\n\n去掉对于预检请求的重定向。大部分的浏览器可能对于预检请求的重定向会报告错误。\n\n解决方式，\n\n* 去掉对预检请求的重定向\n* 将实际的请求变换为一个简单请求\n* 或者发出一个简单请求（使用  [Response.url](https://developer.mozilla.org/en-US/docs/Web/API/Response/url) 或 [XHR.responseURL](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/responseURL)）来判断预检请求的地址，然后再发送真正的请求。使用的是真正的地址。 response.url，这个是响应的url，值为重定向之后的最终URL。\n\n\n\n### 跨域请求携带Cookie\n\n​\t\t因为跨域请求不会发送身份凭证信息，所以需要使用一个特殊的请求头标志位\n\n​\t\t [`XMLHttpRequest.withCredentials`](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/withCredentials) 设置这个值为true，那么就会将会发送cookie等信息。\n\n​\t\t当然如果设置了这个之后，服务器端需要设置 Access-Control-Allow-Credentials: true, 否则浏览器将不会将相应内容返回给发送者。\n\n​\t\t同时，对于附带了身份凭证的请求，服务器不能将访问控制允许源设置为*，而需要设置为一个具体的域名。\n\n​\t\t并且记住，这个算是第三方的cookie，因为域名不一样。\n\n\n\n## 使用代理\n\n​\t\t我们可以知道跨域的原因是浏览器的安全策略问题，所以我们可以使用代理的方式来解决跨域的问题。\n\n​\t\t这里的代理有Node的中间件代理和nginx代理\n\n\n\n## 使用 JSONP\n\n​\t\t这个比较简单的理解，因为JSONP简单来说就是利用了一些标签没有同源限制的漏洞进行的操作。比如script等。\n\n\n\n## 使用iframe\n\n\n\n","slug":"请求跨域","published":0,"updated":"2021-12-09T01:56:49.388Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckznhkk72000eikubgx2k8rzo","content":"<h1 id=\"跨域\"><a href=\"#跨域\" class=\"headerlink\" title=\"跨域\"></a>跨域</h1><p><strong>什么是同源</strong></p>\n<p>​        如果两个 URL 的 <a href=\"https://developer.mozilla.org/zh-CN/docs/Glossary/Protocol\">protocol</a>、<a href=\"https://developer.mozilla.org/en-US/docs/Glossary/Port\">port (en-US)</a> (如果有指定的话)和 <a href=\"https://developer.mozilla.org/zh-CN/docs/Glossary/Host\">host</a> 都相同的话，则这两个 URL 是<em>同源</em>。这个方案也被称为“协议/主机/端口元组”，或者直接是 “元组”。</p>\n<p>跨域就是因为浏览器的安全原因，只能执行同源的脚本。对于不是同源的请求将会产生跨域。</p>\n<p>对于前后端分离的开发方式，如果不解决跨域，那么我们将无法获取到返回的数据。</p>\n<h1 id=\"解决办法\"><a href=\"#解决办法\" class=\"headerlink\" title=\"解决办法\"></a>解决办法</h1><h2 id=\"CORS-跨域资源共享\"><a href=\"#CORS-跨域资源共享\" class=\"headerlink\" title=\"CORS 跨域资源共享\"></a>CORS 跨域资源共享</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS</span><br></pre></td></tr></table></figure>\n\n\n\n<p>​        跨域资源共享分为了简单请求和非简单请求两种。</p>\n<h3 id=\"简单请求\"><a href=\"#简单请求\" class=\"headerlink\" title=\"简单请求\"></a>简单请求</h3><p>当满足下面条件时，就属于简单请求</p>\n<ul>\n<li>请求方法是下面的方法</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET，HEAD，POST</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>请求头字段，除了是用户代理自动设置的字段(user-agent) 以及在 fetch 规范中为禁用首部名称的首部。还有人为设置的字段</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">user-agent 等用户代理的字段</span><br><span class=\"line\">fetch 规范禁用的首部名称的首部</span><br><span class=\"line\">允许人为设置的字段。</span><br><span class=\"line\">accept</span><br><span class=\"line\">accept-language</span><br><span class=\"line\">content-language</span><br><span class=\"line\">content-type (text/plain， mutipart/form-data， application/x-www-form-urlencoded)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>对于任意的 XMLHttpRequestUpload 对象没有注册任何事件监听器。<ul>\n<li><strong>XMLHttpRequest.upload 属性返回一个</strong> <code>XMLHttpRequestUpload</code>对象，用来表示上传的进度。</li>\n</ul>\n</li>\n<li>请求没有使用 ReadableStream 对象<ul>\n<li>流操作API</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"服务器端如何使用响应头进行响应\"><a href=\"#服务器端如何使用响应头进行响应\" class=\"headerlink\" title=\"服务器端如何使用响应头进行响应\"></a>服务器端如何使用响应头进行响应</h4><p>​        首先，请求可以使用请求首部字段 origin 表明请求的来源。这个和refer有点相似，但是origin只是指示了请求来源于哪个站点，并没有包含任何路径信息。</p>\n<p>​        然后服务器端通过使用 Access-Control-Allow-Origin 响应头进行响应。</p>\n<p>​        Access-Control-Allow-Origin: *， 表明了该资源可以被任何外域访问。如果想只允许 <a href=\"http://www.example/\">http://www.example</a> 的访问，设置响应头 Access-Control-Allow-Origin: <a href=\"http://www.example/\">http://www.example</a> 。设置了响应头之后，其他外域不能访问该资源。通过origin来定义是否为外域资源。</p>\n<p>​    Access-Control-Allow-Origin，访问控制允许源</p>\n<h3 id=\"非简单请求\"><a href=\"#非简单请求\" class=\"headerlink\" title=\"非简单请求\"></a>非简单请求</h3><p>非简单请求相对于简单请求来说，多了一个预检请求 options。</p>\n<p>通过预检请求来获取服务器是否允许实际的请求。</p>\n<h4 id=\"预检请求\"><a href=\"#预检请求\" class=\"headerlink\" title=\"预检请求\"></a>预检请求</h4><ul>\n<li>使用的请求方式是 OPTIONS</li>\n<li>会携带了两个请求首部字段<ul>\n<li>Access-Control-Request-Method: POST，访问控制请求方式，代表了我实际请求将使用POST方法。</li>\n<li>Access-Control-Request-Headers: Content-Type，访问控制请求头，代表了我实际请求将携带这个自定义首部字段。</li>\n</ul>\n</li>\n<li>服务器将根据这两个字段来决定该实际请求是否被允许。</li>\n</ul>\n<p>服务器的响应头设置</p>\n<ul>\n<li>Access-Control-Allow-Origin：<a href=\"http://foo.example/\">http://foo.example</a><ul>\n<li>表示了访问控制允许源，允许哪个源进行访问 <a href=\"http://foo.example/\">http://foo.example</a></li>\n</ul>\n</li>\n<li>Access-Control-Allow-Method：POST，GET，OPTIONS <ul>\n<li>访问控制允许方法，比如设置了POST，GET，OPTIONS，表示了允许这三个方法进行访问</li>\n</ul>\n</li>\n<li>Access-Control-Allow-Headers：X-PINGOTHER, Content-Type <ul>\n<li>访问控制允许头，就是说，允许后面的请求头携带。这里就是说，允许自定义头X-PINGOTHER的携带。对于Content-type的携带，因为Content-Type是默认只允许三个内容进行允许。</li>\n</ul>\n</li>\n<li>Access-Control-Max-Age：86400<ul>\n<li>表示该响应的有效时间是86400s，表示在时间内不需要在进行一次预检请求。</li>\n</ul>\n</li>\n</ul>\n<p>去掉对于预检请求的重定向。大部分的浏览器可能对于预检请求的重定向会报告错误。</p>\n<p>解决方式，</p>\n<ul>\n<li>去掉对预检请求的重定向</li>\n<li>将实际的请求变换为一个简单请求</li>\n<li>或者发出一个简单请求（使用  <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Response/url\">Response.url</a> 或 <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/responseURL\">XHR.responseURL</a>）来判断预检请求的地址，然后再发送真正的请求。使用的是真正的地址。 response.url，这个是响应的url，值为重定向之后的最终URL。</li>\n</ul>\n<h3 id=\"跨域请求携带Cookie\"><a href=\"#跨域请求携带Cookie\" class=\"headerlink\" title=\"跨域请求携带Cookie\"></a>跨域请求携带Cookie</h3><p>​        因为跨域请求不会发送身份凭证信息，所以需要使用一个特殊的请求头标志位</p>\n<p>​         <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/withCredentials\"><code>XMLHttpRequest.withCredentials</code></a> 设置这个值为true，那么就会将会发送cookie等信息。</p>\n<p>​        当然如果设置了这个之后，服务器端需要设置 Access-Control-Allow-Credentials: true, 否则浏览器将不会将相应内容返回给发送者。</p>\n<p>​        同时，对于附带了身份凭证的请求，服务器不能将访问控制允许源设置为*，而需要设置为一个具体的域名。</p>\n<p>​        并且记住，这个算是第三方的cookie，因为域名不一样。</p>\n<h2 id=\"使用代理\"><a href=\"#使用代理\" class=\"headerlink\" title=\"使用代理\"></a>使用代理</h2><p>​        我们可以知道跨域的原因是浏览器的安全策略问题，所以我们可以使用代理的方式来解决跨域的问题。</p>\n<p>​        这里的代理有Node的中间件代理和nginx代理</p>\n<h2 id=\"使用-JSONP\"><a href=\"#使用-JSONP\" class=\"headerlink\" title=\"使用 JSONP\"></a>使用 JSONP</h2><p>​        这个比较简单的理解，因为JSONP简单来说就是利用了一些标签没有同源限制的漏洞进行的操作。比如script等。</p>\n<h2 id=\"使用iframe\"><a href=\"#使用iframe\" class=\"headerlink\" title=\"使用iframe\"></a>使用iframe</h2>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"跨域\"><a href=\"#跨域\" class=\"headerlink\" title=\"跨域\"></a>跨域</h1><p><strong>什么是同源</strong></p>\n<p>​        如果两个 URL 的 <a href=\"https://developer.mozilla.org/zh-CN/docs/Glossary/Protocol\">protocol</a>、<a href=\"https://developer.mozilla.org/en-US/docs/Glossary/Port\">port (en-US)</a> (如果有指定的话)和 <a href=\"https://developer.mozilla.org/zh-CN/docs/Glossary/Host\">host</a> 都相同的话，则这两个 URL 是<em>同源</em>。这个方案也被称为“协议/主机/端口元组”，或者直接是 “元组”。</p>\n<p>跨域就是因为浏览器的安全原因，只能执行同源的脚本。对于不是同源的请求将会产生跨域。</p>\n<p>对于前后端分离的开发方式，如果不解决跨域，那么我们将无法获取到返回的数据。</p>\n<h1 id=\"解决办法\"><a href=\"#解决办法\" class=\"headerlink\" title=\"解决办法\"></a>解决办法</h1><h2 id=\"CORS-跨域资源共享\"><a href=\"#CORS-跨域资源共享\" class=\"headerlink\" title=\"CORS 跨域资源共享\"></a>CORS 跨域资源共享</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS</span><br></pre></td></tr></table></figure>\n\n\n\n<p>​        跨域资源共享分为了简单请求和非简单请求两种。</p>\n<h3 id=\"简单请求\"><a href=\"#简单请求\" class=\"headerlink\" title=\"简单请求\"></a>简单请求</h3><p>当满足下面条件时，就属于简单请求</p>\n<ul>\n<li>请求方法是下面的方法</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET，HEAD，POST</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>请求头字段，除了是用户代理自动设置的字段(user-agent) 以及在 fetch 规范中为禁用首部名称的首部。还有人为设置的字段</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">user-agent 等用户代理的字段</span><br><span class=\"line\">fetch 规范禁用的首部名称的首部</span><br><span class=\"line\">允许人为设置的字段。</span><br><span class=\"line\">accept</span><br><span class=\"line\">accept-language</span><br><span class=\"line\">content-language</span><br><span class=\"line\">content-type (text/plain， mutipart/form-data， application/x-www-form-urlencoded)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>对于任意的 XMLHttpRequestUpload 对象没有注册任何事件监听器。<ul>\n<li><strong>XMLHttpRequest.upload 属性返回一个</strong> <code>XMLHttpRequestUpload</code>对象，用来表示上传的进度。</li>\n</ul>\n</li>\n<li>请求没有使用 ReadableStream 对象<ul>\n<li>流操作API</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"服务器端如何使用响应头进行响应\"><a href=\"#服务器端如何使用响应头进行响应\" class=\"headerlink\" title=\"服务器端如何使用响应头进行响应\"></a>服务器端如何使用响应头进行响应</h4><p>​        首先，请求可以使用请求首部字段 origin 表明请求的来源。这个和refer有点相似，但是origin只是指示了请求来源于哪个站点，并没有包含任何路径信息。</p>\n<p>​        然后服务器端通过使用 Access-Control-Allow-Origin 响应头进行响应。</p>\n<p>​        Access-Control-Allow-Origin: *， 表明了该资源可以被任何外域访问。如果想只允许 <a href=\"http://www.example/\">http://www.example</a> 的访问，设置响应头 Access-Control-Allow-Origin: <a href=\"http://www.example/\">http://www.example</a> 。设置了响应头之后，其他外域不能访问该资源。通过origin来定义是否为外域资源。</p>\n<p>​    Access-Control-Allow-Origin，访问控制允许源</p>\n<h3 id=\"非简单请求\"><a href=\"#非简单请求\" class=\"headerlink\" title=\"非简单请求\"></a>非简单请求</h3><p>非简单请求相对于简单请求来说，多了一个预检请求 options。</p>\n<p>通过预检请求来获取服务器是否允许实际的请求。</p>\n<h4 id=\"预检请求\"><a href=\"#预检请求\" class=\"headerlink\" title=\"预检请求\"></a>预检请求</h4><ul>\n<li>使用的请求方式是 OPTIONS</li>\n<li>会携带了两个请求首部字段<ul>\n<li>Access-Control-Request-Method: POST，访问控制请求方式，代表了我实际请求将使用POST方法。</li>\n<li>Access-Control-Request-Headers: Content-Type，访问控制请求头，代表了我实际请求将携带这个自定义首部字段。</li>\n</ul>\n</li>\n<li>服务器将根据这两个字段来决定该实际请求是否被允许。</li>\n</ul>\n<p>服务器的响应头设置</p>\n<ul>\n<li>Access-Control-Allow-Origin：<a href=\"http://foo.example/\">http://foo.example</a><ul>\n<li>表示了访问控制允许源，允许哪个源进行访问 <a href=\"http://foo.example/\">http://foo.example</a></li>\n</ul>\n</li>\n<li>Access-Control-Allow-Method：POST，GET，OPTIONS <ul>\n<li>访问控制允许方法，比如设置了POST，GET，OPTIONS，表示了允许这三个方法进行访问</li>\n</ul>\n</li>\n<li>Access-Control-Allow-Headers：X-PINGOTHER, Content-Type <ul>\n<li>访问控制允许头，就是说，允许后面的请求头携带。这里就是说，允许自定义头X-PINGOTHER的携带。对于Content-type的携带，因为Content-Type是默认只允许三个内容进行允许。</li>\n</ul>\n</li>\n<li>Access-Control-Max-Age：86400<ul>\n<li>表示该响应的有效时间是86400s，表示在时间内不需要在进行一次预检请求。</li>\n</ul>\n</li>\n</ul>\n<p>去掉对于预检请求的重定向。大部分的浏览器可能对于预检请求的重定向会报告错误。</p>\n<p>解决方式，</p>\n<ul>\n<li>去掉对预检请求的重定向</li>\n<li>将实际的请求变换为一个简单请求</li>\n<li>或者发出一个简单请求（使用  <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Response/url\">Response.url</a> 或 <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/responseURL\">XHR.responseURL</a>）来判断预检请求的地址，然后再发送真正的请求。使用的是真正的地址。 response.url，这个是响应的url，值为重定向之后的最终URL。</li>\n</ul>\n<h3 id=\"跨域请求携带Cookie\"><a href=\"#跨域请求携带Cookie\" class=\"headerlink\" title=\"跨域请求携带Cookie\"></a>跨域请求携带Cookie</h3><p>​        因为跨域请求不会发送身份凭证信息，所以需要使用一个特殊的请求头标志位</p>\n<p>​         <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/withCredentials\"><code>XMLHttpRequest.withCredentials</code></a> 设置这个值为true，那么就会将会发送cookie等信息。</p>\n<p>​        当然如果设置了这个之后，服务器端需要设置 Access-Control-Allow-Credentials: true, 否则浏览器将不会将相应内容返回给发送者。</p>\n<p>​        同时，对于附带了身份凭证的请求，服务器不能将访问控制允许源设置为*，而需要设置为一个具体的域名。</p>\n<p>​        并且记住，这个算是第三方的cookie，因为域名不一样。</p>\n<h2 id=\"使用代理\"><a href=\"#使用代理\" class=\"headerlink\" title=\"使用代理\"></a>使用代理</h2><p>​        我们可以知道跨域的原因是浏览器的安全策略问题，所以我们可以使用代理的方式来解决跨域的问题。</p>\n<p>​        这里的代理有Node的中间件代理和nginx代理</p>\n<h2 id=\"使用-JSONP\"><a href=\"#使用-JSONP\" class=\"headerlink\" title=\"使用 JSONP\"></a>使用 JSONP</h2><p>​        这个比较简单的理解，因为JSONP简单来说就是利用了一些标签没有同源限制的漏洞进行的操作。比如script等。</p>\n<h2 id=\"使用iframe\"><a href=\"#使用iframe\" class=\"headerlink\" title=\"使用iframe\"></a>使用iframe</h2>"},{"layout":"draft","title":"vue3迁移指南","date":"2021-12-14T06:51:47.000Z","_content":"\n\n\n# 介绍\n\n## 快速开始\n\n​\t\tCDN，Codepen，CodeSandbox\n\n- 通过 CDN：`<script src=\"https://unpkg.com/vue@next\"></script>`\n- [Codepen](https://codepen.io/yyx990803/pen/OJNoaZL) 上的浏览器内试验田\n- [CodeSandbox](https://v3.vue.new/) 上的浏览器内沙盒\n\n使用脚手架 vite 或者 vue-cli\n\n## 用于迁移的构建版本\n\n​\t\t如果你打算要将一个基于 Vue 2 的项目或者库升级到 Vue 3，我们提供了一个与 Vue 2 API 兼容的 Vue 3 构建版本，详情见[用于迁移的构建版本](https://v3.cn.vuejs.org/guide/migration/migration-build.html)。\n\n### 值得注意的新特性\n\n* 组合式API\n  * 使用了 setup 方法。在组件创建之前执行，一旦 props 被解析就将作为组合式API的入口。\n  * `setup` 选项是一个接收 `props` 和 `context` 的函数，我们将在[之后](https://v3.cn.vuejs.org/guide/composition-api-setup.html#参数)进行讨论。\n  * 我们将 `setup` 返回的所有内容都暴露给组件的其余部分 (计算属性、方法、生命周期钩子等等) 以及组件的模板。\n\n```\n// 在我们的组件内\nsetup (props) {\n  let repositories = []\n  const getUserRepositories = async () => {\n    repositories = await fetchUserRepositories(props.user)\n  }\n\n  return {\n    repositories,\n    getUserRepositories // 返回的函数与方法的行为相同\n  }\n}\n```\n\n​\t\t但是此时的 repositories 变量是非响应式的。此时就需要使用 ref 函数使任何响应式变量在 ref 函数中起作用。\n\n带 ref 的响应式变量\n\n​\t\tref 接收参数并将其包裹在一个带有 value property 的对象中返回，然后可以使用该 property 访问或更改响应式变量的值：\n\n​\t将值封装在对象中，看似没有必要，但是为了保持 JavaScript 中不同数据类型的行为统一，这个是必须的。为了将所有类型都变成引用传递，而不是分为了值传递和引用传递。\n\n```\nconst counter = ref(0)\n```\n\n\n\n\n\n# 用于迁移的构建版本\n\n​\t\t\n\n\n\n# 细节\n","source":"_drafts/Vue/vue3迁移指南.md","raw":"---\nlayout: draft\ntitle: vue3迁移指南\ndate: 2021-12-14 14:51:47\ntags:\n - Vue\n - Vue3\n - 文档\ncategories:\n - Vue\n - Vue3\n---\n\n\n\n# 介绍\n\n## 快速开始\n\n​\t\tCDN，Codepen，CodeSandbox\n\n- 通过 CDN：`<script src=\"https://unpkg.com/vue@next\"></script>`\n- [Codepen](https://codepen.io/yyx990803/pen/OJNoaZL) 上的浏览器内试验田\n- [CodeSandbox](https://v3.vue.new/) 上的浏览器内沙盒\n\n使用脚手架 vite 或者 vue-cli\n\n## 用于迁移的构建版本\n\n​\t\t如果你打算要将一个基于 Vue 2 的项目或者库升级到 Vue 3，我们提供了一个与 Vue 2 API 兼容的 Vue 3 构建版本，详情见[用于迁移的构建版本](https://v3.cn.vuejs.org/guide/migration/migration-build.html)。\n\n### 值得注意的新特性\n\n* 组合式API\n  * 使用了 setup 方法。在组件创建之前执行，一旦 props 被解析就将作为组合式API的入口。\n  * `setup` 选项是一个接收 `props` 和 `context` 的函数，我们将在[之后](https://v3.cn.vuejs.org/guide/composition-api-setup.html#参数)进行讨论。\n  * 我们将 `setup` 返回的所有内容都暴露给组件的其余部分 (计算属性、方法、生命周期钩子等等) 以及组件的模板。\n\n```\n// 在我们的组件内\nsetup (props) {\n  let repositories = []\n  const getUserRepositories = async () => {\n    repositories = await fetchUserRepositories(props.user)\n  }\n\n  return {\n    repositories,\n    getUserRepositories // 返回的函数与方法的行为相同\n  }\n}\n```\n\n​\t\t但是此时的 repositories 变量是非响应式的。此时就需要使用 ref 函数使任何响应式变量在 ref 函数中起作用。\n\n带 ref 的响应式变量\n\n​\t\tref 接收参数并将其包裹在一个带有 value property 的对象中返回，然后可以使用该 property 访问或更改响应式变量的值：\n\n​\t将值封装在对象中，看似没有必要，但是为了保持 JavaScript 中不同数据类型的行为统一，这个是必须的。为了将所有类型都变成引用传递，而不是分为了值传递和引用传递。\n\n```\nconst counter = ref(0)\n```\n\n\n\n\n\n# 用于迁移的构建版本\n\n​\t\t\n\n\n\n# 细节\n","slug":"Vue/vue3迁移指南","published":0,"updated":"2022-02-07T02:21:09.154Z","comments":1,"photos":[],"link":"","_id":"ckznhkk73000hikub4u2q9w2i","content":"<h1 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h1><h2 id=\"快速开始\"><a href=\"#快速开始\" class=\"headerlink\" title=\"快速开始\"></a>快速开始</h2><p>​        CDN，Codepen，CodeSandbox</p>\n<ul>\n<li>通过 CDN：<code>&lt;script src=&quot;https://unpkg.com/vue@next&quot;&gt;&lt;/script&gt;</code></li>\n<li><a href=\"https://codepen.io/yyx990803/pen/OJNoaZL\">Codepen</a> 上的浏览器内试验田</li>\n<li><a href=\"https://v3.vue.new/\">CodeSandbox</a> 上的浏览器内沙盒</li>\n</ul>\n<p>使用脚手架 vite 或者 vue-cli</p>\n<h2 id=\"用于迁移的构建版本\"><a href=\"#用于迁移的构建版本\" class=\"headerlink\" title=\"用于迁移的构建版本\"></a>用于迁移的构建版本</h2><p>​        如果你打算要将一个基于 Vue 2 的项目或者库升级到 Vue 3，我们提供了一个与 Vue 2 API 兼容的 Vue 3 构建版本，详情见<a href=\"https://v3.cn.vuejs.org/guide/migration/migration-build.html\">用于迁移的构建版本</a>。</p>\n<h3 id=\"值得注意的新特性\"><a href=\"#值得注意的新特性\" class=\"headerlink\" title=\"值得注意的新特性\"></a>值得注意的新特性</h3><ul>\n<li>组合式API<ul>\n<li>使用了 setup 方法。在组件创建之前执行，一旦 props 被解析就将作为组合式API的入口。</li>\n<li><code>setup</code> 选项是一个接收 <code>props</code> 和 <code>context</code> 的函数，我们将在<a href=\"https://v3.cn.vuejs.org/guide/composition-api-setup.html#%E5%8F%82%E6%95%B0\">之后</a>进行讨论。</li>\n<li>我们将 <code>setup</code> 返回的所有内容都暴露给组件的其余部分 (计算属性、方法、生命周期钩子等等) 以及组件的模板。</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 在我们的组件内</span><br><span class=\"line\">setup (props) &#123;</span><br><span class=\"line\">  let repositories = []</span><br><span class=\"line\">  const getUserRepositories = async () =&gt; &#123;</span><br><span class=\"line\">    repositories = await fetchUserRepositories(props.user)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  return &#123;</span><br><span class=\"line\">    repositories,</span><br><span class=\"line\">    getUserRepositories // 返回的函数与方法的行为相同</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>​        但是此时的 repositories 变量是非响应式的。此时就需要使用 ref 函数使任何响应式变量在 ref 函数中起作用。</p>\n<p>带 ref 的响应式变量</p>\n<p>​        ref 接收参数并将其包裹在一个带有 value property 的对象中返回，然后可以使用该 property 访问或更改响应式变量的值：</p>\n<p>​    将值封装在对象中，看似没有必要，但是为了保持 JavaScript 中不同数据类型的行为统一，这个是必须的。为了将所有类型都变成引用传递，而不是分为了值传递和引用传递。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const counter = ref(0)</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h1 id=\"用于迁移的构建版本-1\"><a href=\"#用于迁移的构建版本-1\" class=\"headerlink\" title=\"用于迁移的构建版本\"></a>用于迁移的构建版本</h1><p>​        </p>\n<h1 id=\"细节\"><a href=\"#细节\" class=\"headerlink\" title=\"细节\"></a>细节</h1>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h1><h2 id=\"快速开始\"><a href=\"#快速开始\" class=\"headerlink\" title=\"快速开始\"></a>快速开始</h2><p>​        CDN，Codepen，CodeSandbox</p>\n<ul>\n<li>通过 CDN：<code>&lt;script src=&quot;https://unpkg.com/vue@next&quot;&gt;&lt;/script&gt;</code></li>\n<li><a href=\"https://codepen.io/yyx990803/pen/OJNoaZL\">Codepen</a> 上的浏览器内试验田</li>\n<li><a href=\"https://v3.vue.new/\">CodeSandbox</a> 上的浏览器内沙盒</li>\n</ul>\n<p>使用脚手架 vite 或者 vue-cli</p>\n<h2 id=\"用于迁移的构建版本\"><a href=\"#用于迁移的构建版本\" class=\"headerlink\" title=\"用于迁移的构建版本\"></a>用于迁移的构建版本</h2><p>​        如果你打算要将一个基于 Vue 2 的项目或者库升级到 Vue 3，我们提供了一个与 Vue 2 API 兼容的 Vue 3 构建版本，详情见<a href=\"https://v3.cn.vuejs.org/guide/migration/migration-build.html\">用于迁移的构建版本</a>。</p>\n<h3 id=\"值得注意的新特性\"><a href=\"#值得注意的新特性\" class=\"headerlink\" title=\"值得注意的新特性\"></a>值得注意的新特性</h3><ul>\n<li>组合式API<ul>\n<li>使用了 setup 方法。在组件创建之前执行，一旦 props 被解析就将作为组合式API的入口。</li>\n<li><code>setup</code> 选项是一个接收 <code>props</code> 和 <code>context</code> 的函数，我们将在<a href=\"https://v3.cn.vuejs.org/guide/composition-api-setup.html#%E5%8F%82%E6%95%B0\">之后</a>进行讨论。</li>\n<li>我们将 <code>setup</code> 返回的所有内容都暴露给组件的其余部分 (计算属性、方法、生命周期钩子等等) 以及组件的模板。</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 在我们的组件内</span><br><span class=\"line\">setup (props) &#123;</span><br><span class=\"line\">  let repositories = []</span><br><span class=\"line\">  const getUserRepositories = async () =&gt; &#123;</span><br><span class=\"line\">    repositories = await fetchUserRepositories(props.user)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  return &#123;</span><br><span class=\"line\">    repositories,</span><br><span class=\"line\">    getUserRepositories // 返回的函数与方法的行为相同</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>​        但是此时的 repositories 变量是非响应式的。此时就需要使用 ref 函数使任何响应式变量在 ref 函数中起作用。</p>\n<p>带 ref 的响应式变量</p>\n<p>​        ref 接收参数并将其包裹在一个带有 value property 的对象中返回，然后可以使用该 property 访问或更改响应式变量的值：</p>\n<p>​    将值封装在对象中，看似没有必要，但是为了保持 JavaScript 中不同数据类型的行为统一，这个是必须的。为了将所有类型都变成引用传递，而不是分为了值传递和引用传递。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const counter = ref(0)</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h1 id=\"用于迁移的构建版本-1\"><a href=\"#用于迁移的构建版本-1\" class=\"headerlink\" title=\"用于迁移的构建版本\"></a>用于迁移的构建版本</h1><p>​        </p>\n<h1 id=\"细节\"><a href=\"#细节\" class=\"headerlink\" title=\"细节\"></a>细节</h1>"},{"title":"JQuery学习","date":"2022-02-02T11:53:24.000Z","_content":"\n\n\n#  学习\n\n```\nversion: 3.6.0\n```\n\n\n\ng: 4430\n\n```\n获取标签属性里面的data自定义属性\nfunction dataAttr( elem, key, data )\n\n这里的 replace 使用的是正则表达式，搭配的 $&, 这里 $& 代表了与 regexp 相匹配的子串。\nremutiDash 是 大写字母/g，意思就是说，将大写转为 中划线然后再用 toLowerCase 转为小写。\nname = \"data-\" + key.replace( rmultiDash, \"-$&\" ).toLowerCase();\n```\n\n","source":"_drafts/JQuery/JQuery学习.md","raw":"---\ntitle: JQuery学习\ndate: 2022-02-02 19:53:24\ntags:\n - JQuery\ncategories:\n - JQuery\n---\n\n\n\n#  学习\n\n```\nversion: 3.6.0\n```\n\n\n\ng: 4430\n\n```\n获取标签属性里面的data自定义属性\nfunction dataAttr( elem, key, data )\n\n这里的 replace 使用的是正则表达式，搭配的 $&, 这里 $& 代表了与 regexp 相匹配的子串。\nremutiDash 是 大写字母/g，意思就是说，将大写转为 中划线然后再用 toLowerCase 转为小写。\nname = \"data-\" + key.replace( rmultiDash, \"-$&\" ).toLowerCase();\n```\n\n","slug":"JQuery/JQuery学习","published":0,"updated":"2022-02-07T02:21:09.154Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckznhkk74000jikub0kqgeivn","content":"<h1 id=\"学习\"><a href=\"#学习\" class=\"headerlink\" title=\"学习\"></a>学习</h1><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">version: 3.6.0</span><br></pre></td></tr></table></figure>\n\n\n\n<p>g: 4430</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">获取标签属性里面的data自定义属性</span><br><span class=\"line\">function dataAttr( elem, key, data )</span><br><span class=\"line\"></span><br><span class=\"line\">这里的 replace 使用的是正则表达式，搭配的 $&amp;, 这里 $&amp; 代表了与 regexp 相匹配的子串。</span><br><span class=\"line\">remutiDash 是 大写字母/g，意思就是说，将大写转为 中划线然后再用 toLowerCase 转为小写。</span><br><span class=\"line\">name = &quot;data-&quot; + key.replace( rmultiDash, &quot;-$&amp;&quot; ).toLowerCase();</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"学习\"><a href=\"#学习\" class=\"headerlink\" title=\"学习\"></a>学习</h1><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">version: 3.6.0</span><br></pre></td></tr></table></figure>\n\n\n\n<p>g: 4430</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">获取标签属性里面的data自定义属性</span><br><span class=\"line\">function dataAttr( elem, key, data )</span><br><span class=\"line\"></span><br><span class=\"line\">这里的 replace 使用的是正则表达式，搭配的 $&amp;, 这里 $&amp; 代表了与 regexp 相匹配的子串。</span><br><span class=\"line\">remutiDash 是 大写字母/g，意思就是说，将大写转为 中划线然后再用 toLowerCase 转为小写。</span><br><span class=\"line\">name = &quot;data-&quot; + key.replace( rmultiDash, &quot;-$&amp;&quot; ).toLowerCase();</span><br></pre></td></tr></table></figure>\n\n"},{"title":"react学习","date":"2022-02-14T11:30:54.000Z","_content":"\n\n\n# React 学习 / v17.0.2\n\n\n\n","source":"_drafts/React/react学习.md","raw":"---\ntitle: react学习\ndate: 2022-02-14 19:30:54\ntags:\n - React\ncategories:\n - React\n---\n\n\n\n# React 学习 / v17.0.2\n\n\n\n","slug":"React/react学习","published":0,"updated":"2022-02-14T11:39:25.072Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckznhkk75000nikubcnbpetgy","content":"<h1 id=\"React-学习-v17-0-2\"><a href=\"#React-学习-v17-0-2\" class=\"headerlink\" title=\"React 学习 / v17.0.2\"></a>React 学习 / v17.0.2</h1>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"React-学习-v17-0-2\"><a href=\"#React-学习-v17-0-2\" class=\"headerlink\" title=\"React 学习 / v17.0.2\"></a>React 学习 / v17.0.2</h1>"},{"title":"elementUI源码分析(一)","date":"2022-01-29T09:18:30.000Z","_content":"\n\n\n# elementUI 源码分析\n\n​\t最近想学一下如何写一个组件，所以学习一下elementUI的源码，大概有一个基本的了解。\n\n\n\n## 入口 package.json\n\n​\t主要的几个地方\n\n```\nmain，定义一个入口文件，默认值是模块根目录的index.js\nstyle，打包工具通过style知道了样式文件的打包位置\n```\n\n\n\n## src/index.js\n\n​\t我们看一下 src的index\n\n​\t其实大致的意思就是，先进行组件的引入，然后将引入的组件合并为一个数组，然后创建一个 install 方法。里面的核心就是 Vue.component 方法。最后在export 导出组件和install方法。\n\n​\tinstall方法为什么需要呢，因为在调用 Vue.use 时，如果插件是一个对象，那么就会查找里面的install方法。如果插件是一个函数，那么就会作为install方法进行调用。\n\n```\nimport xx from 'xxx'\n\nconst c = [\n\txx\n]\n\nconst install = function(Vue, opts = {}) {\n\tc.forEach(v => {\n\t\tVue.component(v.name, v)\n\t})\n}\n\nexport default {\n\tinstall,\n\t\n\txx\n}\n```\n\n这里，我个人觉得使用 对象来代替数组进行存储。可以将后续的export default 使用解构赋值来进行代替。\n\n```\nconst c = {\n\txx\n}\n\nconst install = function(Vue, opts = {}) {\n\tfor (const key in c) {\n\t\tVue.component(key, c[key])\n\t}\n}\n\nexport default {\n\tinstall,\n\t\n\t...c\n}\n```\n\n\n\n## 组件的文件格式\n\n创建一个目录，然后创建一个index.js文件作为一个入口，创建一个src文件夹作为组件的存放。\n\n```\nxx\n\tsrc\n\t\txx.vue\n\tindex.js\n```\n\n\n\n### index.js \n\n其中，index.js 才是比较重要的一个部分\n\n因为在使用 from 进行引入时，如果是一个目录，那么默认就会去查找index.js文件，当然如果配置了package.json的入口会不一样。\n\n​\tindex.js的内容，简单来说就是创建了一个install方法。\n\n```\nimport xx from '../src/xx'\n\nxx.install = function(Vue) {\n\tVue.component(xx.name, xx)\n}\n\nexport defalt xx\n```\n\n\n\n## index.scss\n\n​\t\t在 package/theme-chalk/src 里面。\n\n​\t\tcommon，里面创建一个 var.scss 里面存储了一些公用的变量。其他地方需要时要引入 var.scss\n\n​\t\t以及在一个index.scss 里面进行一个引入。\n\n​\t\t然后再看看 element ui的官网。\n\n```\nimport 'element-ui/lib/theme-chalk/index.css';\n这个里面就是存储了全局的css，然后进行一个引入。\n```\n\n​\t\t并且将icon.scss 进行了引入，然后通过全局引入index来引入的icon。\n\n​\t\t原因：\n\n* 因为 iconfont 的引入是需要使用url的引入\n\n  * ```\n    src: url('./fonts/iconfont.ttf?t=1643365814886') format('truetype');\n    ```\n\n* 同时对于引用的一个问题。那就是如果我在input目录下的index.scss 进行引入。那么对应的需要将引入的url路径进行改变，例子：url('../fonts/iconfont.ttf')\n\n  * 因为执行文件在这个目录，所以最终scss编译为css的时候会将路径引入在这里。所以会出现问题，所以Elem UI 的方法是将其在外面创建一个index.scss，然后只需要引入这个index.scss，即可。\n\n```\nfonts\n\ticonfont.ttf\ninput\n\tindex.scss\nicon.scss\nindex.scss\n```\n\n\n\n\n\n\n\n## fonts-icon\n\n```\npackage/theme-chalk/src/icon.scss\n```\n\n* 首先，这个fonts-icon 是使用的 font class 这个方法，具体的几个方法。我们可以通过去 阿里巴巴矢量图标库下载时，使用下载代码，查看demo的html来进行查看区分。\n\n* 使用 @font-face 进行初始化。这个参数需要进行了解。这个大概就是说，指定一个font-family的名称，以及指定一个url代表了可以去哪进行获取。\n  * 使用 #{$xx} 让 路径成为一个变量。\n* 然后使用类名选择器进行查找类名，将对应类名的进行初始化项目。\n* 目录构架，创建一个fonts的文件夹，用来存放 tff 和 字体的 js wtff 等文件，然后在外面创建一个icon的scss文件，用来进行使用。\n* 然后对要调用的使用类进行调用，然后类将同一进行一个css选择器进行初始化和选择。\n\n\n\n​\t\t这里我们看一下代码\n\n```\n[class^=\"el-icon-\"], [class*=\" el-icon-\"] {\t}\n```\n\n​\t\t这是element 写的选择器的选择，这两个选择器分别代表 选择从 el-icon- 开始 或者 包含了 ' el-icon-'，这里，你可能会有思考，为什么需要分开，如果我直接使用 class*=\"el-icon-\" 这个不就是包含了吗。开始我也在思考，然后我发现了。因为 *= 是包含。那么如果用户自己定义的类名是 xxel-icon- 那么也会被我们这个包含进去，所以 这个就是需要进行分开，代表了是一个独立的class。\n\n\n\n## input\n\n```\npackage/inpu\n```\n\n​\t\tElem UI 使用 input的方法是。首先，通过type进行类型的决定，并且支持 textarea 类型。\n\n​\t\t输入框包含了 前/后 置元素 和 内容。 内容就是显示在输入框里面内部的icon等。 元素就是显示在输入框前面的。和输入框紧邻的一个样式。 \n\n​\t\t同时，禁用了组件的继承，然后将属性全部赋值于input 输入框里面，方便用于进行透明化的处理。这个常用于封装组件，并且组件的核心不处于根组件的情况。\n\n```\nv-bind=\"$attrs\"\n\ninheritAttrs: false\n```\n\n​\t\t同时 Elem UI 的密码框是通过使用 show-password 进行的操作。\n\n### icon 部分\n\n​\t\t并且使用了 前置内容 和 后置内容 通过使用 prefixIcon 和 suffixIcon 来进行设置。并且在里面同时也设置了 插槽。可以使用插槽的形式来配置前置和后置 内容。\n\n```\n<slot name=\"prefix\"></slot>\n<i class=\"el-input__icon\"\n  v-if=\"prefixIcon\"\n  :class=\"prefixIcon\">\n</i>\n```\n\n​\t\t使用了 v-if 对于没有使用icon的进行了 隐藏。\n\n​\t\t如果使用了 prefixIcon 进行了图标，或者 $slots.prefix 插槽。\n\n```\nspan\n\tv-if=\"prefixIcon || $slots.prefix\"\n```\n\n### input事件部分\n\n```\n@compositionstart=\"handleCompositionStart\"\n@compositionupdate=\"handleCompositionUpdate\"\n@compositionend=\"handleCompositionEnd\"\n@input=\"handleInput\"\n@focus=\"handleFocus\"\n@blur=\"handleBlur\"\n@change=\"handleChange\"\n```\n\n**这里的问题点：** \n\n* 我们为什么不使用 $listeners 进行封装。\n\n* 我们可以知道，默认情况下，进行组件方法的监听会加载入根组件\n\n* 但是，因为组件内部的根组件不是input，所以对于监听一个原生的方法。我们使用.native。\n\n* 并且直接监听给根组件并不会被当作一个原生的监听方法。对于根组件的监听，我们就可以通过 $listeners 进行监听。\n\n* 那么我好奇，如果我 使用 v-model，然后，组件内部使用 v-bind='$attrs' v-on=\"$listeners\" 那么是不是就应该也有对应的效果啊。\n\n* 当然事实是不行，因为数据返回是一个 input event 事件。所以我看到了vue 官网是使用的 this.$emit('input', event.target.value) 然后就可以了。\n\n* 虽然这里，可以使用 v-model 了，但是，有另一个问题，那就这样写，自身的input事件会不一样。\n\n  * 首先 使用 @input=\"xxFn\" 此时的第一个参数不是event事件了，而是子组件传递过来的参数\n  * 其次，如果我们使用 focus.native 那么就会失败。但是因为input是一个可冒泡事件，所以input使用没有问题。\n\n* 同时注意，此时的$event 是子组件传递的数据了。\n\n  * ```\n    inputListeners: function () {\n      var vm = this\n      // `Object.assign` 将所有的对象合并为一个新对象\n      return Object.assign({},\n        // 我们从父级添加所有的监听器\n        this.$listeners,\n        // 然后我们添加自定义监听器，\n        // 或覆写一些监听器的行为\n        {\n          // 这里确保组件配合 `v-model` 的工作\n          input: function (event) {\n            vm.$emit('input', event.target.value)\n          },\n        }\n      )\n    }\n    \n    v-on=\"inputListeners\"\n    \n    父组件的调用\n    方法\n    @input=\"inputFn('$event', $event)\"\n    inputFn(event, e) {\n      console.log('event', event, e) // $event, value\n    },\n    ```\n\n**Elem UI input 的监听事件之 compositionstart**： \n\n通过使用 isComposing 来判断是否处于中文输入情况。对于中文的输入不会提交，不会进行验证和发送。\n\n其中我们发现在update的时候，调用了一个 isKorean 这里的方法就是里面有一个正则判断来判断你的输入是不是韩文的。\n\n```\nconst text = event.target.value;\nconst lastCharacter = text[text.length - 1] || '';\nthis.isComposing = !isKorean(lastCharacter);\n\n判断是不是韩文。\nexport function isKorean(text) {\n  const reg = /([(\\uAC00-\\uD7AF)|(\\u3130-\\u318F)])+/gi;\n  return reg.test(text);\n}\n```\n\n​\t\t同时我发现，Elem UI对于 compositionstart 事件没有进行 emit 提交。所以我这里给我的UI做了一个提交。不知道是不是应该有个什么问题。\n\n​\t\t同时，注意Elem UI input并没有对date进行封装样式，只是另写了一个组件给的date样式，内部input实则还是String。\n\n​\t\t输入框的 清除框通过v-if进行的判断显示隐藏。通过focus事件和mouseenter和mouseleave来解决 focus 和 hover 的值。\n\n输入框的 placeholder 样式使用的 scss的 mixin 和 content 进行的混入。\n\n\n\n## style sass\n\n​\t\t样式的编写。\n\n### 对于 placeholder \n\n​\t\t使用 混入 和 content 进行了 一次 封装，后续只需要混入 这个placeholder 方法就可以进行处理。当然，我发现对于input貌似不需要使用这个混入，直接使用 ::placeholder 这个方法就可以。\n\n```\n@mixin placeholder {\n  &::-webkit-input-placeholder {\n    @content\n  }\n\n  &::-moz-placeholder {\n    @content\n  }\n\n  &:-ms-input-placeholder {\n    @content\n  }\n}\n```\n\n### disabled\n\n​\t\t同时使用混入进行disabled的方法的处理。\n\n\n\n\n\n","source":"_drafts/elementUI源码/elementUI源码分析(一).md","raw":"---\ntitle: elementUI源码分析(一)\ndate: 2022-01-29 17:18:30\ntags:\n - elementUI\ncategories:\n - elementUI\n---\n\n\n\n# elementUI 源码分析\n\n​\t最近想学一下如何写一个组件，所以学习一下elementUI的源码，大概有一个基本的了解。\n\n\n\n## 入口 package.json\n\n​\t主要的几个地方\n\n```\nmain，定义一个入口文件，默认值是模块根目录的index.js\nstyle，打包工具通过style知道了样式文件的打包位置\n```\n\n\n\n## src/index.js\n\n​\t我们看一下 src的index\n\n​\t其实大致的意思就是，先进行组件的引入，然后将引入的组件合并为一个数组，然后创建一个 install 方法。里面的核心就是 Vue.component 方法。最后在export 导出组件和install方法。\n\n​\tinstall方法为什么需要呢，因为在调用 Vue.use 时，如果插件是一个对象，那么就会查找里面的install方法。如果插件是一个函数，那么就会作为install方法进行调用。\n\n```\nimport xx from 'xxx'\n\nconst c = [\n\txx\n]\n\nconst install = function(Vue, opts = {}) {\n\tc.forEach(v => {\n\t\tVue.component(v.name, v)\n\t})\n}\n\nexport default {\n\tinstall,\n\t\n\txx\n}\n```\n\n这里，我个人觉得使用 对象来代替数组进行存储。可以将后续的export default 使用解构赋值来进行代替。\n\n```\nconst c = {\n\txx\n}\n\nconst install = function(Vue, opts = {}) {\n\tfor (const key in c) {\n\t\tVue.component(key, c[key])\n\t}\n}\n\nexport default {\n\tinstall,\n\t\n\t...c\n}\n```\n\n\n\n## 组件的文件格式\n\n创建一个目录，然后创建一个index.js文件作为一个入口，创建一个src文件夹作为组件的存放。\n\n```\nxx\n\tsrc\n\t\txx.vue\n\tindex.js\n```\n\n\n\n### index.js \n\n其中，index.js 才是比较重要的一个部分\n\n因为在使用 from 进行引入时，如果是一个目录，那么默认就会去查找index.js文件，当然如果配置了package.json的入口会不一样。\n\n​\tindex.js的内容，简单来说就是创建了一个install方法。\n\n```\nimport xx from '../src/xx'\n\nxx.install = function(Vue) {\n\tVue.component(xx.name, xx)\n}\n\nexport defalt xx\n```\n\n\n\n## index.scss\n\n​\t\t在 package/theme-chalk/src 里面。\n\n​\t\tcommon，里面创建一个 var.scss 里面存储了一些公用的变量。其他地方需要时要引入 var.scss\n\n​\t\t以及在一个index.scss 里面进行一个引入。\n\n​\t\t然后再看看 element ui的官网。\n\n```\nimport 'element-ui/lib/theme-chalk/index.css';\n这个里面就是存储了全局的css，然后进行一个引入。\n```\n\n​\t\t并且将icon.scss 进行了引入，然后通过全局引入index来引入的icon。\n\n​\t\t原因：\n\n* 因为 iconfont 的引入是需要使用url的引入\n\n  * ```\n    src: url('./fonts/iconfont.ttf?t=1643365814886') format('truetype');\n    ```\n\n* 同时对于引用的一个问题。那就是如果我在input目录下的index.scss 进行引入。那么对应的需要将引入的url路径进行改变，例子：url('../fonts/iconfont.ttf')\n\n  * 因为执行文件在这个目录，所以最终scss编译为css的时候会将路径引入在这里。所以会出现问题，所以Elem UI 的方法是将其在外面创建一个index.scss，然后只需要引入这个index.scss，即可。\n\n```\nfonts\n\ticonfont.ttf\ninput\n\tindex.scss\nicon.scss\nindex.scss\n```\n\n\n\n\n\n\n\n## fonts-icon\n\n```\npackage/theme-chalk/src/icon.scss\n```\n\n* 首先，这个fonts-icon 是使用的 font class 这个方法，具体的几个方法。我们可以通过去 阿里巴巴矢量图标库下载时，使用下载代码，查看demo的html来进行查看区分。\n\n* 使用 @font-face 进行初始化。这个参数需要进行了解。这个大概就是说，指定一个font-family的名称，以及指定一个url代表了可以去哪进行获取。\n  * 使用 #{$xx} 让 路径成为一个变量。\n* 然后使用类名选择器进行查找类名，将对应类名的进行初始化项目。\n* 目录构架，创建一个fonts的文件夹，用来存放 tff 和 字体的 js wtff 等文件，然后在外面创建一个icon的scss文件，用来进行使用。\n* 然后对要调用的使用类进行调用，然后类将同一进行一个css选择器进行初始化和选择。\n\n\n\n​\t\t这里我们看一下代码\n\n```\n[class^=\"el-icon-\"], [class*=\" el-icon-\"] {\t}\n```\n\n​\t\t这是element 写的选择器的选择，这两个选择器分别代表 选择从 el-icon- 开始 或者 包含了 ' el-icon-'，这里，你可能会有思考，为什么需要分开，如果我直接使用 class*=\"el-icon-\" 这个不就是包含了吗。开始我也在思考，然后我发现了。因为 *= 是包含。那么如果用户自己定义的类名是 xxel-icon- 那么也会被我们这个包含进去，所以 这个就是需要进行分开，代表了是一个独立的class。\n\n\n\n## input\n\n```\npackage/inpu\n```\n\n​\t\tElem UI 使用 input的方法是。首先，通过type进行类型的决定，并且支持 textarea 类型。\n\n​\t\t输入框包含了 前/后 置元素 和 内容。 内容就是显示在输入框里面内部的icon等。 元素就是显示在输入框前面的。和输入框紧邻的一个样式。 \n\n​\t\t同时，禁用了组件的继承，然后将属性全部赋值于input 输入框里面，方便用于进行透明化的处理。这个常用于封装组件，并且组件的核心不处于根组件的情况。\n\n```\nv-bind=\"$attrs\"\n\ninheritAttrs: false\n```\n\n​\t\t同时 Elem UI 的密码框是通过使用 show-password 进行的操作。\n\n### icon 部分\n\n​\t\t并且使用了 前置内容 和 后置内容 通过使用 prefixIcon 和 suffixIcon 来进行设置。并且在里面同时也设置了 插槽。可以使用插槽的形式来配置前置和后置 内容。\n\n```\n<slot name=\"prefix\"></slot>\n<i class=\"el-input__icon\"\n  v-if=\"prefixIcon\"\n  :class=\"prefixIcon\">\n</i>\n```\n\n​\t\t使用了 v-if 对于没有使用icon的进行了 隐藏。\n\n​\t\t如果使用了 prefixIcon 进行了图标，或者 $slots.prefix 插槽。\n\n```\nspan\n\tv-if=\"prefixIcon || $slots.prefix\"\n```\n\n### input事件部分\n\n```\n@compositionstart=\"handleCompositionStart\"\n@compositionupdate=\"handleCompositionUpdate\"\n@compositionend=\"handleCompositionEnd\"\n@input=\"handleInput\"\n@focus=\"handleFocus\"\n@blur=\"handleBlur\"\n@change=\"handleChange\"\n```\n\n**这里的问题点：** \n\n* 我们为什么不使用 $listeners 进行封装。\n\n* 我们可以知道，默认情况下，进行组件方法的监听会加载入根组件\n\n* 但是，因为组件内部的根组件不是input，所以对于监听一个原生的方法。我们使用.native。\n\n* 并且直接监听给根组件并不会被当作一个原生的监听方法。对于根组件的监听，我们就可以通过 $listeners 进行监听。\n\n* 那么我好奇，如果我 使用 v-model，然后，组件内部使用 v-bind='$attrs' v-on=\"$listeners\" 那么是不是就应该也有对应的效果啊。\n\n* 当然事实是不行，因为数据返回是一个 input event 事件。所以我看到了vue 官网是使用的 this.$emit('input', event.target.value) 然后就可以了。\n\n* 虽然这里，可以使用 v-model 了，但是，有另一个问题，那就这样写，自身的input事件会不一样。\n\n  * 首先 使用 @input=\"xxFn\" 此时的第一个参数不是event事件了，而是子组件传递过来的参数\n  * 其次，如果我们使用 focus.native 那么就会失败。但是因为input是一个可冒泡事件，所以input使用没有问题。\n\n* 同时注意，此时的$event 是子组件传递的数据了。\n\n  * ```\n    inputListeners: function () {\n      var vm = this\n      // `Object.assign` 将所有的对象合并为一个新对象\n      return Object.assign({},\n        // 我们从父级添加所有的监听器\n        this.$listeners,\n        // 然后我们添加自定义监听器，\n        // 或覆写一些监听器的行为\n        {\n          // 这里确保组件配合 `v-model` 的工作\n          input: function (event) {\n            vm.$emit('input', event.target.value)\n          },\n        }\n      )\n    }\n    \n    v-on=\"inputListeners\"\n    \n    父组件的调用\n    方法\n    @input=\"inputFn('$event', $event)\"\n    inputFn(event, e) {\n      console.log('event', event, e) // $event, value\n    },\n    ```\n\n**Elem UI input 的监听事件之 compositionstart**： \n\n通过使用 isComposing 来判断是否处于中文输入情况。对于中文的输入不会提交，不会进行验证和发送。\n\n其中我们发现在update的时候，调用了一个 isKorean 这里的方法就是里面有一个正则判断来判断你的输入是不是韩文的。\n\n```\nconst text = event.target.value;\nconst lastCharacter = text[text.length - 1] || '';\nthis.isComposing = !isKorean(lastCharacter);\n\n判断是不是韩文。\nexport function isKorean(text) {\n  const reg = /([(\\uAC00-\\uD7AF)|(\\u3130-\\u318F)])+/gi;\n  return reg.test(text);\n}\n```\n\n​\t\t同时我发现，Elem UI对于 compositionstart 事件没有进行 emit 提交。所以我这里给我的UI做了一个提交。不知道是不是应该有个什么问题。\n\n​\t\t同时，注意Elem UI input并没有对date进行封装样式，只是另写了一个组件给的date样式，内部input实则还是String。\n\n​\t\t输入框的 清除框通过v-if进行的判断显示隐藏。通过focus事件和mouseenter和mouseleave来解决 focus 和 hover 的值。\n\n输入框的 placeholder 样式使用的 scss的 mixin 和 content 进行的混入。\n\n\n\n## style sass\n\n​\t\t样式的编写。\n\n### 对于 placeholder \n\n​\t\t使用 混入 和 content 进行了 一次 封装，后续只需要混入 这个placeholder 方法就可以进行处理。当然，我发现对于input貌似不需要使用这个混入，直接使用 ::placeholder 这个方法就可以。\n\n```\n@mixin placeholder {\n  &::-webkit-input-placeholder {\n    @content\n  }\n\n  &::-moz-placeholder {\n    @content\n  }\n\n  &:-ms-input-placeholder {\n    @content\n  }\n}\n```\n\n### disabled\n\n​\t\t同时使用混入进行disabled的方法的处理。\n\n\n\n\n\n","slug":"elementUI源码/elementUI源码分析(一)","published":0,"updated":"2022-02-08T02:12:01.025Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckznhkk76000oikub7zujgra5","content":"<h1 id=\"elementUI-源码分析\"><a href=\"#elementUI-源码分析\" class=\"headerlink\" title=\"elementUI 源码分析\"></a>elementUI 源码分析</h1><p>​    最近想学一下如何写一个组件，所以学习一下elementUI的源码，大概有一个基本的了解。</p>\n<h2 id=\"入口-package-json\"><a href=\"#入口-package-json\" class=\"headerlink\" title=\"入口 package.json\"></a>入口 package.json</h2><p>​    主要的几个地方</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">main，定义一个入口文件，默认值是模块根目录的index.js</span><br><span class=\"line\">style，打包工具通过style知道了样式文件的打包位置</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"src-index-js\"><a href=\"#src-index-js\" class=\"headerlink\" title=\"src/index.js\"></a>src/index.js</h2><p>​    我们看一下 src的index</p>\n<p>​    其实大致的意思就是，先进行组件的引入，然后将引入的组件合并为一个数组，然后创建一个 install 方法。里面的核心就是 Vue.component 方法。最后在export 导出组件和install方法。</p>\n<p>​    install方法为什么需要呢，因为在调用 Vue.use 时，如果插件是一个对象，那么就会查找里面的install方法。如果插件是一个函数，那么就会作为install方法进行调用。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import xx from &#x27;xxx&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">const c = [</span><br><span class=\"line\">\txx</span><br><span class=\"line\">]</span><br><span class=\"line\"></span><br><span class=\"line\">const install = function(Vue, opts = &#123;&#125;) &#123;</span><br><span class=\"line\">\tc.forEach(v =&gt; &#123;</span><br><span class=\"line\">\t\tVue.component(v.name, v)</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">\tinstall,</span><br><span class=\"line\">\t</span><br><span class=\"line\">\txx</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里，我个人觉得使用 对象来代替数组进行存储。可以将后续的export default 使用解构赋值来进行代替。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const c = &#123;</span><br><span class=\"line\">\txx</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const install = function(Vue, opts = &#123;&#125;) &#123;</span><br><span class=\"line\">\tfor (const key in c) &#123;</span><br><span class=\"line\">\t\tVue.component(key, c[key])</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">\tinstall,</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t...c</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"组件的文件格式\"><a href=\"#组件的文件格式\" class=\"headerlink\" title=\"组件的文件格式\"></a>组件的文件格式</h2><p>创建一个目录，然后创建一个index.js文件作为一个入口，创建一个src文件夹作为组件的存放。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xx</span><br><span class=\"line\">\tsrc</span><br><span class=\"line\">\t\txx.vue</span><br><span class=\"line\">\tindex.js</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"index-js\"><a href=\"#index-js\" class=\"headerlink\" title=\"index.js\"></a>index.js</h3><p>其中，index.js 才是比较重要的一个部分</p>\n<p>因为在使用 from 进行引入时，如果是一个目录，那么默认就会去查找index.js文件，当然如果配置了package.json的入口会不一样。</p>\n<p>​    index.js的内容，简单来说就是创建了一个install方法。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import xx from &#x27;../src/xx&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">xx.install = function(Vue) &#123;</span><br><span class=\"line\">\tVue.component(xx.name, xx)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">export defalt xx</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"index-scss\"><a href=\"#index-scss\" class=\"headerlink\" title=\"index.scss\"></a>index.scss</h2><p>​        在 package/theme-chalk/src 里面。</p>\n<p>​        common，里面创建一个 var.scss 里面存储了一些公用的变量。其他地方需要时要引入 var.scss</p>\n<p>​        以及在一个index.scss 里面进行一个引入。</p>\n<p>​        然后再看看 element ui的官网。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#x27;element-ui/lib/theme-chalk/index.css&#x27;;</span><br><span class=\"line\">这个里面就是存储了全局的css，然后进行一个引入。</span><br></pre></td></tr></table></figure>\n\n<p>​        并且将icon.scss 进行了引入，然后通过全局引入index来引入的icon。</p>\n<p>​        原因：</p>\n<ul>\n<li><p>因为 iconfont 的引入是需要使用url的引入</p>\n<ul>\n<li>```<br>src: url(‘./fonts/iconfont.ttf?t=1643365814886’) format(‘truetype’);<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">* 同时对于引用的一个问题。那就是如果我在input目录下的index.scss 进行引入。那么对应的需要将引入的url路径进行改变，例子：url(&#x27;../fonts/iconfont.ttf&#x27;)</span><br><span class=\"line\"></span><br><span class=\"line\">  * 因为执行文件在这个目录，所以最终scss编译为css的时候会将路径引入在这里。所以会出现问题，所以Elem UI 的方法是将其在外面创建一个index.scss，然后只需要引入这个index.scss，即可。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\nfonts<br>iconfont.ttf<br>input<br>index.scss<br>icon.scss<br>index.scss<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">## fonts-icon</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\npackage/theme-chalk/src/icon.scss<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">* 首先，这个fonts-icon 是使用的 font class 这个方法，具体的几个方法。我们可以通过去 阿里巴巴矢量图标库下载时，使用下载代码，查看demo的html来进行查看区分。</span><br><span class=\"line\"></span><br><span class=\"line\">* 使用 @font-face 进行初始化。这个参数需要进行了解。这个大概就是说，指定一个font-family的名称，以及指定一个url代表了可以去哪进行获取。</span><br><span class=\"line\">  * 使用 #&#123;$xx&#125; 让 路径成为一个变量。</span><br><span class=\"line\">* 然后使用类名选择器进行查找类名，将对应类名的进行初始化项目。</span><br><span class=\"line\">* 目录构架，创建一个fonts的文件夹，用来存放 tff 和 字体的 js wtff 等文件，然后在外面创建一个icon的scss文件，用来进行使用。</span><br><span class=\"line\">* 然后对要调用的使用类进行调用，然后类将同一进行一个css选择器进行初始化和选择。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t这里我们看一下代码</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n[class^=”el-icon-“], [class*=” el-icon-“] {    }<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">​\t\t这是element 写的选择器的选择，这两个选择器分别代表 选择从 el-icon- 开始 或者 包含了 &#x27; el-icon-&#x27;，这里，你可能会有思考，为什么需要分开，如果我直接使用 class*=&quot;el-icon-&quot; 这个不就是包含了吗。开始我也在思考，然后我发现了。因为 *= 是包含。那么如果用户自己定义的类名是 xxel-icon- 那么也会被我们这个包含进去，所以 这个就是需要进行分开，代表了是一个独立的class。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">## input</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\npackage/inpu<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">​\t\tElem UI 使用 input的方法是。首先，通过type进行类型的决定，并且支持 textarea 类型。</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t输入框包含了 前/后 置元素 和 内容。 内容就是显示在输入框里面内部的icon等。 元素就是显示在输入框前面的。和输入框紧邻的一个样式。 </span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t同时，禁用了组件的继承，然后将属性全部赋值于input 输入框里面，方便用于进行透明化的处理。这个常用于封装组件，并且组件的核心不处于根组件的情况。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\nv-bind=”$attrs”</li>\n</ul>\n</li>\n</ul>\n<p>inheritAttrs: false</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">​\t\t同时 Elem UI 的密码框是通过使用 show-password 进行的操作。</span><br><span class=\"line\"></span><br><span class=\"line\">### icon 部分</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t并且使用了 前置内容 和 后置内容 通过使用 prefixIcon 和 suffixIcon 来进行设置。并且在里面同时也设置了 插槽。可以使用插槽的形式来配置前置和后置 内容。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p><slot name=\"prefix\"></slot><br><i class=\"el-input__icon\" v-if=\"prefixIcon\" :class=\"prefixIcon\"><br></i></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">​\t\t使用了 v-if 对于没有使用icon的进行了 隐藏。</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t如果使用了 prefixIcon 进行了图标，或者 $slots.prefix 插槽。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>span<br>    v-if=”prefixIcon || $slots.prefix”</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">### input事件部分</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>@compositionstart=”handleCompositionStart”<br>@compositionupdate=”handleCompositionUpdate”<br>@compositionend=”handleCompositionEnd”<br>@input=”handleInput”<br>@focus=”handleFocus”<br>@blur=”handleBlur”<br>@change=”handleChange”</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">**这里的问题点：** </span><br><span class=\"line\"></span><br><span class=\"line\">* 我们为什么不使用 $listeners 进行封装。</span><br><span class=\"line\"></span><br><span class=\"line\">* 我们可以知道，默认情况下，进行组件方法的监听会加载入根组件</span><br><span class=\"line\"></span><br><span class=\"line\">* 但是，因为组件内部的根组件不是input，所以对于监听一个原生的方法。我们使用.native。</span><br><span class=\"line\"></span><br><span class=\"line\">* 并且直接监听给根组件并不会被当作一个原生的监听方法。对于根组件的监听，我们就可以通过 $listeners 进行监听。</span><br><span class=\"line\"></span><br><span class=\"line\">* 那么我好奇，如果我 使用 v-model，然后，组件内部使用 v-bind=&#x27;$attrs&#x27; v-on=&quot;$listeners&quot; 那么是不是就应该也有对应的效果啊。</span><br><span class=\"line\"></span><br><span class=\"line\">* 当然事实是不行，因为数据返回是一个 input event 事件。所以我看到了vue 官网是使用的 this.$emit(&#x27;input&#x27;, event.target.value) 然后就可以了。</span><br><span class=\"line\"></span><br><span class=\"line\">* 虽然这里，可以使用 v-model 了，但是，有另一个问题，那就这样写，自身的input事件会不一样。</span><br><span class=\"line\"></span><br><span class=\"line\">  * 首先 使用 @input=&quot;xxFn&quot; 此时的第一个参数不是event事件了，而是子组件传递过来的参数</span><br><span class=\"line\">  * 其次，如果我们使用 focus.native 那么就会失败。但是因为input是一个可冒泡事件，所以input使用没有问题。</span><br><span class=\"line\"></span><br><span class=\"line\">* 同时注意，此时的$event 是子组件传递的数据了。</span><br><span class=\"line\"></span><br><span class=\"line\">  * ```</span><br><span class=\"line\">    inputListeners: function () &#123;</span><br><span class=\"line\">      var vm = this</span><br><span class=\"line\">      // `Object.assign` 将所有的对象合并为一个新对象</span><br><span class=\"line\">      return Object.assign(&#123;&#125;,</span><br><span class=\"line\">        // 我们从父级添加所有的监听器</span><br><span class=\"line\">        this.$listeners,</span><br><span class=\"line\">        // 然后我们添加自定义监听器，</span><br><span class=\"line\">        // 或覆写一些监听器的行为</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          // 这里确保组件配合 `v-model` 的工作</span><br><span class=\"line\">          input: function (event) &#123;</span><br><span class=\"line\">            vm.$emit(&#x27;input&#x27;, event.target.value)</span><br><span class=\"line\">          &#125;,</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    v-on=&quot;inputListeners&quot;</span><br><span class=\"line\">    </span><br><span class=\"line\">    父组件的调用</span><br><span class=\"line\">    方法</span><br><span class=\"line\">    @input=&quot;inputFn(&#x27;$event&#x27;, $event)&quot;</span><br><span class=\"line\">    inputFn(event, e) &#123;</span><br><span class=\"line\">      console.log(&#x27;event&#x27;, event, e) // $event, value</span><br><span class=\"line\">    &#125;,</span><br></pre></td></tr></table></figure>\n\n<p><strong>Elem UI input 的监听事件之 compositionstart</strong>： </p>\n<p>通过使用 isComposing 来判断是否处于中文输入情况。对于中文的输入不会提交，不会进行验证和发送。</p>\n<p>其中我们发现在update的时候，调用了一个 isKorean 这里的方法就是里面有一个正则判断来判断你的输入是不是韩文的。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const text = event.target.value;</span><br><span class=\"line\">const lastCharacter = text[text.length - 1] || &#x27;&#x27;;</span><br><span class=\"line\">this.isComposing = !isKorean(lastCharacter);</span><br><span class=\"line\"></span><br><span class=\"line\">判断是不是韩文。</span><br><span class=\"line\">export function isKorean(text) &#123;</span><br><span class=\"line\">  const reg = /([(\\uAC00-\\uD7AF)|(\\u3130-\\u318F)])+/gi;</span><br><span class=\"line\">  return reg.test(text);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>​        同时我发现，Elem UI对于 compositionstart 事件没有进行 emit 提交。所以我这里给我的UI做了一个提交。不知道是不是应该有个什么问题。</p>\n<p>​        同时，注意Elem UI input并没有对date进行封装样式，只是另写了一个组件给的date样式，内部input实则还是String。</p>\n<p>​        输入框的 清除框通过v-if进行的判断显示隐藏。通过focus事件和mouseenter和mouseleave来解决 focus 和 hover 的值。</p>\n<p>输入框的 placeholder 样式使用的 scss的 mixin 和 content 进行的混入。</p>\n<h2 id=\"style-sass\"><a href=\"#style-sass\" class=\"headerlink\" title=\"style sass\"></a>style sass</h2><p>​        样式的编写。</p>\n<h3 id=\"对于-placeholder\"><a href=\"#对于-placeholder\" class=\"headerlink\" title=\"对于 placeholder\"></a>对于 placeholder</h3><p>​        使用 混入 和 content 进行了 一次 封装，后续只需要混入 这个placeholder 方法就可以进行处理。当然，我发现对于input貌似不需要使用这个混入，直接使用 ::placeholder 这个方法就可以。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@mixin placeholder &#123;</span><br><span class=\"line\">  &amp;::-webkit-input-placeholder &#123;</span><br><span class=\"line\">    @content</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  &amp;::-moz-placeholder &#123;</span><br><span class=\"line\">    @content</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  &amp;:-ms-input-placeholder &#123;</span><br><span class=\"line\">    @content</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"disabled\"><a href=\"#disabled\" class=\"headerlink\" title=\"disabled\"></a>disabled</h3><p>​        同时使用混入进行disabled的方法的处理。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"elementUI-源码分析\"><a href=\"#elementUI-源码分析\" class=\"headerlink\" title=\"elementUI 源码分析\"></a>elementUI 源码分析</h1><p>​    最近想学一下如何写一个组件，所以学习一下elementUI的源码，大概有一个基本的了解。</p>\n<h2 id=\"入口-package-json\"><a href=\"#入口-package-json\" class=\"headerlink\" title=\"入口 package.json\"></a>入口 package.json</h2><p>​    主要的几个地方</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">main，定义一个入口文件，默认值是模块根目录的index.js</span><br><span class=\"line\">style，打包工具通过style知道了样式文件的打包位置</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"src-index-js\"><a href=\"#src-index-js\" class=\"headerlink\" title=\"src/index.js\"></a>src/index.js</h2><p>​    我们看一下 src的index</p>\n<p>​    其实大致的意思就是，先进行组件的引入，然后将引入的组件合并为一个数组，然后创建一个 install 方法。里面的核心就是 Vue.component 方法。最后在export 导出组件和install方法。</p>\n<p>​    install方法为什么需要呢，因为在调用 Vue.use 时，如果插件是一个对象，那么就会查找里面的install方法。如果插件是一个函数，那么就会作为install方法进行调用。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import xx from &#x27;xxx&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">const c = [</span><br><span class=\"line\">\txx</span><br><span class=\"line\">]</span><br><span class=\"line\"></span><br><span class=\"line\">const install = function(Vue, opts = &#123;&#125;) &#123;</span><br><span class=\"line\">\tc.forEach(v =&gt; &#123;</span><br><span class=\"line\">\t\tVue.component(v.name, v)</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">\tinstall,</span><br><span class=\"line\">\t</span><br><span class=\"line\">\txx</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里，我个人觉得使用 对象来代替数组进行存储。可以将后续的export default 使用解构赋值来进行代替。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const c = &#123;</span><br><span class=\"line\">\txx</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const install = function(Vue, opts = &#123;&#125;) &#123;</span><br><span class=\"line\">\tfor (const key in c) &#123;</span><br><span class=\"line\">\t\tVue.component(key, c[key])</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">\tinstall,</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t...c</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"组件的文件格式\"><a href=\"#组件的文件格式\" class=\"headerlink\" title=\"组件的文件格式\"></a>组件的文件格式</h2><p>创建一个目录，然后创建一个index.js文件作为一个入口，创建一个src文件夹作为组件的存放。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xx</span><br><span class=\"line\">\tsrc</span><br><span class=\"line\">\t\txx.vue</span><br><span class=\"line\">\tindex.js</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"index-js\"><a href=\"#index-js\" class=\"headerlink\" title=\"index.js\"></a>index.js</h3><p>其中，index.js 才是比较重要的一个部分</p>\n<p>因为在使用 from 进行引入时，如果是一个目录，那么默认就会去查找index.js文件，当然如果配置了package.json的入口会不一样。</p>\n<p>​    index.js的内容，简单来说就是创建了一个install方法。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import xx from &#x27;../src/xx&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">xx.install = function(Vue) &#123;</span><br><span class=\"line\">\tVue.component(xx.name, xx)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">export defalt xx</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"index-scss\"><a href=\"#index-scss\" class=\"headerlink\" title=\"index.scss\"></a>index.scss</h2><p>​        在 package/theme-chalk/src 里面。</p>\n<p>​        common，里面创建一个 var.scss 里面存储了一些公用的变量。其他地方需要时要引入 var.scss</p>\n<p>​        以及在一个index.scss 里面进行一个引入。</p>\n<p>​        然后再看看 element ui的官网。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#x27;element-ui/lib/theme-chalk/index.css&#x27;;</span><br><span class=\"line\">这个里面就是存储了全局的css，然后进行一个引入。</span><br></pre></td></tr></table></figure>\n\n<p>​        并且将icon.scss 进行了引入，然后通过全局引入index来引入的icon。</p>\n<p>​        原因：</p>\n<ul>\n<li><p>因为 iconfont 的引入是需要使用url的引入</p>\n<ul>\n<li>```<br>src: url(‘./fonts/iconfont.ttf?t=1643365814886’) format(‘truetype’);<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">* 同时对于引用的一个问题。那就是如果我在input目录下的index.scss 进行引入。那么对应的需要将引入的url路径进行改变，例子：url(&#x27;../fonts/iconfont.ttf&#x27;)</span><br><span class=\"line\"></span><br><span class=\"line\">  * 因为执行文件在这个目录，所以最终scss编译为css的时候会将路径引入在这里。所以会出现问题，所以Elem UI 的方法是将其在外面创建一个index.scss，然后只需要引入这个index.scss，即可。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\nfonts<br>iconfont.ttf<br>input<br>index.scss<br>icon.scss<br>index.scss<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">## fonts-icon</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\npackage/theme-chalk/src/icon.scss<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">* 首先，这个fonts-icon 是使用的 font class 这个方法，具体的几个方法。我们可以通过去 阿里巴巴矢量图标库下载时，使用下载代码，查看demo的html来进行查看区分。</span><br><span class=\"line\"></span><br><span class=\"line\">* 使用 @font-face 进行初始化。这个参数需要进行了解。这个大概就是说，指定一个font-family的名称，以及指定一个url代表了可以去哪进行获取。</span><br><span class=\"line\">  * 使用 #&#123;$xx&#125; 让 路径成为一个变量。</span><br><span class=\"line\">* 然后使用类名选择器进行查找类名，将对应类名的进行初始化项目。</span><br><span class=\"line\">* 目录构架，创建一个fonts的文件夹，用来存放 tff 和 字体的 js wtff 等文件，然后在外面创建一个icon的scss文件，用来进行使用。</span><br><span class=\"line\">* 然后对要调用的使用类进行调用，然后类将同一进行一个css选择器进行初始化和选择。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t这里我们看一下代码</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n[class^=”el-icon-“], [class*=” el-icon-“] {    }<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">​\t\t这是element 写的选择器的选择，这两个选择器分别代表 选择从 el-icon- 开始 或者 包含了 &#x27; el-icon-&#x27;，这里，你可能会有思考，为什么需要分开，如果我直接使用 class*=&quot;el-icon-&quot; 这个不就是包含了吗。开始我也在思考，然后我发现了。因为 *= 是包含。那么如果用户自己定义的类名是 xxel-icon- 那么也会被我们这个包含进去，所以 这个就是需要进行分开，代表了是一个独立的class。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">## input</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\npackage/inpu<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">​\t\tElem UI 使用 input的方法是。首先，通过type进行类型的决定，并且支持 textarea 类型。</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t输入框包含了 前/后 置元素 和 内容。 内容就是显示在输入框里面内部的icon等。 元素就是显示在输入框前面的。和输入框紧邻的一个样式。 </span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t同时，禁用了组件的继承，然后将属性全部赋值于input 输入框里面，方便用于进行透明化的处理。这个常用于封装组件，并且组件的核心不处于根组件的情况。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\nv-bind=”$attrs”</li>\n</ul>\n</li>\n</ul>\n<p>inheritAttrs: false</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">​\t\t同时 Elem UI 的密码框是通过使用 show-password 进行的操作。</span><br><span class=\"line\"></span><br><span class=\"line\">### icon 部分</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t并且使用了 前置内容 和 后置内容 通过使用 prefixIcon 和 suffixIcon 来进行设置。并且在里面同时也设置了 插槽。可以使用插槽的形式来配置前置和后置 内容。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p><slot name=\"prefix\"></slot><br><i class=\"el-input__icon\" v-if=\"prefixIcon\" :class=\"prefixIcon\"><br></i></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">​\t\t使用了 v-if 对于没有使用icon的进行了 隐藏。</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t如果使用了 prefixIcon 进行了图标，或者 $slots.prefix 插槽。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>span<br>    v-if=”prefixIcon || $slots.prefix”</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">### input事件部分</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>@compositionstart=”handleCompositionStart”<br>@compositionupdate=”handleCompositionUpdate”<br>@compositionend=”handleCompositionEnd”<br>@input=”handleInput”<br>@focus=”handleFocus”<br>@blur=”handleBlur”<br>@change=”handleChange”</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">**这里的问题点：** </span><br><span class=\"line\"></span><br><span class=\"line\">* 我们为什么不使用 $listeners 进行封装。</span><br><span class=\"line\"></span><br><span class=\"line\">* 我们可以知道，默认情况下，进行组件方法的监听会加载入根组件</span><br><span class=\"line\"></span><br><span class=\"line\">* 但是，因为组件内部的根组件不是input，所以对于监听一个原生的方法。我们使用.native。</span><br><span class=\"line\"></span><br><span class=\"line\">* 并且直接监听给根组件并不会被当作一个原生的监听方法。对于根组件的监听，我们就可以通过 $listeners 进行监听。</span><br><span class=\"line\"></span><br><span class=\"line\">* 那么我好奇，如果我 使用 v-model，然后，组件内部使用 v-bind=&#x27;$attrs&#x27; v-on=&quot;$listeners&quot; 那么是不是就应该也有对应的效果啊。</span><br><span class=\"line\"></span><br><span class=\"line\">* 当然事实是不行，因为数据返回是一个 input event 事件。所以我看到了vue 官网是使用的 this.$emit(&#x27;input&#x27;, event.target.value) 然后就可以了。</span><br><span class=\"line\"></span><br><span class=\"line\">* 虽然这里，可以使用 v-model 了，但是，有另一个问题，那就这样写，自身的input事件会不一样。</span><br><span class=\"line\"></span><br><span class=\"line\">  * 首先 使用 @input=&quot;xxFn&quot; 此时的第一个参数不是event事件了，而是子组件传递过来的参数</span><br><span class=\"line\">  * 其次，如果我们使用 focus.native 那么就会失败。但是因为input是一个可冒泡事件，所以input使用没有问题。</span><br><span class=\"line\"></span><br><span class=\"line\">* 同时注意，此时的$event 是子组件传递的数据了。</span><br><span class=\"line\"></span><br><span class=\"line\">  * ```</span><br><span class=\"line\">    inputListeners: function () &#123;</span><br><span class=\"line\">      var vm = this</span><br><span class=\"line\">      // `Object.assign` 将所有的对象合并为一个新对象</span><br><span class=\"line\">      return Object.assign(&#123;&#125;,</span><br><span class=\"line\">        // 我们从父级添加所有的监听器</span><br><span class=\"line\">        this.$listeners,</span><br><span class=\"line\">        // 然后我们添加自定义监听器，</span><br><span class=\"line\">        // 或覆写一些监听器的行为</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          // 这里确保组件配合 `v-model` 的工作</span><br><span class=\"line\">          input: function (event) &#123;</span><br><span class=\"line\">            vm.$emit(&#x27;input&#x27;, event.target.value)</span><br><span class=\"line\">          &#125;,</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    v-on=&quot;inputListeners&quot;</span><br><span class=\"line\">    </span><br><span class=\"line\">    父组件的调用</span><br><span class=\"line\">    方法</span><br><span class=\"line\">    @input=&quot;inputFn(&#x27;$event&#x27;, $event)&quot;</span><br><span class=\"line\">    inputFn(event, e) &#123;</span><br><span class=\"line\">      console.log(&#x27;event&#x27;, event, e) // $event, value</span><br><span class=\"line\">    &#125;,</span><br></pre></td></tr></table></figure>\n\n<p><strong>Elem UI input 的监听事件之 compositionstart</strong>： </p>\n<p>通过使用 isComposing 来判断是否处于中文输入情况。对于中文的输入不会提交，不会进行验证和发送。</p>\n<p>其中我们发现在update的时候，调用了一个 isKorean 这里的方法就是里面有一个正则判断来判断你的输入是不是韩文的。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const text = event.target.value;</span><br><span class=\"line\">const lastCharacter = text[text.length - 1] || &#x27;&#x27;;</span><br><span class=\"line\">this.isComposing = !isKorean(lastCharacter);</span><br><span class=\"line\"></span><br><span class=\"line\">判断是不是韩文。</span><br><span class=\"line\">export function isKorean(text) &#123;</span><br><span class=\"line\">  const reg = /([(\\uAC00-\\uD7AF)|(\\u3130-\\u318F)])+/gi;</span><br><span class=\"line\">  return reg.test(text);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>​        同时我发现，Elem UI对于 compositionstart 事件没有进行 emit 提交。所以我这里给我的UI做了一个提交。不知道是不是应该有个什么问题。</p>\n<p>​        同时，注意Elem UI input并没有对date进行封装样式，只是另写了一个组件给的date样式，内部input实则还是String。</p>\n<p>​        输入框的 清除框通过v-if进行的判断显示隐藏。通过focus事件和mouseenter和mouseleave来解决 focus 和 hover 的值。</p>\n<p>输入框的 placeholder 样式使用的 scss的 mixin 和 content 进行的混入。</p>\n<h2 id=\"style-sass\"><a href=\"#style-sass\" class=\"headerlink\" title=\"style sass\"></a>style sass</h2><p>​        样式的编写。</p>\n<h3 id=\"对于-placeholder\"><a href=\"#对于-placeholder\" class=\"headerlink\" title=\"对于 placeholder\"></a>对于 placeholder</h3><p>​        使用 混入 和 content 进行了 一次 封装，后续只需要混入 这个placeholder 方法就可以进行处理。当然，我发现对于input貌似不需要使用这个混入，直接使用 ::placeholder 这个方法就可以。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@mixin placeholder &#123;</span><br><span class=\"line\">  &amp;::-webkit-input-placeholder &#123;</span><br><span class=\"line\">    @content</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  &amp;::-moz-placeholder &#123;</span><br><span class=\"line\">    @content</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  &amp;:-ms-input-placeholder &#123;</span><br><span class=\"line\">    @content</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"disabled\"><a href=\"#disabled\" class=\"headerlink\" title=\"disabled\"></a>disabled</h3><p>​        同时使用混入进行disabled的方法的处理。</p>\n"},{"title":"router基础","date":"2022-02-07T10:41:53.000Z","_content":"\n\n\n#  router 的基础学习\n\n## router 的基本使用\n\n### HTML\n\n```\n<!--使用 router-link 组件进行导航 -->\n<!--通过传递 `to` 来指定链接 -->\n<!--`<router-link>` 将呈现一个带有正确 `href` 属性的 `<a>` 标签-->\n<router-link to=\"/\">Go to Home</router-link>\n<router-link to=\"/about\">Go to About</router-link>\n```\n\n```\n<!-- 路由出口 -->\n<!-- 路由匹配到的组件将渲染在这里 -->\n<router-view></router-view>\n```\n\n### JavaScript\n\n```\nconst routes = [\n  { path: '/', component: Home },\n  { path: '/about', component: About },\n]\n\nconst router = VueRouter.createRouter({\n  // 4. 内部提供了 history 模式的实现。为了简单起见，我们在这里使用 hash 模式。\n  history: VueRouter.createWebHashHistory(),\n  routes, // `routes: routes` 的缩写\n})\n\napp.use(router)\n```\n\n​\t\t通过JavaScript进行调用\n\n```\nthis.$router.push('/login')\n```\n\n​\t\t请记住，`this.$router` 与直接使用通过 `createRouter` 创建的 `router` 实例完全相同。我们使用 `this.$router` 的原因是，我们不想在每个需要操作路由的组件中都导入路由。\n\n\n\n## 动态路由匹配\n\n​\t\t我们可以使用一个动态字段来进行实现，我们称之为 路径参数。\n\n```\nconst routes = [\n  // 动态字段以冒号开始\n  { path: '/users/:id', component: User },\n]\n```\n\n​\t\t现在像 `/users/johnny` 和 `/users/jolyne` 这样的 URL 都会映射到同一个路由。\n\n​\t\t它的 *params* 的值将在每个组件中以 `this.$route.params` 的形式暴露出来。\n\n```\nthis.$route.params.id\n```\n\n通过这个方式添加的参数是直接会放在url路径里面的，所以不会因为刷新而消失\n\n\n\n### 相应路由参数的变化\n\n​\t\t当用户从 `/users/johnny` 导航到 `/users/jolyne` 时，**相同的组件实例将被重复使用**。因为两个路由都渲染同个组件，比起销毁再创建，复用则显得更加高效。**不过，这也意味着组件的生命周期钩子不会被调用**。\n\n​\t\t要对同一个组件中参数的变化做出响应的话，你可以简单地 watch `$route` 对象上的任意属性，在这个场景中，就是 `$route.params ` \n\n**方法一：我们可以使用 watch 事件，对params进行监听：** \n\n```\nconst User = {\n  template: '...',\n  created() {\n    this.$watch(\n      () => this.$route.params,\n      (toParams, previousParams) => {\n        // 对路由变化做出响应...\n      }\n    )\n  },\n}\n```\n\n​\t\t我们逐行分析，首先，this.$watch 是vue的一个 vm.$watch 的方法。其实就是 watch 属性。\n\n​\t\t然后，我们得知道 this.$watch 的参数，才知道这个作用是什么。\n\n* 参数一： 是一个string类型，是一个表达式。或者是一个函数。通过判断返回值的变化来进行处理。\n* 参数二：是一个调用的方法。对应的两个参数是 oldValue 和 newValue。同时会返回一个 unwatch 的方法。调用后将取消监听。\n\n```\nvar unwatch = vm.$watch('a', cb)\n// 之后取消观察\nunwatch()\n```\n\n\n\n**方法二：使用路由守卫 beforeRouterUpdate**：\n\n```\nconst User = {\n  template: '...',\n  async beforeRouteUpdate(to, from) {\n    // 对路由变化做出响应...\n    this.userData = await fetchUser(to.params.id)\n  },\n}\n```\n\n\n\n**我们分析两个的区别**：\n\n简述区别：下面的说法很长，并且总结的可能不对：\n\n* $watch 是通过监听的方式进行的监听，所以，只要组件没有被销毁的情况下，监听就有效。所以再从监听组件跳出其他组件时会触发。\n* 路由守卫 beforeRouteUpdate 是需要在路由内部的参数变化才会触发。对于跳转去其他路由和从其他路由跳转回来都不会触发。\n\n\n\n第一个：是利用路由的复用原因，所以使用watch来监听参数的变化，通过参数的变化，来表示里面的修改。\n\n​\t\t同时使用 watch 进行监听，对于跳转去其他路由，也会进入监听的判断。\n\n​\t\t为什么跳出去的时候会进行一次判断。虽然我们可以知道，监听的是 this.$route.params。这个是一个全局且是一个唯一的对象。\n\n​\t\t就是说。在当前项目里面的params。那么就会是这一个，那么确实，监听有效是应该的。但是我们更应该思考。这个监听我们是在这个里面进行的创建，那么在这个组件被移除之后，监听也会被移除。所以按理，跳转出去之后是不会触发监听的。\n\n​\t\t结果也算是半个很像。因为在跳转出去之后的每一次都不会触发监听。但是，在跳转出去的那一次也会触发。并把目的路由也找到。\n\n​\t\t说明了路由是在destroy之前进行了判断跳转修改了。\n\n第二个：是使用的路由守卫。通过每次跳转路由时，会经过的路由守卫来判断。\n\n​\t\t通过使用路由守卫来进行判断的。跳转去其他路由，并不会触发路由守卫。\n\n​\t\t但是跳转时机 beforeRouteUpdate 会在监听之前进行输出。\n\n​\t\t那么我们就需要思考了，首先对于 before路由守卫 会在监听前进行调用执行。那么按理说。应该会和监听的输出基本一致。\n\n​\t\t但是最终就是，对于跳转出去的路由并不会触发路由守卫\n\n\n\n​\t\t同时我们通过断点调试发现。before路由守卫 执行之后，浏览器的url才会进行改变。意思就是说。watch事件的时候，浏览器的url已经发生改变了。\n\n\n\n### 捕获路由\n\n​\t\t简单来说，我们可以通过加入正则表达式来进行。\n\n```\nconst routes = [\n  // 将匹配所有内容并将其放在 `$route.params.pathMatch` 下\n  { path: '/:pathMatch(.*)*', name: 'NotFound', component: NotFound },\n  // 将匹配以 `/user-` 开头的所有内容，并将其放在 `$route.params.afterUser` 下\n  { path: '/user-:afterUser(.*)', component: UserGeneric },\n]\n```\n\n​\t\t这里使用了 正则表达式的语法。然后意思就是 :pathMatch 里面的内容要满足正则表达式，对于不满足的。那么就不会进入这个路由。\n\n​\t\t同时使用匹配的，对于 /:path 可以匹配到 /a /a/b 这种多层的嵌套。但是前提是，没有其他的path选择。\n\n​\t\trouter 使用的路径匹配算法，其灵感来自于 express\n\n\n\n## 路由的匹配语法\n\n```\n// /:orderId -> 仅匹配数字\n{ path: '/:orderId(\\\\d+)' },\n// /:productName -> 匹配其他任何内容\n{ path: '/:productName' },\n```\n\n​\t\t现在，转到 `/25` 将匹配 `/:orderId`，其他情况将会匹配 `/:productName`。`routes` 数组的顺序并不重要!\n\n> TIP\n>\n> 确保**转义反斜杠( `\\` )**，就像我们对 `\\d` (变成`\\\\d`)所做的那样，在 JavaScript 中实际传递字符串中的反斜杠字符。\n\n\n\n```\n{ path: '/:pathMatch', component: About }\n\n这样匹配将不能匹配到 / /asd/s\n因为这个正则是默认的([^/]+)，^代表了不匹配括号里面的。然后 +，代表了至少需要匹配到一个以上。所以对于上面的，不会被匹配到。\n```\n\n```\n{ path: '/:p(.*)' } \n同时我们自己也可以进行覆盖。\n```\n\n```\n{ path: '/:p*' }\n\n可以匹配到 / /as/a /sa/s\n同时我们也可以 把 p 进行正则。那么这样的话，可以多次进行匹配。注意这样生成的params是一个数组。而不是一个字符串。\n```\n\n```\nconst routes = [\n  // 仅匹配数字\n  // 匹配 /1, /1/2, 等\n  { path: '/:chapters(\\\\d+)+' },\n  // 匹配 /, /1, /1/2, 等\n  { path: '/:chapters(\\\\d+)*' },\n]\n```\n\n​\t\t同时也可以使用  **?** 来代表可选参数。当然使用 * 这个也是可选的。但是使用 ？是0或者1个，不会出现重复。\n\n\n\n​\t\t**路径的排名**\n\n```\nhttps://paths.esm.dev/?p=AAMeJSyAwR4UbFDAFxAcAGAIJXMAAA..\n```\n\n​\t\t这是一个路径的排名工具，作用的话，我认为应该是通过计算分数。路径的匹配会通过分数进行排序来匹配。\n\n\n\n## 嵌套路由\n\n​\t\t简单来说就是，router-view 是会渲染 的顶层的路由组件，但是对于组件内部也使用了路由的。我们就可以使用路由嵌套了。\n\n```\nconst routes = [\n  {\n    path: '/user/:id',\n    component: User,\n    children: [\n      {\n        // 当 /user/:id/profile 匹配成功\n        // UserProfile 将被渲染到 User 的 <router-view> 内部\n        path: 'profile',\n        component: UserProfile,\n      },\n      {\n        // 当 /user/:id/posts 匹配成功\n        // UserPosts 将被渲染到 User 的 <router-view> 内部\n        path: 'posts',\n        component: UserPosts,\n      },\n    ],\n  },\n]\n```\n\n​\t\t简单来说就是我们会对于匹配成功的子路由，然后会在 User组件里面的 router-view 进行渲染。\n\n```\nchildren: [\n    // 当 /user/:id 匹配成功\n    // UserHome 将被渲染到 User 的 <router-view> 内部\n    { path: '', component: UserHome },\n\n    // ...其他子路由\n],\n```\n\n​\t\t同时我们可以使用一个空的 path 来代表子路由的home。但是记住，空的path只是代表匹配了 /user/:id 但是对于 /user/:id/asd 虽然没有在子路由匹配成功。但是进入了子路由的，这个不会被匹配到。\n\n\n\n## 编程式导航\n\n​\t\t**在 Vue 实例中，你可以通过 `$router` 访问路由实例。因此你可以调用 `this.$router.push`。**\n\n​\t\t当你点击 `<router-link>` 时，内部会调用这个方法，所以点击\t `<router-link :to=\"...\">` 相当于调用 `router.push(...)` \n\n```\n// 字符串路径\nrouter.push('/users/eduardo')\n\n// 带有路径的对象\nrouter.push({ path: '/users/eduardo' })\n\n// 命名的路由，并加上参数，让路由建立 url\nrouter.push({ name: 'user', params: { username: 'eduardo' } })\n\n// 带查询参数，结果是 /register?plan=private\nrouter.push({ path: '/register', query: { plan: 'private' } })\n\n// 带 hash，结果是 /about#team\nrouter.push({ path: '/about', hash: '#team' })\n```\n\n​\t\t**但是注意**，如果提供了 `path`，`params` 会被忽略，上述例子中的 `query` 并不属于这种情况。\n\n```\nconst username = 'eduardo'\n// 我们可以手动建立 url，但我们必须自己处理编码\nrouter.push(`/user/${username}`) // -> /user/eduardo\n// 同样\nrouter.push({ path: `/user/${username}` }) // -> /user/eduardo\n// 如果可能的话，使用 `name` 和 `params` 从自动 URL 编码中获益\nrouter.push({ name: 'user', params: { username } }) // -> /user/eduardo\n// `params` 不能与 `path` 一起使用\nrouter.push({ path: '/user', params: { username } }) // -> /user\n```\n\n​\t\t由于属性 `to` 与 `router.push` 接受的对象种类相同，所以两者的规则完全相同。\n\n​\t\t `router.push` 和所有其他导航方法都会返回一个 *Promise*，让我们可以等到导航完成后才知道是成功还是失败。我们将在 [Navigation Handling](https://router.vuejs.org/zh/guide/advanced/navigation-failures.html) 中详细介绍。\n\n\n\n### 替换当前位置\n\n​\t\t使用 replace 来进行跳转，唯一不同的是，它在导航时不会向 history 添加新记录，正如它的名字所暗示的那样——它取代了当前的条目。\n\n```\n<router-link :to=\"...\" replace>\t\nrouter.replace(...)\n```\n\n​\t\t也可以直接在传递给 `router.push` 的 `routeLocation` 中增加一个属性 `replace: true` \n\n```\nrouter.push({ path: '/home', replace: true })\n// 相当于\nrouter.replace({ path: '/home' })\n```\n\n\n\n### 横跨历史\n\n​\t\t该方法采用一个整数作为参数，表示在历史堆栈中前进或后退多少步，类似于 `window.history.go(n)`。\n\n```\n// 向前移动一条记录，与 router.forward() 相同\nrouter.go(1) 右箭头\n\n// 返回一条记录，与router.back() 相同\nrouter.go(-1) 左箭头\n\n// 前进 3 条记录\nrouter.go(3)\n\n// 如果没有那么多记录，静默失败\nrouter.go(-100)\nrouter.go(100)\n```\n\n\n\n### 篡改历史\n\n​\t\t你可能已经注意到，`router.push`、`router.replace` 和 `router.go` 是 [`window.history.pushState`、`window.history.replaceState` 和 `window.history.go`](https://developer.mozilla.org/en-US/docs/Web/API/History) 的翻版，它们确实模仿了 `window.history` 的 API。\n\n​\t\t同时我刚刚进行了测试，发现了 pushState并没有刷新浏览器，但是更新了url，所以这就是router模仿的。对，使用history.go 以及使用 replaceState 都没有进行刷新，仅仅只是修改了url，因为这个是一个同源的方法。对于不同源的处理会出错。\n\n\n\n## 命名路由\n\n​\t\t除了 `path` 之外，你还可以为任何路由提供 `name`。这有以下优点：\n\n- 没有硬编码的 URL\n- `params` 的自动编码/解码。\n- 防止你在 url 中出现打字错误。\n- 绕过路径排序（如显示一个）\n\n\n\n```\nconst routes = [\n  {\n    path: '/user/:username',\n    name: 'user',\n    component: User\n  }\n]\n```\n\n```\n<router-link :to=\"{ name: 'user', params: { username: 'erina' }}\">\n  User\n</router-link>\n\n路由将导航到路径 `/user/erina`。\n```\n\n\n\n## 命名视图\n\n​\t\t有时候想同时 (同级) 展示多个视图，而不是嵌套展示，例如创建一个布局，有 `sidebar` (侧导航) 和 `main` (主内容) 两个视图，这个时候命名视图就派上用场了。你可以在界面中拥有多个单独命名的视图，而不是只有一个单独的出口。如果 `router-view` 没有设置名字，那么默认为 `default`。\n\n​\t\t简单来说就是，想要存在多个同级的router-view，可以使用命名视图， 默认名字为 default\n\n```\n<router-view class=\"view left-sidebar\" name=\"LeftSidebar\"></router-view>\n<router-view class=\"view main-content\"></router-view>\n<router-view class=\"view right-sidebar\" name=\"RightSidebar\"></router-view>\n```\n\n​\t\t一个视图使用一个组件渲染，因此对于同个路由，多个视图就需要多个组件。确保正确使用 `components` 配置 (带上 **s**)：\n\n```\nconst router = createRouter({\n  history: createWebHashHistory(),\n  routes: [\n    {\n      path: '/',\n      components: {\n        default: Home,\n        // LeftSidebar: LeftSidebar 的缩写\n        LeftSidebar,\n        // 它们与 `<router-view>` 上的 `name` 属性匹配\n        RightSidebar,\n      },\n    },\n  ],\n})\n```\n\n​\t\t当然也是可以不用全部路由都要渲染的。\n\n\n\n### 命名嵌套视图\n\n```\n{\n  path: '/settings',\n  // 你也可以在顶级路由就配置命名视图\n  component: UserSettings,\n  children: [{\n    path: 'emails',\n    component: UserEmailsSubscriptions\n  }, {\n    path: 'profile',\n    components: {\n      default: UserProfile,\n      helper: UserProfilePreview\n    }\n  }]\n}\n```\n\n\n\n## 重定向和别名\n\n```\n使用路由\nconst routes = [{ path: '/home', redirect: '/' }]\n\n使用命名的路由\nconst routes = [{ path: '/home', redirect: { name: 'homepage' } }]\n\n通过一个方法，返回一个重定向目标\nconst routes = [\n  {\n    // /search/screens -> /search?q=screens\n    path: '/search/:searchText',\n    redirect: to => {\n      // 方法接收目标路由作为参数\n      // return 重定向的字符串路径/路径对象\n      return { path: '/search', query: { q: to.params.searchText } }\n    },\n  },\n  {\n    path: '/search',\n    // ...\n  },\n]\n```\n\n​\t\t请注意，**[导航守卫](https://router.vuejs.org/zh/guide/advanced/navigation-guards.html)并没有应用在跳转路由上，而仅仅应用在其目标上**。在上面的例子中，在 `/home` 路由中添加 `beforeEnter` 守卫不会有任何效果。\n\n​\t\t在写 `redirect` 的时候，可以省略 `component` 配置，因为它从来没有被直接访问过，所以没有组件要渲染。唯一的例外是[嵌套路由](https://router.vuejs.org/zh/guide/essentials/nested-routes.html)：如果一个路由记录有 `children` 和 `redirect` 属性，它也应该有 `component` 属性。\n\n\n\n### 相对重定向\n\n​\t\t也可以重定向到相对位置，这里没有理解\n\n```\nconst routes = [\n  {\n    path: '/users/:id/posts',\n    redirect: to => {\n      // 方法接收目标路由作为参数\n      // return 重定向的字符串路径/路径对象\n    },\n  },\n]\n```\n\n\n\n### 别名\n\n​\t\t重定向是指当用户访问 `/home` 时，URL 会被 `/` 替换，然后匹配成 `/`。那么什么是别名呢？\n\n​\t\t **将 `/` 别名为 `/home`，意味着当用户访问 `/home` 时，URL 仍然是 `/home`，但会被匹配为用户正在访问 `/`。** \n\n​\t\t别名就是我从url输入的路径会在别名里面判断是否存在，简单来说就是我多次定义一个path不同，但是component相同等其他相同的一个意思，我们不需要这样重复编写，而是通过别名来进行处理。\n\n```\nconst routes = [{ path: '/', component: Homepage, alias: '/home' }]\n```\n\n​\t\t使别名以 `/` 开头，以使嵌套路径中的路径成为绝对路径。你甚至可以将两者结合起来，用一个数组提供多个别名：\n\n```\nconst routes = [\n  {\n    path: '/users',\n    component: UsersLayout,\n    children: [\n      // 为这 3 个 URL 呈现 UserList\n      // - /users\n      // - /users/list\n      // - /people\n      // /people 是绝对路径， list 是相对路径\n      { path: '', component: UserList, alias: ['/people', 'list'] },\n    ],\n  },\n]\n```\n\n​\t\t如果你的路由有参数，请确保在任何绝对别名中包含它们：\n\n```\nconst routes = [\n  {\n    path: '/users/:id',\n    component: UsersByIdLayout,\n    children: [\n      // 为这 3 个 URL 呈现 UserDetails\n      // - /users/24\n      // - /users/24/profile\n      // - /24\n      { path: 'profile', component: UserDetails, alias: ['/:id', ''] },\n    ],\n  },\n]\n```\n\n\n\n## 路由组件传参\n\n### 通过 props:true 传递给路由组件\n\n```\nconst User = {\n  props: ['id'],\n  template: '<div>User {{ id }}</div>'\n}\nconst routes = [{ path: '/user/:id', component: User, props: true }]\n```\n\n​\t\t那么此时，id 就会通过props传递给路由组件\n\n\n\n### 命名视图\n\n​\t\t对于有命名视图的路由，必须给props里面给每个命名视图定义配置\n\n* 如果直接使用 props: true，那么代表里面所有的都为true\n\n* 否则就需要使用对象来对每个命名视图进行处理\n\n```\nconst routes = [\n  {\n    path: '/user/:id',\n    components: { default: User, sidebar: Sidebar },\n    props: { default: true, sidebar: false }\n    // 所有的都为true\n    // props: true\n  }\n]\n```\n\n\n\n### props使用对象\n\n​\t\t当 `props` 是一个对象时，它将原样设置为组件 props。当 props 是静态的时候很有用。\n\n​\t\t就是说，使用的是对象的话，那么对象里面的内容就会作为props传递给路由组件。同时如果此时你的路由组件是携带了参数的。那么将不会传递给路由组件了。\n\n```\nconst routes = [\n  {\n    path: '/promotion/from-newsletter',\n    component: Promotion,\n    props: { newsletterPopup: false }\n  }\n]\n```\n\n\n\n### 函数模式\n\n注意：\n\n* 对于函数，参数是route\n* 返回值，如果是 Boolean 值，并不会变成 props: true 这两个并不是一个意思。所以不会起作用。\n* 返回值，常是一个对象。然后按照对象的形式来处理\n\n```\nconst routes = [\n  {\n    path: '/search',\n    component: SearchUser,\n    props: route => ({ query: route.query.q })\n  }\n]\n```\n\n\n\n## 不同的历史模式\n\n### Hash模式\n\n​\t\thash 模式是用 `createWebHashHistory()` 创建的：\n\n```\nimport { createRouter, createWebHashHistory } from 'vue-router'\n\nconst router = createRouter({\n  history: createWebHashHistory(),\n  routes: [\n    //...\n  ],\n})\n```\n\n​\t\thash模式就是通过在url后面使用一个hash字符 #。然后因为哈希字符并不会发送到服务器，所以不会出现找不到url的情况。但是对于 SEO 和 看来说，确实有点影响。\n\n\n\n### HTML5模式，history模式\n\n​\t\t用 `createWebHistory()` 创建 HTML5 模式，推荐使用这个模式：\n\n```\nimport { createRouter, createWebHistory } from 'vue-router'\n\nconst router = createRouter({\n  history: createWebHistory(),\n  routes: [\n    //...\n  ],\n})\n```\n\n​\t\t当使用这种历史模式时，URL 会看起来很 \"正常\"，例如 `https://example.com/user/id`。漂亮!\n\n​\t\t不过，问题来了。由于我们的应用是一个单页的客户端应用，如果没有适当的服务器配置，用户在浏览器中直接访问 `https://example.com/user/id`，就会得到一个 404 错误。这就丑了。\n\n​\t\t不用担心：要解决这个问题，你需要做的就是在你的服务器上添加一个简单的回退路由。如果 URL 不匹配任何静态资源，它应提供与你的应用程序中的 `index.html` 相同的页面。漂亮依旧!\n\n\n\n​\t\t简单来说就是，因为history模式的 url 是不带hash，所以我们知道从一个浏览器里面输入一个正常的url，他会找到对应的服务器并发送请求，那么类似于这种的： https://example.com/usre/id 他就会先进入对应的。\n\n\n\n### 服务器配置实例\n\n​\t\t**注意**：以下示例假定你正在从根目录提供服务。如果你部署到子目录，你应该使用[Vue CLI 的 `publicPath` 配置](https://cli.vuejs.org/config/#publicpath)和相关的[路由器的 `base` 属性](https://router.vuejs.org/zh/api/#createwebhistory)。你还需要调整下面的例子，以使用子目录而不是根目录（例如，将`RewriteBase/` 替换为 `RewriteBase/name-of-your-subfolder/`）。\n\n\n\n#### Apache\n\n​\t\t没有学过，可以说是完全看不懂了。\n\n​\t\t也可以使用 [`FallbackResource`](https://httpd.apache.org/docs/2.2/mod/mod_dir.html#fallbackresource) 代替 `mod_rewrite`。\n\n```\n<IfModule mod_rewrite.c>\n  RewriteEngine On\n  RewriteBase /\n  RewriteRule ^index\\.html$ - [L]\n  RewriteCond %{REQUEST_FILENAME} !-f\n  RewriteCond %{REQUEST_FILENAME} !-d\n  RewriteRule . /index.html [L]\n</IfModule>\n```\n\n\n\n#### nginx\n\n​\t\t实不相瞒，nginx，我也没有学过。。\n\n```\nlocation / {\n  try_files $uri $uri/ /index.html;\n}\n```\n\n\n\n#### 原生 Node.js\n\n​\t\t简单来说，就是先建立监听。\n\n​\t\t然后使用 createServer，这个方法就会将所有的请求都会进行处理了。无论是什么请求，都会进行一个处理。那么我们思考这个算是一个拦截吗，因为既然什么请求都可以进行处理。那么就可以先做一个请求的拦截。当然，这样写符不符合规范不清楚。但是确实做拦截应该是可以的。\n\n​\t\t这里的内容就是，收到请求，然后将index文件里的内容进行读取，然后再通过写响应头，并将内容进行返回。\n\n```\nconst http = require('http')\nconst fs = require('fs')\nconst httpPort = 80\n\nhttp\n  .createServer((req, res) => {\n    fs.readFile('index.html', 'utf-8', (err, content) => {\n      if (err) {\n        console.log('We cannot open \"index.html\" file.')\n      }\n\n      res.writeHead(200, {\n        'Content-Type': 'text/html; charset=utf-8',\n      })\n\n      res.end(content)\n    })\n  })\n  .listen(httpPort, () => {\n    console.log('Server listening on: http://localhost:%s', httpPort)\n  })\n```\n\n\n\n#### Express + Node.js\n\n​\t\t对于 Node.js/Express，可以考虑使用 [connect-history-api-fallback 中间件](https://github.com/bripkens/connect-history-api-fallback)。\n\n\n\n后续还有很多其他的，但是因为其他的我连名字都没有听过了，所以就不写了，直接上官网链接。\n\n```\nhttps://router.vuejs.org/zh/guide/essentials/history-mode.html\n```\n\n\n\n### caveat\n\n​\t\t这有一个注意事项。你的服务器将不再报告 404 错误，因为现在所有未找到的路径都会显示你的 `index.html` 文件。为了解决这个问题，你应该在你的 Vue 应用程序中实现一个万能的路由来显示 404 页面。\n\n```\nconst router = createRouter({\n  history: createWebHistory(),\n  routes: [{ path: '/:pathMatch(.*)', component: NotFoundComponent }],\n})\n```\n\n​\t\t另外，如果你使用的是 Node.js 服务器，你可以通过在服务器端使用路由器来匹配传入的 URL，如果没有匹配到路由，则用 404 来响应，从而实现回退。查看 [Vue 服务器端渲染文档](https://v3.cn.vuejs.org/guide/ssr/introduction.html#what-is-server-side-rendering-ssr)了解更多信息。\n\n​\t\t这里，为什么使用 /:pathMatch(.*) 来匹配404呢，那是因为，这里路由的选择是一个按照分级来排名的。而这个写法的分数只有20分，基本可以说是，只有其他都匹配不上了，才会匹配上这个。\n\n​\t\t所以常用这个来匹配404路由。\n\n","source":"_drafts/router/router基础.md","raw":"---\ntitle: router基础\ndate: 2022-02-07 18:41:53\ntags:\n - router\ncategories:\n - router\n---\n\n\n\n#  router 的基础学习\n\n## router 的基本使用\n\n### HTML\n\n```\n<!--使用 router-link 组件进行导航 -->\n<!--通过传递 `to` 来指定链接 -->\n<!--`<router-link>` 将呈现一个带有正确 `href` 属性的 `<a>` 标签-->\n<router-link to=\"/\">Go to Home</router-link>\n<router-link to=\"/about\">Go to About</router-link>\n```\n\n```\n<!-- 路由出口 -->\n<!-- 路由匹配到的组件将渲染在这里 -->\n<router-view></router-view>\n```\n\n### JavaScript\n\n```\nconst routes = [\n  { path: '/', component: Home },\n  { path: '/about', component: About },\n]\n\nconst router = VueRouter.createRouter({\n  // 4. 内部提供了 history 模式的实现。为了简单起见，我们在这里使用 hash 模式。\n  history: VueRouter.createWebHashHistory(),\n  routes, // `routes: routes` 的缩写\n})\n\napp.use(router)\n```\n\n​\t\t通过JavaScript进行调用\n\n```\nthis.$router.push('/login')\n```\n\n​\t\t请记住，`this.$router` 与直接使用通过 `createRouter` 创建的 `router` 实例完全相同。我们使用 `this.$router` 的原因是，我们不想在每个需要操作路由的组件中都导入路由。\n\n\n\n## 动态路由匹配\n\n​\t\t我们可以使用一个动态字段来进行实现，我们称之为 路径参数。\n\n```\nconst routes = [\n  // 动态字段以冒号开始\n  { path: '/users/:id', component: User },\n]\n```\n\n​\t\t现在像 `/users/johnny` 和 `/users/jolyne` 这样的 URL 都会映射到同一个路由。\n\n​\t\t它的 *params* 的值将在每个组件中以 `this.$route.params` 的形式暴露出来。\n\n```\nthis.$route.params.id\n```\n\n通过这个方式添加的参数是直接会放在url路径里面的，所以不会因为刷新而消失\n\n\n\n### 相应路由参数的变化\n\n​\t\t当用户从 `/users/johnny` 导航到 `/users/jolyne` 时，**相同的组件实例将被重复使用**。因为两个路由都渲染同个组件，比起销毁再创建，复用则显得更加高效。**不过，这也意味着组件的生命周期钩子不会被调用**。\n\n​\t\t要对同一个组件中参数的变化做出响应的话，你可以简单地 watch `$route` 对象上的任意属性，在这个场景中，就是 `$route.params ` \n\n**方法一：我们可以使用 watch 事件，对params进行监听：** \n\n```\nconst User = {\n  template: '...',\n  created() {\n    this.$watch(\n      () => this.$route.params,\n      (toParams, previousParams) => {\n        // 对路由变化做出响应...\n      }\n    )\n  },\n}\n```\n\n​\t\t我们逐行分析，首先，this.$watch 是vue的一个 vm.$watch 的方法。其实就是 watch 属性。\n\n​\t\t然后，我们得知道 this.$watch 的参数，才知道这个作用是什么。\n\n* 参数一： 是一个string类型，是一个表达式。或者是一个函数。通过判断返回值的变化来进行处理。\n* 参数二：是一个调用的方法。对应的两个参数是 oldValue 和 newValue。同时会返回一个 unwatch 的方法。调用后将取消监听。\n\n```\nvar unwatch = vm.$watch('a', cb)\n// 之后取消观察\nunwatch()\n```\n\n\n\n**方法二：使用路由守卫 beforeRouterUpdate**：\n\n```\nconst User = {\n  template: '...',\n  async beforeRouteUpdate(to, from) {\n    // 对路由变化做出响应...\n    this.userData = await fetchUser(to.params.id)\n  },\n}\n```\n\n\n\n**我们分析两个的区别**：\n\n简述区别：下面的说法很长，并且总结的可能不对：\n\n* $watch 是通过监听的方式进行的监听，所以，只要组件没有被销毁的情况下，监听就有效。所以再从监听组件跳出其他组件时会触发。\n* 路由守卫 beforeRouteUpdate 是需要在路由内部的参数变化才会触发。对于跳转去其他路由和从其他路由跳转回来都不会触发。\n\n\n\n第一个：是利用路由的复用原因，所以使用watch来监听参数的变化，通过参数的变化，来表示里面的修改。\n\n​\t\t同时使用 watch 进行监听，对于跳转去其他路由，也会进入监听的判断。\n\n​\t\t为什么跳出去的时候会进行一次判断。虽然我们可以知道，监听的是 this.$route.params。这个是一个全局且是一个唯一的对象。\n\n​\t\t就是说。在当前项目里面的params。那么就会是这一个，那么确实，监听有效是应该的。但是我们更应该思考。这个监听我们是在这个里面进行的创建，那么在这个组件被移除之后，监听也会被移除。所以按理，跳转出去之后是不会触发监听的。\n\n​\t\t结果也算是半个很像。因为在跳转出去之后的每一次都不会触发监听。但是，在跳转出去的那一次也会触发。并把目的路由也找到。\n\n​\t\t说明了路由是在destroy之前进行了判断跳转修改了。\n\n第二个：是使用的路由守卫。通过每次跳转路由时，会经过的路由守卫来判断。\n\n​\t\t通过使用路由守卫来进行判断的。跳转去其他路由，并不会触发路由守卫。\n\n​\t\t但是跳转时机 beforeRouteUpdate 会在监听之前进行输出。\n\n​\t\t那么我们就需要思考了，首先对于 before路由守卫 会在监听前进行调用执行。那么按理说。应该会和监听的输出基本一致。\n\n​\t\t但是最终就是，对于跳转出去的路由并不会触发路由守卫\n\n\n\n​\t\t同时我们通过断点调试发现。before路由守卫 执行之后，浏览器的url才会进行改变。意思就是说。watch事件的时候，浏览器的url已经发生改变了。\n\n\n\n### 捕获路由\n\n​\t\t简单来说，我们可以通过加入正则表达式来进行。\n\n```\nconst routes = [\n  // 将匹配所有内容并将其放在 `$route.params.pathMatch` 下\n  { path: '/:pathMatch(.*)*', name: 'NotFound', component: NotFound },\n  // 将匹配以 `/user-` 开头的所有内容，并将其放在 `$route.params.afterUser` 下\n  { path: '/user-:afterUser(.*)', component: UserGeneric },\n]\n```\n\n​\t\t这里使用了 正则表达式的语法。然后意思就是 :pathMatch 里面的内容要满足正则表达式，对于不满足的。那么就不会进入这个路由。\n\n​\t\t同时使用匹配的，对于 /:path 可以匹配到 /a /a/b 这种多层的嵌套。但是前提是，没有其他的path选择。\n\n​\t\trouter 使用的路径匹配算法，其灵感来自于 express\n\n\n\n## 路由的匹配语法\n\n```\n// /:orderId -> 仅匹配数字\n{ path: '/:orderId(\\\\d+)' },\n// /:productName -> 匹配其他任何内容\n{ path: '/:productName' },\n```\n\n​\t\t现在，转到 `/25` 将匹配 `/:orderId`，其他情况将会匹配 `/:productName`。`routes` 数组的顺序并不重要!\n\n> TIP\n>\n> 确保**转义反斜杠( `\\` )**，就像我们对 `\\d` (变成`\\\\d`)所做的那样，在 JavaScript 中实际传递字符串中的反斜杠字符。\n\n\n\n```\n{ path: '/:pathMatch', component: About }\n\n这样匹配将不能匹配到 / /asd/s\n因为这个正则是默认的([^/]+)，^代表了不匹配括号里面的。然后 +，代表了至少需要匹配到一个以上。所以对于上面的，不会被匹配到。\n```\n\n```\n{ path: '/:p(.*)' } \n同时我们自己也可以进行覆盖。\n```\n\n```\n{ path: '/:p*' }\n\n可以匹配到 / /as/a /sa/s\n同时我们也可以 把 p 进行正则。那么这样的话，可以多次进行匹配。注意这样生成的params是一个数组。而不是一个字符串。\n```\n\n```\nconst routes = [\n  // 仅匹配数字\n  // 匹配 /1, /1/2, 等\n  { path: '/:chapters(\\\\d+)+' },\n  // 匹配 /, /1, /1/2, 等\n  { path: '/:chapters(\\\\d+)*' },\n]\n```\n\n​\t\t同时也可以使用  **?** 来代表可选参数。当然使用 * 这个也是可选的。但是使用 ？是0或者1个，不会出现重复。\n\n\n\n​\t\t**路径的排名**\n\n```\nhttps://paths.esm.dev/?p=AAMeJSyAwR4UbFDAFxAcAGAIJXMAAA..\n```\n\n​\t\t这是一个路径的排名工具，作用的话，我认为应该是通过计算分数。路径的匹配会通过分数进行排序来匹配。\n\n\n\n## 嵌套路由\n\n​\t\t简单来说就是，router-view 是会渲染 的顶层的路由组件，但是对于组件内部也使用了路由的。我们就可以使用路由嵌套了。\n\n```\nconst routes = [\n  {\n    path: '/user/:id',\n    component: User,\n    children: [\n      {\n        // 当 /user/:id/profile 匹配成功\n        // UserProfile 将被渲染到 User 的 <router-view> 内部\n        path: 'profile',\n        component: UserProfile,\n      },\n      {\n        // 当 /user/:id/posts 匹配成功\n        // UserPosts 将被渲染到 User 的 <router-view> 内部\n        path: 'posts',\n        component: UserPosts,\n      },\n    ],\n  },\n]\n```\n\n​\t\t简单来说就是我们会对于匹配成功的子路由，然后会在 User组件里面的 router-view 进行渲染。\n\n```\nchildren: [\n    // 当 /user/:id 匹配成功\n    // UserHome 将被渲染到 User 的 <router-view> 内部\n    { path: '', component: UserHome },\n\n    // ...其他子路由\n],\n```\n\n​\t\t同时我们可以使用一个空的 path 来代表子路由的home。但是记住，空的path只是代表匹配了 /user/:id 但是对于 /user/:id/asd 虽然没有在子路由匹配成功。但是进入了子路由的，这个不会被匹配到。\n\n\n\n## 编程式导航\n\n​\t\t**在 Vue 实例中，你可以通过 `$router` 访问路由实例。因此你可以调用 `this.$router.push`。**\n\n​\t\t当你点击 `<router-link>` 时，内部会调用这个方法，所以点击\t `<router-link :to=\"...\">` 相当于调用 `router.push(...)` \n\n```\n// 字符串路径\nrouter.push('/users/eduardo')\n\n// 带有路径的对象\nrouter.push({ path: '/users/eduardo' })\n\n// 命名的路由，并加上参数，让路由建立 url\nrouter.push({ name: 'user', params: { username: 'eduardo' } })\n\n// 带查询参数，结果是 /register?plan=private\nrouter.push({ path: '/register', query: { plan: 'private' } })\n\n// 带 hash，结果是 /about#team\nrouter.push({ path: '/about', hash: '#team' })\n```\n\n​\t\t**但是注意**，如果提供了 `path`，`params` 会被忽略，上述例子中的 `query` 并不属于这种情况。\n\n```\nconst username = 'eduardo'\n// 我们可以手动建立 url，但我们必须自己处理编码\nrouter.push(`/user/${username}`) // -> /user/eduardo\n// 同样\nrouter.push({ path: `/user/${username}` }) // -> /user/eduardo\n// 如果可能的话，使用 `name` 和 `params` 从自动 URL 编码中获益\nrouter.push({ name: 'user', params: { username } }) // -> /user/eduardo\n// `params` 不能与 `path` 一起使用\nrouter.push({ path: '/user', params: { username } }) // -> /user\n```\n\n​\t\t由于属性 `to` 与 `router.push` 接受的对象种类相同，所以两者的规则完全相同。\n\n​\t\t `router.push` 和所有其他导航方法都会返回一个 *Promise*，让我们可以等到导航完成后才知道是成功还是失败。我们将在 [Navigation Handling](https://router.vuejs.org/zh/guide/advanced/navigation-failures.html) 中详细介绍。\n\n\n\n### 替换当前位置\n\n​\t\t使用 replace 来进行跳转，唯一不同的是，它在导航时不会向 history 添加新记录，正如它的名字所暗示的那样——它取代了当前的条目。\n\n```\n<router-link :to=\"...\" replace>\t\nrouter.replace(...)\n```\n\n​\t\t也可以直接在传递给 `router.push` 的 `routeLocation` 中增加一个属性 `replace: true` \n\n```\nrouter.push({ path: '/home', replace: true })\n// 相当于\nrouter.replace({ path: '/home' })\n```\n\n\n\n### 横跨历史\n\n​\t\t该方法采用一个整数作为参数，表示在历史堆栈中前进或后退多少步，类似于 `window.history.go(n)`。\n\n```\n// 向前移动一条记录，与 router.forward() 相同\nrouter.go(1) 右箭头\n\n// 返回一条记录，与router.back() 相同\nrouter.go(-1) 左箭头\n\n// 前进 3 条记录\nrouter.go(3)\n\n// 如果没有那么多记录，静默失败\nrouter.go(-100)\nrouter.go(100)\n```\n\n\n\n### 篡改历史\n\n​\t\t你可能已经注意到，`router.push`、`router.replace` 和 `router.go` 是 [`window.history.pushState`、`window.history.replaceState` 和 `window.history.go`](https://developer.mozilla.org/en-US/docs/Web/API/History) 的翻版，它们确实模仿了 `window.history` 的 API。\n\n​\t\t同时我刚刚进行了测试，发现了 pushState并没有刷新浏览器，但是更新了url，所以这就是router模仿的。对，使用history.go 以及使用 replaceState 都没有进行刷新，仅仅只是修改了url，因为这个是一个同源的方法。对于不同源的处理会出错。\n\n\n\n## 命名路由\n\n​\t\t除了 `path` 之外，你还可以为任何路由提供 `name`。这有以下优点：\n\n- 没有硬编码的 URL\n- `params` 的自动编码/解码。\n- 防止你在 url 中出现打字错误。\n- 绕过路径排序（如显示一个）\n\n\n\n```\nconst routes = [\n  {\n    path: '/user/:username',\n    name: 'user',\n    component: User\n  }\n]\n```\n\n```\n<router-link :to=\"{ name: 'user', params: { username: 'erina' }}\">\n  User\n</router-link>\n\n路由将导航到路径 `/user/erina`。\n```\n\n\n\n## 命名视图\n\n​\t\t有时候想同时 (同级) 展示多个视图，而不是嵌套展示，例如创建一个布局，有 `sidebar` (侧导航) 和 `main` (主内容) 两个视图，这个时候命名视图就派上用场了。你可以在界面中拥有多个单独命名的视图，而不是只有一个单独的出口。如果 `router-view` 没有设置名字，那么默认为 `default`。\n\n​\t\t简单来说就是，想要存在多个同级的router-view，可以使用命名视图， 默认名字为 default\n\n```\n<router-view class=\"view left-sidebar\" name=\"LeftSidebar\"></router-view>\n<router-view class=\"view main-content\"></router-view>\n<router-view class=\"view right-sidebar\" name=\"RightSidebar\"></router-view>\n```\n\n​\t\t一个视图使用一个组件渲染，因此对于同个路由，多个视图就需要多个组件。确保正确使用 `components` 配置 (带上 **s**)：\n\n```\nconst router = createRouter({\n  history: createWebHashHistory(),\n  routes: [\n    {\n      path: '/',\n      components: {\n        default: Home,\n        // LeftSidebar: LeftSidebar 的缩写\n        LeftSidebar,\n        // 它们与 `<router-view>` 上的 `name` 属性匹配\n        RightSidebar,\n      },\n    },\n  ],\n})\n```\n\n​\t\t当然也是可以不用全部路由都要渲染的。\n\n\n\n### 命名嵌套视图\n\n```\n{\n  path: '/settings',\n  // 你也可以在顶级路由就配置命名视图\n  component: UserSettings,\n  children: [{\n    path: 'emails',\n    component: UserEmailsSubscriptions\n  }, {\n    path: 'profile',\n    components: {\n      default: UserProfile,\n      helper: UserProfilePreview\n    }\n  }]\n}\n```\n\n\n\n## 重定向和别名\n\n```\n使用路由\nconst routes = [{ path: '/home', redirect: '/' }]\n\n使用命名的路由\nconst routes = [{ path: '/home', redirect: { name: 'homepage' } }]\n\n通过一个方法，返回一个重定向目标\nconst routes = [\n  {\n    // /search/screens -> /search?q=screens\n    path: '/search/:searchText',\n    redirect: to => {\n      // 方法接收目标路由作为参数\n      // return 重定向的字符串路径/路径对象\n      return { path: '/search', query: { q: to.params.searchText } }\n    },\n  },\n  {\n    path: '/search',\n    // ...\n  },\n]\n```\n\n​\t\t请注意，**[导航守卫](https://router.vuejs.org/zh/guide/advanced/navigation-guards.html)并没有应用在跳转路由上，而仅仅应用在其目标上**。在上面的例子中，在 `/home` 路由中添加 `beforeEnter` 守卫不会有任何效果。\n\n​\t\t在写 `redirect` 的时候，可以省略 `component` 配置，因为它从来没有被直接访问过，所以没有组件要渲染。唯一的例外是[嵌套路由](https://router.vuejs.org/zh/guide/essentials/nested-routes.html)：如果一个路由记录有 `children` 和 `redirect` 属性，它也应该有 `component` 属性。\n\n\n\n### 相对重定向\n\n​\t\t也可以重定向到相对位置，这里没有理解\n\n```\nconst routes = [\n  {\n    path: '/users/:id/posts',\n    redirect: to => {\n      // 方法接收目标路由作为参数\n      // return 重定向的字符串路径/路径对象\n    },\n  },\n]\n```\n\n\n\n### 别名\n\n​\t\t重定向是指当用户访问 `/home` 时，URL 会被 `/` 替换，然后匹配成 `/`。那么什么是别名呢？\n\n​\t\t **将 `/` 别名为 `/home`，意味着当用户访问 `/home` 时，URL 仍然是 `/home`，但会被匹配为用户正在访问 `/`。** \n\n​\t\t别名就是我从url输入的路径会在别名里面判断是否存在，简单来说就是我多次定义一个path不同，但是component相同等其他相同的一个意思，我们不需要这样重复编写，而是通过别名来进行处理。\n\n```\nconst routes = [{ path: '/', component: Homepage, alias: '/home' }]\n```\n\n​\t\t使别名以 `/` 开头，以使嵌套路径中的路径成为绝对路径。你甚至可以将两者结合起来，用一个数组提供多个别名：\n\n```\nconst routes = [\n  {\n    path: '/users',\n    component: UsersLayout,\n    children: [\n      // 为这 3 个 URL 呈现 UserList\n      // - /users\n      // - /users/list\n      // - /people\n      // /people 是绝对路径， list 是相对路径\n      { path: '', component: UserList, alias: ['/people', 'list'] },\n    ],\n  },\n]\n```\n\n​\t\t如果你的路由有参数，请确保在任何绝对别名中包含它们：\n\n```\nconst routes = [\n  {\n    path: '/users/:id',\n    component: UsersByIdLayout,\n    children: [\n      // 为这 3 个 URL 呈现 UserDetails\n      // - /users/24\n      // - /users/24/profile\n      // - /24\n      { path: 'profile', component: UserDetails, alias: ['/:id', ''] },\n    ],\n  },\n]\n```\n\n\n\n## 路由组件传参\n\n### 通过 props:true 传递给路由组件\n\n```\nconst User = {\n  props: ['id'],\n  template: '<div>User {{ id }}</div>'\n}\nconst routes = [{ path: '/user/:id', component: User, props: true }]\n```\n\n​\t\t那么此时，id 就会通过props传递给路由组件\n\n\n\n### 命名视图\n\n​\t\t对于有命名视图的路由，必须给props里面给每个命名视图定义配置\n\n* 如果直接使用 props: true，那么代表里面所有的都为true\n\n* 否则就需要使用对象来对每个命名视图进行处理\n\n```\nconst routes = [\n  {\n    path: '/user/:id',\n    components: { default: User, sidebar: Sidebar },\n    props: { default: true, sidebar: false }\n    // 所有的都为true\n    // props: true\n  }\n]\n```\n\n\n\n### props使用对象\n\n​\t\t当 `props` 是一个对象时，它将原样设置为组件 props。当 props 是静态的时候很有用。\n\n​\t\t就是说，使用的是对象的话，那么对象里面的内容就会作为props传递给路由组件。同时如果此时你的路由组件是携带了参数的。那么将不会传递给路由组件了。\n\n```\nconst routes = [\n  {\n    path: '/promotion/from-newsletter',\n    component: Promotion,\n    props: { newsletterPopup: false }\n  }\n]\n```\n\n\n\n### 函数模式\n\n注意：\n\n* 对于函数，参数是route\n* 返回值，如果是 Boolean 值，并不会变成 props: true 这两个并不是一个意思。所以不会起作用。\n* 返回值，常是一个对象。然后按照对象的形式来处理\n\n```\nconst routes = [\n  {\n    path: '/search',\n    component: SearchUser,\n    props: route => ({ query: route.query.q })\n  }\n]\n```\n\n\n\n## 不同的历史模式\n\n### Hash模式\n\n​\t\thash 模式是用 `createWebHashHistory()` 创建的：\n\n```\nimport { createRouter, createWebHashHistory } from 'vue-router'\n\nconst router = createRouter({\n  history: createWebHashHistory(),\n  routes: [\n    //...\n  ],\n})\n```\n\n​\t\thash模式就是通过在url后面使用一个hash字符 #。然后因为哈希字符并不会发送到服务器，所以不会出现找不到url的情况。但是对于 SEO 和 看来说，确实有点影响。\n\n\n\n### HTML5模式，history模式\n\n​\t\t用 `createWebHistory()` 创建 HTML5 模式，推荐使用这个模式：\n\n```\nimport { createRouter, createWebHistory } from 'vue-router'\n\nconst router = createRouter({\n  history: createWebHistory(),\n  routes: [\n    //...\n  ],\n})\n```\n\n​\t\t当使用这种历史模式时，URL 会看起来很 \"正常\"，例如 `https://example.com/user/id`。漂亮!\n\n​\t\t不过，问题来了。由于我们的应用是一个单页的客户端应用，如果没有适当的服务器配置，用户在浏览器中直接访问 `https://example.com/user/id`，就会得到一个 404 错误。这就丑了。\n\n​\t\t不用担心：要解决这个问题，你需要做的就是在你的服务器上添加一个简单的回退路由。如果 URL 不匹配任何静态资源，它应提供与你的应用程序中的 `index.html` 相同的页面。漂亮依旧!\n\n\n\n​\t\t简单来说就是，因为history模式的 url 是不带hash，所以我们知道从一个浏览器里面输入一个正常的url，他会找到对应的服务器并发送请求，那么类似于这种的： https://example.com/usre/id 他就会先进入对应的。\n\n\n\n### 服务器配置实例\n\n​\t\t**注意**：以下示例假定你正在从根目录提供服务。如果你部署到子目录，你应该使用[Vue CLI 的 `publicPath` 配置](https://cli.vuejs.org/config/#publicpath)和相关的[路由器的 `base` 属性](https://router.vuejs.org/zh/api/#createwebhistory)。你还需要调整下面的例子，以使用子目录而不是根目录（例如，将`RewriteBase/` 替换为 `RewriteBase/name-of-your-subfolder/`）。\n\n\n\n#### Apache\n\n​\t\t没有学过，可以说是完全看不懂了。\n\n​\t\t也可以使用 [`FallbackResource`](https://httpd.apache.org/docs/2.2/mod/mod_dir.html#fallbackresource) 代替 `mod_rewrite`。\n\n```\n<IfModule mod_rewrite.c>\n  RewriteEngine On\n  RewriteBase /\n  RewriteRule ^index\\.html$ - [L]\n  RewriteCond %{REQUEST_FILENAME} !-f\n  RewriteCond %{REQUEST_FILENAME} !-d\n  RewriteRule . /index.html [L]\n</IfModule>\n```\n\n\n\n#### nginx\n\n​\t\t实不相瞒，nginx，我也没有学过。。\n\n```\nlocation / {\n  try_files $uri $uri/ /index.html;\n}\n```\n\n\n\n#### 原生 Node.js\n\n​\t\t简单来说，就是先建立监听。\n\n​\t\t然后使用 createServer，这个方法就会将所有的请求都会进行处理了。无论是什么请求，都会进行一个处理。那么我们思考这个算是一个拦截吗，因为既然什么请求都可以进行处理。那么就可以先做一个请求的拦截。当然，这样写符不符合规范不清楚。但是确实做拦截应该是可以的。\n\n​\t\t这里的内容就是，收到请求，然后将index文件里的内容进行读取，然后再通过写响应头，并将内容进行返回。\n\n```\nconst http = require('http')\nconst fs = require('fs')\nconst httpPort = 80\n\nhttp\n  .createServer((req, res) => {\n    fs.readFile('index.html', 'utf-8', (err, content) => {\n      if (err) {\n        console.log('We cannot open \"index.html\" file.')\n      }\n\n      res.writeHead(200, {\n        'Content-Type': 'text/html; charset=utf-8',\n      })\n\n      res.end(content)\n    })\n  })\n  .listen(httpPort, () => {\n    console.log('Server listening on: http://localhost:%s', httpPort)\n  })\n```\n\n\n\n#### Express + Node.js\n\n​\t\t对于 Node.js/Express，可以考虑使用 [connect-history-api-fallback 中间件](https://github.com/bripkens/connect-history-api-fallback)。\n\n\n\n后续还有很多其他的，但是因为其他的我连名字都没有听过了，所以就不写了，直接上官网链接。\n\n```\nhttps://router.vuejs.org/zh/guide/essentials/history-mode.html\n```\n\n\n\n### caveat\n\n​\t\t这有一个注意事项。你的服务器将不再报告 404 错误，因为现在所有未找到的路径都会显示你的 `index.html` 文件。为了解决这个问题，你应该在你的 Vue 应用程序中实现一个万能的路由来显示 404 页面。\n\n```\nconst router = createRouter({\n  history: createWebHistory(),\n  routes: [{ path: '/:pathMatch(.*)', component: NotFoundComponent }],\n})\n```\n\n​\t\t另外，如果你使用的是 Node.js 服务器，你可以通过在服务器端使用路由器来匹配传入的 URL，如果没有匹配到路由，则用 404 来响应，从而实现回退。查看 [Vue 服务器端渲染文档](https://v3.cn.vuejs.org/guide/ssr/introduction.html#what-is-server-side-rendering-ssr)了解更多信息。\n\n​\t\t这里，为什么使用 /:pathMatch(.*) 来匹配404呢，那是因为，这里路由的选择是一个按照分级来排名的。而这个写法的分数只有20分，基本可以说是，只有其他都匹配不上了，才会匹配上这个。\n\n​\t\t所以常用这个来匹配404路由。\n\n","slug":"router/router基础","published":0,"updated":"2022-02-10T09:26:06.693Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckznhkk76000sikub433q0oku","content":"<h1 id=\"router-的基础学习\"><a href=\"#router-的基础学习\" class=\"headerlink\" title=\"router 的基础学习\"></a>router 的基础学习</h1><h2 id=\"router-的基本使用\"><a href=\"#router-的基本使用\" class=\"headerlink\" title=\"router 的基本使用\"></a>router 的基本使用</h2><h3 id=\"HTML\"><a href=\"#HTML\" class=\"headerlink\" title=\"HTML\"></a>HTML</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!--使用 router-link 组件进行导航 --&gt;</span><br><span class=\"line\">&lt;!--通过传递 `to` 来指定链接 --&gt;</span><br><span class=\"line\">&lt;!--`&lt;router-link&gt;` 将呈现一个带有正确 `href` 属性的 `&lt;a&gt;` 标签--&gt;</span><br><span class=\"line\">&lt;router-link to=&quot;/&quot;&gt;Go to Home&lt;/router-link&gt;</span><br><span class=\"line\">&lt;router-link to=&quot;/about&quot;&gt;Go to About&lt;/router-link&gt;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- 路由出口 --&gt;</span><br><span class=\"line\">&lt;!-- 路由匹配到的组件将渲染在这里 --&gt;</span><br><span class=\"line\">&lt;router-view&gt;&lt;/router-view&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"JavaScript\"><a href=\"#JavaScript\" class=\"headerlink\" title=\"JavaScript\"></a>JavaScript</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const routes = [</span><br><span class=\"line\">  &#123; path: &#x27;/&#x27;, component: Home &#125;,</span><br><span class=\"line\">  &#123; path: &#x27;/about&#x27;, component: About &#125;,</span><br><span class=\"line\">]</span><br><span class=\"line\"></span><br><span class=\"line\">const router = VueRouter.createRouter(&#123;</span><br><span class=\"line\">  // 4. 内部提供了 history 模式的实现。为了简单起见，我们在这里使用 hash 模式。</span><br><span class=\"line\">  history: VueRouter.createWebHashHistory(),</span><br><span class=\"line\">  routes, // `routes: routes` 的缩写</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">app.use(router)</span><br></pre></td></tr></table></figure>\n\n<p>​        通过JavaScript进行调用</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">this.$router.push(&#x27;/login&#x27;)</span><br></pre></td></tr></table></figure>\n\n<p>​        请记住，<code>this.$router</code> 与直接使用通过 <code>createRouter</code> 创建的 <code>router</code> 实例完全相同。我们使用 <code>this.$router</code> 的原因是，我们不想在每个需要操作路由的组件中都导入路由。</p>\n<h2 id=\"动态路由匹配\"><a href=\"#动态路由匹配\" class=\"headerlink\" title=\"动态路由匹配\"></a>动态路由匹配</h2><p>​        我们可以使用一个动态字段来进行实现，我们称之为 路径参数。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const routes = [</span><br><span class=\"line\">  // 动态字段以冒号开始</span><br><span class=\"line\">  &#123; path: &#x27;/users/:id&#x27;, component: User &#125;,</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n\n<p>​        现在像 <code>/users/johnny</code> 和 <code>/users/jolyne</code> 这样的 URL 都会映射到同一个路由。</p>\n<p>​        它的 <em>params</em> 的值将在每个组件中以 <code>this.$route.params</code> 的形式暴露出来。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">this.$route.params.id</span><br></pre></td></tr></table></figure>\n\n<p>通过这个方式添加的参数是直接会放在url路径里面的，所以不会因为刷新而消失</p>\n<h3 id=\"相应路由参数的变化\"><a href=\"#相应路由参数的变化\" class=\"headerlink\" title=\"相应路由参数的变化\"></a>相应路由参数的变化</h3><p>​        当用户从 <code>/users/johnny</code> 导航到 <code>/users/jolyne</code> 时，<strong>相同的组件实例将被重复使用</strong>。因为两个路由都渲染同个组件，比起销毁再创建，复用则显得更加高效。<strong>不过，这也意味着组件的生命周期钩子不会被调用</strong>。</p>\n<p>​        要对同一个组件中参数的变化做出响应的话，你可以简单地 watch <code>$route</code> 对象上的任意属性，在这个场景中，就是 <code>$route.params </code> </p>\n<p><strong>方法一：我们可以使用 watch 事件，对params进行监听：</strong> </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const User = &#123;</span><br><span class=\"line\">  template: &#x27;...&#x27;,</span><br><span class=\"line\">  created() &#123;</span><br><span class=\"line\">    this.$watch(</span><br><span class=\"line\">      () =&gt; this.$route.params,</span><br><span class=\"line\">      (toParams, previousParams) =&gt; &#123;</span><br><span class=\"line\">        // 对路由变化做出响应...</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>​        我们逐行分析，首先，this.$watch 是vue的一个 vm.$watch 的方法。其实就是 watch 属性。</p>\n<p>​        然后，我们得知道 this.$watch 的参数，才知道这个作用是什么。</p>\n<ul>\n<li>参数一： 是一个string类型，是一个表达式。或者是一个函数。通过判断返回值的变化来进行处理。</li>\n<li>参数二：是一个调用的方法。对应的两个参数是 oldValue 和 newValue。同时会返回一个 unwatch 的方法。调用后将取消监听。</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var unwatch = vm.$watch(&#x27;a&#x27;, cb)</span><br><span class=\"line\">// 之后取消观察</span><br><span class=\"line\">unwatch()</span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>方法二：使用路由守卫 beforeRouterUpdate</strong>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const User = &#123;</span><br><span class=\"line\">  template: &#x27;...&#x27;,</span><br><span class=\"line\">  async beforeRouteUpdate(to, from) &#123;</span><br><span class=\"line\">    // 对路由变化做出响应...</span><br><span class=\"line\">    this.userData = await fetchUser(to.params.id)</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>我们分析两个的区别</strong>：</p>\n<p>简述区别：下面的说法很长，并且总结的可能不对：</p>\n<ul>\n<li>$watch 是通过监听的方式进行的监听，所以，只要组件没有被销毁的情况下，监听就有效。所以再从监听组件跳出其他组件时会触发。</li>\n<li>路由守卫 beforeRouteUpdate 是需要在路由内部的参数变化才会触发。对于跳转去其他路由和从其他路由跳转回来都不会触发。</li>\n</ul>\n<p>第一个：是利用路由的复用原因，所以使用watch来监听参数的变化，通过参数的变化，来表示里面的修改。</p>\n<p>​        同时使用 watch 进行监听，对于跳转去其他路由，也会进入监听的判断。</p>\n<p>​        为什么跳出去的时候会进行一次判断。虽然我们可以知道，监听的是 this.$route.params。这个是一个全局且是一个唯一的对象。</p>\n<p>​        就是说。在当前项目里面的params。那么就会是这一个，那么确实，监听有效是应该的。但是我们更应该思考。这个监听我们是在这个里面进行的创建，那么在这个组件被移除之后，监听也会被移除。所以按理，跳转出去之后是不会触发监听的。</p>\n<p>​        结果也算是半个很像。因为在跳转出去之后的每一次都不会触发监听。但是，在跳转出去的那一次也会触发。并把目的路由也找到。</p>\n<p>​        说明了路由是在destroy之前进行了判断跳转修改了。</p>\n<p>第二个：是使用的路由守卫。通过每次跳转路由时，会经过的路由守卫来判断。</p>\n<p>​        通过使用路由守卫来进行判断的。跳转去其他路由，并不会触发路由守卫。</p>\n<p>​        但是跳转时机 beforeRouteUpdate 会在监听之前进行输出。</p>\n<p>​        那么我们就需要思考了，首先对于 before路由守卫 会在监听前进行调用执行。那么按理说。应该会和监听的输出基本一致。</p>\n<p>​        但是最终就是，对于跳转出去的路由并不会触发路由守卫</p>\n<p>​        同时我们通过断点调试发现。before路由守卫 执行之后，浏览器的url才会进行改变。意思就是说。watch事件的时候，浏览器的url已经发生改变了。</p>\n<h3 id=\"捕获路由\"><a href=\"#捕获路由\" class=\"headerlink\" title=\"捕获路由\"></a>捕获路由</h3><p>​        简单来说，我们可以通过加入正则表达式来进行。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const routes = [</span><br><span class=\"line\">  // 将匹配所有内容并将其放在 `$route.params.pathMatch` 下</span><br><span class=\"line\">  &#123; path: &#x27;/:pathMatch(.*)*&#x27;, name: &#x27;NotFound&#x27;, component: NotFound &#125;,</span><br><span class=\"line\">  // 将匹配以 `/user-` 开头的所有内容，并将其放在 `$route.params.afterUser` 下</span><br><span class=\"line\">  &#123; path: &#x27;/user-:afterUser(.*)&#x27;, component: UserGeneric &#125;,</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n\n<p>​        这里使用了 正则表达式的语法。然后意思就是 :pathMatch 里面的内容要满足正则表达式，对于不满足的。那么就不会进入这个路由。</p>\n<p>​        同时使用匹配的，对于 /:path 可以匹配到 /a /a/b 这种多层的嵌套。但是前提是，没有其他的path选择。</p>\n<p>​        router 使用的路径匹配算法，其灵感来自于 express</p>\n<h2 id=\"路由的匹配语法\"><a href=\"#路由的匹配语法\" class=\"headerlink\" title=\"路由的匹配语法\"></a>路由的匹配语法</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// /:orderId -&gt; 仅匹配数字</span><br><span class=\"line\">&#123; path: &#x27;/:orderId(\\\\d+)&#x27; &#125;,</span><br><span class=\"line\">// /:productName -&gt; 匹配其他任何内容</span><br><span class=\"line\">&#123; path: &#x27;/:productName&#x27; &#125;,</span><br></pre></td></tr></table></figure>\n\n<p>​        现在，转到 <code>/25</code> 将匹配 <code>/:orderId</code>，其他情况将会匹配 <code>/:productName</code>。<code>routes</code> 数组的顺序并不重要!</p>\n<blockquote>\n<p>TIP</p>\n<p>确保**转义反斜杠( <code>\\</code> )**，就像我们对 <code>\\d</code> (变成<code>\\\\d</code>)所做的那样，在 JavaScript 中实际传递字符串中的反斜杠字符。</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123; path: &#x27;/:pathMatch&#x27;, component: About &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">这样匹配将不能匹配到 / /asd/s</span><br><span class=\"line\">因为这个正则是默认的([^/]+)，^代表了不匹配括号里面的。然后 +，代表了至少需要匹配到一个以上。所以对于上面的，不会被匹配到。</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123; path: &#x27;/:p(.*)&#x27; &#125; </span><br><span class=\"line\">同时我们自己也可以进行覆盖。</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123; path: &#x27;/:p*&#x27; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">可以匹配到 / /as/a /sa/s</span><br><span class=\"line\">同时我们也可以 把 p 进行正则。那么这样的话，可以多次进行匹配。注意这样生成的params是一个数组。而不是一个字符串。</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const routes = [</span><br><span class=\"line\">  // 仅匹配数字</span><br><span class=\"line\">  // 匹配 /1, /1/2, 等</span><br><span class=\"line\">  &#123; path: &#x27;/:chapters(\\\\d+)+&#x27; &#125;,</span><br><span class=\"line\">  // 匹配 /, /1, /1/2, 等</span><br><span class=\"line\">  &#123; path: &#x27;/:chapters(\\\\d+)*&#x27; &#125;,</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n\n<p>​        同时也可以使用  <strong>?</strong> 来代表可选参数。当然使用 * 这个也是可选的。但是使用 ？是0或者1个，不会出现重复。</p>\n<p>​        <strong>路径的排名</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://paths.esm.dev/?p=AAMeJSyAwR4UbFDAFxAcAGAIJXMAAA..</span><br></pre></td></tr></table></figure>\n\n<p>​        这是一个路径的排名工具，作用的话，我认为应该是通过计算分数。路径的匹配会通过分数进行排序来匹配。</p>\n<h2 id=\"嵌套路由\"><a href=\"#嵌套路由\" class=\"headerlink\" title=\"嵌套路由\"></a>嵌套路由</h2><p>​        简单来说就是，router-view 是会渲染 的顶层的路由组件，但是对于组件内部也使用了路由的。我们就可以使用路由嵌套了。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const routes = [</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    path: &#x27;/user/:id&#x27;,</span><br><span class=\"line\">    component: User,</span><br><span class=\"line\">    children: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        // 当 /user/:id/profile 匹配成功</span><br><span class=\"line\">        // UserProfile 将被渲染到 User 的 &lt;router-view&gt; 内部</span><br><span class=\"line\">        path: &#x27;profile&#x27;,</span><br><span class=\"line\">        component: UserProfile,</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        // 当 /user/:id/posts 匹配成功</span><br><span class=\"line\">        // UserPosts 将被渲染到 User 的 &lt;router-view&gt; 内部</span><br><span class=\"line\">        path: &#x27;posts&#x27;,</span><br><span class=\"line\">        component: UserPosts,</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">    ],</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n\n<p>​        简单来说就是我们会对于匹配成功的子路由，然后会在 User组件里面的 router-view 进行渲染。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">children: [</span><br><span class=\"line\">    // 当 /user/:id 匹配成功</span><br><span class=\"line\">    // UserHome 将被渲染到 User 的 &lt;router-view&gt; 内部</span><br><span class=\"line\">    &#123; path: &#x27;&#x27;, component: UserHome &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">    // ...其他子路由</span><br><span class=\"line\">],</span><br></pre></td></tr></table></figure>\n\n<p>​        同时我们可以使用一个空的 path 来代表子路由的home。但是记住，空的path只是代表匹配了 /user/:id 但是对于 /user/:id/asd 虽然没有在子路由匹配成功。但是进入了子路由的，这个不会被匹配到。</p>\n<h2 id=\"编程式导航\"><a href=\"#编程式导航\" class=\"headerlink\" title=\"编程式导航\"></a>编程式导航</h2><p>​        <strong>在 Vue 实例中，你可以通过 <code>$router</code> 访问路由实例。因此你可以调用 <code>this.$router.push</code>。</strong></p>\n<p>​        当你点击 <code>&lt;router-link&gt;</code> 时，内部会调用这个方法，所以点击     <code>&lt;router-link :to=&quot;...&quot;&gt;</code> 相当于调用 <code>router.push(...)</code> </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 字符串路径</span><br><span class=\"line\">router.push(&#x27;/users/eduardo&#x27;)</span><br><span class=\"line\"></span><br><span class=\"line\">// 带有路径的对象</span><br><span class=\"line\">router.push(&#123; path: &#x27;/users/eduardo&#x27; &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">// 命名的路由，并加上参数，让路由建立 url</span><br><span class=\"line\">router.push(&#123; name: &#x27;user&#x27;, params: &#123; username: &#x27;eduardo&#x27; &#125; &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">// 带查询参数，结果是 /register?plan=private</span><br><span class=\"line\">router.push(&#123; path: &#x27;/register&#x27;, query: &#123; plan: &#x27;private&#x27; &#125; &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">// 带 hash，结果是 /about#team</span><br><span class=\"line\">router.push(&#123; path: &#x27;/about&#x27;, hash: &#x27;#team&#x27; &#125;)</span><br></pre></td></tr></table></figure>\n\n<p>​        <strong>但是注意</strong>，如果提供了 <code>path</code>，<code>params</code> 会被忽略，上述例子中的 <code>query</code> 并不属于这种情况。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const username = &#x27;eduardo&#x27;</span><br><span class=\"line\">// 我们可以手动建立 url，但我们必须自己处理编码</span><br><span class=\"line\">router.push(`/user/$&#123;username&#125;`) // -&gt; /user/eduardo</span><br><span class=\"line\">// 同样</span><br><span class=\"line\">router.push(&#123; path: `/user/$&#123;username&#125;` &#125;) // -&gt; /user/eduardo</span><br><span class=\"line\">// 如果可能的话，使用 `name` 和 `params` 从自动 URL 编码中获益</span><br><span class=\"line\">router.push(&#123; name: &#x27;user&#x27;, params: &#123; username &#125; &#125;) // -&gt; /user/eduardo</span><br><span class=\"line\">// `params` 不能与 `path` 一起使用</span><br><span class=\"line\">router.push(&#123; path: &#x27;/user&#x27;, params: &#123; username &#125; &#125;) // -&gt; /user</span><br></pre></td></tr></table></figure>\n\n<p>​        由于属性 <code>to</code> 与 <code>router.push</code> 接受的对象种类相同，所以两者的规则完全相同。</p>\n<p>​         <code>router.push</code> 和所有其他导航方法都会返回一个 <em>Promise</em>，让我们可以等到导航完成后才知道是成功还是失败。我们将在 <a href=\"https://router.vuejs.org/zh/guide/advanced/navigation-failures.html\">Navigation Handling</a> 中详细介绍。</p>\n<h3 id=\"替换当前位置\"><a href=\"#替换当前位置\" class=\"headerlink\" title=\"替换当前位置\"></a>替换当前位置</h3><p>​        使用 replace 来进行跳转，唯一不同的是，它在导航时不会向 history 添加新记录，正如它的名字所暗示的那样——它取代了当前的条目。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;router-link :to=&quot;...&quot; replace&gt;\t</span><br><span class=\"line\">router.replace(...)</span><br></pre></td></tr></table></figure>\n\n<p>​        也可以直接在传递给 <code>router.push</code> 的 <code>routeLocation</code> 中增加一个属性 <code>replace: true</code> </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">router.push(&#123; path: &#x27;/home&#x27;, replace: true &#125;)</span><br><span class=\"line\">// 相当于</span><br><span class=\"line\">router.replace(&#123; path: &#x27;/home&#x27; &#125;)</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"横跨历史\"><a href=\"#横跨历史\" class=\"headerlink\" title=\"横跨历史\"></a>横跨历史</h3><p>​        该方法采用一个整数作为参数，表示在历史堆栈中前进或后退多少步，类似于 <code>window.history.go(n)</code>。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 向前移动一条记录，与 router.forward() 相同</span><br><span class=\"line\">router.go(1) 右箭头</span><br><span class=\"line\"></span><br><span class=\"line\">// 返回一条记录，与router.back() 相同</span><br><span class=\"line\">router.go(-1) 左箭头</span><br><span class=\"line\"></span><br><span class=\"line\">// 前进 3 条记录</span><br><span class=\"line\">router.go(3)</span><br><span class=\"line\"></span><br><span class=\"line\">// 如果没有那么多记录，静默失败</span><br><span class=\"line\">router.go(-100)</span><br><span class=\"line\">router.go(100)</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"篡改历史\"><a href=\"#篡改历史\" class=\"headerlink\" title=\"篡改历史\"></a>篡改历史</h3><p>​        你可能已经注意到，<code>router.push</code>、<code>router.replace</code> 和 <code>router.go</code> 是 <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/History\"><code>window.history.pushState</code>、<code>window.history.replaceState</code> 和 <code>window.history.go</code></a> 的翻版，它们确实模仿了 <code>window.history</code> 的 API。</p>\n<p>​        同时我刚刚进行了测试，发现了 pushState并没有刷新浏览器，但是更新了url，所以这就是router模仿的。对，使用history.go 以及使用 replaceState 都没有进行刷新，仅仅只是修改了url，因为这个是一个同源的方法。对于不同源的处理会出错。</p>\n<h2 id=\"命名路由\"><a href=\"#命名路由\" class=\"headerlink\" title=\"命名路由\"></a>命名路由</h2><p>​        除了 <code>path</code> 之外，你还可以为任何路由提供 <code>name</code>。这有以下优点：</p>\n<ul>\n<li>没有硬编码的 URL</li>\n<li><code>params</code> 的自动编码/解码。</li>\n<li>防止你在 url 中出现打字错误。</li>\n<li>绕过路径排序（如显示一个）</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const routes = [</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    path: &#x27;/user/:username&#x27;,</span><br><span class=\"line\">    name: &#x27;user&#x27;,</span><br><span class=\"line\">    component: User</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;router-link :to=&quot;&#123; name: &#x27;user&#x27;, params: &#123; username: &#x27;erina&#x27; &#125;&#125;&quot;&gt;</span><br><span class=\"line\">  User</span><br><span class=\"line\">&lt;/router-link&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">路由将导航到路径 `/user/erina`。</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"命名视图\"><a href=\"#命名视图\" class=\"headerlink\" title=\"命名视图\"></a>命名视图</h2><p>​        有时候想同时 (同级) 展示多个视图，而不是嵌套展示，例如创建一个布局，有 <code>sidebar</code> (侧导航) 和 <code>main</code> (主内容) 两个视图，这个时候命名视图就派上用场了。你可以在界面中拥有多个单独命名的视图，而不是只有一个单独的出口。如果 <code>router-view</code> 没有设置名字，那么默认为 <code>default</code>。</p>\n<p>​        简单来说就是，想要存在多个同级的router-view，可以使用命名视图， 默认名字为 default</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;router-view class=&quot;view left-sidebar&quot; name=&quot;LeftSidebar&quot;&gt;&lt;/router-view&gt;</span><br><span class=\"line\">&lt;router-view class=&quot;view main-content&quot;&gt;&lt;/router-view&gt;</span><br><span class=\"line\">&lt;router-view class=&quot;view right-sidebar&quot; name=&quot;RightSidebar&quot;&gt;&lt;/router-view&gt;</span><br></pre></td></tr></table></figure>\n\n<p>​        一个视图使用一个组件渲染，因此对于同个路由，多个视图就需要多个组件。确保正确使用 <code>components</code> 配置 (带上 <strong>s</strong>)：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const router = createRouter(&#123;</span><br><span class=\"line\">  history: createWebHashHistory(),</span><br><span class=\"line\">  routes: [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      path: &#x27;/&#x27;,</span><br><span class=\"line\">      components: &#123;</span><br><span class=\"line\">        default: Home,</span><br><span class=\"line\">        // LeftSidebar: LeftSidebar 的缩写</span><br><span class=\"line\">        LeftSidebar,</span><br><span class=\"line\">        // 它们与 `&lt;router-view&gt;` 上的 `name` 属性匹配</span><br><span class=\"line\">        RightSidebar,</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  ],</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>​        当然也是可以不用全部路由都要渲染的。</p>\n<h3 id=\"命名嵌套视图\"><a href=\"#命名嵌套视图\" class=\"headerlink\" title=\"命名嵌套视图\"></a>命名嵌套视图</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  path: &#x27;/settings&#x27;,</span><br><span class=\"line\">  // 你也可以在顶级路由就配置命名视图</span><br><span class=\"line\">  component: UserSettings,</span><br><span class=\"line\">  children: [&#123;</span><br><span class=\"line\">    path: &#x27;emails&#x27;,</span><br><span class=\"line\">    component: UserEmailsSubscriptions</span><br><span class=\"line\">  &#125;, &#123;</span><br><span class=\"line\">    path: &#x27;profile&#x27;,</span><br><span class=\"line\">    components: &#123;</span><br><span class=\"line\">      default: UserProfile,</span><br><span class=\"line\">      helper: UserProfilePreview</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"重定向和别名\"><a href=\"#重定向和别名\" class=\"headerlink\" title=\"重定向和别名\"></a>重定向和别名</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">使用路由</span><br><span class=\"line\">const routes = [&#123; path: &#x27;/home&#x27;, redirect: &#x27;/&#x27; &#125;]</span><br><span class=\"line\"></span><br><span class=\"line\">使用命名的路由</span><br><span class=\"line\">const routes = [&#123; path: &#x27;/home&#x27;, redirect: &#123; name: &#x27;homepage&#x27; &#125; &#125;]</span><br><span class=\"line\"></span><br><span class=\"line\">通过一个方法，返回一个重定向目标</span><br><span class=\"line\">const routes = [</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    // /search/screens -&gt; /search?q=screens</span><br><span class=\"line\">    path: &#x27;/search/:searchText&#x27;,</span><br><span class=\"line\">    redirect: to =&gt; &#123;</span><br><span class=\"line\">      // 方法接收目标路由作为参数</span><br><span class=\"line\">      // return 重定向的字符串路径/路径对象</span><br><span class=\"line\">      return &#123; path: &#x27;/search&#x27;, query: &#123; q: to.params.searchText &#125; &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    path: &#x27;/search&#x27;,</span><br><span class=\"line\">    // ...</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n\n<p>​        请注意，**<a href=\"https://router.vuejs.org/zh/guide/advanced/navigation-guards.html\">导航守卫</a>并没有应用在跳转路由上，而仅仅应用在其目标上**。在上面的例子中，在 <code>/home</code> 路由中添加 <code>beforeEnter</code> 守卫不会有任何效果。</p>\n<p>​        在写 <code>redirect</code> 的时候，可以省略 <code>component</code> 配置，因为它从来没有被直接访问过，所以没有组件要渲染。唯一的例外是<a href=\"https://router.vuejs.org/zh/guide/essentials/nested-routes.html\">嵌套路由</a>：如果一个路由记录有 <code>children</code> 和 <code>redirect</code> 属性，它也应该有 <code>component</code> 属性。</p>\n<h3 id=\"相对重定向\"><a href=\"#相对重定向\" class=\"headerlink\" title=\"相对重定向\"></a>相对重定向</h3><p>​        也可以重定向到相对位置，这里没有理解</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const routes = [</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    path: &#x27;/users/:id/posts&#x27;,</span><br><span class=\"line\">    redirect: to =&gt; &#123;</span><br><span class=\"line\">      // 方法接收目标路由作为参数</span><br><span class=\"line\">      // return 重定向的字符串路径/路径对象</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"别名\"><a href=\"#别名\" class=\"headerlink\" title=\"别名\"></a>别名</h3><p>​        重定向是指当用户访问 <code>/home</code> 时，URL 会被 <code>/</code> 替换，然后匹配成 <code>/</code>。那么什么是别名呢？</p>\n<p>​         <strong>将 <code>/</code> 别名为 <code>/home</code>，意味着当用户访问 <code>/home</code> 时，URL 仍然是 <code>/home</code>，但会被匹配为用户正在访问 <code>/</code>。</strong> </p>\n<p>​        别名就是我从url输入的路径会在别名里面判断是否存在，简单来说就是我多次定义一个path不同，但是component相同等其他相同的一个意思，我们不需要这样重复编写，而是通过别名来进行处理。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const routes = [&#123; path: &#x27;/&#x27;, component: Homepage, alias: &#x27;/home&#x27; &#125;]</span><br></pre></td></tr></table></figure>\n\n<p>​        使别名以 <code>/</code> 开头，以使嵌套路径中的路径成为绝对路径。你甚至可以将两者结合起来，用一个数组提供多个别名：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const routes = [</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    path: &#x27;/users&#x27;,</span><br><span class=\"line\">    component: UsersLayout,</span><br><span class=\"line\">    children: [</span><br><span class=\"line\">      // 为这 3 个 URL 呈现 UserList</span><br><span class=\"line\">      // - /users</span><br><span class=\"line\">      // - /users/list</span><br><span class=\"line\">      // - /people</span><br><span class=\"line\">      // /people 是绝对路径， list 是相对路径</span><br><span class=\"line\">      &#123; path: &#x27;&#x27;, component: UserList, alias: [&#x27;/people&#x27;, &#x27;list&#x27;] &#125;,</span><br><span class=\"line\">    ],</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n\n<p>​        如果你的路由有参数，请确保在任何绝对别名中包含它们：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const routes = [</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    path: &#x27;/users/:id&#x27;,</span><br><span class=\"line\">    component: UsersByIdLayout,</span><br><span class=\"line\">    children: [</span><br><span class=\"line\">      // 为这 3 个 URL 呈现 UserDetails</span><br><span class=\"line\">      // - /users/24</span><br><span class=\"line\">      // - /users/24/profile</span><br><span class=\"line\">      // - /24</span><br><span class=\"line\">      &#123; path: &#x27;profile&#x27;, component: UserDetails, alias: [&#x27;/:id&#x27;, &#x27;&#x27;] &#125;,</span><br><span class=\"line\">    ],</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"路由组件传参\"><a href=\"#路由组件传参\" class=\"headerlink\" title=\"路由组件传参\"></a>路由组件传参</h2><h3 id=\"通过-props-true-传递给路由组件\"><a href=\"#通过-props-true-传递给路由组件\" class=\"headerlink\" title=\"通过 props:true 传递给路由组件\"></a>通过 props:true 传递给路由组件</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const User = &#123;</span><br><span class=\"line\">  props: [&#x27;id&#x27;],</span><br><span class=\"line\">  template: &#x27;&lt;div&gt;User &#123;&#123; id &#125;&#125;&lt;/div&gt;&#x27;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">const routes = [&#123; path: &#x27;/user/:id&#x27;, component: User, props: true &#125;]</span><br></pre></td></tr></table></figure>\n\n<p>​        那么此时，id 就会通过props传递给路由组件</p>\n<h3 id=\"命名视图-1\"><a href=\"#命名视图-1\" class=\"headerlink\" title=\"命名视图\"></a>命名视图</h3><p>​        对于有命名视图的路由，必须给props里面给每个命名视图定义配置</p>\n<ul>\n<li><p>如果直接使用 props: true，那么代表里面所有的都为true</p>\n</li>\n<li><p>否则就需要使用对象来对每个命名视图进行处理</p>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const routes = [</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    path: &#x27;/user/:id&#x27;,</span><br><span class=\"line\">    components: &#123; default: User, sidebar: Sidebar &#125;,</span><br><span class=\"line\">    props: &#123; default: true, sidebar: false &#125;</span><br><span class=\"line\">    // 所有的都为true</span><br><span class=\"line\">    // props: true</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"props使用对象\"><a href=\"#props使用对象\" class=\"headerlink\" title=\"props使用对象\"></a>props使用对象</h3><p>​        当 <code>props</code> 是一个对象时，它将原样设置为组件 props。当 props 是静态的时候很有用。</p>\n<p>​        就是说，使用的是对象的话，那么对象里面的内容就会作为props传递给路由组件。同时如果此时你的路由组件是携带了参数的。那么将不会传递给路由组件了。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const routes = [</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    path: &#x27;/promotion/from-newsletter&#x27;,</span><br><span class=\"line\">    component: Promotion,</span><br><span class=\"line\">    props: &#123; newsletterPopup: false &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"函数模式\"><a href=\"#函数模式\" class=\"headerlink\" title=\"函数模式\"></a>函数模式</h3><p>注意：</p>\n<ul>\n<li>对于函数，参数是route</li>\n<li>返回值，如果是 Boolean 值，并不会变成 props: true 这两个并不是一个意思。所以不会起作用。</li>\n<li>返回值，常是一个对象。然后按照对象的形式来处理</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const routes = [</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    path: &#x27;/search&#x27;,</span><br><span class=\"line\">    component: SearchUser,</span><br><span class=\"line\">    props: route =&gt; (&#123; query: route.query.q &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"不同的历史模式\"><a href=\"#不同的历史模式\" class=\"headerlink\" title=\"不同的历史模式\"></a>不同的历史模式</h2><h3 id=\"Hash模式\"><a href=\"#Hash模式\" class=\"headerlink\" title=\"Hash模式\"></a>Hash模式</h3><p>​        hash 模式是用 <code>createWebHashHistory()</code> 创建的：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#123; createRouter, createWebHashHistory &#125; from &#x27;vue-router&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">const router = createRouter(&#123;</span><br><span class=\"line\">  history: createWebHashHistory(),</span><br><span class=\"line\">  routes: [</span><br><span class=\"line\">    //...</span><br><span class=\"line\">  ],</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>​        hash模式就是通过在url后面使用一个hash字符 #。然后因为哈希字符并不会发送到服务器，所以不会出现找不到url的情况。但是对于 SEO 和 看来说，确实有点影响。</p>\n<h3 id=\"HTML5模式，history模式\"><a href=\"#HTML5模式，history模式\" class=\"headerlink\" title=\"HTML5模式，history模式\"></a>HTML5模式，history模式</h3><p>​        用 <code>createWebHistory()</code> 创建 HTML5 模式，推荐使用这个模式：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#123; createRouter, createWebHistory &#125; from &#x27;vue-router&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">const router = createRouter(&#123;</span><br><span class=\"line\">  history: createWebHistory(),</span><br><span class=\"line\">  routes: [</span><br><span class=\"line\">    //...</span><br><span class=\"line\">  ],</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>​        当使用这种历史模式时，URL 会看起来很 “正常”，例如 <code>https://example.com/user/id</code>。漂亮!</p>\n<p>​        不过，问题来了。由于我们的应用是一个单页的客户端应用，如果没有适当的服务器配置，用户在浏览器中直接访问 <code>https://example.com/user/id</code>，就会得到一个 404 错误。这就丑了。</p>\n<p>​        不用担心：要解决这个问题，你需要做的就是在你的服务器上添加一个简单的回退路由。如果 URL 不匹配任何静态资源，它应提供与你的应用程序中的 <code>index.html</code> 相同的页面。漂亮依旧!</p>\n<p>​        简单来说就是，因为history模式的 url 是不带hash，所以我们知道从一个浏览器里面输入一个正常的url，他会找到对应的服务器并发送请求，那么类似于这种的： <a href=\"https://example.com/usre/id\">https://example.com/usre/id</a> 他就会先进入对应的。</p>\n<h3 id=\"服务器配置实例\"><a href=\"#服务器配置实例\" class=\"headerlink\" title=\"服务器配置实例\"></a>服务器配置实例</h3><p>​        <strong>注意</strong>：以下示例假定你正在从根目录提供服务。如果你部署到子目录，你应该使用<a href=\"https://cli.vuejs.org/config/#publicpath\">Vue CLI 的 <code>publicPath</code> 配置</a>和相关的<a href=\"https://router.vuejs.org/zh/api/#createwebhistory\">路由器的 <code>base</code> 属性</a>。你还需要调整下面的例子，以使用子目录而不是根目录（例如，将<code>RewriteBase/</code> 替换为 <code>RewriteBase/name-of-your-subfolder/</code>）。</p>\n<h4 id=\"Apache\"><a href=\"#Apache\" class=\"headerlink\" title=\"Apache\"></a>Apache</h4><p>​        没有学过，可以说是完全看不懂了。</p>\n<p>​        也可以使用 <a href=\"https://httpd.apache.org/docs/2.2/mod/mod_dir.html#fallbackresource\"><code>FallbackResource</code></a> 代替 <code>mod_rewrite</code>。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;IfModule mod_rewrite.c&gt;</span><br><span class=\"line\">  RewriteEngine On</span><br><span class=\"line\">  RewriteBase /</span><br><span class=\"line\">  RewriteRule ^index\\.html$ - [L]</span><br><span class=\"line\">  RewriteCond %&#123;REQUEST_FILENAME&#125; !-f</span><br><span class=\"line\">  RewriteCond %&#123;REQUEST_FILENAME&#125; !-d</span><br><span class=\"line\">  RewriteRule . /index.html [L]</span><br><span class=\"line\">&lt;/IfModule&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"nginx\"><a href=\"#nginx\" class=\"headerlink\" title=\"nginx\"></a>nginx</h4><p>​        实不相瞒，nginx，我也没有学过。。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">location / &#123;</span><br><span class=\"line\">  try_files $uri $uri/ /index.html;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"原生-Node-js\"><a href=\"#原生-Node-js\" class=\"headerlink\" title=\"原生 Node.js\"></a>原生 Node.js</h4><p>​        简单来说，就是先建立监听。</p>\n<p>​        然后使用 createServer，这个方法就会将所有的请求都会进行处理了。无论是什么请求，都会进行一个处理。那么我们思考这个算是一个拦截吗，因为既然什么请求都可以进行处理。那么就可以先做一个请求的拦截。当然，这样写符不符合规范不清楚。但是确实做拦截应该是可以的。</p>\n<p>​        这里的内容就是，收到请求，然后将index文件里的内容进行读取，然后再通过写响应头，并将内容进行返回。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const http = require(&#x27;http&#x27;)</span><br><span class=\"line\">const fs = require(&#x27;fs&#x27;)</span><br><span class=\"line\">const httpPort = 80</span><br><span class=\"line\"></span><br><span class=\"line\">http</span><br><span class=\"line\">  .createServer((req, res) =&gt; &#123;</span><br><span class=\"line\">    fs.readFile(&#x27;index.html&#x27;, &#x27;utf-8&#x27;, (err, content) =&gt; &#123;</span><br><span class=\"line\">      if (err) &#123;</span><br><span class=\"line\">        console.log(&#x27;We cannot open &quot;index.html&quot; file.&#x27;)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      res.writeHead(200, &#123;</span><br><span class=\"line\">        &#x27;Content-Type&#x27;: &#x27;text/html; charset=utf-8&#x27;,</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">      res.end(content)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .listen(httpPort, () =&gt; &#123;</span><br><span class=\"line\">    console.log(&#x27;Server listening on: http://localhost:%s&#x27;, httpPort)</span><br><span class=\"line\">  &#125;)</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"Express-Node-js\"><a href=\"#Express-Node-js\" class=\"headerlink\" title=\"Express + Node.js\"></a>Express + Node.js</h4><p>​        对于 Node.js/Express，可以考虑使用 <a href=\"https://github.com/bripkens/connect-history-api-fallback\">connect-history-api-fallback 中间件</a>。</p>\n<p>后续还有很多其他的，但是因为其他的我连名字都没有听过了，所以就不写了，直接上官网链接。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://router.vuejs.org/zh/guide/essentials/history-mode.html</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"caveat\"><a href=\"#caveat\" class=\"headerlink\" title=\"caveat\"></a>caveat</h3><p>​        这有一个注意事项。你的服务器将不再报告 404 错误，因为现在所有未找到的路径都会显示你的 <code>index.html</code> 文件。为了解决这个问题，你应该在你的 Vue 应用程序中实现一个万能的路由来显示 404 页面。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const router = createRouter(&#123;</span><br><span class=\"line\">  history: createWebHistory(),</span><br><span class=\"line\">  routes: [&#123; path: &#x27;/:pathMatch(.*)&#x27;, component: NotFoundComponent &#125;],</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>​        另外，如果你使用的是 Node.js 服务器，你可以通过在服务器端使用路由器来匹配传入的 URL，如果没有匹配到路由，则用 404 来响应，从而实现回退。查看 <a href=\"https://v3.cn.vuejs.org/guide/ssr/introduction.html#what-is-server-side-rendering-ssr\">Vue 服务器端渲染文档</a>了解更多信息。</p>\n<p>​        这里，为什么使用 /:pathMatch(.*) 来匹配404呢，那是因为，这里路由的选择是一个按照分级来排名的。而这个写法的分数只有20分，基本可以说是，只有其他都匹配不上了，才会匹配上这个。</p>\n<p>​        所以常用这个来匹配404路由。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"router-的基础学习\"><a href=\"#router-的基础学习\" class=\"headerlink\" title=\"router 的基础学习\"></a>router 的基础学习</h1><h2 id=\"router-的基本使用\"><a href=\"#router-的基本使用\" class=\"headerlink\" title=\"router 的基本使用\"></a>router 的基本使用</h2><h3 id=\"HTML\"><a href=\"#HTML\" class=\"headerlink\" title=\"HTML\"></a>HTML</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!--使用 router-link 组件进行导航 --&gt;</span><br><span class=\"line\">&lt;!--通过传递 `to` 来指定链接 --&gt;</span><br><span class=\"line\">&lt;!--`&lt;router-link&gt;` 将呈现一个带有正确 `href` 属性的 `&lt;a&gt;` 标签--&gt;</span><br><span class=\"line\">&lt;router-link to=&quot;/&quot;&gt;Go to Home&lt;/router-link&gt;</span><br><span class=\"line\">&lt;router-link to=&quot;/about&quot;&gt;Go to About&lt;/router-link&gt;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- 路由出口 --&gt;</span><br><span class=\"line\">&lt;!-- 路由匹配到的组件将渲染在这里 --&gt;</span><br><span class=\"line\">&lt;router-view&gt;&lt;/router-view&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"JavaScript\"><a href=\"#JavaScript\" class=\"headerlink\" title=\"JavaScript\"></a>JavaScript</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const routes = [</span><br><span class=\"line\">  &#123; path: &#x27;/&#x27;, component: Home &#125;,</span><br><span class=\"line\">  &#123; path: &#x27;/about&#x27;, component: About &#125;,</span><br><span class=\"line\">]</span><br><span class=\"line\"></span><br><span class=\"line\">const router = VueRouter.createRouter(&#123;</span><br><span class=\"line\">  // 4. 内部提供了 history 模式的实现。为了简单起见，我们在这里使用 hash 模式。</span><br><span class=\"line\">  history: VueRouter.createWebHashHistory(),</span><br><span class=\"line\">  routes, // `routes: routes` 的缩写</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">app.use(router)</span><br></pre></td></tr></table></figure>\n\n<p>​        通过JavaScript进行调用</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">this.$router.push(&#x27;/login&#x27;)</span><br></pre></td></tr></table></figure>\n\n<p>​        请记住，<code>this.$router</code> 与直接使用通过 <code>createRouter</code> 创建的 <code>router</code> 实例完全相同。我们使用 <code>this.$router</code> 的原因是，我们不想在每个需要操作路由的组件中都导入路由。</p>\n<h2 id=\"动态路由匹配\"><a href=\"#动态路由匹配\" class=\"headerlink\" title=\"动态路由匹配\"></a>动态路由匹配</h2><p>​        我们可以使用一个动态字段来进行实现，我们称之为 路径参数。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const routes = [</span><br><span class=\"line\">  // 动态字段以冒号开始</span><br><span class=\"line\">  &#123; path: &#x27;/users/:id&#x27;, component: User &#125;,</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n\n<p>​        现在像 <code>/users/johnny</code> 和 <code>/users/jolyne</code> 这样的 URL 都会映射到同一个路由。</p>\n<p>​        它的 <em>params</em> 的值将在每个组件中以 <code>this.$route.params</code> 的形式暴露出来。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">this.$route.params.id</span><br></pre></td></tr></table></figure>\n\n<p>通过这个方式添加的参数是直接会放在url路径里面的，所以不会因为刷新而消失</p>\n<h3 id=\"相应路由参数的变化\"><a href=\"#相应路由参数的变化\" class=\"headerlink\" title=\"相应路由参数的变化\"></a>相应路由参数的变化</h3><p>​        当用户从 <code>/users/johnny</code> 导航到 <code>/users/jolyne</code> 时，<strong>相同的组件实例将被重复使用</strong>。因为两个路由都渲染同个组件，比起销毁再创建，复用则显得更加高效。<strong>不过，这也意味着组件的生命周期钩子不会被调用</strong>。</p>\n<p>​        要对同一个组件中参数的变化做出响应的话，你可以简单地 watch <code>$route</code> 对象上的任意属性，在这个场景中，就是 <code>$route.params </code> </p>\n<p><strong>方法一：我们可以使用 watch 事件，对params进行监听：</strong> </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const User = &#123;</span><br><span class=\"line\">  template: &#x27;...&#x27;,</span><br><span class=\"line\">  created() &#123;</span><br><span class=\"line\">    this.$watch(</span><br><span class=\"line\">      () =&gt; this.$route.params,</span><br><span class=\"line\">      (toParams, previousParams) =&gt; &#123;</span><br><span class=\"line\">        // 对路由变化做出响应...</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>​        我们逐行分析，首先，this.$watch 是vue的一个 vm.$watch 的方法。其实就是 watch 属性。</p>\n<p>​        然后，我们得知道 this.$watch 的参数，才知道这个作用是什么。</p>\n<ul>\n<li>参数一： 是一个string类型，是一个表达式。或者是一个函数。通过判断返回值的变化来进行处理。</li>\n<li>参数二：是一个调用的方法。对应的两个参数是 oldValue 和 newValue。同时会返回一个 unwatch 的方法。调用后将取消监听。</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var unwatch = vm.$watch(&#x27;a&#x27;, cb)</span><br><span class=\"line\">// 之后取消观察</span><br><span class=\"line\">unwatch()</span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>方法二：使用路由守卫 beforeRouterUpdate</strong>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const User = &#123;</span><br><span class=\"line\">  template: &#x27;...&#x27;,</span><br><span class=\"line\">  async beforeRouteUpdate(to, from) &#123;</span><br><span class=\"line\">    // 对路由变化做出响应...</span><br><span class=\"line\">    this.userData = await fetchUser(to.params.id)</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>我们分析两个的区别</strong>：</p>\n<p>简述区别：下面的说法很长，并且总结的可能不对：</p>\n<ul>\n<li>$watch 是通过监听的方式进行的监听，所以，只要组件没有被销毁的情况下，监听就有效。所以再从监听组件跳出其他组件时会触发。</li>\n<li>路由守卫 beforeRouteUpdate 是需要在路由内部的参数变化才会触发。对于跳转去其他路由和从其他路由跳转回来都不会触发。</li>\n</ul>\n<p>第一个：是利用路由的复用原因，所以使用watch来监听参数的变化，通过参数的变化，来表示里面的修改。</p>\n<p>​        同时使用 watch 进行监听，对于跳转去其他路由，也会进入监听的判断。</p>\n<p>​        为什么跳出去的时候会进行一次判断。虽然我们可以知道，监听的是 this.$route.params。这个是一个全局且是一个唯一的对象。</p>\n<p>​        就是说。在当前项目里面的params。那么就会是这一个，那么确实，监听有效是应该的。但是我们更应该思考。这个监听我们是在这个里面进行的创建，那么在这个组件被移除之后，监听也会被移除。所以按理，跳转出去之后是不会触发监听的。</p>\n<p>​        结果也算是半个很像。因为在跳转出去之后的每一次都不会触发监听。但是，在跳转出去的那一次也会触发。并把目的路由也找到。</p>\n<p>​        说明了路由是在destroy之前进行了判断跳转修改了。</p>\n<p>第二个：是使用的路由守卫。通过每次跳转路由时，会经过的路由守卫来判断。</p>\n<p>​        通过使用路由守卫来进行判断的。跳转去其他路由，并不会触发路由守卫。</p>\n<p>​        但是跳转时机 beforeRouteUpdate 会在监听之前进行输出。</p>\n<p>​        那么我们就需要思考了，首先对于 before路由守卫 会在监听前进行调用执行。那么按理说。应该会和监听的输出基本一致。</p>\n<p>​        但是最终就是，对于跳转出去的路由并不会触发路由守卫</p>\n<p>​        同时我们通过断点调试发现。before路由守卫 执行之后，浏览器的url才会进行改变。意思就是说。watch事件的时候，浏览器的url已经发生改变了。</p>\n<h3 id=\"捕获路由\"><a href=\"#捕获路由\" class=\"headerlink\" title=\"捕获路由\"></a>捕获路由</h3><p>​        简单来说，我们可以通过加入正则表达式来进行。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const routes = [</span><br><span class=\"line\">  // 将匹配所有内容并将其放在 `$route.params.pathMatch` 下</span><br><span class=\"line\">  &#123; path: &#x27;/:pathMatch(.*)*&#x27;, name: &#x27;NotFound&#x27;, component: NotFound &#125;,</span><br><span class=\"line\">  // 将匹配以 `/user-` 开头的所有内容，并将其放在 `$route.params.afterUser` 下</span><br><span class=\"line\">  &#123; path: &#x27;/user-:afterUser(.*)&#x27;, component: UserGeneric &#125;,</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n\n<p>​        这里使用了 正则表达式的语法。然后意思就是 :pathMatch 里面的内容要满足正则表达式，对于不满足的。那么就不会进入这个路由。</p>\n<p>​        同时使用匹配的，对于 /:path 可以匹配到 /a /a/b 这种多层的嵌套。但是前提是，没有其他的path选择。</p>\n<p>​        router 使用的路径匹配算法，其灵感来自于 express</p>\n<h2 id=\"路由的匹配语法\"><a href=\"#路由的匹配语法\" class=\"headerlink\" title=\"路由的匹配语法\"></a>路由的匹配语法</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// /:orderId -&gt; 仅匹配数字</span><br><span class=\"line\">&#123; path: &#x27;/:orderId(\\\\d+)&#x27; &#125;,</span><br><span class=\"line\">// /:productName -&gt; 匹配其他任何内容</span><br><span class=\"line\">&#123; path: &#x27;/:productName&#x27; &#125;,</span><br></pre></td></tr></table></figure>\n\n<p>​        现在，转到 <code>/25</code> 将匹配 <code>/:orderId</code>，其他情况将会匹配 <code>/:productName</code>。<code>routes</code> 数组的顺序并不重要!</p>\n<blockquote>\n<p>TIP</p>\n<p>确保**转义反斜杠( <code>\\</code> )**，就像我们对 <code>\\d</code> (变成<code>\\\\d</code>)所做的那样，在 JavaScript 中实际传递字符串中的反斜杠字符。</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123; path: &#x27;/:pathMatch&#x27;, component: About &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">这样匹配将不能匹配到 / /asd/s</span><br><span class=\"line\">因为这个正则是默认的([^/]+)，^代表了不匹配括号里面的。然后 +，代表了至少需要匹配到一个以上。所以对于上面的，不会被匹配到。</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123; path: &#x27;/:p(.*)&#x27; &#125; </span><br><span class=\"line\">同时我们自己也可以进行覆盖。</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123; path: &#x27;/:p*&#x27; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">可以匹配到 / /as/a /sa/s</span><br><span class=\"line\">同时我们也可以 把 p 进行正则。那么这样的话，可以多次进行匹配。注意这样生成的params是一个数组。而不是一个字符串。</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const routes = [</span><br><span class=\"line\">  // 仅匹配数字</span><br><span class=\"line\">  // 匹配 /1, /1/2, 等</span><br><span class=\"line\">  &#123; path: &#x27;/:chapters(\\\\d+)+&#x27; &#125;,</span><br><span class=\"line\">  // 匹配 /, /1, /1/2, 等</span><br><span class=\"line\">  &#123; path: &#x27;/:chapters(\\\\d+)*&#x27; &#125;,</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n\n<p>​        同时也可以使用  <strong>?</strong> 来代表可选参数。当然使用 * 这个也是可选的。但是使用 ？是0或者1个，不会出现重复。</p>\n<p>​        <strong>路径的排名</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://paths.esm.dev/?p=AAMeJSyAwR4UbFDAFxAcAGAIJXMAAA..</span><br></pre></td></tr></table></figure>\n\n<p>​        这是一个路径的排名工具，作用的话，我认为应该是通过计算分数。路径的匹配会通过分数进行排序来匹配。</p>\n<h2 id=\"嵌套路由\"><a href=\"#嵌套路由\" class=\"headerlink\" title=\"嵌套路由\"></a>嵌套路由</h2><p>​        简单来说就是，router-view 是会渲染 的顶层的路由组件，但是对于组件内部也使用了路由的。我们就可以使用路由嵌套了。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const routes = [</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    path: &#x27;/user/:id&#x27;,</span><br><span class=\"line\">    component: User,</span><br><span class=\"line\">    children: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        // 当 /user/:id/profile 匹配成功</span><br><span class=\"line\">        // UserProfile 将被渲染到 User 的 &lt;router-view&gt; 内部</span><br><span class=\"line\">        path: &#x27;profile&#x27;,</span><br><span class=\"line\">        component: UserProfile,</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        // 当 /user/:id/posts 匹配成功</span><br><span class=\"line\">        // UserPosts 将被渲染到 User 的 &lt;router-view&gt; 内部</span><br><span class=\"line\">        path: &#x27;posts&#x27;,</span><br><span class=\"line\">        component: UserPosts,</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">    ],</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n\n<p>​        简单来说就是我们会对于匹配成功的子路由，然后会在 User组件里面的 router-view 进行渲染。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">children: [</span><br><span class=\"line\">    // 当 /user/:id 匹配成功</span><br><span class=\"line\">    // UserHome 将被渲染到 User 的 &lt;router-view&gt; 内部</span><br><span class=\"line\">    &#123; path: &#x27;&#x27;, component: UserHome &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">    // ...其他子路由</span><br><span class=\"line\">],</span><br></pre></td></tr></table></figure>\n\n<p>​        同时我们可以使用一个空的 path 来代表子路由的home。但是记住，空的path只是代表匹配了 /user/:id 但是对于 /user/:id/asd 虽然没有在子路由匹配成功。但是进入了子路由的，这个不会被匹配到。</p>\n<h2 id=\"编程式导航\"><a href=\"#编程式导航\" class=\"headerlink\" title=\"编程式导航\"></a>编程式导航</h2><p>​        <strong>在 Vue 实例中，你可以通过 <code>$router</code> 访问路由实例。因此你可以调用 <code>this.$router.push</code>。</strong></p>\n<p>​        当你点击 <code>&lt;router-link&gt;</code> 时，内部会调用这个方法，所以点击     <code>&lt;router-link :to=&quot;...&quot;&gt;</code> 相当于调用 <code>router.push(...)</code> </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 字符串路径</span><br><span class=\"line\">router.push(&#x27;/users/eduardo&#x27;)</span><br><span class=\"line\"></span><br><span class=\"line\">// 带有路径的对象</span><br><span class=\"line\">router.push(&#123; path: &#x27;/users/eduardo&#x27; &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">// 命名的路由，并加上参数，让路由建立 url</span><br><span class=\"line\">router.push(&#123; name: &#x27;user&#x27;, params: &#123; username: &#x27;eduardo&#x27; &#125; &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">// 带查询参数，结果是 /register?plan=private</span><br><span class=\"line\">router.push(&#123; path: &#x27;/register&#x27;, query: &#123; plan: &#x27;private&#x27; &#125; &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">// 带 hash，结果是 /about#team</span><br><span class=\"line\">router.push(&#123; path: &#x27;/about&#x27;, hash: &#x27;#team&#x27; &#125;)</span><br></pre></td></tr></table></figure>\n\n<p>​        <strong>但是注意</strong>，如果提供了 <code>path</code>，<code>params</code> 会被忽略，上述例子中的 <code>query</code> 并不属于这种情况。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const username = &#x27;eduardo&#x27;</span><br><span class=\"line\">// 我们可以手动建立 url，但我们必须自己处理编码</span><br><span class=\"line\">router.push(`/user/$&#123;username&#125;`) // -&gt; /user/eduardo</span><br><span class=\"line\">// 同样</span><br><span class=\"line\">router.push(&#123; path: `/user/$&#123;username&#125;` &#125;) // -&gt; /user/eduardo</span><br><span class=\"line\">// 如果可能的话，使用 `name` 和 `params` 从自动 URL 编码中获益</span><br><span class=\"line\">router.push(&#123; name: &#x27;user&#x27;, params: &#123; username &#125; &#125;) // -&gt; /user/eduardo</span><br><span class=\"line\">// `params` 不能与 `path` 一起使用</span><br><span class=\"line\">router.push(&#123; path: &#x27;/user&#x27;, params: &#123; username &#125; &#125;) // -&gt; /user</span><br></pre></td></tr></table></figure>\n\n<p>​        由于属性 <code>to</code> 与 <code>router.push</code> 接受的对象种类相同，所以两者的规则完全相同。</p>\n<p>​         <code>router.push</code> 和所有其他导航方法都会返回一个 <em>Promise</em>，让我们可以等到导航完成后才知道是成功还是失败。我们将在 <a href=\"https://router.vuejs.org/zh/guide/advanced/navigation-failures.html\">Navigation Handling</a> 中详细介绍。</p>\n<h3 id=\"替换当前位置\"><a href=\"#替换当前位置\" class=\"headerlink\" title=\"替换当前位置\"></a>替换当前位置</h3><p>​        使用 replace 来进行跳转，唯一不同的是，它在导航时不会向 history 添加新记录，正如它的名字所暗示的那样——它取代了当前的条目。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;router-link :to=&quot;...&quot; replace&gt;\t</span><br><span class=\"line\">router.replace(...)</span><br></pre></td></tr></table></figure>\n\n<p>​        也可以直接在传递给 <code>router.push</code> 的 <code>routeLocation</code> 中增加一个属性 <code>replace: true</code> </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">router.push(&#123; path: &#x27;/home&#x27;, replace: true &#125;)</span><br><span class=\"line\">// 相当于</span><br><span class=\"line\">router.replace(&#123; path: &#x27;/home&#x27; &#125;)</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"横跨历史\"><a href=\"#横跨历史\" class=\"headerlink\" title=\"横跨历史\"></a>横跨历史</h3><p>​        该方法采用一个整数作为参数，表示在历史堆栈中前进或后退多少步，类似于 <code>window.history.go(n)</code>。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 向前移动一条记录，与 router.forward() 相同</span><br><span class=\"line\">router.go(1) 右箭头</span><br><span class=\"line\"></span><br><span class=\"line\">// 返回一条记录，与router.back() 相同</span><br><span class=\"line\">router.go(-1) 左箭头</span><br><span class=\"line\"></span><br><span class=\"line\">// 前进 3 条记录</span><br><span class=\"line\">router.go(3)</span><br><span class=\"line\"></span><br><span class=\"line\">// 如果没有那么多记录，静默失败</span><br><span class=\"line\">router.go(-100)</span><br><span class=\"line\">router.go(100)</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"篡改历史\"><a href=\"#篡改历史\" class=\"headerlink\" title=\"篡改历史\"></a>篡改历史</h3><p>​        你可能已经注意到，<code>router.push</code>、<code>router.replace</code> 和 <code>router.go</code> 是 <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/History\"><code>window.history.pushState</code>、<code>window.history.replaceState</code> 和 <code>window.history.go</code></a> 的翻版，它们确实模仿了 <code>window.history</code> 的 API。</p>\n<p>​        同时我刚刚进行了测试，发现了 pushState并没有刷新浏览器，但是更新了url，所以这就是router模仿的。对，使用history.go 以及使用 replaceState 都没有进行刷新，仅仅只是修改了url，因为这个是一个同源的方法。对于不同源的处理会出错。</p>\n<h2 id=\"命名路由\"><a href=\"#命名路由\" class=\"headerlink\" title=\"命名路由\"></a>命名路由</h2><p>​        除了 <code>path</code> 之外，你还可以为任何路由提供 <code>name</code>。这有以下优点：</p>\n<ul>\n<li>没有硬编码的 URL</li>\n<li><code>params</code> 的自动编码/解码。</li>\n<li>防止你在 url 中出现打字错误。</li>\n<li>绕过路径排序（如显示一个）</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const routes = [</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    path: &#x27;/user/:username&#x27;,</span><br><span class=\"line\">    name: &#x27;user&#x27;,</span><br><span class=\"line\">    component: User</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;router-link :to=&quot;&#123; name: &#x27;user&#x27;, params: &#123; username: &#x27;erina&#x27; &#125;&#125;&quot;&gt;</span><br><span class=\"line\">  User</span><br><span class=\"line\">&lt;/router-link&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">路由将导航到路径 `/user/erina`。</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"命名视图\"><a href=\"#命名视图\" class=\"headerlink\" title=\"命名视图\"></a>命名视图</h2><p>​        有时候想同时 (同级) 展示多个视图，而不是嵌套展示，例如创建一个布局，有 <code>sidebar</code> (侧导航) 和 <code>main</code> (主内容) 两个视图，这个时候命名视图就派上用场了。你可以在界面中拥有多个单独命名的视图，而不是只有一个单独的出口。如果 <code>router-view</code> 没有设置名字，那么默认为 <code>default</code>。</p>\n<p>​        简单来说就是，想要存在多个同级的router-view，可以使用命名视图， 默认名字为 default</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;router-view class=&quot;view left-sidebar&quot; name=&quot;LeftSidebar&quot;&gt;&lt;/router-view&gt;</span><br><span class=\"line\">&lt;router-view class=&quot;view main-content&quot;&gt;&lt;/router-view&gt;</span><br><span class=\"line\">&lt;router-view class=&quot;view right-sidebar&quot; name=&quot;RightSidebar&quot;&gt;&lt;/router-view&gt;</span><br></pre></td></tr></table></figure>\n\n<p>​        一个视图使用一个组件渲染，因此对于同个路由，多个视图就需要多个组件。确保正确使用 <code>components</code> 配置 (带上 <strong>s</strong>)：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const router = createRouter(&#123;</span><br><span class=\"line\">  history: createWebHashHistory(),</span><br><span class=\"line\">  routes: [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      path: &#x27;/&#x27;,</span><br><span class=\"line\">      components: &#123;</span><br><span class=\"line\">        default: Home,</span><br><span class=\"line\">        // LeftSidebar: LeftSidebar 的缩写</span><br><span class=\"line\">        LeftSidebar,</span><br><span class=\"line\">        // 它们与 `&lt;router-view&gt;` 上的 `name` 属性匹配</span><br><span class=\"line\">        RightSidebar,</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  ],</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>​        当然也是可以不用全部路由都要渲染的。</p>\n<h3 id=\"命名嵌套视图\"><a href=\"#命名嵌套视图\" class=\"headerlink\" title=\"命名嵌套视图\"></a>命名嵌套视图</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  path: &#x27;/settings&#x27;,</span><br><span class=\"line\">  // 你也可以在顶级路由就配置命名视图</span><br><span class=\"line\">  component: UserSettings,</span><br><span class=\"line\">  children: [&#123;</span><br><span class=\"line\">    path: &#x27;emails&#x27;,</span><br><span class=\"line\">    component: UserEmailsSubscriptions</span><br><span class=\"line\">  &#125;, &#123;</span><br><span class=\"line\">    path: &#x27;profile&#x27;,</span><br><span class=\"line\">    components: &#123;</span><br><span class=\"line\">      default: UserProfile,</span><br><span class=\"line\">      helper: UserProfilePreview</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"重定向和别名\"><a href=\"#重定向和别名\" class=\"headerlink\" title=\"重定向和别名\"></a>重定向和别名</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">使用路由</span><br><span class=\"line\">const routes = [&#123; path: &#x27;/home&#x27;, redirect: &#x27;/&#x27; &#125;]</span><br><span class=\"line\"></span><br><span class=\"line\">使用命名的路由</span><br><span class=\"line\">const routes = [&#123; path: &#x27;/home&#x27;, redirect: &#123; name: &#x27;homepage&#x27; &#125; &#125;]</span><br><span class=\"line\"></span><br><span class=\"line\">通过一个方法，返回一个重定向目标</span><br><span class=\"line\">const routes = [</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    // /search/screens -&gt; /search?q=screens</span><br><span class=\"line\">    path: &#x27;/search/:searchText&#x27;,</span><br><span class=\"line\">    redirect: to =&gt; &#123;</span><br><span class=\"line\">      // 方法接收目标路由作为参数</span><br><span class=\"line\">      // return 重定向的字符串路径/路径对象</span><br><span class=\"line\">      return &#123; path: &#x27;/search&#x27;, query: &#123; q: to.params.searchText &#125; &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    path: &#x27;/search&#x27;,</span><br><span class=\"line\">    // ...</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n\n<p>​        请注意，**<a href=\"https://router.vuejs.org/zh/guide/advanced/navigation-guards.html\">导航守卫</a>并没有应用在跳转路由上，而仅仅应用在其目标上**。在上面的例子中，在 <code>/home</code> 路由中添加 <code>beforeEnter</code> 守卫不会有任何效果。</p>\n<p>​        在写 <code>redirect</code> 的时候，可以省略 <code>component</code> 配置，因为它从来没有被直接访问过，所以没有组件要渲染。唯一的例外是<a href=\"https://router.vuejs.org/zh/guide/essentials/nested-routes.html\">嵌套路由</a>：如果一个路由记录有 <code>children</code> 和 <code>redirect</code> 属性，它也应该有 <code>component</code> 属性。</p>\n<h3 id=\"相对重定向\"><a href=\"#相对重定向\" class=\"headerlink\" title=\"相对重定向\"></a>相对重定向</h3><p>​        也可以重定向到相对位置，这里没有理解</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const routes = [</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    path: &#x27;/users/:id/posts&#x27;,</span><br><span class=\"line\">    redirect: to =&gt; &#123;</span><br><span class=\"line\">      // 方法接收目标路由作为参数</span><br><span class=\"line\">      // return 重定向的字符串路径/路径对象</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"别名\"><a href=\"#别名\" class=\"headerlink\" title=\"别名\"></a>别名</h3><p>​        重定向是指当用户访问 <code>/home</code> 时，URL 会被 <code>/</code> 替换，然后匹配成 <code>/</code>。那么什么是别名呢？</p>\n<p>​         <strong>将 <code>/</code> 别名为 <code>/home</code>，意味着当用户访问 <code>/home</code> 时，URL 仍然是 <code>/home</code>，但会被匹配为用户正在访问 <code>/</code>。</strong> </p>\n<p>​        别名就是我从url输入的路径会在别名里面判断是否存在，简单来说就是我多次定义一个path不同，但是component相同等其他相同的一个意思，我们不需要这样重复编写，而是通过别名来进行处理。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const routes = [&#123; path: &#x27;/&#x27;, component: Homepage, alias: &#x27;/home&#x27; &#125;]</span><br></pre></td></tr></table></figure>\n\n<p>​        使别名以 <code>/</code> 开头，以使嵌套路径中的路径成为绝对路径。你甚至可以将两者结合起来，用一个数组提供多个别名：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const routes = [</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    path: &#x27;/users&#x27;,</span><br><span class=\"line\">    component: UsersLayout,</span><br><span class=\"line\">    children: [</span><br><span class=\"line\">      // 为这 3 个 URL 呈现 UserList</span><br><span class=\"line\">      // - /users</span><br><span class=\"line\">      // - /users/list</span><br><span class=\"line\">      // - /people</span><br><span class=\"line\">      // /people 是绝对路径， list 是相对路径</span><br><span class=\"line\">      &#123; path: &#x27;&#x27;, component: UserList, alias: [&#x27;/people&#x27;, &#x27;list&#x27;] &#125;,</span><br><span class=\"line\">    ],</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n\n<p>​        如果你的路由有参数，请确保在任何绝对别名中包含它们：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const routes = [</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    path: &#x27;/users/:id&#x27;,</span><br><span class=\"line\">    component: UsersByIdLayout,</span><br><span class=\"line\">    children: [</span><br><span class=\"line\">      // 为这 3 个 URL 呈现 UserDetails</span><br><span class=\"line\">      // - /users/24</span><br><span class=\"line\">      // - /users/24/profile</span><br><span class=\"line\">      // - /24</span><br><span class=\"line\">      &#123; path: &#x27;profile&#x27;, component: UserDetails, alias: [&#x27;/:id&#x27;, &#x27;&#x27;] &#125;,</span><br><span class=\"line\">    ],</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"路由组件传参\"><a href=\"#路由组件传参\" class=\"headerlink\" title=\"路由组件传参\"></a>路由组件传参</h2><h3 id=\"通过-props-true-传递给路由组件\"><a href=\"#通过-props-true-传递给路由组件\" class=\"headerlink\" title=\"通过 props:true 传递给路由组件\"></a>通过 props:true 传递给路由组件</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const User = &#123;</span><br><span class=\"line\">  props: [&#x27;id&#x27;],</span><br><span class=\"line\">  template: &#x27;&lt;div&gt;User &#123;&#123; id &#125;&#125;&lt;/div&gt;&#x27;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">const routes = [&#123; path: &#x27;/user/:id&#x27;, component: User, props: true &#125;]</span><br></pre></td></tr></table></figure>\n\n<p>​        那么此时，id 就会通过props传递给路由组件</p>\n<h3 id=\"命名视图-1\"><a href=\"#命名视图-1\" class=\"headerlink\" title=\"命名视图\"></a>命名视图</h3><p>​        对于有命名视图的路由，必须给props里面给每个命名视图定义配置</p>\n<ul>\n<li><p>如果直接使用 props: true，那么代表里面所有的都为true</p>\n</li>\n<li><p>否则就需要使用对象来对每个命名视图进行处理</p>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const routes = [</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    path: &#x27;/user/:id&#x27;,</span><br><span class=\"line\">    components: &#123; default: User, sidebar: Sidebar &#125;,</span><br><span class=\"line\">    props: &#123; default: true, sidebar: false &#125;</span><br><span class=\"line\">    // 所有的都为true</span><br><span class=\"line\">    // props: true</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"props使用对象\"><a href=\"#props使用对象\" class=\"headerlink\" title=\"props使用对象\"></a>props使用对象</h3><p>​        当 <code>props</code> 是一个对象时，它将原样设置为组件 props。当 props 是静态的时候很有用。</p>\n<p>​        就是说，使用的是对象的话，那么对象里面的内容就会作为props传递给路由组件。同时如果此时你的路由组件是携带了参数的。那么将不会传递给路由组件了。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const routes = [</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    path: &#x27;/promotion/from-newsletter&#x27;,</span><br><span class=\"line\">    component: Promotion,</span><br><span class=\"line\">    props: &#123; newsletterPopup: false &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"函数模式\"><a href=\"#函数模式\" class=\"headerlink\" title=\"函数模式\"></a>函数模式</h3><p>注意：</p>\n<ul>\n<li>对于函数，参数是route</li>\n<li>返回值，如果是 Boolean 值，并不会变成 props: true 这两个并不是一个意思。所以不会起作用。</li>\n<li>返回值，常是一个对象。然后按照对象的形式来处理</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const routes = [</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    path: &#x27;/search&#x27;,</span><br><span class=\"line\">    component: SearchUser,</span><br><span class=\"line\">    props: route =&gt; (&#123; query: route.query.q &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"不同的历史模式\"><a href=\"#不同的历史模式\" class=\"headerlink\" title=\"不同的历史模式\"></a>不同的历史模式</h2><h3 id=\"Hash模式\"><a href=\"#Hash模式\" class=\"headerlink\" title=\"Hash模式\"></a>Hash模式</h3><p>​        hash 模式是用 <code>createWebHashHistory()</code> 创建的：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#123; createRouter, createWebHashHistory &#125; from &#x27;vue-router&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">const router = createRouter(&#123;</span><br><span class=\"line\">  history: createWebHashHistory(),</span><br><span class=\"line\">  routes: [</span><br><span class=\"line\">    //...</span><br><span class=\"line\">  ],</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>​        hash模式就是通过在url后面使用一个hash字符 #。然后因为哈希字符并不会发送到服务器，所以不会出现找不到url的情况。但是对于 SEO 和 看来说，确实有点影响。</p>\n<h3 id=\"HTML5模式，history模式\"><a href=\"#HTML5模式，history模式\" class=\"headerlink\" title=\"HTML5模式，history模式\"></a>HTML5模式，history模式</h3><p>​        用 <code>createWebHistory()</code> 创建 HTML5 模式，推荐使用这个模式：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#123; createRouter, createWebHistory &#125; from &#x27;vue-router&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">const router = createRouter(&#123;</span><br><span class=\"line\">  history: createWebHistory(),</span><br><span class=\"line\">  routes: [</span><br><span class=\"line\">    //...</span><br><span class=\"line\">  ],</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>​        当使用这种历史模式时，URL 会看起来很 “正常”，例如 <code>https://example.com/user/id</code>。漂亮!</p>\n<p>​        不过，问题来了。由于我们的应用是一个单页的客户端应用，如果没有适当的服务器配置，用户在浏览器中直接访问 <code>https://example.com/user/id</code>，就会得到一个 404 错误。这就丑了。</p>\n<p>​        不用担心：要解决这个问题，你需要做的就是在你的服务器上添加一个简单的回退路由。如果 URL 不匹配任何静态资源，它应提供与你的应用程序中的 <code>index.html</code> 相同的页面。漂亮依旧!</p>\n<p>​        简单来说就是，因为history模式的 url 是不带hash，所以我们知道从一个浏览器里面输入一个正常的url，他会找到对应的服务器并发送请求，那么类似于这种的： <a href=\"https://example.com/usre/id\">https://example.com/usre/id</a> 他就会先进入对应的。</p>\n<h3 id=\"服务器配置实例\"><a href=\"#服务器配置实例\" class=\"headerlink\" title=\"服务器配置实例\"></a>服务器配置实例</h3><p>​        <strong>注意</strong>：以下示例假定你正在从根目录提供服务。如果你部署到子目录，你应该使用<a href=\"https://cli.vuejs.org/config/#publicpath\">Vue CLI 的 <code>publicPath</code> 配置</a>和相关的<a href=\"https://router.vuejs.org/zh/api/#createwebhistory\">路由器的 <code>base</code> 属性</a>。你还需要调整下面的例子，以使用子目录而不是根目录（例如，将<code>RewriteBase/</code> 替换为 <code>RewriteBase/name-of-your-subfolder/</code>）。</p>\n<h4 id=\"Apache\"><a href=\"#Apache\" class=\"headerlink\" title=\"Apache\"></a>Apache</h4><p>​        没有学过，可以说是完全看不懂了。</p>\n<p>​        也可以使用 <a href=\"https://httpd.apache.org/docs/2.2/mod/mod_dir.html#fallbackresource\"><code>FallbackResource</code></a> 代替 <code>mod_rewrite</code>。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;IfModule mod_rewrite.c&gt;</span><br><span class=\"line\">  RewriteEngine On</span><br><span class=\"line\">  RewriteBase /</span><br><span class=\"line\">  RewriteRule ^index\\.html$ - [L]</span><br><span class=\"line\">  RewriteCond %&#123;REQUEST_FILENAME&#125; !-f</span><br><span class=\"line\">  RewriteCond %&#123;REQUEST_FILENAME&#125; !-d</span><br><span class=\"line\">  RewriteRule . /index.html [L]</span><br><span class=\"line\">&lt;/IfModule&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"nginx\"><a href=\"#nginx\" class=\"headerlink\" title=\"nginx\"></a>nginx</h4><p>​        实不相瞒，nginx，我也没有学过。。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">location / &#123;</span><br><span class=\"line\">  try_files $uri $uri/ /index.html;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"原生-Node-js\"><a href=\"#原生-Node-js\" class=\"headerlink\" title=\"原生 Node.js\"></a>原生 Node.js</h4><p>​        简单来说，就是先建立监听。</p>\n<p>​        然后使用 createServer，这个方法就会将所有的请求都会进行处理了。无论是什么请求，都会进行一个处理。那么我们思考这个算是一个拦截吗，因为既然什么请求都可以进行处理。那么就可以先做一个请求的拦截。当然，这样写符不符合规范不清楚。但是确实做拦截应该是可以的。</p>\n<p>​        这里的内容就是，收到请求，然后将index文件里的内容进行读取，然后再通过写响应头，并将内容进行返回。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const http = require(&#x27;http&#x27;)</span><br><span class=\"line\">const fs = require(&#x27;fs&#x27;)</span><br><span class=\"line\">const httpPort = 80</span><br><span class=\"line\"></span><br><span class=\"line\">http</span><br><span class=\"line\">  .createServer((req, res) =&gt; &#123;</span><br><span class=\"line\">    fs.readFile(&#x27;index.html&#x27;, &#x27;utf-8&#x27;, (err, content) =&gt; &#123;</span><br><span class=\"line\">      if (err) &#123;</span><br><span class=\"line\">        console.log(&#x27;We cannot open &quot;index.html&quot; file.&#x27;)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      res.writeHead(200, &#123;</span><br><span class=\"line\">        &#x27;Content-Type&#x27;: &#x27;text/html; charset=utf-8&#x27;,</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">      res.end(content)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .listen(httpPort, () =&gt; &#123;</span><br><span class=\"line\">    console.log(&#x27;Server listening on: http://localhost:%s&#x27;, httpPort)</span><br><span class=\"line\">  &#125;)</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"Express-Node-js\"><a href=\"#Express-Node-js\" class=\"headerlink\" title=\"Express + Node.js\"></a>Express + Node.js</h4><p>​        对于 Node.js/Express，可以考虑使用 <a href=\"https://github.com/bripkens/connect-history-api-fallback\">connect-history-api-fallback 中间件</a>。</p>\n<p>后续还有很多其他的，但是因为其他的我连名字都没有听过了，所以就不写了，直接上官网链接。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://router.vuejs.org/zh/guide/essentials/history-mode.html</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"caveat\"><a href=\"#caveat\" class=\"headerlink\" title=\"caveat\"></a>caveat</h3><p>​        这有一个注意事项。你的服务器将不再报告 404 错误，因为现在所有未找到的路径都会显示你的 <code>index.html</code> 文件。为了解决这个问题，你应该在你的 Vue 应用程序中实现一个万能的路由来显示 404 页面。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const router = createRouter(&#123;</span><br><span class=\"line\">  history: createWebHistory(),</span><br><span class=\"line\">  routes: [&#123; path: &#x27;/:pathMatch(.*)&#x27;, component: NotFoundComponent &#125;],</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>​        另外，如果你使用的是 Node.js 服务器，你可以通过在服务器端使用路由器来匹配传入的 URL，如果没有匹配到路由，则用 404 来响应，从而实现回退。查看 <a href=\"https://v3.cn.vuejs.org/guide/ssr/introduction.html#what-is-server-side-rendering-ssr\">Vue 服务器端渲染文档</a>了解更多信息。</p>\n<p>​        这里，为什么使用 /:pathMatch(.*) 来匹配404呢，那是因为，这里路由的选择是一个按照分级来排名的。而这个写法的分数只有20分，基本可以说是，只有其他都匹配不上了，才会匹配上这个。</p>\n<p>​        所以常用这个来匹配404路由。</p>\n"},{"title":"router进阶","date":"2022-02-10T05:51:03.000Z","_content":"\n\n\n **router进阶学习**\n\n# 导航守卫\n\n​\t\t正如其名，vue-router 提供的导航守卫主要用来通过跳转或取消的方式守卫导航。这里有很多方式植入路由导航中：全局的，单个路由独享的，或者组件级的。\n\n\n\n## 全局前置守卫\n\n​\t\t你可以使用 `router.beforeEach` 注册一个全局前置守卫：\n\n```\nconst router = createRouter({ ... })\n\nrouter.beforeEach((to, from) => {\n  // ...\n  // 返回 false 以取消导航\n  return false\n})\n```\n\n​\t\t当一个导航触发时，全局前置守卫按照创建顺序调用。守卫是异步解析执行，此时导航在所有守卫 resolve 完之前一直处于**等待中**。\n\n​\t\t每个守卫方法接收两个参数：\n\n- **`to`**: 即将要进入的目标 [用一种标准化的方式](https://router.vuejs.org/zh/api/#routelocationnormalized)\n- **`from`**: 当前导航正要离开的路由 [用一种标准化的方式](https://router.vuejs.org/zh/api/#routelocationnormalized)\n\n​\t\t可以返回的值如下:\n\n- `false`: 取消当前的导航。如果浏览器的 URL 改变了(可能是用户手动或者浏览器后退按钮)，那么 URL 地址会重置到 `from` 路由对应的地址。\n- 一个[路由地址](https://router.vuejs.org/zh/api/#routelocationraw): 通过一个路由地址跳转到一个不同的地址，就像你调用 [`router.push()`](https://router.vuejs.org/zh/api/#push) 一样，你可以设置诸如 `replace: true` 或 `name: 'home'` 之类的配置。当前的导航被中断，然后进行一个新的导航，就和 `from` 一样。\n\n​\t\t如果遇到了意料之外的情况，可能会抛出一个 `Error`。这会取消导航并且调用 [`router.onError()`](https://router.vuejs.org/zh/api/#onerror) 注册过的回调。\n\n​\t\t如果什么都没有，`undefined` 或返回 `true`，**则导航是有效的**，并调用下一个导航守卫\n\n\n\n​\t\t以上所有都同 **`async` 函数** 和 Promise 工作方式一样：\n\n```\nrouter.beforeEach(async (to, from) => {\n  // canUserAccess() 返回 `true` 或 `false`\n  return await canUserAccess(to)\n})\n```\n\n\n\n### 可选参数 next\n\n​\t\t**确保 `next`** 在任何给定的导航守卫中都被**严格调用一次**。\n\n```\n// BAD\nrouter.beforeEach((to, from, next) => {\n  if (to.name !== 'Login' && !isAuthenticated) next({ name: 'Login' })\n  // 如果用户未能验证身份，则 `next` 会被调用两次\n  next()\n})\n```\n\n```\n// GOOD\nrouter.beforeEach((to, from, next) => {\n  if (to.name !== 'Login' && !isAuthenticated) next({ name: 'Login' })\n  else next()\n})\n```\n\n\n\n## 全局解析守卫\n\n​\t\t你可以用 `router.beforeResolve` 注册一个全局守卫。这和 `router.beforeEach` 类似，因为它在 **每次导航**时都会触发，但是确保在导航被确认之前，**同时在所有组件内守卫和异步路由组件被解析之后，解析守卫就被正确调用**。这里有一个例子，确保用户可以访问[自定义 meta](https://router.vuejs.org/zh/guide/advanced/meta.html) 属性 `requiresCamera` 的路由：\n\n```\nrouter.beforeResolve(async to => {\n  if (to.meta.requiresCamera) {\n    try {\n      await askForCameraPermission()\n    } catch (error) {\n      if (error instanceof NotAllowedError) {\n        // ... 处理错误，然后取消导航\n        return false\n      } else {\n        // 意料之外的错误，取消导航并把错误传给全局处理器\n        throw error\n      }\n    }\n  }\n})\n```\n\n​\t\t`router.beforeResolve` 是获取数据或执行任何其他操作（如果用户无法进入页面时你希望避免执行的操作）的理想位置。\n\n\n\n## 全局后置钩子\n\n​\t\t你也可以注册全局后置钩子，然而和守卫不同的是，这些钩子不会接受 `next` 函数也不会改变导航本身：\n\n```\nrouter.afterEach((to, from) => {\n  sendToAnalytics(to.fullPath)\n})\n```\n\n​\t\t它们对于分析、更改页面标题、声明页面等辅助功能以及许多其他事情都很有用。\n\n​\t\t它们也反映了 [navigation failures](https://router.vuejs.org/zh/guide/advanced/navigation-failures.html) 作为第三个参数：\n\n```\nrouter.afterEach((to, from, failure) => {\n  if (!failure) sendToAnalytics(to.fullPath)\n})\n```\n\n​\t\t**navigation failures 的属性** \n\n​\t\t所有导航失败都会公开`to`和`from`属性以反映当前位置以及失败导航的目标位置：\n\n```\n// trying to access the admin page\nrouter.push('/admin').then(failure => {\n  if (isNavigationFailure(failure, NavigationFailureType.redirected)) {\n    failure.to.path // '/admin'\n    failure.from.path // '/'\n  }\n})\n```\n\n\n\n## 路由独享的守卫\n\n​\t\t你可以直接在路由配置上定义 `beforeEnter` 守卫：\n\n```\nconst routes = [\n  {\n    path: '/users/:id',\n    component: UserDetails,\n    beforeEnter: (to, from) => {\n      // reject the navigation\n      return false\n    },\n  },\n]\n```\n\n​\t\t`beforeEnter` 守卫 **只在进入路由时触发**，不会在 `params`、`query` 或 `hash` 改变时触发。例如，从 `/users/2` 进入到 `/users/3` 或者从 `/users/2#info` 进入到 `/users/2#projects`。它们只有在 **从一个不同的** 路由导航时，才会被触发。\n\n​\t\t注意：\n\n* beforeEnter 是写在routes里面，而不是组件里面。\n* 其次触发时机就是进入路由的时候，但是如果没有离开路由就不会再次触发了。其中对于 参数的变化也是在路由之中的。\n* return 值的判定就是导航守卫的判定方法。\n\n​\t\t你也可以将一个函数数组传递给 `beforeEnter`，这在为不同的路由重用守卫时很有用：\n\n```\nfunction removeQueryParams(to) {\n  if (Object.keys(to.query).length)\n    return { path: to.path, query: {}, hash: to.hash }\n}\n\nfunction removeHash(to) {\n  if (to.hash) return { path: to.path, query: to.query, hash: '' }\n}\n\nconst routes = [\n  {\n    path: '/users/:id',\n    component: UserDetails,\n    beforeEnter: [removeQueryParams, removeHash],\n  },\n  {\n    path: '/about',\n    component: UserDetails,\n    beforeEnter: [removeQueryParams],\n  },\n]\n```\n\n​\t\t请注意，你也可以通过使用[路径 meta 字段](https://router.vuejs.org/zh/guide/advanced/meta.html)和[全局导航守卫](https://router.vuejs.org/zh/guide/advanced/navigation-guards.html#global-before-guards)来实现类似的行为。\n\n\n\n## 组件内的守卫\n\n​\t\t最后，你可以在路由组件内直接定义路由导航守卫(传递给路由配置的)\n\n### 可用的配置 API\n\n你可以为路由组件添加以下配置：\n\n- `beforeRouteEnter`\n- `beforeRouteUpdate`\n- `beforeRouteLeave`\n\n```\nconst UserDetails = {\n  template: `...`,\n  beforeRouteEnter(to, from) {\n    // 在渲染该组件的对应路由被验证前调用\n    // 不能获取组件实例 `this` ！\n    // 因为当守卫执行时，组件实例还没被创建！\n  },\n  beforeRouteUpdate(to, from) {\n    // 在当前路由改变，但是该组件被复用时调用\n    // 举例来说，对于一个带有动态参数的路径 `/users/:id`，在 `/users/1` 和 `/users/2` 之间跳转的时候，\n    // 由于会渲染同样的 `UserDetails` 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。\n    // 因为在这种情况发生的时候，组件已经挂载好了，导航守卫可以访问组件实例 `this`\n  },\n  beforeRouteLeave(to, from) {\n    // 在导航离开渲染该组件的对应路由时调用\n    // 与 `beforeRouteUpdate` 一样，它可以访问组件实例 `this`\n  },\n}\n```\n\n​\t\t`beforeRouteEnter` 守卫 **不能** 访问 `this`，因为守卫在导航确认前被调用，因此即将登场的新组件还没被创建。\n\n​\t\t不过，你可以通过传一个回调给 `next` 来访问组件实例。在导航被确认的时候执行回调，并且把组件实例作为回调方法的参数：\n\n```\nbeforeRouteEnter (to, from, next) {\n  next(vm => {\n    // 通过 `vm` 访问组件实例\n  })\n}\n```\n\n​\t\t注意 `beforeRouteEnter` 是支持给 `next` 传递回调的唯一守卫。对于 `beforeRouteUpdate` 和 `beforeRouteLeave` 来说，`this` 已经可用了，所以*不支持* 传递回调，因为没有必要了：\n\n```\nbeforeRouteUpdate (to, from) {\n  // just use `this`\n  this.name = to.params.name\n}\n```\n\n​\t\t这个 **离开守卫** 通常用来预防用户在还未保存修改前突然离开。该导航可以通过返回 `false` 来取消。\n\n```\nbeforeRouteLeave (to, from) {\n  const answer = window.confirm('Do you really want to leave? you have unsaved changes!')\n  if (!answer) return false\n}\n```\n\n\n\n### 使用组合式 API\n\n​\t\t如果你正在使用[组合 API 和 `setup` 函数](https://v3.vuejs.org/guide/composition-api-setup.html#setup)来编写组件，你可以通过 `onBeforeRouteUpdate` 和 `onBeforeRouteLeave` 分别添加 update 和 leave 守卫。 请参考[组合 API 部分](https://router.vuejs.org/zh/guide/advanced/composition-api.html#导航守卫)以获得更多细节。\n\n\n\n## 完整的导航解析流程\n\n* 导航被触发\n* 在失活的组件里调用 `beforeRouteLeave` 守卫。\n* 调用全局的 `beforeEach` 守卫。\n* 在重用的组件里调用 `beforeRouteUpdate` 守卫(2.2+)。\n* 在路由配置里调用 `beforeEnter`。\n* 解析异步路由组件。\n* 在被激活的组件里调用 `beforeRouteEnter`。\n* 调用全局的 `beforeResolve` 守卫(2.5+)。\n* 导航被确认。\n* 调用全局的 `afterEach` 钩子。\n* 触发 DOM 更新。\n* 调用 `beforeRouteEnter` 守卫中传给 `next` 的回调函数，创建好的组件实例会作为回调函数的参数传入。\n\n```\n\t触发导航，失活调用组件的routeleave，调用全局的beforeEach，重用组件调用routeUpdate，调用路由配置beforeEnter，调用routeEnter，调用全局beforeResolve，调用全局afterEach，调用routeEnter的next回调函数。\n```\n\n\n\n# 路由元信息\n\n​\t\t有时，你可能希望将任意信息附加到路由上，如过渡名称、谁可以访问路由等。这些事情可以通过接收属性对象的`meta`属性来实现，并且它可以在路由地址和导航守卫上都被访问到。定义路由的时候你可以这样配置 `meta` 字段：\n\n```\nconst routes = [\n  {\n    path: '/posts',\n    component: PostsLayout,\n    children: [\n      {\n        path: 'new',\n        component: PostsNew,\n        // 只有经过身份验证的用户才能创建帖子\n        meta: { requiresAuth: true }\n      },\n      {\n        path: ':id',\n        component: PostsDetail\n        // 任何人都可以阅读文章\n        meta: { requiresAuth: false }\n      }\n    ]\n  }\n]\n```\n\n​\t\t首先，我们称呼 `routes` 配置中的每个路由对象为 **路由记录**。路由记录可以是嵌套的，因此，当一个路由匹配成功后，它可能匹配多个路由记录。\n\n​\t\t例如，根据上面的路由配置，`/posts/new` 这个 URL 将会匹配父路由记录 (`path: '/posts'`) 以及子路由记录 (`path: 'new'`)。\n\n​\t\t一个路由匹配到的所有路由记录会暴露为 `$route` 对象(还有在导航守卫中的路由对象)的`$route.matched` 数组。我们需要遍历这个数组来检查路由记录中的 `meta` 字段，但是 Vue Router 还为你提供了一个 `$route.meta` 方法，它是一个非递归合并**所有 `meta`** 字段的（从父字段到子字段）的方法。这意味着你可以简单地写\n\n```\nrouter.beforeEach((to, from) => {\n  // 而不是去检查每条路由记录\n  // to.matched.some(record => record.meta.requiresAuth)\n  if (to.meta.requiresAuth && !auth.isLoggedIn()) {\n    // 此路由需要授权，请检查是否已登录\n    // 如果没有，则重定向到登录页面\n    return {\n      path: '/login',\n      // 保存我们所在的位置，以便以后再来\n      query: { redirect: to.fullPath },\n    }\n  }\n})\n```\n\n​\t\tmatched 里面的值的path是一个路由定义的样子(/about/:id) 而不是实际的url路由值。\n\n\n\n## TypeScript\n\n​\t\t可以通过扩展 `RouteMeta` 接口来输入 meta 字段：\n\n```\n// typings.d.ts or router.ts\nimport 'vue-router'\n\ndeclare module 'vue-router' {\n  interface RouteMeta {\n    // 是可选的\n    isAdmin?: boolean\n    // 每个路由都必须声明\n    requiresAuth: boolean\n  }\n}\n```\n\n\n\n# 数据获取\n\n​\t\t有时候，进入某个路由后，需要从服务器获取数据。例如，在渲染用户信息时，你需要从服务器获取用户的数据。我们可以通过两种方式来实现：\n\n- **导航完成之后获取**：先完成导航，然后在接下来的组件生命周期钩子中获取数据。在数据获取期间显示“加载中”之类的指示。\n- **导航完成之前获取**：导航完成前，在路由进入的守卫中获取数据，在数据获取成功后执行导航。\n\n​\t\t从技术角度讲，两种方式都不错 —— 就看你想要的用户体验是哪种。\n\n## 导航完成后获取数据\n\n​\t\t当你使用这种方式时，我们会马上导航和渲染组件，然后在组件的 created 钩子中获取数据。这让我们有机会在数据获取期间展示一个 loading 状态，还可以在不同视图间展示不同的 loading 状态。\n\n```\n<template>\n  <div class=\"post\">\n    <div v-if=\"loading\" class=\"loading\">Loading...</div>\n\n    <div v-if=\"error\" class=\"error\">{{ error }}</div>\n\n    <div v-if=\"post\" class=\"content\">\n      <h2>{{ post.title }}</h2>\n      <p>{{ post.body }}</p>\n    </div>\n  </div>\n</template>\n```\n\n```\nexport default {\n  data() {\n    return {\n      loading: false,\n      post: null,\n      error: null,\n    }\n  },\n  created() {\n    // watch 路由的参数，以便再次获取数据\n    this.$watch(\n      () => this.$route.params,\n      () => {\n        this.fetchData()\n      },\n      // 组件创建完后获取数据，\n      // 此时 data 已经被 observed 了\n      { immediate: true }\n    )\n  },\n  methods: {\n    fetchData() {\n      this.error = this.post = null\n      this.loading = true\n      // replace `getPost` with your data fetching util / API wrapper\n      // 用你的数据获取 util 或 API 替换 `getPost`\n      getPost(this.$route.params.id, (err, post) => {\n        this.loading = false\n        if (err) {\n          this.error = err.toString()\n        } else {\n          this.post = post\n        }\n      })\n    },\n  },\n}\n```\n\n​\t\t简单来说就是创建了 loading error post 三个状态，然后再created的时候创建监听（理由是创建的监听参数的变化，可以重复触发。否则在参数变化时使用的复用将不会触发改变。）使用 immediate 为true，立刻触发。再调用fetch方法。然后再进行调用时设置post，error为null，作用是避免复用的影响，设置loading为true，然后便是正常的获取数据并显示了。\n\n\n\n## 导航完成前获取数据\n\n​\t\t通过这种方式，我们在导航转入新的路由前获取数据。我们可以在接下来的组件的 `beforeRouteEnter` 守卫中获取数据，当数据获取成功后只调用 `next` 方法：\n\n```\nexport default {\n  data() {\n    return {\n      post: null,\n      error: null,\n    }\n  },\n  beforeRouteEnter(to, from, next) {\n    getPost(to.params.id, (err, post) => {\n      next(vm => vm.setData(err, post))\n    })\n  },\n  // 路由改变前，组件就已经渲染完了\n  // 逻辑稍稍不同\n  async beforeRouteUpdate(to, from) {\n    this.post = null\n    try {\n      this.post = await getPost(to.params.id)\n    } catch (error) {\n      this.error = error.toString()\n    }\n  },\n}\n```\n\n​\t\t这个就是在 beforeRouteEnter里面调用了异步请求，然后再获取到数据之后将数据使用next回调进行调用。同时再beforeRouteUpdate进行更新时使用了es6的async 和 await方法。同时设置this.post为null，然后在调用getPost方法获取数据返回给post。\n\n​\t\t在为后面的视图获取数据时，用户会停留在当前的界面，因此建议在数据获取期间，显示一些进度条或者别的指示。如果数据获取失败，同样有必要展示一些全局的错误提醒。\n\n\n\n# 组合式API\n\n## 在 setup 中访问路由和当前路由\n\n​\t\t因为我们在 `setup` 里面没有访问 `this`，所以我们不能再直接访问 `this.$router` 或 `this.$route`。作为替代，我们使用 `useRouter` 函数：\n\n```\nimport { useRouter, useRoute } from 'vue-router'\n\nexport default {\n  setup() {\n  \t// useRouter 和 useRoute 是一个方法。返回一个route 和 router 的一个对象\n  \t// route 是当前路由的信息， router 主要是原型的方法。和 全局路由信息。\n    const router = useRouter()\n    const route = useRoute()\n\n\t// \n    function pushWithQuery(query) {\n      router.push({\n        name: 'search',\n        query: {\n          ...route.query,\n        },\n      })\n    }\n  },\n}\n```\n\n​\t\t`route` 对象是一个响应式对象，所以它的任何属性都可以被监听，但你应该**避免监听整个 `route`** 对象：\n\n```\nimport { useRoute } from 'vue-router'\n\nexport default {\n  setup() {\n    const route = useRoute()\n    const userData = ref()\n\n    // 当参数更改时获取用户信息\n    watch(\n      () => route.params,\n      async newParams => {\n        userData.value = await fetchUser(newParams.id)\n      }\n    )\n  },\n}\n```\n\n​\t\t请注意，在模板中我们仍然可以访问 `$router` 和 `$route`，所以不需要在 `setup` 中返回 `router` 或 `route`。\n\n\n\n## 导航守卫\n\n​\t\t\n\n\n\n\n\n\n\n\n\n\n\n","source":"_drafts/router/router进阶.md","raw":"---\ntitle: router进阶\ndate: 2022-02-10 13:51:03\ntags:\n - router\ncategories:\n - router\n---\n\n\n\n **router进阶学习**\n\n# 导航守卫\n\n​\t\t正如其名，vue-router 提供的导航守卫主要用来通过跳转或取消的方式守卫导航。这里有很多方式植入路由导航中：全局的，单个路由独享的，或者组件级的。\n\n\n\n## 全局前置守卫\n\n​\t\t你可以使用 `router.beforeEach` 注册一个全局前置守卫：\n\n```\nconst router = createRouter({ ... })\n\nrouter.beforeEach((to, from) => {\n  // ...\n  // 返回 false 以取消导航\n  return false\n})\n```\n\n​\t\t当一个导航触发时，全局前置守卫按照创建顺序调用。守卫是异步解析执行，此时导航在所有守卫 resolve 完之前一直处于**等待中**。\n\n​\t\t每个守卫方法接收两个参数：\n\n- **`to`**: 即将要进入的目标 [用一种标准化的方式](https://router.vuejs.org/zh/api/#routelocationnormalized)\n- **`from`**: 当前导航正要离开的路由 [用一种标准化的方式](https://router.vuejs.org/zh/api/#routelocationnormalized)\n\n​\t\t可以返回的值如下:\n\n- `false`: 取消当前的导航。如果浏览器的 URL 改变了(可能是用户手动或者浏览器后退按钮)，那么 URL 地址会重置到 `from` 路由对应的地址。\n- 一个[路由地址](https://router.vuejs.org/zh/api/#routelocationraw): 通过一个路由地址跳转到一个不同的地址，就像你调用 [`router.push()`](https://router.vuejs.org/zh/api/#push) 一样，你可以设置诸如 `replace: true` 或 `name: 'home'` 之类的配置。当前的导航被中断，然后进行一个新的导航，就和 `from` 一样。\n\n​\t\t如果遇到了意料之外的情况，可能会抛出一个 `Error`。这会取消导航并且调用 [`router.onError()`](https://router.vuejs.org/zh/api/#onerror) 注册过的回调。\n\n​\t\t如果什么都没有，`undefined` 或返回 `true`，**则导航是有效的**，并调用下一个导航守卫\n\n\n\n​\t\t以上所有都同 **`async` 函数** 和 Promise 工作方式一样：\n\n```\nrouter.beforeEach(async (to, from) => {\n  // canUserAccess() 返回 `true` 或 `false`\n  return await canUserAccess(to)\n})\n```\n\n\n\n### 可选参数 next\n\n​\t\t**确保 `next`** 在任何给定的导航守卫中都被**严格调用一次**。\n\n```\n// BAD\nrouter.beforeEach((to, from, next) => {\n  if (to.name !== 'Login' && !isAuthenticated) next({ name: 'Login' })\n  // 如果用户未能验证身份，则 `next` 会被调用两次\n  next()\n})\n```\n\n```\n// GOOD\nrouter.beforeEach((to, from, next) => {\n  if (to.name !== 'Login' && !isAuthenticated) next({ name: 'Login' })\n  else next()\n})\n```\n\n\n\n## 全局解析守卫\n\n​\t\t你可以用 `router.beforeResolve` 注册一个全局守卫。这和 `router.beforeEach` 类似，因为它在 **每次导航**时都会触发，但是确保在导航被确认之前，**同时在所有组件内守卫和异步路由组件被解析之后，解析守卫就被正确调用**。这里有一个例子，确保用户可以访问[自定义 meta](https://router.vuejs.org/zh/guide/advanced/meta.html) 属性 `requiresCamera` 的路由：\n\n```\nrouter.beforeResolve(async to => {\n  if (to.meta.requiresCamera) {\n    try {\n      await askForCameraPermission()\n    } catch (error) {\n      if (error instanceof NotAllowedError) {\n        // ... 处理错误，然后取消导航\n        return false\n      } else {\n        // 意料之外的错误，取消导航并把错误传给全局处理器\n        throw error\n      }\n    }\n  }\n})\n```\n\n​\t\t`router.beforeResolve` 是获取数据或执行任何其他操作（如果用户无法进入页面时你希望避免执行的操作）的理想位置。\n\n\n\n## 全局后置钩子\n\n​\t\t你也可以注册全局后置钩子，然而和守卫不同的是，这些钩子不会接受 `next` 函数也不会改变导航本身：\n\n```\nrouter.afterEach((to, from) => {\n  sendToAnalytics(to.fullPath)\n})\n```\n\n​\t\t它们对于分析、更改页面标题、声明页面等辅助功能以及许多其他事情都很有用。\n\n​\t\t它们也反映了 [navigation failures](https://router.vuejs.org/zh/guide/advanced/navigation-failures.html) 作为第三个参数：\n\n```\nrouter.afterEach((to, from, failure) => {\n  if (!failure) sendToAnalytics(to.fullPath)\n})\n```\n\n​\t\t**navigation failures 的属性** \n\n​\t\t所有导航失败都会公开`to`和`from`属性以反映当前位置以及失败导航的目标位置：\n\n```\n// trying to access the admin page\nrouter.push('/admin').then(failure => {\n  if (isNavigationFailure(failure, NavigationFailureType.redirected)) {\n    failure.to.path // '/admin'\n    failure.from.path // '/'\n  }\n})\n```\n\n\n\n## 路由独享的守卫\n\n​\t\t你可以直接在路由配置上定义 `beforeEnter` 守卫：\n\n```\nconst routes = [\n  {\n    path: '/users/:id',\n    component: UserDetails,\n    beforeEnter: (to, from) => {\n      // reject the navigation\n      return false\n    },\n  },\n]\n```\n\n​\t\t`beforeEnter` 守卫 **只在进入路由时触发**，不会在 `params`、`query` 或 `hash` 改变时触发。例如，从 `/users/2` 进入到 `/users/3` 或者从 `/users/2#info` 进入到 `/users/2#projects`。它们只有在 **从一个不同的** 路由导航时，才会被触发。\n\n​\t\t注意：\n\n* beforeEnter 是写在routes里面，而不是组件里面。\n* 其次触发时机就是进入路由的时候，但是如果没有离开路由就不会再次触发了。其中对于 参数的变化也是在路由之中的。\n* return 值的判定就是导航守卫的判定方法。\n\n​\t\t你也可以将一个函数数组传递给 `beforeEnter`，这在为不同的路由重用守卫时很有用：\n\n```\nfunction removeQueryParams(to) {\n  if (Object.keys(to.query).length)\n    return { path: to.path, query: {}, hash: to.hash }\n}\n\nfunction removeHash(to) {\n  if (to.hash) return { path: to.path, query: to.query, hash: '' }\n}\n\nconst routes = [\n  {\n    path: '/users/:id',\n    component: UserDetails,\n    beforeEnter: [removeQueryParams, removeHash],\n  },\n  {\n    path: '/about',\n    component: UserDetails,\n    beforeEnter: [removeQueryParams],\n  },\n]\n```\n\n​\t\t请注意，你也可以通过使用[路径 meta 字段](https://router.vuejs.org/zh/guide/advanced/meta.html)和[全局导航守卫](https://router.vuejs.org/zh/guide/advanced/navigation-guards.html#global-before-guards)来实现类似的行为。\n\n\n\n## 组件内的守卫\n\n​\t\t最后，你可以在路由组件内直接定义路由导航守卫(传递给路由配置的)\n\n### 可用的配置 API\n\n你可以为路由组件添加以下配置：\n\n- `beforeRouteEnter`\n- `beforeRouteUpdate`\n- `beforeRouteLeave`\n\n```\nconst UserDetails = {\n  template: `...`,\n  beforeRouteEnter(to, from) {\n    // 在渲染该组件的对应路由被验证前调用\n    // 不能获取组件实例 `this` ！\n    // 因为当守卫执行时，组件实例还没被创建！\n  },\n  beforeRouteUpdate(to, from) {\n    // 在当前路由改变，但是该组件被复用时调用\n    // 举例来说，对于一个带有动态参数的路径 `/users/:id`，在 `/users/1` 和 `/users/2` 之间跳转的时候，\n    // 由于会渲染同样的 `UserDetails` 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。\n    // 因为在这种情况发生的时候，组件已经挂载好了，导航守卫可以访问组件实例 `this`\n  },\n  beforeRouteLeave(to, from) {\n    // 在导航离开渲染该组件的对应路由时调用\n    // 与 `beforeRouteUpdate` 一样，它可以访问组件实例 `this`\n  },\n}\n```\n\n​\t\t`beforeRouteEnter` 守卫 **不能** 访问 `this`，因为守卫在导航确认前被调用，因此即将登场的新组件还没被创建。\n\n​\t\t不过，你可以通过传一个回调给 `next` 来访问组件实例。在导航被确认的时候执行回调，并且把组件实例作为回调方法的参数：\n\n```\nbeforeRouteEnter (to, from, next) {\n  next(vm => {\n    // 通过 `vm` 访问组件实例\n  })\n}\n```\n\n​\t\t注意 `beforeRouteEnter` 是支持给 `next` 传递回调的唯一守卫。对于 `beforeRouteUpdate` 和 `beforeRouteLeave` 来说，`this` 已经可用了，所以*不支持* 传递回调，因为没有必要了：\n\n```\nbeforeRouteUpdate (to, from) {\n  // just use `this`\n  this.name = to.params.name\n}\n```\n\n​\t\t这个 **离开守卫** 通常用来预防用户在还未保存修改前突然离开。该导航可以通过返回 `false` 来取消。\n\n```\nbeforeRouteLeave (to, from) {\n  const answer = window.confirm('Do you really want to leave? you have unsaved changes!')\n  if (!answer) return false\n}\n```\n\n\n\n### 使用组合式 API\n\n​\t\t如果你正在使用[组合 API 和 `setup` 函数](https://v3.vuejs.org/guide/composition-api-setup.html#setup)来编写组件，你可以通过 `onBeforeRouteUpdate` 和 `onBeforeRouteLeave` 分别添加 update 和 leave 守卫。 请参考[组合 API 部分](https://router.vuejs.org/zh/guide/advanced/composition-api.html#导航守卫)以获得更多细节。\n\n\n\n## 完整的导航解析流程\n\n* 导航被触发\n* 在失活的组件里调用 `beforeRouteLeave` 守卫。\n* 调用全局的 `beforeEach` 守卫。\n* 在重用的组件里调用 `beforeRouteUpdate` 守卫(2.2+)。\n* 在路由配置里调用 `beforeEnter`。\n* 解析异步路由组件。\n* 在被激活的组件里调用 `beforeRouteEnter`。\n* 调用全局的 `beforeResolve` 守卫(2.5+)。\n* 导航被确认。\n* 调用全局的 `afterEach` 钩子。\n* 触发 DOM 更新。\n* 调用 `beforeRouteEnter` 守卫中传给 `next` 的回调函数，创建好的组件实例会作为回调函数的参数传入。\n\n```\n\t触发导航，失活调用组件的routeleave，调用全局的beforeEach，重用组件调用routeUpdate，调用路由配置beforeEnter，调用routeEnter，调用全局beforeResolve，调用全局afterEach，调用routeEnter的next回调函数。\n```\n\n\n\n# 路由元信息\n\n​\t\t有时，你可能希望将任意信息附加到路由上，如过渡名称、谁可以访问路由等。这些事情可以通过接收属性对象的`meta`属性来实现，并且它可以在路由地址和导航守卫上都被访问到。定义路由的时候你可以这样配置 `meta` 字段：\n\n```\nconst routes = [\n  {\n    path: '/posts',\n    component: PostsLayout,\n    children: [\n      {\n        path: 'new',\n        component: PostsNew,\n        // 只有经过身份验证的用户才能创建帖子\n        meta: { requiresAuth: true }\n      },\n      {\n        path: ':id',\n        component: PostsDetail\n        // 任何人都可以阅读文章\n        meta: { requiresAuth: false }\n      }\n    ]\n  }\n]\n```\n\n​\t\t首先，我们称呼 `routes` 配置中的每个路由对象为 **路由记录**。路由记录可以是嵌套的，因此，当一个路由匹配成功后，它可能匹配多个路由记录。\n\n​\t\t例如，根据上面的路由配置，`/posts/new` 这个 URL 将会匹配父路由记录 (`path: '/posts'`) 以及子路由记录 (`path: 'new'`)。\n\n​\t\t一个路由匹配到的所有路由记录会暴露为 `$route` 对象(还有在导航守卫中的路由对象)的`$route.matched` 数组。我们需要遍历这个数组来检查路由记录中的 `meta` 字段，但是 Vue Router 还为你提供了一个 `$route.meta` 方法，它是一个非递归合并**所有 `meta`** 字段的（从父字段到子字段）的方法。这意味着你可以简单地写\n\n```\nrouter.beforeEach((to, from) => {\n  // 而不是去检查每条路由记录\n  // to.matched.some(record => record.meta.requiresAuth)\n  if (to.meta.requiresAuth && !auth.isLoggedIn()) {\n    // 此路由需要授权，请检查是否已登录\n    // 如果没有，则重定向到登录页面\n    return {\n      path: '/login',\n      // 保存我们所在的位置，以便以后再来\n      query: { redirect: to.fullPath },\n    }\n  }\n})\n```\n\n​\t\tmatched 里面的值的path是一个路由定义的样子(/about/:id) 而不是实际的url路由值。\n\n\n\n## TypeScript\n\n​\t\t可以通过扩展 `RouteMeta` 接口来输入 meta 字段：\n\n```\n// typings.d.ts or router.ts\nimport 'vue-router'\n\ndeclare module 'vue-router' {\n  interface RouteMeta {\n    // 是可选的\n    isAdmin?: boolean\n    // 每个路由都必须声明\n    requiresAuth: boolean\n  }\n}\n```\n\n\n\n# 数据获取\n\n​\t\t有时候，进入某个路由后，需要从服务器获取数据。例如，在渲染用户信息时，你需要从服务器获取用户的数据。我们可以通过两种方式来实现：\n\n- **导航完成之后获取**：先完成导航，然后在接下来的组件生命周期钩子中获取数据。在数据获取期间显示“加载中”之类的指示。\n- **导航完成之前获取**：导航完成前，在路由进入的守卫中获取数据，在数据获取成功后执行导航。\n\n​\t\t从技术角度讲，两种方式都不错 —— 就看你想要的用户体验是哪种。\n\n## 导航完成后获取数据\n\n​\t\t当你使用这种方式时，我们会马上导航和渲染组件，然后在组件的 created 钩子中获取数据。这让我们有机会在数据获取期间展示一个 loading 状态，还可以在不同视图间展示不同的 loading 状态。\n\n```\n<template>\n  <div class=\"post\">\n    <div v-if=\"loading\" class=\"loading\">Loading...</div>\n\n    <div v-if=\"error\" class=\"error\">{{ error }}</div>\n\n    <div v-if=\"post\" class=\"content\">\n      <h2>{{ post.title }}</h2>\n      <p>{{ post.body }}</p>\n    </div>\n  </div>\n</template>\n```\n\n```\nexport default {\n  data() {\n    return {\n      loading: false,\n      post: null,\n      error: null,\n    }\n  },\n  created() {\n    // watch 路由的参数，以便再次获取数据\n    this.$watch(\n      () => this.$route.params,\n      () => {\n        this.fetchData()\n      },\n      // 组件创建完后获取数据，\n      // 此时 data 已经被 observed 了\n      { immediate: true }\n    )\n  },\n  methods: {\n    fetchData() {\n      this.error = this.post = null\n      this.loading = true\n      // replace `getPost` with your data fetching util / API wrapper\n      // 用你的数据获取 util 或 API 替换 `getPost`\n      getPost(this.$route.params.id, (err, post) => {\n        this.loading = false\n        if (err) {\n          this.error = err.toString()\n        } else {\n          this.post = post\n        }\n      })\n    },\n  },\n}\n```\n\n​\t\t简单来说就是创建了 loading error post 三个状态，然后再created的时候创建监听（理由是创建的监听参数的变化，可以重复触发。否则在参数变化时使用的复用将不会触发改变。）使用 immediate 为true，立刻触发。再调用fetch方法。然后再进行调用时设置post，error为null，作用是避免复用的影响，设置loading为true，然后便是正常的获取数据并显示了。\n\n\n\n## 导航完成前获取数据\n\n​\t\t通过这种方式，我们在导航转入新的路由前获取数据。我们可以在接下来的组件的 `beforeRouteEnter` 守卫中获取数据，当数据获取成功后只调用 `next` 方法：\n\n```\nexport default {\n  data() {\n    return {\n      post: null,\n      error: null,\n    }\n  },\n  beforeRouteEnter(to, from, next) {\n    getPost(to.params.id, (err, post) => {\n      next(vm => vm.setData(err, post))\n    })\n  },\n  // 路由改变前，组件就已经渲染完了\n  // 逻辑稍稍不同\n  async beforeRouteUpdate(to, from) {\n    this.post = null\n    try {\n      this.post = await getPost(to.params.id)\n    } catch (error) {\n      this.error = error.toString()\n    }\n  },\n}\n```\n\n​\t\t这个就是在 beforeRouteEnter里面调用了异步请求，然后再获取到数据之后将数据使用next回调进行调用。同时再beforeRouteUpdate进行更新时使用了es6的async 和 await方法。同时设置this.post为null，然后在调用getPost方法获取数据返回给post。\n\n​\t\t在为后面的视图获取数据时，用户会停留在当前的界面，因此建议在数据获取期间，显示一些进度条或者别的指示。如果数据获取失败，同样有必要展示一些全局的错误提醒。\n\n\n\n# 组合式API\n\n## 在 setup 中访问路由和当前路由\n\n​\t\t因为我们在 `setup` 里面没有访问 `this`，所以我们不能再直接访问 `this.$router` 或 `this.$route`。作为替代，我们使用 `useRouter` 函数：\n\n```\nimport { useRouter, useRoute } from 'vue-router'\n\nexport default {\n  setup() {\n  \t// useRouter 和 useRoute 是一个方法。返回一个route 和 router 的一个对象\n  \t// route 是当前路由的信息， router 主要是原型的方法。和 全局路由信息。\n    const router = useRouter()\n    const route = useRoute()\n\n\t// \n    function pushWithQuery(query) {\n      router.push({\n        name: 'search',\n        query: {\n          ...route.query,\n        },\n      })\n    }\n  },\n}\n```\n\n​\t\t`route` 对象是一个响应式对象，所以它的任何属性都可以被监听，但你应该**避免监听整个 `route`** 对象：\n\n```\nimport { useRoute } from 'vue-router'\n\nexport default {\n  setup() {\n    const route = useRoute()\n    const userData = ref()\n\n    // 当参数更改时获取用户信息\n    watch(\n      () => route.params,\n      async newParams => {\n        userData.value = await fetchUser(newParams.id)\n      }\n    )\n  },\n}\n```\n\n​\t\t请注意，在模板中我们仍然可以访问 `$router` 和 `$route`，所以不需要在 `setup` 中返回 `router` 或 `route`。\n\n\n\n## 导航守卫\n\n​\t\t\n\n\n\n\n\n\n\n\n\n\n\n","slug":"router/router进阶","published":0,"updated":"2022-02-14T10:39:56.847Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckznhkk78000uikubac8w7vkl","content":"<p> <strong>router进阶学习</strong></p>\n<h1 id=\"导航守卫\"><a href=\"#导航守卫\" class=\"headerlink\" title=\"导航守卫\"></a>导航守卫</h1><p>​        正如其名，vue-router 提供的导航守卫主要用来通过跳转或取消的方式守卫导航。这里有很多方式植入路由导航中：全局的，单个路由独享的，或者组件级的。</p>\n<h2 id=\"全局前置守卫\"><a href=\"#全局前置守卫\" class=\"headerlink\" title=\"全局前置守卫\"></a>全局前置守卫</h2><p>​        你可以使用 <code>router.beforeEach</code> 注册一个全局前置守卫：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const router = createRouter(&#123; ... &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">router.beforeEach((to, from) =&gt; &#123;</span><br><span class=\"line\">  // ...</span><br><span class=\"line\">  // 返回 false 以取消导航</span><br><span class=\"line\">  return false</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>​        当一个导航触发时，全局前置守卫按照创建顺序调用。守卫是异步解析执行，此时导航在所有守卫 resolve 完之前一直处于<strong>等待中</strong>。</p>\n<p>​        每个守卫方法接收两个参数：</p>\n<ul>\n<li><strong><code>to</code></strong>: 即将要进入的目标 <a href=\"https://router.vuejs.org/zh/api/#routelocationnormalized\">用一种标准化的方式</a></li>\n<li><strong><code>from</code></strong>: 当前导航正要离开的路由 <a href=\"https://router.vuejs.org/zh/api/#routelocationnormalized\">用一种标准化的方式</a></li>\n</ul>\n<p>​        可以返回的值如下:</p>\n<ul>\n<li><code>false</code>: 取消当前的导航。如果浏览器的 URL 改变了(可能是用户手动或者浏览器后退按钮)，那么 URL 地址会重置到 <code>from</code> 路由对应的地址。</li>\n<li>一个<a href=\"https://router.vuejs.org/zh/api/#routelocationraw\">路由地址</a>: 通过一个路由地址跳转到一个不同的地址，就像你调用 <a href=\"https://router.vuejs.org/zh/api/#push\"><code>router.push()</code></a> 一样，你可以设置诸如 <code>replace: true</code> 或 <code>name: &#39;home&#39;</code> 之类的配置。当前的导航被中断，然后进行一个新的导航，就和 <code>from</code> 一样。</li>\n</ul>\n<p>​        如果遇到了意料之外的情况，可能会抛出一个 <code>Error</code>。这会取消导航并且调用 <a href=\"https://router.vuejs.org/zh/api/#onerror\"><code>router.onError()</code></a> 注册过的回调。</p>\n<p>​        如果什么都没有，<code>undefined</code> 或返回 <code>true</code>，<strong>则导航是有效的</strong>，并调用下一个导航守卫</p>\n<p>​        以上所有都同 <strong><code>async</code> 函数</strong> 和 Promise 工作方式一样：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">router.beforeEach(async (to, from) =&gt; &#123;</span><br><span class=\"line\">  // canUserAccess() 返回 `true` 或 `false`</span><br><span class=\"line\">  return await canUserAccess(to)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"可选参数-next\"><a href=\"#可选参数-next\" class=\"headerlink\" title=\"可选参数 next\"></a>可选参数 next</h3><p>​        <strong>确保 <code>next</code></strong> 在任何给定的导航守卫中都被<strong>严格调用一次</strong>。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// BAD</span><br><span class=\"line\">router.beforeEach((to, from, next) =&gt; &#123;</span><br><span class=\"line\">  if (to.name !== &#x27;Login&#x27; &amp;&amp; !isAuthenticated) next(&#123; name: &#x27;Login&#x27; &#125;)</span><br><span class=\"line\">  // 如果用户未能验证身份，则 `next` 会被调用两次</span><br><span class=\"line\">  next()</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// GOOD</span><br><span class=\"line\">router.beforeEach((to, from, next) =&gt; &#123;</span><br><span class=\"line\">  if (to.name !== &#x27;Login&#x27; &amp;&amp; !isAuthenticated) next(&#123; name: &#x27;Login&#x27; &#125;)</span><br><span class=\"line\">  else next()</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"全局解析守卫\"><a href=\"#全局解析守卫\" class=\"headerlink\" title=\"全局解析守卫\"></a>全局解析守卫</h2><p>​        你可以用 <code>router.beforeResolve</code> 注册一个全局守卫。这和 <code>router.beforeEach</code> 类似，因为它在 <strong>每次导航</strong>时都会触发，但是确保在导航被确认之前，<strong>同时在所有组件内守卫和异步路由组件被解析之后，解析守卫就被正确调用</strong>。这里有一个例子，确保用户可以访问<a href=\"https://router.vuejs.org/zh/guide/advanced/meta.html\">自定义 meta</a> 属性 <code>requiresCamera</code> 的路由：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">router.beforeResolve(async to =&gt; &#123;</span><br><span class=\"line\">  if (to.meta.requiresCamera) &#123;</span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">      await askForCameraPermission()</span><br><span class=\"line\">    &#125; catch (error) &#123;</span><br><span class=\"line\">      if (error instanceof NotAllowedError) &#123;</span><br><span class=\"line\">        // ... 处理错误，然后取消导航</span><br><span class=\"line\">        return false</span><br><span class=\"line\">      &#125; else &#123;</span><br><span class=\"line\">        // 意料之外的错误，取消导航并把错误传给全局处理器</span><br><span class=\"line\">        throw error</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>​        <code>router.beforeResolve</code> 是获取数据或执行任何其他操作（如果用户无法进入页面时你希望避免执行的操作）的理想位置。</p>\n<h2 id=\"全局后置钩子\"><a href=\"#全局后置钩子\" class=\"headerlink\" title=\"全局后置钩子\"></a>全局后置钩子</h2><p>​        你也可以注册全局后置钩子，然而和守卫不同的是，这些钩子不会接受 <code>next</code> 函数也不会改变导航本身：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">router.afterEach((to, from) =&gt; &#123;</span><br><span class=\"line\">  sendToAnalytics(to.fullPath)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>​        它们对于分析、更改页面标题、声明页面等辅助功能以及许多其他事情都很有用。</p>\n<p>​        它们也反映了 <a href=\"https://router.vuejs.org/zh/guide/advanced/navigation-failures.html\">navigation failures</a> 作为第三个参数：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">router.afterEach((to, from, failure) =&gt; &#123;</span><br><span class=\"line\">  if (!failure) sendToAnalytics(to.fullPath)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>​        <strong>navigation failures 的属性</strong> </p>\n<p>​        所有导航失败都会公开<code>to</code>和<code>from</code>属性以反映当前位置以及失败导航的目标位置：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// trying to access the admin page</span><br><span class=\"line\">router.push(&#x27;/admin&#x27;).then(failure =&gt; &#123;</span><br><span class=\"line\">  if (isNavigationFailure(failure, NavigationFailureType.redirected)) &#123;</span><br><span class=\"line\">    failure.to.path // &#x27;/admin&#x27;</span><br><span class=\"line\">    failure.from.path // &#x27;/&#x27;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"路由独享的守卫\"><a href=\"#路由独享的守卫\" class=\"headerlink\" title=\"路由独享的守卫\"></a>路由独享的守卫</h2><p>​        你可以直接在路由配置上定义 <code>beforeEnter</code> 守卫：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const routes = [</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    path: &#x27;/users/:id&#x27;,</span><br><span class=\"line\">    component: UserDetails,</span><br><span class=\"line\">    beforeEnter: (to, from) =&gt; &#123;</span><br><span class=\"line\">      // reject the navigation</span><br><span class=\"line\">      return false</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n\n<p>​        <code>beforeEnter</code> 守卫 <strong>只在进入路由时触发</strong>，不会在 <code>params</code>、<code>query</code> 或 <code>hash</code> 改变时触发。例如，从 <code>/users/2</code> 进入到 <code>/users/3</code> 或者从 <code>/users/2#info</code> 进入到 <code>/users/2#projects</code>。它们只有在 <strong>从一个不同的</strong> 路由导航时，才会被触发。</p>\n<p>​        注意：</p>\n<ul>\n<li>beforeEnter 是写在routes里面，而不是组件里面。</li>\n<li>其次触发时机就是进入路由的时候，但是如果没有离开路由就不会再次触发了。其中对于 参数的变化也是在路由之中的。</li>\n<li>return 值的判定就是导航守卫的判定方法。</li>\n</ul>\n<p>​        你也可以将一个函数数组传递给 <code>beforeEnter</code>，这在为不同的路由重用守卫时很有用：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function removeQueryParams(to) &#123;</span><br><span class=\"line\">  if (Object.keys(to.query).length)</span><br><span class=\"line\">    return &#123; path: to.path, query: &#123;&#125;, hash: to.hash &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function removeHash(to) &#123;</span><br><span class=\"line\">  if (to.hash) return &#123; path: to.path, query: to.query, hash: &#x27;&#x27; &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const routes = [</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    path: &#x27;/users/:id&#x27;,</span><br><span class=\"line\">    component: UserDetails,</span><br><span class=\"line\">    beforeEnter: [removeQueryParams, removeHash],</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    path: &#x27;/about&#x27;,</span><br><span class=\"line\">    component: UserDetails,</span><br><span class=\"line\">    beforeEnter: [removeQueryParams],</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n\n<p>​        请注意，你也可以通过使用<a href=\"https://router.vuejs.org/zh/guide/advanced/meta.html\">路径 meta 字段</a>和<a href=\"https://router.vuejs.org/zh/guide/advanced/navigation-guards.html#global-before-guards\">全局导航守卫</a>来实现类似的行为。</p>\n<h2 id=\"组件内的守卫\"><a href=\"#组件内的守卫\" class=\"headerlink\" title=\"组件内的守卫\"></a>组件内的守卫</h2><p>​        最后，你可以在路由组件内直接定义路由导航守卫(传递给路由配置的)</p>\n<h3 id=\"可用的配置-API\"><a href=\"#可用的配置-API\" class=\"headerlink\" title=\"可用的配置 API\"></a>可用的配置 API</h3><p>你可以为路由组件添加以下配置：</p>\n<ul>\n<li><code>beforeRouteEnter</code></li>\n<li><code>beforeRouteUpdate</code></li>\n<li><code>beforeRouteLeave</code></li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const UserDetails = &#123;</span><br><span class=\"line\">  template: `...`,</span><br><span class=\"line\">  beforeRouteEnter(to, from) &#123;</span><br><span class=\"line\">    // 在渲染该组件的对应路由被验证前调用</span><br><span class=\"line\">    // 不能获取组件实例 `this` ！</span><br><span class=\"line\">    // 因为当守卫执行时，组件实例还没被创建！</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  beforeRouteUpdate(to, from) &#123;</span><br><span class=\"line\">    // 在当前路由改变，但是该组件被复用时调用</span><br><span class=\"line\">    // 举例来说，对于一个带有动态参数的路径 `/users/:id`，在 `/users/1` 和 `/users/2` 之间跳转的时候，</span><br><span class=\"line\">    // 由于会渲染同样的 `UserDetails` 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。</span><br><span class=\"line\">    // 因为在这种情况发生的时候，组件已经挂载好了，导航守卫可以访问组件实例 `this`</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  beforeRouteLeave(to, from) &#123;</span><br><span class=\"line\">    // 在导航离开渲染该组件的对应路由时调用</span><br><span class=\"line\">    // 与 `beforeRouteUpdate` 一样，它可以访问组件实例 `this`</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>​        <code>beforeRouteEnter</code> 守卫 <strong>不能</strong> 访问 <code>this</code>，因为守卫在导航确认前被调用，因此即将登场的新组件还没被创建。</p>\n<p>​        不过，你可以通过传一个回调给 <code>next</code> 来访问组件实例。在导航被确认的时候执行回调，并且把组件实例作为回调方法的参数：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">beforeRouteEnter (to, from, next) &#123;</span><br><span class=\"line\">  next(vm =&gt; &#123;</span><br><span class=\"line\">    // 通过 `vm` 访问组件实例</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>​        注意 <code>beforeRouteEnter</code> 是支持给 <code>next</code> 传递回调的唯一守卫。对于 <code>beforeRouteUpdate</code> 和 <code>beforeRouteLeave</code> 来说，<code>this</code> 已经可用了，所以<em>不支持</em> 传递回调，因为没有必要了：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">beforeRouteUpdate (to, from) &#123;</span><br><span class=\"line\">  // just use `this`</span><br><span class=\"line\">  this.name = to.params.name</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>​        这个 <strong>离开守卫</strong> 通常用来预防用户在还未保存修改前突然离开。该导航可以通过返回 <code>false</code> 来取消。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">beforeRouteLeave (to, from) &#123;</span><br><span class=\"line\">  const answer = window.confirm(&#x27;Do you really want to leave? you have unsaved changes!&#x27;)</span><br><span class=\"line\">  if (!answer) return false</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"使用组合式-API\"><a href=\"#使用组合式-API\" class=\"headerlink\" title=\"使用组合式 API\"></a>使用组合式 API</h3><p>​        如果你正在使用<a href=\"https://v3.vuejs.org/guide/composition-api-setup.html#setup\">组合 API 和 <code>setup</code> 函数</a>来编写组件，你可以通过 <code>onBeforeRouteUpdate</code> 和 <code>onBeforeRouteLeave</code> 分别添加 update 和 leave 守卫。 请参考<a href=\"https://router.vuejs.org/zh/guide/advanced/composition-api.html#%E5%AF%BC%E8%88%AA%E5%AE%88%E5%8D%AB\">组合 API 部分</a>以获得更多细节。</p>\n<h2 id=\"完整的导航解析流程\"><a href=\"#完整的导航解析流程\" class=\"headerlink\" title=\"完整的导航解析流程\"></a>完整的导航解析流程</h2><ul>\n<li>导航被触发</li>\n<li>在失活的组件里调用 <code>beforeRouteLeave</code> 守卫。</li>\n<li>调用全局的 <code>beforeEach</code> 守卫。</li>\n<li>在重用的组件里调用 <code>beforeRouteUpdate</code> 守卫(2.2+)。</li>\n<li>在路由配置里调用 <code>beforeEnter</code>。</li>\n<li>解析异步路由组件。</li>\n<li>在被激活的组件里调用 <code>beforeRouteEnter</code>。</li>\n<li>调用全局的 <code>beforeResolve</code> 守卫(2.5+)。</li>\n<li>导航被确认。</li>\n<li>调用全局的 <code>afterEach</code> 钩子。</li>\n<li>触发 DOM 更新。</li>\n<li>调用 <code>beforeRouteEnter</code> 守卫中传给 <code>next</code> 的回调函数，创建好的组件实例会作为回调函数的参数传入。</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">触发导航，失活调用组件的routeleave，调用全局的beforeEach，重用组件调用routeUpdate，调用路由配置beforeEnter，调用routeEnter，调用全局beforeResolve，调用全局afterEach，调用routeEnter的next回调函数。</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"路由元信息\"><a href=\"#路由元信息\" class=\"headerlink\" title=\"路由元信息\"></a>路由元信息</h1><p>​        有时，你可能希望将任意信息附加到路由上，如过渡名称、谁可以访问路由等。这些事情可以通过接收属性对象的<code>meta</code>属性来实现，并且它可以在路由地址和导航守卫上都被访问到。定义路由的时候你可以这样配置 <code>meta</code> 字段：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const routes = [</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    path: &#x27;/posts&#x27;,</span><br><span class=\"line\">    component: PostsLayout,</span><br><span class=\"line\">    children: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        path: &#x27;new&#x27;,</span><br><span class=\"line\">        component: PostsNew,</span><br><span class=\"line\">        // 只有经过身份验证的用户才能创建帖子</span><br><span class=\"line\">        meta: &#123; requiresAuth: true &#125;</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        path: &#x27;:id&#x27;,</span><br><span class=\"line\">        component: PostsDetail</span><br><span class=\"line\">        // 任何人都可以阅读文章</span><br><span class=\"line\">        meta: &#123; requiresAuth: false &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n\n<p>​        首先，我们称呼 <code>routes</code> 配置中的每个路由对象为 <strong>路由记录</strong>。路由记录可以是嵌套的，因此，当一个路由匹配成功后，它可能匹配多个路由记录。</p>\n<p>​        例如，根据上面的路由配置，<code>/posts/new</code> 这个 URL 将会匹配父路由记录 (<code>path: &#39;/posts&#39;</code>) 以及子路由记录 (<code>path: &#39;new&#39;</code>)。</p>\n<p>​        一个路由匹配到的所有路由记录会暴露为 <code>$route</code> 对象(还有在导航守卫中的路由对象)的<code>$route.matched</code> 数组。我们需要遍历这个数组来检查路由记录中的 <code>meta</code> 字段，但是 Vue Router 还为你提供了一个 <code>$route.meta</code> 方法，它是一个非递归合并<strong>所有 <code>meta</code></strong> 字段的（从父字段到子字段）的方法。这意味着你可以简单地写</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">router.beforeEach((to, from) =&gt; &#123;</span><br><span class=\"line\">  // 而不是去检查每条路由记录</span><br><span class=\"line\">  // to.matched.some(record =&gt; record.meta.requiresAuth)</span><br><span class=\"line\">  if (to.meta.requiresAuth &amp;&amp; !auth.isLoggedIn()) &#123;</span><br><span class=\"line\">    // 此路由需要授权，请检查是否已登录</span><br><span class=\"line\">    // 如果没有，则重定向到登录页面</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">      path: &#x27;/login&#x27;,</span><br><span class=\"line\">      // 保存我们所在的位置，以便以后再来</span><br><span class=\"line\">      query: &#123; redirect: to.fullPath &#125;,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>​        matched 里面的值的path是一个路由定义的样子(/about/:id) 而不是实际的url路由值。</p>\n<h2 id=\"TypeScript\"><a href=\"#TypeScript\" class=\"headerlink\" title=\"TypeScript\"></a>TypeScript</h2><p>​        可以通过扩展 <code>RouteMeta</code> 接口来输入 meta 字段：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// typings.d.ts or router.ts</span><br><span class=\"line\">import &#x27;vue-router&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">declare module &#x27;vue-router&#x27; &#123;</span><br><span class=\"line\">  interface RouteMeta &#123;</span><br><span class=\"line\">    // 是可选的</span><br><span class=\"line\">    isAdmin?: boolean</span><br><span class=\"line\">    // 每个路由都必须声明</span><br><span class=\"line\">    requiresAuth: boolean</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"数据获取\"><a href=\"#数据获取\" class=\"headerlink\" title=\"数据获取\"></a>数据获取</h1><p>​        有时候，进入某个路由后，需要从服务器获取数据。例如，在渲染用户信息时，你需要从服务器获取用户的数据。我们可以通过两种方式来实现：</p>\n<ul>\n<li><strong>导航完成之后获取</strong>：先完成导航，然后在接下来的组件生命周期钩子中获取数据。在数据获取期间显示“加载中”之类的指示。</li>\n<li><strong>导航完成之前获取</strong>：导航完成前，在路由进入的守卫中获取数据，在数据获取成功后执行导航。</li>\n</ul>\n<p>​        从技术角度讲，两种方式都不错 —— 就看你想要的用户体验是哪种。</p>\n<h2 id=\"导航完成后获取数据\"><a href=\"#导航完成后获取数据\" class=\"headerlink\" title=\"导航完成后获取数据\"></a>导航完成后获取数据</h2><p>​        当你使用这种方式时，我们会马上导航和渲染组件，然后在组件的 created 钩子中获取数据。这让我们有机会在数据获取期间展示一个 loading 状态，还可以在不同视图间展示不同的 loading 状态。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  &lt;div class=&quot;post&quot;&gt;</span><br><span class=\"line\">    &lt;div v-if=&quot;loading&quot; class=&quot;loading&quot;&gt;Loading...&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;div v-if=&quot;error&quot; class=&quot;error&quot;&gt;&#123;&#123; error &#125;&#125;&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;div v-if=&quot;post&quot; class=&quot;content&quot;&gt;</span><br><span class=\"line\">      &lt;h2&gt;&#123;&#123; post.title &#125;&#125;&lt;/h2&gt;</span><br><span class=\"line\">      &lt;p&gt;&#123;&#123; post.body &#125;&#125;&lt;/p&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export default &#123;</span><br><span class=\"line\">  data() &#123;</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">      loading: false,</span><br><span class=\"line\">      post: null,</span><br><span class=\"line\">      error: null,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  created() &#123;</span><br><span class=\"line\">    // watch 路由的参数，以便再次获取数据</span><br><span class=\"line\">    this.$watch(</span><br><span class=\"line\">      () =&gt; this.$route.params,</span><br><span class=\"line\">      () =&gt; &#123;</span><br><span class=\"line\">        this.fetchData()</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      // 组件创建完后获取数据，</span><br><span class=\"line\">      // 此时 data 已经被 observed 了</span><br><span class=\"line\">      &#123; immediate: true &#125;</span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  methods: &#123;</span><br><span class=\"line\">    fetchData() &#123;</span><br><span class=\"line\">      this.error = this.post = null</span><br><span class=\"line\">      this.loading = true</span><br><span class=\"line\">      // replace `getPost` with your data fetching util / API wrapper</span><br><span class=\"line\">      // 用你的数据获取 util 或 API 替换 `getPost`</span><br><span class=\"line\">      getPost(this.$route.params.id, (err, post) =&gt; &#123;</span><br><span class=\"line\">        this.loading = false</span><br><span class=\"line\">        if (err) &#123;</span><br><span class=\"line\">          this.error = err.toString()</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">          this.post = post</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>​        简单来说就是创建了 loading error post 三个状态，然后再created的时候创建监听（理由是创建的监听参数的变化，可以重复触发。否则在参数变化时使用的复用将不会触发改变。）使用 immediate 为true，立刻触发。再调用fetch方法。然后再进行调用时设置post，error为null，作用是避免复用的影响，设置loading为true，然后便是正常的获取数据并显示了。</p>\n<h2 id=\"导航完成前获取数据\"><a href=\"#导航完成前获取数据\" class=\"headerlink\" title=\"导航完成前获取数据\"></a>导航完成前获取数据</h2><p>​        通过这种方式，我们在导航转入新的路由前获取数据。我们可以在接下来的组件的 <code>beforeRouteEnter</code> 守卫中获取数据，当数据获取成功后只调用 <code>next</code> 方法：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export default &#123;</span><br><span class=\"line\">  data() &#123;</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">      post: null,</span><br><span class=\"line\">      error: null,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  beforeRouteEnter(to, from, next) &#123;</span><br><span class=\"line\">    getPost(to.params.id, (err, post) =&gt; &#123;</span><br><span class=\"line\">      next(vm =&gt; vm.setData(err, post))</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  // 路由改变前，组件就已经渲染完了</span><br><span class=\"line\">  // 逻辑稍稍不同</span><br><span class=\"line\">  async beforeRouteUpdate(to, from) &#123;</span><br><span class=\"line\">    this.post = null</span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">      this.post = await getPost(to.params.id)</span><br><span class=\"line\">    &#125; catch (error) &#123;</span><br><span class=\"line\">      this.error = error.toString()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>​        这个就是在 beforeRouteEnter里面调用了异步请求，然后再获取到数据之后将数据使用next回调进行调用。同时再beforeRouteUpdate进行更新时使用了es6的async 和 await方法。同时设置this.post为null，然后在调用getPost方法获取数据返回给post。</p>\n<p>​        在为后面的视图获取数据时，用户会停留在当前的界面，因此建议在数据获取期间，显示一些进度条或者别的指示。如果数据获取失败，同样有必要展示一些全局的错误提醒。</p>\n<h1 id=\"组合式API\"><a href=\"#组合式API\" class=\"headerlink\" title=\"组合式API\"></a>组合式API</h1><h2 id=\"在-setup-中访问路由和当前路由\"><a href=\"#在-setup-中访问路由和当前路由\" class=\"headerlink\" title=\"在 setup 中访问路由和当前路由\"></a>在 setup 中访问路由和当前路由</h2><p>​        因为我们在 <code>setup</code> 里面没有访问 <code>this</code>，所以我们不能再直接访问 <code>this.$router</code> 或 <code>this.$route</code>。作为替代，我们使用 <code>useRouter</code> 函数：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#123; useRouter, useRoute &#125; from &#x27;vue-router&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">  setup() &#123;</span><br><span class=\"line\">  \t// useRouter 和 useRoute 是一个方法。返回一个route 和 router 的一个对象</span><br><span class=\"line\">  \t// route 是当前路由的信息， router 主要是原型的方法。和 全局路由信息。</span><br><span class=\"line\">    const router = useRouter()</span><br><span class=\"line\">    const route = useRoute()</span><br><span class=\"line\"></span><br><span class=\"line\">\t// </span><br><span class=\"line\">    function pushWithQuery(query) &#123;</span><br><span class=\"line\">      router.push(&#123;</span><br><span class=\"line\">        name: &#x27;search&#x27;,</span><br><span class=\"line\">        query: &#123;</span><br><span class=\"line\">          ...route.query,</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>​        <code>route</code> 对象是一个响应式对象，所以它的任何属性都可以被监听，但你应该<strong>避免监听整个 <code>route</code></strong> 对象：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#123; useRoute &#125; from &#x27;vue-router&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">  setup() &#123;</span><br><span class=\"line\">    const route = useRoute()</span><br><span class=\"line\">    const userData = ref()</span><br><span class=\"line\"></span><br><span class=\"line\">    // 当参数更改时获取用户信息</span><br><span class=\"line\">    watch(</span><br><span class=\"line\">      () =&gt; route.params,</span><br><span class=\"line\">      async newParams =&gt; &#123;</span><br><span class=\"line\">        userData.value = await fetchUser(newParams.id)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>​        请注意，在模板中我们仍然可以访问 <code>$router</code> 和 <code>$route</code>，所以不需要在 <code>setup</code> 中返回 <code>router</code> 或 <code>route</code>。</p>\n<h2 id=\"导航守卫-1\"><a href=\"#导航守卫-1\" class=\"headerlink\" title=\"导航守卫\"></a>导航守卫</h2><p>​        </p>\n","site":{"data":{}},"excerpt":"","more":"<p> <strong>router进阶学习</strong></p>\n<h1 id=\"导航守卫\"><a href=\"#导航守卫\" class=\"headerlink\" title=\"导航守卫\"></a>导航守卫</h1><p>​        正如其名，vue-router 提供的导航守卫主要用来通过跳转或取消的方式守卫导航。这里有很多方式植入路由导航中：全局的，单个路由独享的，或者组件级的。</p>\n<h2 id=\"全局前置守卫\"><a href=\"#全局前置守卫\" class=\"headerlink\" title=\"全局前置守卫\"></a>全局前置守卫</h2><p>​        你可以使用 <code>router.beforeEach</code> 注册一个全局前置守卫：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const router = createRouter(&#123; ... &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">router.beforeEach((to, from) =&gt; &#123;</span><br><span class=\"line\">  // ...</span><br><span class=\"line\">  // 返回 false 以取消导航</span><br><span class=\"line\">  return false</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>​        当一个导航触发时，全局前置守卫按照创建顺序调用。守卫是异步解析执行，此时导航在所有守卫 resolve 完之前一直处于<strong>等待中</strong>。</p>\n<p>​        每个守卫方法接收两个参数：</p>\n<ul>\n<li><strong><code>to</code></strong>: 即将要进入的目标 <a href=\"https://router.vuejs.org/zh/api/#routelocationnormalized\">用一种标准化的方式</a></li>\n<li><strong><code>from</code></strong>: 当前导航正要离开的路由 <a href=\"https://router.vuejs.org/zh/api/#routelocationnormalized\">用一种标准化的方式</a></li>\n</ul>\n<p>​        可以返回的值如下:</p>\n<ul>\n<li><code>false</code>: 取消当前的导航。如果浏览器的 URL 改变了(可能是用户手动或者浏览器后退按钮)，那么 URL 地址会重置到 <code>from</code> 路由对应的地址。</li>\n<li>一个<a href=\"https://router.vuejs.org/zh/api/#routelocationraw\">路由地址</a>: 通过一个路由地址跳转到一个不同的地址，就像你调用 <a href=\"https://router.vuejs.org/zh/api/#push\"><code>router.push()</code></a> 一样，你可以设置诸如 <code>replace: true</code> 或 <code>name: &#39;home&#39;</code> 之类的配置。当前的导航被中断，然后进行一个新的导航，就和 <code>from</code> 一样。</li>\n</ul>\n<p>​        如果遇到了意料之外的情况，可能会抛出一个 <code>Error</code>。这会取消导航并且调用 <a href=\"https://router.vuejs.org/zh/api/#onerror\"><code>router.onError()</code></a> 注册过的回调。</p>\n<p>​        如果什么都没有，<code>undefined</code> 或返回 <code>true</code>，<strong>则导航是有效的</strong>，并调用下一个导航守卫</p>\n<p>​        以上所有都同 <strong><code>async</code> 函数</strong> 和 Promise 工作方式一样：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">router.beforeEach(async (to, from) =&gt; &#123;</span><br><span class=\"line\">  // canUserAccess() 返回 `true` 或 `false`</span><br><span class=\"line\">  return await canUserAccess(to)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"可选参数-next\"><a href=\"#可选参数-next\" class=\"headerlink\" title=\"可选参数 next\"></a>可选参数 next</h3><p>​        <strong>确保 <code>next</code></strong> 在任何给定的导航守卫中都被<strong>严格调用一次</strong>。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// BAD</span><br><span class=\"line\">router.beforeEach((to, from, next) =&gt; &#123;</span><br><span class=\"line\">  if (to.name !== &#x27;Login&#x27; &amp;&amp; !isAuthenticated) next(&#123; name: &#x27;Login&#x27; &#125;)</span><br><span class=\"line\">  // 如果用户未能验证身份，则 `next` 会被调用两次</span><br><span class=\"line\">  next()</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// GOOD</span><br><span class=\"line\">router.beforeEach((to, from, next) =&gt; &#123;</span><br><span class=\"line\">  if (to.name !== &#x27;Login&#x27; &amp;&amp; !isAuthenticated) next(&#123; name: &#x27;Login&#x27; &#125;)</span><br><span class=\"line\">  else next()</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"全局解析守卫\"><a href=\"#全局解析守卫\" class=\"headerlink\" title=\"全局解析守卫\"></a>全局解析守卫</h2><p>​        你可以用 <code>router.beforeResolve</code> 注册一个全局守卫。这和 <code>router.beforeEach</code> 类似，因为它在 <strong>每次导航</strong>时都会触发，但是确保在导航被确认之前，<strong>同时在所有组件内守卫和异步路由组件被解析之后，解析守卫就被正确调用</strong>。这里有一个例子，确保用户可以访问<a href=\"https://router.vuejs.org/zh/guide/advanced/meta.html\">自定义 meta</a> 属性 <code>requiresCamera</code> 的路由：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">router.beforeResolve(async to =&gt; &#123;</span><br><span class=\"line\">  if (to.meta.requiresCamera) &#123;</span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">      await askForCameraPermission()</span><br><span class=\"line\">    &#125; catch (error) &#123;</span><br><span class=\"line\">      if (error instanceof NotAllowedError) &#123;</span><br><span class=\"line\">        // ... 处理错误，然后取消导航</span><br><span class=\"line\">        return false</span><br><span class=\"line\">      &#125; else &#123;</span><br><span class=\"line\">        // 意料之外的错误，取消导航并把错误传给全局处理器</span><br><span class=\"line\">        throw error</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>​        <code>router.beforeResolve</code> 是获取数据或执行任何其他操作（如果用户无法进入页面时你希望避免执行的操作）的理想位置。</p>\n<h2 id=\"全局后置钩子\"><a href=\"#全局后置钩子\" class=\"headerlink\" title=\"全局后置钩子\"></a>全局后置钩子</h2><p>​        你也可以注册全局后置钩子，然而和守卫不同的是，这些钩子不会接受 <code>next</code> 函数也不会改变导航本身：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">router.afterEach((to, from) =&gt; &#123;</span><br><span class=\"line\">  sendToAnalytics(to.fullPath)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>​        它们对于分析、更改页面标题、声明页面等辅助功能以及许多其他事情都很有用。</p>\n<p>​        它们也反映了 <a href=\"https://router.vuejs.org/zh/guide/advanced/navigation-failures.html\">navigation failures</a> 作为第三个参数：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">router.afterEach((to, from, failure) =&gt; &#123;</span><br><span class=\"line\">  if (!failure) sendToAnalytics(to.fullPath)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>​        <strong>navigation failures 的属性</strong> </p>\n<p>​        所有导航失败都会公开<code>to</code>和<code>from</code>属性以反映当前位置以及失败导航的目标位置：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// trying to access the admin page</span><br><span class=\"line\">router.push(&#x27;/admin&#x27;).then(failure =&gt; &#123;</span><br><span class=\"line\">  if (isNavigationFailure(failure, NavigationFailureType.redirected)) &#123;</span><br><span class=\"line\">    failure.to.path // &#x27;/admin&#x27;</span><br><span class=\"line\">    failure.from.path // &#x27;/&#x27;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"路由独享的守卫\"><a href=\"#路由独享的守卫\" class=\"headerlink\" title=\"路由独享的守卫\"></a>路由独享的守卫</h2><p>​        你可以直接在路由配置上定义 <code>beforeEnter</code> 守卫：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const routes = [</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    path: &#x27;/users/:id&#x27;,</span><br><span class=\"line\">    component: UserDetails,</span><br><span class=\"line\">    beforeEnter: (to, from) =&gt; &#123;</span><br><span class=\"line\">      // reject the navigation</span><br><span class=\"line\">      return false</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n\n<p>​        <code>beforeEnter</code> 守卫 <strong>只在进入路由时触发</strong>，不会在 <code>params</code>、<code>query</code> 或 <code>hash</code> 改变时触发。例如，从 <code>/users/2</code> 进入到 <code>/users/3</code> 或者从 <code>/users/2#info</code> 进入到 <code>/users/2#projects</code>。它们只有在 <strong>从一个不同的</strong> 路由导航时，才会被触发。</p>\n<p>​        注意：</p>\n<ul>\n<li>beforeEnter 是写在routes里面，而不是组件里面。</li>\n<li>其次触发时机就是进入路由的时候，但是如果没有离开路由就不会再次触发了。其中对于 参数的变化也是在路由之中的。</li>\n<li>return 值的判定就是导航守卫的判定方法。</li>\n</ul>\n<p>​        你也可以将一个函数数组传递给 <code>beforeEnter</code>，这在为不同的路由重用守卫时很有用：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function removeQueryParams(to) &#123;</span><br><span class=\"line\">  if (Object.keys(to.query).length)</span><br><span class=\"line\">    return &#123; path: to.path, query: &#123;&#125;, hash: to.hash &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function removeHash(to) &#123;</span><br><span class=\"line\">  if (to.hash) return &#123; path: to.path, query: to.query, hash: &#x27;&#x27; &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const routes = [</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    path: &#x27;/users/:id&#x27;,</span><br><span class=\"line\">    component: UserDetails,</span><br><span class=\"line\">    beforeEnter: [removeQueryParams, removeHash],</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    path: &#x27;/about&#x27;,</span><br><span class=\"line\">    component: UserDetails,</span><br><span class=\"line\">    beforeEnter: [removeQueryParams],</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n\n<p>​        请注意，你也可以通过使用<a href=\"https://router.vuejs.org/zh/guide/advanced/meta.html\">路径 meta 字段</a>和<a href=\"https://router.vuejs.org/zh/guide/advanced/navigation-guards.html#global-before-guards\">全局导航守卫</a>来实现类似的行为。</p>\n<h2 id=\"组件内的守卫\"><a href=\"#组件内的守卫\" class=\"headerlink\" title=\"组件内的守卫\"></a>组件内的守卫</h2><p>​        最后，你可以在路由组件内直接定义路由导航守卫(传递给路由配置的)</p>\n<h3 id=\"可用的配置-API\"><a href=\"#可用的配置-API\" class=\"headerlink\" title=\"可用的配置 API\"></a>可用的配置 API</h3><p>你可以为路由组件添加以下配置：</p>\n<ul>\n<li><code>beforeRouteEnter</code></li>\n<li><code>beforeRouteUpdate</code></li>\n<li><code>beforeRouteLeave</code></li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const UserDetails = &#123;</span><br><span class=\"line\">  template: `...`,</span><br><span class=\"line\">  beforeRouteEnter(to, from) &#123;</span><br><span class=\"line\">    // 在渲染该组件的对应路由被验证前调用</span><br><span class=\"line\">    // 不能获取组件实例 `this` ！</span><br><span class=\"line\">    // 因为当守卫执行时，组件实例还没被创建！</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  beforeRouteUpdate(to, from) &#123;</span><br><span class=\"line\">    // 在当前路由改变，但是该组件被复用时调用</span><br><span class=\"line\">    // 举例来说，对于一个带有动态参数的路径 `/users/:id`，在 `/users/1` 和 `/users/2` 之间跳转的时候，</span><br><span class=\"line\">    // 由于会渲染同样的 `UserDetails` 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。</span><br><span class=\"line\">    // 因为在这种情况发生的时候，组件已经挂载好了，导航守卫可以访问组件实例 `this`</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  beforeRouteLeave(to, from) &#123;</span><br><span class=\"line\">    // 在导航离开渲染该组件的对应路由时调用</span><br><span class=\"line\">    // 与 `beforeRouteUpdate` 一样，它可以访问组件实例 `this`</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>​        <code>beforeRouteEnter</code> 守卫 <strong>不能</strong> 访问 <code>this</code>，因为守卫在导航确认前被调用，因此即将登场的新组件还没被创建。</p>\n<p>​        不过，你可以通过传一个回调给 <code>next</code> 来访问组件实例。在导航被确认的时候执行回调，并且把组件实例作为回调方法的参数：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">beforeRouteEnter (to, from, next) &#123;</span><br><span class=\"line\">  next(vm =&gt; &#123;</span><br><span class=\"line\">    // 通过 `vm` 访问组件实例</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>​        注意 <code>beforeRouteEnter</code> 是支持给 <code>next</code> 传递回调的唯一守卫。对于 <code>beforeRouteUpdate</code> 和 <code>beforeRouteLeave</code> 来说，<code>this</code> 已经可用了，所以<em>不支持</em> 传递回调，因为没有必要了：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">beforeRouteUpdate (to, from) &#123;</span><br><span class=\"line\">  // just use `this`</span><br><span class=\"line\">  this.name = to.params.name</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>​        这个 <strong>离开守卫</strong> 通常用来预防用户在还未保存修改前突然离开。该导航可以通过返回 <code>false</code> 来取消。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">beforeRouteLeave (to, from) &#123;</span><br><span class=\"line\">  const answer = window.confirm(&#x27;Do you really want to leave? you have unsaved changes!&#x27;)</span><br><span class=\"line\">  if (!answer) return false</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"使用组合式-API\"><a href=\"#使用组合式-API\" class=\"headerlink\" title=\"使用组合式 API\"></a>使用组合式 API</h3><p>​        如果你正在使用<a href=\"https://v3.vuejs.org/guide/composition-api-setup.html#setup\">组合 API 和 <code>setup</code> 函数</a>来编写组件，你可以通过 <code>onBeforeRouteUpdate</code> 和 <code>onBeforeRouteLeave</code> 分别添加 update 和 leave 守卫。 请参考<a href=\"https://router.vuejs.org/zh/guide/advanced/composition-api.html#%E5%AF%BC%E8%88%AA%E5%AE%88%E5%8D%AB\">组合 API 部分</a>以获得更多细节。</p>\n<h2 id=\"完整的导航解析流程\"><a href=\"#完整的导航解析流程\" class=\"headerlink\" title=\"完整的导航解析流程\"></a>完整的导航解析流程</h2><ul>\n<li>导航被触发</li>\n<li>在失活的组件里调用 <code>beforeRouteLeave</code> 守卫。</li>\n<li>调用全局的 <code>beforeEach</code> 守卫。</li>\n<li>在重用的组件里调用 <code>beforeRouteUpdate</code> 守卫(2.2+)。</li>\n<li>在路由配置里调用 <code>beforeEnter</code>。</li>\n<li>解析异步路由组件。</li>\n<li>在被激活的组件里调用 <code>beforeRouteEnter</code>。</li>\n<li>调用全局的 <code>beforeResolve</code> 守卫(2.5+)。</li>\n<li>导航被确认。</li>\n<li>调用全局的 <code>afterEach</code> 钩子。</li>\n<li>触发 DOM 更新。</li>\n<li>调用 <code>beforeRouteEnter</code> 守卫中传给 <code>next</code> 的回调函数，创建好的组件实例会作为回调函数的参数传入。</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">触发导航，失活调用组件的routeleave，调用全局的beforeEach，重用组件调用routeUpdate，调用路由配置beforeEnter，调用routeEnter，调用全局beforeResolve，调用全局afterEach，调用routeEnter的next回调函数。</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"路由元信息\"><a href=\"#路由元信息\" class=\"headerlink\" title=\"路由元信息\"></a>路由元信息</h1><p>​        有时，你可能希望将任意信息附加到路由上，如过渡名称、谁可以访问路由等。这些事情可以通过接收属性对象的<code>meta</code>属性来实现，并且它可以在路由地址和导航守卫上都被访问到。定义路由的时候你可以这样配置 <code>meta</code> 字段：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const routes = [</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    path: &#x27;/posts&#x27;,</span><br><span class=\"line\">    component: PostsLayout,</span><br><span class=\"line\">    children: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        path: &#x27;new&#x27;,</span><br><span class=\"line\">        component: PostsNew,</span><br><span class=\"line\">        // 只有经过身份验证的用户才能创建帖子</span><br><span class=\"line\">        meta: &#123; requiresAuth: true &#125;</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        path: &#x27;:id&#x27;,</span><br><span class=\"line\">        component: PostsDetail</span><br><span class=\"line\">        // 任何人都可以阅读文章</span><br><span class=\"line\">        meta: &#123; requiresAuth: false &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n\n<p>​        首先，我们称呼 <code>routes</code> 配置中的每个路由对象为 <strong>路由记录</strong>。路由记录可以是嵌套的，因此，当一个路由匹配成功后，它可能匹配多个路由记录。</p>\n<p>​        例如，根据上面的路由配置，<code>/posts/new</code> 这个 URL 将会匹配父路由记录 (<code>path: &#39;/posts&#39;</code>) 以及子路由记录 (<code>path: &#39;new&#39;</code>)。</p>\n<p>​        一个路由匹配到的所有路由记录会暴露为 <code>$route</code> 对象(还有在导航守卫中的路由对象)的<code>$route.matched</code> 数组。我们需要遍历这个数组来检查路由记录中的 <code>meta</code> 字段，但是 Vue Router 还为你提供了一个 <code>$route.meta</code> 方法，它是一个非递归合并<strong>所有 <code>meta</code></strong> 字段的（从父字段到子字段）的方法。这意味着你可以简单地写</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">router.beforeEach((to, from) =&gt; &#123;</span><br><span class=\"line\">  // 而不是去检查每条路由记录</span><br><span class=\"line\">  // to.matched.some(record =&gt; record.meta.requiresAuth)</span><br><span class=\"line\">  if (to.meta.requiresAuth &amp;&amp; !auth.isLoggedIn()) &#123;</span><br><span class=\"line\">    // 此路由需要授权，请检查是否已登录</span><br><span class=\"line\">    // 如果没有，则重定向到登录页面</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">      path: &#x27;/login&#x27;,</span><br><span class=\"line\">      // 保存我们所在的位置，以便以后再来</span><br><span class=\"line\">      query: &#123; redirect: to.fullPath &#125;,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>​        matched 里面的值的path是一个路由定义的样子(/about/:id) 而不是实际的url路由值。</p>\n<h2 id=\"TypeScript\"><a href=\"#TypeScript\" class=\"headerlink\" title=\"TypeScript\"></a>TypeScript</h2><p>​        可以通过扩展 <code>RouteMeta</code> 接口来输入 meta 字段：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// typings.d.ts or router.ts</span><br><span class=\"line\">import &#x27;vue-router&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">declare module &#x27;vue-router&#x27; &#123;</span><br><span class=\"line\">  interface RouteMeta &#123;</span><br><span class=\"line\">    // 是可选的</span><br><span class=\"line\">    isAdmin?: boolean</span><br><span class=\"line\">    // 每个路由都必须声明</span><br><span class=\"line\">    requiresAuth: boolean</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"数据获取\"><a href=\"#数据获取\" class=\"headerlink\" title=\"数据获取\"></a>数据获取</h1><p>​        有时候，进入某个路由后，需要从服务器获取数据。例如，在渲染用户信息时，你需要从服务器获取用户的数据。我们可以通过两种方式来实现：</p>\n<ul>\n<li><strong>导航完成之后获取</strong>：先完成导航，然后在接下来的组件生命周期钩子中获取数据。在数据获取期间显示“加载中”之类的指示。</li>\n<li><strong>导航完成之前获取</strong>：导航完成前，在路由进入的守卫中获取数据，在数据获取成功后执行导航。</li>\n</ul>\n<p>​        从技术角度讲，两种方式都不错 —— 就看你想要的用户体验是哪种。</p>\n<h2 id=\"导航完成后获取数据\"><a href=\"#导航完成后获取数据\" class=\"headerlink\" title=\"导航完成后获取数据\"></a>导航完成后获取数据</h2><p>​        当你使用这种方式时，我们会马上导航和渲染组件，然后在组件的 created 钩子中获取数据。这让我们有机会在数据获取期间展示一个 loading 状态，还可以在不同视图间展示不同的 loading 状态。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  &lt;div class=&quot;post&quot;&gt;</span><br><span class=\"line\">    &lt;div v-if=&quot;loading&quot; class=&quot;loading&quot;&gt;Loading...&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;div v-if=&quot;error&quot; class=&quot;error&quot;&gt;&#123;&#123; error &#125;&#125;&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;div v-if=&quot;post&quot; class=&quot;content&quot;&gt;</span><br><span class=\"line\">      &lt;h2&gt;&#123;&#123; post.title &#125;&#125;&lt;/h2&gt;</span><br><span class=\"line\">      &lt;p&gt;&#123;&#123; post.body &#125;&#125;&lt;/p&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export default &#123;</span><br><span class=\"line\">  data() &#123;</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">      loading: false,</span><br><span class=\"line\">      post: null,</span><br><span class=\"line\">      error: null,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  created() &#123;</span><br><span class=\"line\">    // watch 路由的参数，以便再次获取数据</span><br><span class=\"line\">    this.$watch(</span><br><span class=\"line\">      () =&gt; this.$route.params,</span><br><span class=\"line\">      () =&gt; &#123;</span><br><span class=\"line\">        this.fetchData()</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      // 组件创建完后获取数据，</span><br><span class=\"line\">      // 此时 data 已经被 observed 了</span><br><span class=\"line\">      &#123; immediate: true &#125;</span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  methods: &#123;</span><br><span class=\"line\">    fetchData() &#123;</span><br><span class=\"line\">      this.error = this.post = null</span><br><span class=\"line\">      this.loading = true</span><br><span class=\"line\">      // replace `getPost` with your data fetching util / API wrapper</span><br><span class=\"line\">      // 用你的数据获取 util 或 API 替换 `getPost`</span><br><span class=\"line\">      getPost(this.$route.params.id, (err, post) =&gt; &#123;</span><br><span class=\"line\">        this.loading = false</span><br><span class=\"line\">        if (err) &#123;</span><br><span class=\"line\">          this.error = err.toString()</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">          this.post = post</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>​        简单来说就是创建了 loading error post 三个状态，然后再created的时候创建监听（理由是创建的监听参数的变化，可以重复触发。否则在参数变化时使用的复用将不会触发改变。）使用 immediate 为true，立刻触发。再调用fetch方法。然后再进行调用时设置post，error为null，作用是避免复用的影响，设置loading为true，然后便是正常的获取数据并显示了。</p>\n<h2 id=\"导航完成前获取数据\"><a href=\"#导航完成前获取数据\" class=\"headerlink\" title=\"导航完成前获取数据\"></a>导航完成前获取数据</h2><p>​        通过这种方式，我们在导航转入新的路由前获取数据。我们可以在接下来的组件的 <code>beforeRouteEnter</code> 守卫中获取数据，当数据获取成功后只调用 <code>next</code> 方法：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export default &#123;</span><br><span class=\"line\">  data() &#123;</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">      post: null,</span><br><span class=\"line\">      error: null,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  beforeRouteEnter(to, from, next) &#123;</span><br><span class=\"line\">    getPost(to.params.id, (err, post) =&gt; &#123;</span><br><span class=\"line\">      next(vm =&gt; vm.setData(err, post))</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  // 路由改变前，组件就已经渲染完了</span><br><span class=\"line\">  // 逻辑稍稍不同</span><br><span class=\"line\">  async beforeRouteUpdate(to, from) &#123;</span><br><span class=\"line\">    this.post = null</span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">      this.post = await getPost(to.params.id)</span><br><span class=\"line\">    &#125; catch (error) &#123;</span><br><span class=\"line\">      this.error = error.toString()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>​        这个就是在 beforeRouteEnter里面调用了异步请求，然后再获取到数据之后将数据使用next回调进行调用。同时再beforeRouteUpdate进行更新时使用了es6的async 和 await方法。同时设置this.post为null，然后在调用getPost方法获取数据返回给post。</p>\n<p>​        在为后面的视图获取数据时，用户会停留在当前的界面，因此建议在数据获取期间，显示一些进度条或者别的指示。如果数据获取失败，同样有必要展示一些全局的错误提醒。</p>\n<h1 id=\"组合式API\"><a href=\"#组合式API\" class=\"headerlink\" title=\"组合式API\"></a>组合式API</h1><h2 id=\"在-setup-中访问路由和当前路由\"><a href=\"#在-setup-中访问路由和当前路由\" class=\"headerlink\" title=\"在 setup 中访问路由和当前路由\"></a>在 setup 中访问路由和当前路由</h2><p>​        因为我们在 <code>setup</code> 里面没有访问 <code>this</code>，所以我们不能再直接访问 <code>this.$router</code> 或 <code>this.$route</code>。作为替代，我们使用 <code>useRouter</code> 函数：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#123; useRouter, useRoute &#125; from &#x27;vue-router&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">  setup() &#123;</span><br><span class=\"line\">  \t// useRouter 和 useRoute 是一个方法。返回一个route 和 router 的一个对象</span><br><span class=\"line\">  \t// route 是当前路由的信息， router 主要是原型的方法。和 全局路由信息。</span><br><span class=\"line\">    const router = useRouter()</span><br><span class=\"line\">    const route = useRoute()</span><br><span class=\"line\"></span><br><span class=\"line\">\t// </span><br><span class=\"line\">    function pushWithQuery(query) &#123;</span><br><span class=\"line\">      router.push(&#123;</span><br><span class=\"line\">        name: &#x27;search&#x27;,</span><br><span class=\"line\">        query: &#123;</span><br><span class=\"line\">          ...route.query,</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>​        <code>route</code> 对象是一个响应式对象，所以它的任何属性都可以被监听，但你应该<strong>避免监听整个 <code>route</code></strong> 对象：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#123; useRoute &#125; from &#x27;vue-router&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">  setup() &#123;</span><br><span class=\"line\">    const route = useRoute()</span><br><span class=\"line\">    const userData = ref()</span><br><span class=\"line\"></span><br><span class=\"line\">    // 当参数更改时获取用户信息</span><br><span class=\"line\">    watch(</span><br><span class=\"line\">      () =&gt; route.params,</span><br><span class=\"line\">      async newParams =&gt; &#123;</span><br><span class=\"line\">        userData.value = await fetchUser(newParams.id)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>​        请注意，在模板中我们仍然可以访问 <code>$router</code> 和 <code>$route</code>，所以不需要在 <code>setup</code> 中返回 <code>router</code> 或 <code>route</code>。</p>\n<h2 id=\"导航守卫-1\"><a href=\"#导航守卫-1\" class=\"headerlink\" title=\"导航守卫\"></a>导航守卫</h2><p>​        </p>\n"},{"title":"webpack学习一","date":"2022-02-02T10:53:38.000Z","_content":"\n\n\n#  webpack 学习\n\n## 模块化\n\n​\t\t首先，对于模块化，我们可以知道的一个是 node.js 作为一个后端的一个JavaScript，可以使用 require。但是这个不能在浏览器上面进行使用。\n\n\n\n​\t\t此时我们可以使用一个requireJs的一个方法来进行一个实现。可以在浏览器上面进行调用\n\n```\n大致就是 \n第一个是需要调用其他js文件的位置，是一个数组，代表了可以传递很多。 ./requireJs/add.js 。。\n第二个是一个回调函数，回调函数的参数是从你的 引入的 文件里面那个回调函数的执行的返回值作为的一个参数。同时参数的顺序取决于第一个数组的顺序。\ndefine([], function() {\n\treturn callFn\n})\n```\n\n<img src=\"webpack学习一/image-20220202191750607.png\" alt=\"image-20220202191750607\" style=\"zoom:50%;\" />\n\n\n\n定义一个 data-main的位置，代表了需要从哪进行执行。\n\n<img src=\"webpack学习一/image-20220202191837055.png\" alt=\"image-20220202191837055\" style=\"zoom:80%;\" />\n\n最后进行执行调用。\n\n![image-20220202191945426](webpack学习一/image-20220202191945426.png)\n\n这里的 data-* 是html5 的一个新的语法。同时图片懒加载也是运用了这个语法来存储图片的真正的src路径。\n\n\n\n​\t\t使用 script 的 type，设置type为module，然后使用 import进行导入\n\n```\nimport add from './esm/add.js'\n```\n\n​\t\t同时，如果使用 file 的方法去浏览器进行访问。那么及那个不能进行获取其他文件的内容。因为此时这个产生了跨域的请求。需要创建一个 http-server。\n\n​\t\t可以使用 npx http-server 进行启动\n\n\n\n\n\n\n\n","source":"_drafts/webpack/webpack学习一.md","raw":"---\ntitle: webpack学习一\ndate: 2022-02-02 18:53:38\ntags:\n - webpack\ncategories:\n - webpack\n---\n\n\n\n#  webpack 学习\n\n## 模块化\n\n​\t\t首先，对于模块化，我们可以知道的一个是 node.js 作为一个后端的一个JavaScript，可以使用 require。但是这个不能在浏览器上面进行使用。\n\n\n\n​\t\t此时我们可以使用一个requireJs的一个方法来进行一个实现。可以在浏览器上面进行调用\n\n```\n大致就是 \n第一个是需要调用其他js文件的位置，是一个数组，代表了可以传递很多。 ./requireJs/add.js 。。\n第二个是一个回调函数，回调函数的参数是从你的 引入的 文件里面那个回调函数的执行的返回值作为的一个参数。同时参数的顺序取决于第一个数组的顺序。\ndefine([], function() {\n\treturn callFn\n})\n```\n\n<img src=\"webpack学习一/image-20220202191750607.png\" alt=\"image-20220202191750607\" style=\"zoom:50%;\" />\n\n\n\n定义一个 data-main的位置，代表了需要从哪进行执行。\n\n<img src=\"webpack学习一/image-20220202191837055.png\" alt=\"image-20220202191837055\" style=\"zoom:80%;\" />\n\n最后进行执行调用。\n\n![image-20220202191945426](webpack学习一/image-20220202191945426.png)\n\n这里的 data-* 是html5 的一个新的语法。同时图片懒加载也是运用了这个语法来存储图片的真正的src路径。\n\n\n\n​\t\t使用 script 的 type，设置type为module，然后使用 import进行导入\n\n```\nimport add from './esm/add.js'\n```\n\n​\t\t同时，如果使用 file 的方法去浏览器进行访问。那么及那个不能进行获取其他文件的内容。因为此时这个产生了跨域的请求。需要创建一个 http-server。\n\n​\t\t可以使用 npx http-server 进行启动\n\n\n\n\n\n\n\n","slug":"webpack/webpack学习一","published":0,"updated":"2022-02-07T02:21:09.165Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckznhkk78000yikub494n5u9r","content":"<h1 id=\"webpack-学习\"><a href=\"#webpack-学习\" class=\"headerlink\" title=\"webpack 学习\"></a>webpack 学习</h1><h2 id=\"模块化\"><a href=\"#模块化\" class=\"headerlink\" title=\"模块化\"></a>模块化</h2><p>​        首先，对于模块化，我们可以知道的一个是 node.js 作为一个后端的一个JavaScript，可以使用 require。但是这个不能在浏览器上面进行使用。</p>\n<p>​        此时我们可以使用一个requireJs的一个方法来进行一个实现。可以在浏览器上面进行调用</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">大致就是 </span><br><span class=\"line\">第一个是需要调用其他js文件的位置，是一个数组，代表了可以传递很多。 ./requireJs/add.js 。。</span><br><span class=\"line\">第二个是一个回调函数，回调函数的参数是从你的 引入的 文件里面那个回调函数的执行的返回值作为的一个参数。同时参数的顺序取决于第一个数组的顺序。</span><br><span class=\"line\">define([], function() &#123;</span><br><span class=\"line\">\treturn callFn</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<img src=\"/.io//image-20220202191750607.png\" alt=\"image-20220202191750607\" style=\"zoom:50%;\">\n\n\n\n<p>定义一个 data-main的位置，代表了需要从哪进行执行。</p>\n<img src=\"/.io//image-20220202191837055.png\" alt=\"image-20220202191837055\" style=\"zoom:80%;\">\n\n<p>最后进行执行调用。</p>\n<p><img src=\"/.io//image-20220202191945426.png\" alt=\"image-20220202191945426\"></p>\n<p>这里的 data-* 是html5 的一个新的语法。同时图片懒加载也是运用了这个语法来存储图片的真正的src路径。</p>\n<p>​        使用 script 的 type，设置type为module，然后使用 import进行导入</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import add from &#x27;./esm/add.js&#x27;</span><br></pre></td></tr></table></figure>\n\n<p>​        同时，如果使用 file 的方法去浏览器进行访问。那么及那个不能进行获取其他文件的内容。因为此时这个产生了跨域的请求。需要创建一个 http-server。</p>\n<p>​        可以使用 npx http-server 进行启动</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"webpack-学习\"><a href=\"#webpack-学习\" class=\"headerlink\" title=\"webpack 学习\"></a>webpack 学习</h1><h2 id=\"模块化\"><a href=\"#模块化\" class=\"headerlink\" title=\"模块化\"></a>模块化</h2><p>​        首先，对于模块化，我们可以知道的一个是 node.js 作为一个后端的一个JavaScript，可以使用 require。但是这个不能在浏览器上面进行使用。</p>\n<p>​        此时我们可以使用一个requireJs的一个方法来进行一个实现。可以在浏览器上面进行调用</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">大致就是 </span><br><span class=\"line\">第一个是需要调用其他js文件的位置，是一个数组，代表了可以传递很多。 ./requireJs/add.js 。。</span><br><span class=\"line\">第二个是一个回调函数，回调函数的参数是从你的 引入的 文件里面那个回调函数的执行的返回值作为的一个参数。同时参数的顺序取决于第一个数组的顺序。</span><br><span class=\"line\">define([], function() &#123;</span><br><span class=\"line\">\treturn callFn</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<img src=\"/.io//image-20220202191750607.png\" alt=\"image-20220202191750607\" style=\"zoom:50%;\">\n\n\n\n<p>定义一个 data-main的位置，代表了需要从哪进行执行。</p>\n<img src=\"/.io//image-20220202191837055.png\" alt=\"image-20220202191837055\" style=\"zoom:80%;\">\n\n<p>最后进行执行调用。</p>\n<p><img src=\"/.io//image-20220202191945426.png\" alt=\"image-20220202191945426\"></p>\n<p>这里的 data-* 是html5 的一个新的语法。同时图片懒加载也是运用了这个语法来存储图片的真正的src路径。</p>\n<p>​        使用 script 的 type，设置type为module，然后使用 import进行导入</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import add from &#x27;./esm/add.js&#x27;</span><br></pre></td></tr></table></figure>\n\n<p>​        同时，如果使用 file 的方法去浏览器进行访问。那么及那个不能进行获取其他文件的内容。因为此时这个产生了跨域的请求。需要创建一个 http-server。</p>\n<p>​        可以使用 npx http-server 进行启动</p>\n"},{"title":"JavaScript定时器","date":"2022-01-22T11:28:13.000Z","_content":"\n\n\n#  JavaScript 定时器\n\n这里就简单的提几句。常用的两个\n\n```\nsetTimeout\nclearTimeout\n\nsetInterval\nclearInterval\n```\n\n\n\n## settimeout在执行之后，timer也不会清空的\n\n都会执行，代表了，执行之后，timer不清空\n\n```\nlet timer = settimeout(() => {}, 1)\n\n然后再延时执行下面方法\nlog.timer\nif (timer) log.1\ntimer && log.2\n```\n\n\n\n## cleartimeout清除之后 timer依然判断为true\n\n```\ncleartimeout(timer)\n\n然后再延时执行下面方法, 同上\nlog.timer\nif (timer) log.1\ntimer && log.2\n```\n\n","source":"_drafts/随笔/JavaScript定时器.md","raw":"---\ntitle: JavaScript定时器\ndate: 2022-01-22 19:28:13\ntags:\n - JavaScript\n - 随笔\ncategories:\n - JavaScript\n - 随笔\n---\n\n\n\n#  JavaScript 定时器\n\n这里就简单的提几句。常用的两个\n\n```\nsetTimeout\nclearTimeout\n\nsetInterval\nclearInterval\n```\n\n\n\n## settimeout在执行之后，timer也不会清空的\n\n都会执行，代表了，执行之后，timer不清空\n\n```\nlet timer = settimeout(() => {}, 1)\n\n然后再延时执行下面方法\nlog.timer\nif (timer) log.1\ntimer && log.2\n```\n\n\n\n## cleartimeout清除之后 timer依然判断为true\n\n```\ncleartimeout(timer)\n\n然后再延时执行下面方法, 同上\nlog.timer\nif (timer) log.1\ntimer && log.2\n```\n\n","slug":"随笔/JavaScript定时器","published":0,"updated":"2022-01-24T03:10:27.235Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckznhkk790011ikub962w5fyu","content":"<h1 id=\"JavaScript-定时器\"><a href=\"#JavaScript-定时器\" class=\"headerlink\" title=\"JavaScript 定时器\"></a>JavaScript 定时器</h1><p>这里就简单的提几句。常用的两个</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setTimeout</span><br><span class=\"line\">clearTimeout</span><br><span class=\"line\"></span><br><span class=\"line\">setInterval</span><br><span class=\"line\">clearInterval</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"settimeout在执行之后，timer也不会清空的\"><a href=\"#settimeout在执行之后，timer也不会清空的\" class=\"headerlink\" title=\"settimeout在执行之后，timer也不会清空的\"></a>settimeout在执行之后，timer也不会清空的</h2><p>都会执行，代表了，执行之后，timer不清空</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let timer = settimeout(() =&gt; &#123;&#125;, 1)</span><br><span class=\"line\"></span><br><span class=\"line\">然后再延时执行下面方法</span><br><span class=\"line\">log.timer</span><br><span class=\"line\">if (timer) log.1</span><br><span class=\"line\">timer &amp;&amp; log.2</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"cleartimeout清除之后-timer依然判断为true\"><a href=\"#cleartimeout清除之后-timer依然判断为true\" class=\"headerlink\" title=\"cleartimeout清除之后 timer依然判断为true\"></a>cleartimeout清除之后 timer依然判断为true</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cleartimeout(timer)</span><br><span class=\"line\"></span><br><span class=\"line\">然后再延时执行下面方法, 同上</span><br><span class=\"line\">log.timer</span><br><span class=\"line\">if (timer) log.1</span><br><span class=\"line\">timer &amp;&amp; log.2</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"JavaScript-定时器\"><a href=\"#JavaScript-定时器\" class=\"headerlink\" title=\"JavaScript 定时器\"></a>JavaScript 定时器</h1><p>这里就简单的提几句。常用的两个</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setTimeout</span><br><span class=\"line\">clearTimeout</span><br><span class=\"line\"></span><br><span class=\"line\">setInterval</span><br><span class=\"line\">clearInterval</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"settimeout在执行之后，timer也不会清空的\"><a href=\"#settimeout在执行之后，timer也不会清空的\" class=\"headerlink\" title=\"settimeout在执行之后，timer也不会清空的\"></a>settimeout在执行之后，timer也不会清空的</h2><p>都会执行，代表了，执行之后，timer不清空</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let timer = settimeout(() =&gt; &#123;&#125;, 1)</span><br><span class=\"line\"></span><br><span class=\"line\">然后再延时执行下面方法</span><br><span class=\"line\">log.timer</span><br><span class=\"line\">if (timer) log.1</span><br><span class=\"line\">timer &amp;&amp; log.2</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"cleartimeout清除之后-timer依然判断为true\"><a href=\"#cleartimeout清除之后-timer依然判断为true\" class=\"headerlink\" title=\"cleartimeout清除之后 timer依然判断为true\"></a>cleartimeout清除之后 timer依然判断为true</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cleartimeout(timer)</span><br><span class=\"line\"></span><br><span class=\"line\">然后再延时执行下面方法, 同上</span><br><span class=\"line\">log.timer</span><br><span class=\"line\">if (timer) log.1</span><br><span class=\"line\">timer &amp;&amp; log.2</span><br></pre></td></tr></table></figure>\n\n"},{"title":"nginx的使用","date":"2021-11-19T15:22:14.000Z","_content":"","source":"_drafts/随笔/nginx的使用.md","raw":"---\ntitle: nginx的使用\ndate: 2021-11-19 23:22:14\ntags:\ncategories:\n---\n","slug":"随笔/nginx的使用","published":0,"updated":"2022-02-07T02:21:09.165Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckznhkk7a0014ikubcbqwddwt","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"npm-package上传","date":"2022-01-22T15:02:31.000Z","_content":"\n\n\n#  npm包上传到npm官网\n\n众所周知，我们可以使用npm i xxx进行下载，npm作为一个包管理的一个工具，我们可以使用别人的包，我们也可以自己在npm上面创建一个属于自己的包，然后使用npm进行下载\n\n\n\n## 首先，肯定是要在 npm 官网上面创建一个账号了\n\n```\nhttps://www.npmjs.com/\n```\n\n\n\n## 然后就是 进入 cmd在本地进行登录\n\n```\n使用 npm login 就可以进行登录\n```\n\n注意点：\n\n​\t这个需要在官网，所以你要知道你现在连接的仓库是\n\n```\nhttps://registry.npmjs.org/\n```\n\n​\t当然我记得现在比较新的npm应该是在登录的时候可以看到自己登录的网站是哪个，\n\n​\t如果看不到自己的网站是哪个，那么我们可以使用一个包管理工具 nrm 进行管理\n\n```\nnpm i -g nrm\n\nnrm ls\nnrm use npm\n```\n\n然后使用\n\n```\nnpm login\n\n输入自己的用户名和密码，然后输入邮箱\n```\n\n\n\n## 初始化一个包\n\n```\nnpm init\n\n对应的意思是\n包名\n版本，听说需要从 0.0.1 开始\n描述\n入口文件\n测试指令：应该是，这个没有用过\ngit 仓库\n关键字，可以用于搜索\n作者\n证书，用MIT，开源管理不会过于严格，不会引起应激反应\n然后就是回车回车完事儿\n```\n\n![image-20220122231048580](npm-package上传/image-20220122231048580.png)\n\n\n\n## 编写自己的包的过程\n\nxxxx\n\n\n\n然后包编写完了，就是开始上传了\n\n## 最后，上传\n\n这个很简单，就是publish就完了。\n\n```\nnpm publish\n```\n\n\n\n## 更新 npm\n\n```\n就是修改一下 version\n然后 npm publish 就行\n```\n\n","source":"_drafts/随笔/npm-package上传.md","raw":"---\ntitle: npm-package上传\ndate: 2022-01-22 23:02:31\ntags:\n - npm\n - 随笔\ncategories:\n - 随笔\n---\n\n\n\n#  npm包上传到npm官网\n\n众所周知，我们可以使用npm i xxx进行下载，npm作为一个包管理的一个工具，我们可以使用别人的包，我们也可以自己在npm上面创建一个属于自己的包，然后使用npm进行下载\n\n\n\n## 首先，肯定是要在 npm 官网上面创建一个账号了\n\n```\nhttps://www.npmjs.com/\n```\n\n\n\n## 然后就是 进入 cmd在本地进行登录\n\n```\n使用 npm login 就可以进行登录\n```\n\n注意点：\n\n​\t这个需要在官网，所以你要知道你现在连接的仓库是\n\n```\nhttps://registry.npmjs.org/\n```\n\n​\t当然我记得现在比较新的npm应该是在登录的时候可以看到自己登录的网站是哪个，\n\n​\t如果看不到自己的网站是哪个，那么我们可以使用一个包管理工具 nrm 进行管理\n\n```\nnpm i -g nrm\n\nnrm ls\nnrm use npm\n```\n\n然后使用\n\n```\nnpm login\n\n输入自己的用户名和密码，然后输入邮箱\n```\n\n\n\n## 初始化一个包\n\n```\nnpm init\n\n对应的意思是\n包名\n版本，听说需要从 0.0.1 开始\n描述\n入口文件\n测试指令：应该是，这个没有用过\ngit 仓库\n关键字，可以用于搜索\n作者\n证书，用MIT，开源管理不会过于严格，不会引起应激反应\n然后就是回车回车完事儿\n```\n\n![image-20220122231048580](npm-package上传/image-20220122231048580.png)\n\n\n\n## 编写自己的包的过程\n\nxxxx\n\n\n\n然后包编写完了，就是开始上传了\n\n## 最后，上传\n\n这个很简单，就是publish就完了。\n\n```\nnpm publish\n```\n\n\n\n## 更新 npm\n\n```\n就是修改一下 version\n然后 npm publish 就行\n```\n\n","slug":"随笔/npm-package上传","published":0,"updated":"2022-01-24T02:18:53.312Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckznhkk7b0018ikubdy9c5czb","content":"<h1 id=\"npm包上传到npm官网\"><a href=\"#npm包上传到npm官网\" class=\"headerlink\" title=\"npm包上传到npm官网\"></a>npm包上传到npm官网</h1><p>众所周知，我们可以使用npm i xxx进行下载，npm作为一个包管理的一个工具，我们可以使用别人的包，我们也可以自己在npm上面创建一个属于自己的包，然后使用npm进行下载</p>\n<h2 id=\"首先，肯定是要在-npm-官网上面创建一个账号了\"><a href=\"#首先，肯定是要在-npm-官网上面创建一个账号了\" class=\"headerlink\" title=\"首先，肯定是要在 npm 官网上面创建一个账号了\"></a>首先，肯定是要在 npm 官网上面创建一个账号了</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://www.npmjs.com/</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"然后就是-进入-cmd在本地进行登录\"><a href=\"#然后就是-进入-cmd在本地进行登录\" class=\"headerlink\" title=\"然后就是 进入 cmd在本地进行登录\"></a>然后就是 进入 cmd在本地进行登录</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">使用 npm login 就可以进行登录</span><br></pre></td></tr></table></figure>\n\n<p>注意点：</p>\n<p>​    这个需要在官网，所以你要知道你现在连接的仓库是</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://registry.npmjs.org/</span><br></pre></td></tr></table></figure>\n\n<p>​    当然我记得现在比较新的npm应该是在登录的时候可以看到自己登录的网站是哪个，</p>\n<p>​    如果看不到自己的网站是哪个，那么我们可以使用一个包管理工具 nrm 进行管理</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm i -g nrm</span><br><span class=\"line\"></span><br><span class=\"line\">nrm ls</span><br><span class=\"line\">nrm use npm</span><br></pre></td></tr></table></figure>\n\n<p>然后使用</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm login</span><br><span class=\"line\"></span><br><span class=\"line\">输入自己的用户名和密码，然后输入邮箱</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"初始化一个包\"><a href=\"#初始化一个包\" class=\"headerlink\" title=\"初始化一个包\"></a>初始化一个包</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm init</span><br><span class=\"line\"></span><br><span class=\"line\">对应的意思是</span><br><span class=\"line\">包名</span><br><span class=\"line\">版本，听说需要从 0.0.1 开始</span><br><span class=\"line\">描述</span><br><span class=\"line\">入口文件</span><br><span class=\"line\">测试指令：应该是，这个没有用过</span><br><span class=\"line\">git 仓库</span><br><span class=\"line\">关键字，可以用于搜索</span><br><span class=\"line\">作者</span><br><span class=\"line\">证书，用MIT，开源管理不会过于严格，不会引起应激反应</span><br><span class=\"line\">然后就是回车回车完事儿</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/.io//image-20220122231048580.png\" alt=\"image-20220122231048580\"></p>\n<h2 id=\"编写自己的包的过程\"><a href=\"#编写自己的包的过程\" class=\"headerlink\" title=\"编写自己的包的过程\"></a>编写自己的包的过程</h2><p>xxxx</p>\n<p>然后包编写完了，就是开始上传了</p>\n<h2 id=\"最后，上传\"><a href=\"#最后，上传\" class=\"headerlink\" title=\"最后，上传\"></a>最后，上传</h2><p>这个很简单，就是publish就完了。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm publish</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"更新-npm\"><a href=\"#更新-npm\" class=\"headerlink\" title=\"更新 npm\"></a>更新 npm</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">就是修改一下 version</span><br><span class=\"line\">然后 npm publish 就行</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"npm包上传到npm官网\"><a href=\"#npm包上传到npm官网\" class=\"headerlink\" title=\"npm包上传到npm官网\"></a>npm包上传到npm官网</h1><p>众所周知，我们可以使用npm i xxx进行下载，npm作为一个包管理的一个工具，我们可以使用别人的包，我们也可以自己在npm上面创建一个属于自己的包，然后使用npm进行下载</p>\n<h2 id=\"首先，肯定是要在-npm-官网上面创建一个账号了\"><a href=\"#首先，肯定是要在-npm-官网上面创建一个账号了\" class=\"headerlink\" title=\"首先，肯定是要在 npm 官网上面创建一个账号了\"></a>首先，肯定是要在 npm 官网上面创建一个账号了</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://www.npmjs.com/</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"然后就是-进入-cmd在本地进行登录\"><a href=\"#然后就是-进入-cmd在本地进行登录\" class=\"headerlink\" title=\"然后就是 进入 cmd在本地进行登录\"></a>然后就是 进入 cmd在本地进行登录</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">使用 npm login 就可以进行登录</span><br></pre></td></tr></table></figure>\n\n<p>注意点：</p>\n<p>​    这个需要在官网，所以你要知道你现在连接的仓库是</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://registry.npmjs.org/</span><br></pre></td></tr></table></figure>\n\n<p>​    当然我记得现在比较新的npm应该是在登录的时候可以看到自己登录的网站是哪个，</p>\n<p>​    如果看不到自己的网站是哪个，那么我们可以使用一个包管理工具 nrm 进行管理</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm i -g nrm</span><br><span class=\"line\"></span><br><span class=\"line\">nrm ls</span><br><span class=\"line\">nrm use npm</span><br></pre></td></tr></table></figure>\n\n<p>然后使用</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm login</span><br><span class=\"line\"></span><br><span class=\"line\">输入自己的用户名和密码，然后输入邮箱</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"初始化一个包\"><a href=\"#初始化一个包\" class=\"headerlink\" title=\"初始化一个包\"></a>初始化一个包</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm init</span><br><span class=\"line\"></span><br><span class=\"line\">对应的意思是</span><br><span class=\"line\">包名</span><br><span class=\"line\">版本，听说需要从 0.0.1 开始</span><br><span class=\"line\">描述</span><br><span class=\"line\">入口文件</span><br><span class=\"line\">测试指令：应该是，这个没有用过</span><br><span class=\"line\">git 仓库</span><br><span class=\"line\">关键字，可以用于搜索</span><br><span class=\"line\">作者</span><br><span class=\"line\">证书，用MIT，开源管理不会过于严格，不会引起应激反应</span><br><span class=\"line\">然后就是回车回车完事儿</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/.io//image-20220122231048580.png\" alt=\"image-20220122231048580\"></p>\n<h2 id=\"编写自己的包的过程\"><a href=\"#编写自己的包的过程\" class=\"headerlink\" title=\"编写自己的包的过程\"></a>编写自己的包的过程</h2><p>xxxx</p>\n<p>然后包编写完了，就是开始上传了</p>\n<h2 id=\"最后，上传\"><a href=\"#最后，上传\" class=\"headerlink\" title=\"最后，上传\"></a>最后，上传</h2><p>这个很简单，就是publish就完了。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm publish</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"更新-npm\"><a href=\"#更新-npm\" class=\"headerlink\" title=\"更新 npm\"></a>更新 npm</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">就是修改一下 version</span><br><span class=\"line\">然后 npm publish 就行</span><br></pre></td></tr></table></figure>\n\n"},{"layout":"draft","title":"vue-css外部引入","date":"2022-01-20T08:48:04.000Z","_content":"\n\n\n#  vue的css样式 进行外部引入问题\n\n最近在项目开发中出现了如下的问题\n\n​\t就是 vue的样式 style 使用 scoped 进行了 私有化属性，但是却发现，我内部的一个组件的样式还是被其他地方影响了，所以记录一下问题原因\n\n\n\n原因：\n\n​\t因为 style 样式是通过 @import 进行的引入，所以就会出现私有化属性不起作用，原因的话，应该是@imort引入是一个属于重新请求的过程？（应该是）所以就绕过了 vue-loader 进行属性私有化过程，导致了样式变成了全局化\n\n\n\n方法：\n\n​\t其实也没有什么方法，要不就是直接写在 style 里面，要不就是使用 src进行引入，这样引入的样式就不会出现全局污染\n\n```\n<style scoped src=\"~/static/css/xxx.css\"></style>\n```\n\n\n\n同时也记录一下， style是可以同时写多个的，但是 scripte 一个vue文件里面只能写一个，因为需要 export导出的属性。\n","source":"_drafts/随笔/vue-css外部引入.md","raw":"---\nlayout: draft\ntitle: vue-css外部引入\ndate: 2022-01-20 16:48:04\ntags:\n - vue\n - 随笔\n---\n\n\n\n#  vue的css样式 进行外部引入问题\n\n最近在项目开发中出现了如下的问题\n\n​\t就是 vue的样式 style 使用 scoped 进行了 私有化属性，但是却发现，我内部的一个组件的样式还是被其他地方影响了，所以记录一下问题原因\n\n\n\n原因：\n\n​\t因为 style 样式是通过 @import 进行的引入，所以就会出现私有化属性不起作用，原因的话，应该是@imort引入是一个属于重新请求的过程？（应该是）所以就绕过了 vue-loader 进行属性私有化过程，导致了样式变成了全局化\n\n\n\n方法：\n\n​\t其实也没有什么方法，要不就是直接写在 style 里面，要不就是使用 src进行引入，这样引入的样式就不会出现全局污染\n\n```\n<style scoped src=\"~/static/css/xxx.css\"></style>\n```\n\n\n\n同时也记录一下， style是可以同时写多个的，但是 scripte 一个vue文件里面只能写一个，因为需要 export导出的属性。\n","slug":"随笔/vue-css外部引入","published":0,"updated":"2022-01-20T08:53:39.392Z","comments":1,"photos":[],"link":"","_id":"ckznhkk7b001aikubgermcg26","content":"<h1 id=\"vue的css样式-进行外部引入问题\"><a href=\"#vue的css样式-进行外部引入问题\" class=\"headerlink\" title=\"vue的css样式 进行外部引入问题\"></a>vue的css样式 进行外部引入问题</h1><p>最近在项目开发中出现了如下的问题</p>\n<p>​    就是 vue的样式 style 使用 scoped 进行了 私有化属性，但是却发现，我内部的一个组件的样式还是被其他地方影响了，所以记录一下问题原因</p>\n<p>原因：</p>\n<p>​    因为 style 样式是通过 @import 进行的引入，所以就会出现私有化属性不起作用，原因的话，应该是@imort引入是一个属于重新请求的过程？（应该是）所以就绕过了 vue-loader 进行属性私有化过程，导致了样式变成了全局化</p>\n<p>方法：</p>\n<p>​    其实也没有什么方法，要不就是直接写在 style 里面，要不就是使用 src进行引入，这样引入的样式就不会出现全局污染</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;style scoped src=&quot;~/static/css/xxx.css&quot;&gt;&lt;/style&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>同时也记录一下， style是可以同时写多个的，但是 scripte 一个vue文件里面只能写一个，因为需要 export导出的属性。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"vue的css样式-进行外部引入问题\"><a href=\"#vue的css样式-进行外部引入问题\" class=\"headerlink\" title=\"vue的css样式 进行外部引入问题\"></a>vue的css样式 进行外部引入问题</h1><p>最近在项目开发中出现了如下的问题</p>\n<p>​    就是 vue的样式 style 使用 scoped 进行了 私有化属性，但是却发现，我内部的一个组件的样式还是被其他地方影响了，所以记录一下问题原因</p>\n<p>原因：</p>\n<p>​    因为 style 样式是通过 @import 进行的引入，所以就会出现私有化属性不起作用，原因的话，应该是@imort引入是一个属于重新请求的过程？（应该是）所以就绕过了 vue-loader 进行属性私有化过程，导致了样式变成了全局化</p>\n<p>方法：</p>\n<p>​    其实也没有什么方法，要不就是直接写在 style 里面，要不就是使用 src进行引入，这样引入的样式就不会出现全局污染</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;style scoped src=&quot;~/static/css/xxx.css&quot;&gt;&lt;/style&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>同时也记录一下， style是可以同时写多个的，但是 scripte 一个vue文件里面只能写一个，因为需要 export导出的属性。</p>\n"},{"title":"css-hover和focus顺序","date":"2022-02-04T09:16:47.000Z","_content":"\n\n\n#  hover和focus的顺序问题\n\n```\ndiv:hover { }\ndiv:focus { }\n```\n\n​\t\t最近在写项目的时候无意间发现的问题，对于hover和触发和focus的触发问题。这个其实在学的时候就已经知道了，但是因为用的较少，所以还忘记了这个问题。\n\n​\t\t简单来说就是 hover需要放在focus的前面，因为hover的触发比focus触发的时机问题。会先focus然后再hover(应该)，但是在css里面，对于优先级相同的。在后面的会覆盖前面的。\n\n​\t\t通过这个我们也要知道关于冒泡和捕获触发的问题也要注意这个情况。事件是先捕获，然后再冒泡。\n\n","source":"_drafts/随笔/css-hover和focus顺序.md","raw":"---\ntitle: css-hover和focus顺序\ndate: 2022-02-04 17:16:47\ntags:\n - 随笔\n - CSS\ncategories:\n - CSS\n - 随笔\n---\n\n\n\n#  hover和focus的顺序问题\n\n```\ndiv:hover { }\ndiv:focus { }\n```\n\n​\t\t最近在写项目的时候无意间发现的问题，对于hover和触发和focus的触发问题。这个其实在学的时候就已经知道了，但是因为用的较少，所以还忘记了这个问题。\n\n​\t\t简单来说就是 hover需要放在focus的前面，因为hover的触发比focus触发的时机问题。会先focus然后再hover(应该)，但是在css里面，对于优先级相同的。在后面的会覆盖前面的。\n\n​\t\t通过这个我们也要知道关于冒泡和捕获触发的问题也要注意这个情况。事件是先捕获，然后再冒泡。\n\n","slug":"随笔/css-hover和focus顺序","published":0,"updated":"2022-02-07T02:21:09.165Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckznhkk7c001fikub5i43afm1","content":"<h1 id=\"hover和focus的顺序问题\"><a href=\"#hover和focus的顺序问题\" class=\"headerlink\" title=\"hover和focus的顺序问题\"></a>hover和focus的顺序问题</h1><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">div:hover &#123; &#125;</span><br><span class=\"line\">div:focus &#123; &#125;</span><br></pre></td></tr></table></figure>\n\n<p>​        最近在写项目的时候无意间发现的问题，对于hover和触发和focus的触发问题。这个其实在学的时候就已经知道了，但是因为用的较少，所以还忘记了这个问题。</p>\n<p>​        简单来说就是 hover需要放在focus的前面，因为hover的触发比focus触发的时机问题。会先focus然后再hover(应该)，但是在css里面，对于优先级相同的。在后面的会覆盖前面的。</p>\n<p>​        通过这个我们也要知道关于冒泡和捕获触发的问题也要注意这个情况。事件是先捕获，然后再冒泡。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"hover和focus的顺序问题\"><a href=\"#hover和focus的顺序问题\" class=\"headerlink\" title=\"hover和focus的顺序问题\"></a>hover和focus的顺序问题</h1><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">div:hover &#123; &#125;</span><br><span class=\"line\">div:focus &#123; &#125;</span><br></pre></td></tr></table></figure>\n\n<p>​        最近在写项目的时候无意间发现的问题，对于hover和触发和focus的触发问题。这个其实在学的时候就已经知道了，但是因为用的较少，所以还忘记了这个问题。</p>\n<p>​        简单来说就是 hover需要放在focus的前面，因为hover的触发比focus触发的时机问题。会先focus然后再hover(应该)，但是在css里面，对于优先级相同的。在后面的会覆盖前面的。</p>\n<p>​        通过这个我们也要知道关于冒泡和捕获触发的问题也要注意这个情况。事件是先捕获，然后再冒泡。</p>\n"},{"layout":"draft","title":"jet-brains文件内容的正则查找和替换","date":"2022-01-11T06:40:44.000Z","_content":"\n\n\n\n\n#  jet-brains webStore的正则查找\n\n![image-20220111144213336](jet-brains文件内容的正则查找和替换\\image-20220111144213336.png)\n\n\n\n在 ctrl+f 之后，选择这个 .* 或者是 reg 的就是正则的。这个其实也没有什么\n\n重点来了！！正则的替换\n\n\n\n# 正则替换\n\n```\naaaaa(.*)ccc(.*)\n```\n\n```\nxxx$2aa$1z\n```\n\n使用 () 将要保留的元素给记录下来，然后再在下面使用 $1/2/3 来进行获取对应的值来进行替换\n\n![image-20220111144549850](jet-brains文件内容的正则查找和替换\\image-20220111144549850.png)\n\n![image-20220111144559970](jet-brains文件内容的正则查找和替换\\image-20220111144559970-16418835623721.png)\n\n\n\n这样就能给替换成功了，很是方便。\n\n","source":"_drafts/随笔/jet-brains文件内容的正则查找和替换.md","raw":"---\nlayout: draft\ntitle: jet-brains文件内容的正则查找和替换\ndate: 2022-01-11 14:40:44\ntags:\n - 随笔\ncategories:\n - 随笔\n---\n\n\n\n\n\n#  jet-brains webStore的正则查找\n\n![image-20220111144213336](jet-brains文件内容的正则查找和替换\\image-20220111144213336.png)\n\n\n\n在 ctrl+f 之后，选择这个 .* 或者是 reg 的就是正则的。这个其实也没有什么\n\n重点来了！！正则的替换\n\n\n\n# 正则替换\n\n```\naaaaa(.*)ccc(.*)\n```\n\n```\nxxx$2aa$1z\n```\n\n使用 () 将要保留的元素给记录下来，然后再在下面使用 $1/2/3 来进行获取对应的值来进行替换\n\n![image-20220111144549850](jet-brains文件内容的正则查找和替换\\image-20220111144549850.png)\n\n![image-20220111144559970](jet-brains文件内容的正则查找和替换\\image-20220111144559970-16418835623721.png)\n\n\n\n这样就能给替换成功了，很是方便。\n\n","slug":"随笔/jet-brains文件内容的正则查找和替换","published":0,"updated":"2022-01-11T06:47:03.759Z","comments":1,"photos":[],"link":"","_id":"ckznhkk7d001iikubec48ef7n","content":"<h1 id=\"jet-brains-webStore的正则查找\"><a href=\"#jet-brains-webStore的正则查找\" class=\"headerlink\" title=\"jet-brains webStore的正则查找\"></a>jet-brains webStore的正则查找</h1><p><img src=\"/.io//jet-brains%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%E7%9A%84%E6%AD%A3%E5%88%99%E6%9F%A5%E6%89%BE%E5%92%8C%E6%9B%BF%E6%8D%A2%5Cimage-20220111144213336.png\" alt=\"image-20220111144213336\"></p>\n<p>在 ctrl+f 之后，选择这个 .* 或者是 reg 的就是正则的。这个其实也没有什么</p>\n<p>重点来了！！正则的替换</p>\n<h1 id=\"正则替换\"><a href=\"#正则替换\" class=\"headerlink\" title=\"正则替换\"></a>正则替换</h1><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">aaaaa(.*)ccc(.*)</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xxx$2aa$1z</span><br></pre></td></tr></table></figure>\n\n<p>使用 () 将要保留的元素给记录下来，然后再在下面使用 $1/2/3 来进行获取对应的值来进行替换</p>\n<p><img src=\"/.io//jet-brains%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%E7%9A%84%E6%AD%A3%E5%88%99%E6%9F%A5%E6%89%BE%E5%92%8C%E6%9B%BF%E6%8D%A2%5Cimage-20220111144549850.png\" alt=\"image-20220111144549850\"></p>\n<p><img src=\"/.io//jet-brains%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%E7%9A%84%E6%AD%A3%E5%88%99%E6%9F%A5%E6%89%BE%E5%92%8C%E6%9B%BF%E6%8D%A2%5Cimage-20220111144559970-16418835623721.png\" alt=\"image-20220111144559970\"></p>\n<p>这样就能给替换成功了，很是方便。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"jet-brains-webStore的正则查找\"><a href=\"#jet-brains-webStore的正则查找\" class=\"headerlink\" title=\"jet-brains webStore的正则查找\"></a>jet-brains webStore的正则查找</h1><p><img src=\"/.io//jet-brains%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%E7%9A%84%E6%AD%A3%E5%88%99%E6%9F%A5%E6%89%BE%E5%92%8C%E6%9B%BF%E6%8D%A2%5Cimage-20220111144213336.png\" alt=\"image-20220111144213336\"></p>\n<p>在 ctrl+f 之后，选择这个 .* 或者是 reg 的就是正则的。这个其实也没有什么</p>\n<p>重点来了！！正则的替换</p>\n<h1 id=\"正则替换\"><a href=\"#正则替换\" class=\"headerlink\" title=\"正则替换\"></a>正则替换</h1><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">aaaaa(.*)ccc(.*)</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xxx$2aa$1z</span><br></pre></td></tr></table></figure>\n\n<p>使用 () 将要保留的元素给记录下来，然后再在下面使用 $1/2/3 来进行获取对应的值来进行替换</p>\n<p><img src=\"/.io//jet-brains%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%E7%9A%84%E6%AD%A3%E5%88%99%E6%9F%A5%E6%89%BE%E5%92%8C%E6%9B%BF%E6%8D%A2%5Cimage-20220111144549850.png\" alt=\"image-20220111144549850\"></p>\n<p><img src=\"/.io//jet-brains%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%E7%9A%84%E6%AD%A3%E5%88%99%E6%9F%A5%E6%89%BE%E5%92%8C%E6%9B%BF%E6%8D%A2%5Cimage-20220111144559970-16418835623721.png\" alt=\"image-20220111144559970\"></p>\n<p>这样就能给替换成功了，很是方便。</p>\n"},{"title":"字体图标的制作方法","date":"2022-02-03T08:31:18.000Z","_content":"\n\n\n#  字体图标的制作\n\n​\t\t首先。我们知道对于一个input输入框左右两边的一个小图标。一般会用一个常用的方法：字体图标 来进行显示。然后我们又从element ui的源码里面知道。字体图标是引入的。通过设置一个 font-face 来进行初始化一个 font-family。\n\n​\t\t那么我们此时就先知道一个事情。那就是如何使用字体图标。\n\n​\t\t但是我们此时就开始思考。那么这个字体图标是怎么进行显示的呢。\n\n\n\n## 字体图标的显示\n\n​\t\t我们通过查阅资料后，首先知道了，文字的显示是通过一个unicode码，进行的编译。unicode码又被叫做万国码。其中对于 e000 到 f8ff 这个返回作为用户的专用区，所以我们也可以发现。对于自定义的字体图标的content里面都是 \\e217 等等这种样子的。\n\n\n\n## 字体图标的生成\n\n​\t\t通过上面我们知道了第一个，那就是字体图标是使用的自定义专区。\n\n​\t\t然后就是我们要知道的第二个，字体图标是怎么生成的。\n\n\n\n​\t\t这里我就简单的直说了。\n\n​\t\t字体图标的生成。我们只需要对应的svg图片。然后通过使用一个转换方法进行转换。这里我说一个 **阿里巴巴矢量图标库** 的网站，它这个网站可以上传图标。然后就会自动给你生成打包好。不需要你自己的操作。\n\n\n\n## svg的制作\n\n​\t\t知道了字体图标的生成是通过svg进行的。那么我们只需要制作svg图标即可。这个也很方便。最简单的我们可以直接使用网站上进行svg制作。但是这样就没有那么好。制作的不会那么精良。那么我们也可以使用专业的制作软件，比例PS。等进行制作。\n\n\n\n## 字体图标的生成原理\n\n​\t\t暂未了解。\n\n​\t\t我们知道，字体图标是通过svg进行的转换。但是这个中间的转换方法我还没有了解。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_drafts/随笔/字体图标的制作方法.md","raw":"---\ntitle: 字体图标的制作方法\ndate: 2022-02-03 16:31:18\ntags:\n - 随笔\ncategories:\n - 随笔\n---\n\n\n\n#  字体图标的制作\n\n​\t\t首先。我们知道对于一个input输入框左右两边的一个小图标。一般会用一个常用的方法：字体图标 来进行显示。然后我们又从element ui的源码里面知道。字体图标是引入的。通过设置一个 font-face 来进行初始化一个 font-family。\n\n​\t\t那么我们此时就先知道一个事情。那就是如何使用字体图标。\n\n​\t\t但是我们此时就开始思考。那么这个字体图标是怎么进行显示的呢。\n\n\n\n## 字体图标的显示\n\n​\t\t我们通过查阅资料后，首先知道了，文字的显示是通过一个unicode码，进行的编译。unicode码又被叫做万国码。其中对于 e000 到 f8ff 这个返回作为用户的专用区，所以我们也可以发现。对于自定义的字体图标的content里面都是 \\e217 等等这种样子的。\n\n\n\n## 字体图标的生成\n\n​\t\t通过上面我们知道了第一个，那就是字体图标是使用的自定义专区。\n\n​\t\t然后就是我们要知道的第二个，字体图标是怎么生成的。\n\n\n\n​\t\t这里我就简单的直说了。\n\n​\t\t字体图标的生成。我们只需要对应的svg图片。然后通过使用一个转换方法进行转换。这里我说一个 **阿里巴巴矢量图标库** 的网站，它这个网站可以上传图标。然后就会自动给你生成打包好。不需要你自己的操作。\n\n\n\n## svg的制作\n\n​\t\t知道了字体图标的生成是通过svg进行的。那么我们只需要制作svg图标即可。这个也很方便。最简单的我们可以直接使用网站上进行svg制作。但是这样就没有那么好。制作的不会那么精良。那么我们也可以使用专业的制作软件，比例PS。等进行制作。\n\n\n\n## 字体图标的生成原理\n\n​\t\t暂未了解。\n\n​\t\t我们知道，字体图标是通过svg进行的转换。但是这个中间的转换方法我还没有了解。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"随笔/字体图标的制作方法","published":0,"updated":"2022-02-07T02:21:09.165Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckznhkk7e001mikub5fov2duw","content":"<h1 id=\"字体图标的制作\"><a href=\"#字体图标的制作\" class=\"headerlink\" title=\"字体图标的制作\"></a>字体图标的制作</h1><p>​        首先。我们知道对于一个input输入框左右两边的一个小图标。一般会用一个常用的方法：字体图标 来进行显示。然后我们又从element ui的源码里面知道。字体图标是引入的。通过设置一个 font-face 来进行初始化一个 font-family。</p>\n<p>​        那么我们此时就先知道一个事情。那就是如何使用字体图标。</p>\n<p>​        但是我们此时就开始思考。那么这个字体图标是怎么进行显示的呢。</p>\n<h2 id=\"字体图标的显示\"><a href=\"#字体图标的显示\" class=\"headerlink\" title=\"字体图标的显示\"></a>字体图标的显示</h2><p>​        我们通过查阅资料后，首先知道了，文字的显示是通过一个unicode码，进行的编译。unicode码又被叫做万国码。其中对于 e000 到 f8ff 这个返回作为用户的专用区，所以我们也可以发现。对于自定义的字体图标的content里面都是 \\e217 等等这种样子的。</p>\n<h2 id=\"字体图标的生成\"><a href=\"#字体图标的生成\" class=\"headerlink\" title=\"字体图标的生成\"></a>字体图标的生成</h2><p>​        通过上面我们知道了第一个，那就是字体图标是使用的自定义专区。</p>\n<p>​        然后就是我们要知道的第二个，字体图标是怎么生成的。</p>\n<p>​        这里我就简单的直说了。</p>\n<p>​        字体图标的生成。我们只需要对应的svg图片。然后通过使用一个转换方法进行转换。这里我说一个 <strong>阿里巴巴矢量图标库</strong> 的网站，它这个网站可以上传图标。然后就会自动给你生成打包好。不需要你自己的操作。</p>\n<h2 id=\"svg的制作\"><a href=\"#svg的制作\" class=\"headerlink\" title=\"svg的制作\"></a>svg的制作</h2><p>​        知道了字体图标的生成是通过svg进行的。那么我们只需要制作svg图标即可。这个也很方便。最简单的我们可以直接使用网站上进行svg制作。但是这样就没有那么好。制作的不会那么精良。那么我们也可以使用专业的制作软件，比例PS。等进行制作。</p>\n<h2 id=\"字体图标的生成原理\"><a href=\"#字体图标的生成原理\" class=\"headerlink\" title=\"字体图标的生成原理\"></a>字体图标的生成原理</h2><p>​        暂未了解。</p>\n<p>​        我们知道，字体图标是通过svg进行的转换。但是这个中间的转换方法我还没有了解。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"字体图标的制作\"><a href=\"#字体图标的制作\" class=\"headerlink\" title=\"字体图标的制作\"></a>字体图标的制作</h1><p>​        首先。我们知道对于一个input输入框左右两边的一个小图标。一般会用一个常用的方法：字体图标 来进行显示。然后我们又从element ui的源码里面知道。字体图标是引入的。通过设置一个 font-face 来进行初始化一个 font-family。</p>\n<p>​        那么我们此时就先知道一个事情。那就是如何使用字体图标。</p>\n<p>​        但是我们此时就开始思考。那么这个字体图标是怎么进行显示的呢。</p>\n<h2 id=\"字体图标的显示\"><a href=\"#字体图标的显示\" class=\"headerlink\" title=\"字体图标的显示\"></a>字体图标的显示</h2><p>​        我们通过查阅资料后，首先知道了，文字的显示是通过一个unicode码，进行的编译。unicode码又被叫做万国码。其中对于 e000 到 f8ff 这个返回作为用户的专用区，所以我们也可以发现。对于自定义的字体图标的content里面都是 \\e217 等等这种样子的。</p>\n<h2 id=\"字体图标的生成\"><a href=\"#字体图标的生成\" class=\"headerlink\" title=\"字体图标的生成\"></a>字体图标的生成</h2><p>​        通过上面我们知道了第一个，那就是字体图标是使用的自定义专区。</p>\n<p>​        然后就是我们要知道的第二个，字体图标是怎么生成的。</p>\n<p>​        这里我就简单的直说了。</p>\n<p>​        字体图标的生成。我们只需要对应的svg图片。然后通过使用一个转换方法进行转换。这里我说一个 <strong>阿里巴巴矢量图标库</strong> 的网站，它这个网站可以上传图标。然后就会自动给你生成打包好。不需要你自己的操作。</p>\n<h2 id=\"svg的制作\"><a href=\"#svg的制作\" class=\"headerlink\" title=\"svg的制作\"></a>svg的制作</h2><p>​        知道了字体图标的生成是通过svg进行的。那么我们只需要制作svg图标即可。这个也很方便。最简单的我们可以直接使用网站上进行svg制作。但是这样就没有那么好。制作的不会那么精良。那么我们也可以使用专业的制作软件，比例PS。等进行制作。</p>\n<h2 id=\"字体图标的生成原理\"><a href=\"#字体图标的生成原理\" class=\"headerlink\" title=\"字体图标的生成原理\"></a>字体图标的生成原理</h2><p>​        暂未了解。</p>\n<p>​        我们知道，字体图标是通过svg进行的转换。但是这个中间的转换方法我还没有了解。</p>\n"},{"title":"html标签的data-*属性","date":"2022-02-02T11:25:12.000Z","_content":"\n\n\n#  什么是HTML标签的 data-* 属性\n\n​\t\t通过对于图片懒加载的学习和requireJs中的一个了解。我们发现了一个处于标签中的一个属性data-*。那么这个属性是什么意思呢。\n\n\n\n​\t\t首先通过了解。我们知道了，data-*，这个属性是属于HTML5的一个新的特性。特点就是，可以通过这个方式给HTML标签添加新的属性。\n\n\n\n## 获取方式\n\n### 使用 getAttribute进行获取\n\n```\nelem.getAttribute( name );\n```\n\n\n\n### 使用 HTML5 欣特性 dataset 进行获取\n\n```\nelem.dataset.name 注意，使用 短横线命名的需要改为驼峰来进行取值。\n```\n\n\n\n","source":"_drafts/随笔/html标签的data-属性.md","raw":"---\ntitle: html标签的data-*属性\ndate: 2022-02-02 19:25:12\ntags:\n - HTML\n - 随笔\ncategories:\n - HTML\n - 随笔\n---\n\n\n\n#  什么是HTML标签的 data-* 属性\n\n​\t\t通过对于图片懒加载的学习和requireJs中的一个了解。我们发现了一个处于标签中的一个属性data-*。那么这个属性是什么意思呢。\n\n\n\n​\t\t首先通过了解。我们知道了，data-*，这个属性是属于HTML5的一个新的特性。特点就是，可以通过这个方式给HTML标签添加新的属性。\n\n\n\n## 获取方式\n\n### 使用 getAttribute进行获取\n\n```\nelem.getAttribute( name );\n```\n\n\n\n### 使用 HTML5 欣特性 dataset 进行获取\n\n```\nelem.dataset.name 注意，使用 短横线命名的需要改为驼峰来进行取值。\n```\n\n\n\n","slug":"随笔/html标签的data-属性","published":0,"updated":"2022-02-07T02:21:09.165Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckznhkk7e001pikubbvyh4d48","content":"<h1 id=\"什么是HTML标签的-data-属性\"><a href=\"#什么是HTML标签的-data-属性\" class=\"headerlink\" title=\"什么是HTML标签的 data-* 属性\"></a>什么是HTML标签的 data-* 属性</h1><p>​        通过对于图片懒加载的学习和requireJs中的一个了解。我们发现了一个处于标签中的一个属性data-*。那么这个属性是什么意思呢。</p>\n<p>​        首先通过了解。我们知道了，data-*，这个属性是属于HTML5的一个新的特性。特点就是，可以通过这个方式给HTML标签添加新的属性。</p>\n<h2 id=\"获取方式\"><a href=\"#获取方式\" class=\"headerlink\" title=\"获取方式\"></a>获取方式</h2><h3 id=\"使用-getAttribute进行获取\"><a href=\"#使用-getAttribute进行获取\" class=\"headerlink\" title=\"使用 getAttribute进行获取\"></a>使用 getAttribute进行获取</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">elem.getAttribute( name );</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"使用-HTML5-欣特性-dataset-进行获取\"><a href=\"#使用-HTML5-欣特性-dataset-进行获取\" class=\"headerlink\" title=\"使用 HTML5 欣特性 dataset 进行获取\"></a>使用 HTML5 欣特性 dataset 进行获取</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">elem.dataset.name 注意，使用 短横线命名的需要改为驼峰来进行取值。</span><br></pre></td></tr></table></figure>\n\n\n\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"什么是HTML标签的-data-属性\"><a href=\"#什么是HTML标签的-data-属性\" class=\"headerlink\" title=\"什么是HTML标签的 data-* 属性\"></a>什么是HTML标签的 data-* 属性</h1><p>​        通过对于图片懒加载的学习和requireJs中的一个了解。我们发现了一个处于标签中的一个属性data-*。那么这个属性是什么意思呢。</p>\n<p>​        首先通过了解。我们知道了，data-*，这个属性是属于HTML5的一个新的特性。特点就是，可以通过这个方式给HTML标签添加新的属性。</p>\n<h2 id=\"获取方式\"><a href=\"#获取方式\" class=\"headerlink\" title=\"获取方式\"></a>获取方式</h2><h3 id=\"使用-getAttribute进行获取\"><a href=\"#使用-getAttribute进行获取\" class=\"headerlink\" title=\"使用 getAttribute进行获取\"></a>使用 getAttribute进行获取</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">elem.getAttribute( name );</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"使用-HTML5-欣特性-dataset-进行获取\"><a href=\"#使用-HTML5-欣特性-dataset-进行获取\" class=\"headerlink\" title=\"使用 HTML5 欣特性 dataset 进行获取\"></a>使用 HTML5 欣特性 dataset 进行获取</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">elem.dataset.name 注意，使用 短横线命名的需要改为驼峰来进行取值。</span><br></pre></td></tr></table></figure>\n\n\n\n"},{"layout":"draft","title":"媒体查询","date":"2022-01-20T09:21:40.000Z","_content":"\n\n\n#  css 媒体查询的问题\n\n最近在开发项目时，对于项目的适配，发现了一个关于媒体查询的问题\n\n就是在电脑端，放大了浏览器，然后对应的媒体查询也会进行改变，\n\n比如\n\n```\n@media screen and (min-width: 300px) {}\n```\n\n上面这个是 最小宽度300 时进行调用，但是如果我们开始的屏幕宽度是350，是满足的，但是我们放大浏览器导致了屏幕放大，就会出现可能屏幕像素没有350的情况，这个就是媒体查询的问题，具体原因没有了解，但是因为媒体查询导致了出现屏幕放大会变成移动端的样式，所以要慎用。\n","source":"_drafts/随笔/媒体查询.md","raw":"---\nlayout: draft\ntitle: 媒体查询\ndate: 2022-01-20 17:21:40\ntags:\n - 随笔\n---\n\n\n\n#  css 媒体查询的问题\n\n最近在开发项目时，对于项目的适配，发现了一个关于媒体查询的问题\n\n就是在电脑端，放大了浏览器，然后对应的媒体查询也会进行改变，\n\n比如\n\n```\n@media screen and (min-width: 300px) {}\n```\n\n上面这个是 最小宽度300 时进行调用，但是如果我们开始的屏幕宽度是350，是满足的，但是我们放大浏览器导致了屏幕放大，就会出现可能屏幕像素没有350的情况，这个就是媒体查询的问题，具体原因没有了解，但是因为媒体查询导致了出现屏幕放大会变成移动端的样式，所以要慎用。\n","slug":"随笔/媒体查询","published":0,"updated":"2022-01-20T09:25:07.254Z","comments":1,"photos":[],"link":"","_id":"ckznhkk7g001uikub352zezws","content":"<h1 id=\"css-媒体查询的问题\"><a href=\"#css-媒体查询的问题\" class=\"headerlink\" title=\"css 媒体查询的问题\"></a>css 媒体查询的问题</h1><p>最近在开发项目时，对于项目的适配，发现了一个关于媒体查询的问题</p>\n<p>就是在电脑端，放大了浏览器，然后对应的媒体查询也会进行改变，</p>\n<p>比如</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@media screen and (min-width: 300px) &#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面这个是 最小宽度300 时进行调用，但是如果我们开始的屏幕宽度是350，是满足的，但是我们放大浏览器导致了屏幕放大，就会出现可能屏幕像素没有350的情况，这个就是媒体查询的问题，具体原因没有了解，但是因为媒体查询导致了出现屏幕放大会变成移动端的样式，所以要慎用。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"css-媒体查询的问题\"><a href=\"#css-媒体查询的问题\" class=\"headerlink\" title=\"css 媒体查询的问题\"></a>css 媒体查询的问题</h1><p>最近在开发项目时，对于项目的适配，发现了一个关于媒体查询的问题</p>\n<p>就是在电脑端，放大了浏览器，然后对应的媒体查询也会进行改变，</p>\n<p>比如</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@media screen and (min-width: 300px) &#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面这个是 最小宽度300 时进行调用，但是如果我们开始的屏幕宽度是350，是满足的，但是我们放大浏览器导致了屏幕放大，就会出现可能屏幕像素没有350的情况，这个就是媒体查询的问题，具体原因没有了解，但是因为媒体查询导致了出现屏幕放大会变成移动端的样式，所以要慎用。</p>\n"},{"title":"CSS伪类和伪元素","date":"2021-11-13T15:08:34.000Z","_content":"\n\n\n#  CSS伪类和伪元素\n\n```\nhttps://developer.mozilla.org/zh-CN/docs/Learn/CSS/Building_blocks/Selectors/Pseudo-classes_and_pseudo-elements\n```\n\n\n\n## 伪类\n\n```\nhttps://developer.mozilla.org/zh-CN/docs/Web/CSS/Pseudo-classes\n```\n\n​\t\t伪类是选择器的一种，它用于选择处于特定状态的元素，比如当它们是这一类型的第一个元素时，或者是当鼠标指针悬浮在元素上面的时候。\n\n```\n使用的是单冒号\n:\n```\n\n### 行为伪类\n\n​\t\t一些伪类只会在用户以某种方式和文档交互的时候应用。这些**用户行为伪类**，有时叫做**动态伪类**，表现得就像是一个类在用户和元素交互的时候加到了元素上一样。\n\n```\n:hover,:focus\n```\n\n```\ndiv:hover {}\n```\n\n\n\n## 伪元素\n\n```\nhttps://developer.mozilla.org/zh-CN/docs/Web/CSS/Pseudo-elements\n```\n\n​\t\t伪元素以类似方式表现，不过表现得是像你往标记文本中加入全新的HTML元素一样，而不是向现有的元素上应用类。伪元素开头为双冒号`::`。\n\n> **备注：**一些早期的伪元素曾使用单冒号的语法，所以你可能会在代码或者示例中看到。现代的浏览器为了保持后向兼容，支持早期的带有单双冒号语法的伪元素。\n\n```\n::before\n::after\n```\n\n```\n//before和after的伪元素 content是必须的。\ndiv::before {\n\tcontent: '';\n}\n```\n\n\n\n# 区别\n\n* 伪元素是生成一个新的，或者表现的像是生成了一个新的HTML元素。\n\n  伪类是选择处于某种状态的的元素。\n\n* 伪元素是使用的 ::\n\n  伪类是使用的 :\n\n","source":"_posts/CSS/CSS伪类和伪元素.md","raw":"---\ntitle: CSS伪类和伪元素\ndate: 2021-11-13 23:08:34\ntags:\n - CSS\n - 随笔\ncategories:\n - CSS\n - 随笔\n---\n\n\n\n#  CSS伪类和伪元素\n\n```\nhttps://developer.mozilla.org/zh-CN/docs/Learn/CSS/Building_blocks/Selectors/Pseudo-classes_and_pseudo-elements\n```\n\n\n\n## 伪类\n\n```\nhttps://developer.mozilla.org/zh-CN/docs/Web/CSS/Pseudo-classes\n```\n\n​\t\t伪类是选择器的一种，它用于选择处于特定状态的元素，比如当它们是这一类型的第一个元素时，或者是当鼠标指针悬浮在元素上面的时候。\n\n```\n使用的是单冒号\n:\n```\n\n### 行为伪类\n\n​\t\t一些伪类只会在用户以某种方式和文档交互的时候应用。这些**用户行为伪类**，有时叫做**动态伪类**，表现得就像是一个类在用户和元素交互的时候加到了元素上一样。\n\n```\n:hover,:focus\n```\n\n```\ndiv:hover {}\n```\n\n\n\n## 伪元素\n\n```\nhttps://developer.mozilla.org/zh-CN/docs/Web/CSS/Pseudo-elements\n```\n\n​\t\t伪元素以类似方式表现，不过表现得是像你往标记文本中加入全新的HTML元素一样，而不是向现有的元素上应用类。伪元素开头为双冒号`::`。\n\n> **备注：**一些早期的伪元素曾使用单冒号的语法，所以你可能会在代码或者示例中看到。现代的浏览器为了保持后向兼容，支持早期的带有单双冒号语法的伪元素。\n\n```\n::before\n::after\n```\n\n```\n//before和after的伪元素 content是必须的。\ndiv::before {\n\tcontent: '';\n}\n```\n\n\n\n# 区别\n\n* 伪元素是生成一个新的，或者表现的像是生成了一个新的HTML元素。\n\n  伪类是选择处于某种状态的的元素。\n\n* 伪元素是使用的 ::\n\n  伪类是使用的 :\n\n","slug":"CSS/CSS伪类和伪元素","published":1,"updated":"2021-12-09T01:56:49.388Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckznhkk7h001wikub0m561tyd","content":"<h1 id=\"CSS伪类和伪元素\"><a href=\"#CSS伪类和伪元素\" class=\"headerlink\" title=\"CSS伪类和伪元素\"></a>CSS伪类和伪元素</h1><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://developer.mozilla.org/zh-CN/docs/Learn/CSS/Building_blocks/Selectors/Pseudo-classes_and_pseudo-elements</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"伪类\"><a href=\"#伪类\" class=\"headerlink\" title=\"伪类\"></a>伪类</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://developer.mozilla.org/zh-CN/docs/Web/CSS/Pseudo-classes</span><br></pre></td></tr></table></figure>\n\n<p>​        伪类是选择器的一种，它用于选择处于特定状态的元素，比如当它们是这一类型的第一个元素时，或者是当鼠标指针悬浮在元素上面的时候。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">使用的是单冒号</span><br><span class=\"line\">:</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"行为伪类\"><a href=\"#行为伪类\" class=\"headerlink\" title=\"行为伪类\"></a>行为伪类</h3><p>​        一些伪类只会在用户以某种方式和文档交互的时候应用。这些<strong>用户行为伪类</strong>，有时叫做<strong>动态伪类</strong>，表现得就像是一个类在用户和元素交互的时候加到了元素上一样。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:hover,:focus</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">div:hover &#123;&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"伪元素\"><a href=\"#伪元素\" class=\"headerlink\" title=\"伪元素\"></a>伪元素</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://developer.mozilla.org/zh-CN/docs/Web/CSS/Pseudo-elements</span><br></pre></td></tr></table></figure>\n\n<p>​        伪元素以类似方式表现，不过表现得是像你往标记文本中加入全新的HTML元素一样，而不是向现有的元素上应用类。伪元素开头为双冒号<code>::</code>。</p>\n<blockquote>\n<p><strong>备注：</strong>一些早期的伪元素曾使用单冒号的语法，所以你可能会在代码或者示例中看到。现代的浏览器为了保持后向兼容，支持早期的带有单双冒号语法的伪元素。</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">::before</span><br><span class=\"line\">::after</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//before和after的伪元素 content是必须的。</span><br><span class=\"line\">div::before &#123;</span><br><span class=\"line\">\tcontent: &#x27;&#x27;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"区别\"><a href=\"#区别\" class=\"headerlink\" title=\"区别\"></a>区别</h1><ul>\n<li><p>伪元素是生成一个新的，或者表现的像是生成了一个新的HTML元素。</p>\n<p>伪类是选择处于某种状态的的元素。</p>\n</li>\n<li><p>伪元素是使用的 ::</p>\n<p>伪类是使用的 :</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"CSS伪类和伪元素\"><a href=\"#CSS伪类和伪元素\" class=\"headerlink\" title=\"CSS伪类和伪元素\"></a>CSS伪类和伪元素</h1><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://developer.mozilla.org/zh-CN/docs/Learn/CSS/Building_blocks/Selectors/Pseudo-classes_and_pseudo-elements</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"伪类\"><a href=\"#伪类\" class=\"headerlink\" title=\"伪类\"></a>伪类</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://developer.mozilla.org/zh-CN/docs/Web/CSS/Pseudo-classes</span><br></pre></td></tr></table></figure>\n\n<p>​        伪类是选择器的一种，它用于选择处于特定状态的元素，比如当它们是这一类型的第一个元素时，或者是当鼠标指针悬浮在元素上面的时候。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">使用的是单冒号</span><br><span class=\"line\">:</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"行为伪类\"><a href=\"#行为伪类\" class=\"headerlink\" title=\"行为伪类\"></a>行为伪类</h3><p>​        一些伪类只会在用户以某种方式和文档交互的时候应用。这些<strong>用户行为伪类</strong>，有时叫做<strong>动态伪类</strong>，表现得就像是一个类在用户和元素交互的时候加到了元素上一样。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:hover,:focus</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">div:hover &#123;&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"伪元素\"><a href=\"#伪元素\" class=\"headerlink\" title=\"伪元素\"></a>伪元素</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://developer.mozilla.org/zh-CN/docs/Web/CSS/Pseudo-elements</span><br></pre></td></tr></table></figure>\n\n<p>​        伪元素以类似方式表现，不过表现得是像你往标记文本中加入全新的HTML元素一样，而不是向现有的元素上应用类。伪元素开头为双冒号<code>::</code>。</p>\n<blockquote>\n<p><strong>备注：</strong>一些早期的伪元素曾使用单冒号的语法，所以你可能会在代码或者示例中看到。现代的浏览器为了保持后向兼容，支持早期的带有单双冒号语法的伪元素。</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">::before</span><br><span class=\"line\">::after</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//before和after的伪元素 content是必须的。</span><br><span class=\"line\">div::before &#123;</span><br><span class=\"line\">\tcontent: &#x27;&#x27;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"区别\"><a href=\"#区别\" class=\"headerlink\" title=\"区别\"></a>区别</h1><ul>\n<li><p>伪元素是生成一个新的，或者表现的像是生成了一个新的HTML元素。</p>\n<p>伪类是选择处于某种状态的的元素。</p>\n</li>\n<li><p>伪元素是使用的 ::</p>\n<p>伪类是使用的 :</p>\n</li>\n</ul>\n"},{"title":"border-radius的原理和使用","date":"2021-10-24T02:53:12.000Z","_content":"\n\n\n#  border-radius的原理和使用\n\n```\nhttps://developer.mozilla.org/zh-CN/docs/Web/CSS/border-radius\n```\n\n\n\n## 原理：\n\n首先我们可以知道 `border-radius` 是四个属性的简写，所以我们先理解四个属性的值的效果。\n\n`border-top-right-radius` `border-top-left-radius`\n\n `border-bottom-right-radius` `border-bottm-left-radius`\n\n我们取其中一个\n\n`border-top-right-radius`\n\n```\nhttps://developer.mozilla.org/zh-CN/docs/Web/CSS/border-top-right-radius\n```\n\n```\n\tborder-top-right-radius属性设置元素的右上角弧形，这个圆弧可能是一个椭圆，或者其中一个值是0的话，就是没有圆弧，换句话就是说拐角是方形的。\n```\n\n<img src=\"border-radius的原理和使用/image-20211025104917514.png\" alt=\"image-20211025104917514\" style=\"zoom:50%;\" />\n\n通过图片我们可以知道 `border-top-right-radius` 的值是一个据 top 和 right 的一个半径，然后画弧所裁剪出来的值。\n\n```\nborder-top-right-radius: radius               \n/* the corner is a circle    */  E.g. border-top-right-radius: 3px\nborder-top-right-radius: horizontal vertical  \n/* the corner is an ellipsis */  E.g. border-top-right-radius: 0.5em 1em\n```\n\n通过例子也可以知道，对于一个值，说明了 横轴`horizontal` 和 数轴`vertical` 的值相等，对于两个值，那么就说明了第一值是横轴，第二个值是数轴。\n\n然后得到横轴和数轴的半径后，相对进行偏移，然后画出一个圆形或者一个椭圆形，所裁剪出来的值。就是得到的效果。\n\n对于值是%的，那么宽度就会相对于宽度，高度就会相对于高度。\n\n\n\n### 对于超过 50% 的计算方式\n\n原文链接\n\n```\nhttps://zhuanlan.zhihu.com/p/20128284\n```\n\n简单来说就是对于 **相邻的角的半径和超过了对应的盒子的边的长度，那么浏览器要重新计算保证它们不会重合。**\n\n就是会同时进行缩放。来保证不会重合。\n\n\n\n## 水平和垂直从哪个位置开始偏移\n\n### 我们先看使用px的计算\n\n先说结果，结果是，**px的计算是相对于border的位置开始的偏移。**\n\n然后我们再看代码和执行结果\n\n```\n<!DOCTYPE html>\n<html lang=\"zh\">\n<head>\n  <meta charset=\"UTF-8\">\n  <title>Title</title>\n  <style>\n    .d {\n      width: 100px;\n      height: 100px;\n      background-color: #f00;\n      border: blue solid 10px;\n      padding: 10px;\n      margin: 10px;\n      border-radius: 10px;\n    }\n  </style>\n</head>\n<body>\n<div class=\"d\">123</div>\n</body>\n</html>\n```\n\n<img src=\"border-radius的原理和使用/image-20211025104342522.png\" alt=\"image-20211025104342522\" style=\"zoom:50%;\" />\n\n\n\n### 我们再看使用 百分号% 进行的计算\n\n意思是一样的，会按照你的宽高加上你的border的宽高，然后乘以 百分比。\n\n```\n开始我这样写，以为10%应该是 50px，但是忘了border有上有下，所以真正的宽高是550px，所以50%是55px，后面才搞清楚\n\nwidth: 450px;\nheight: 450px;\nbackground-color: #f00;\nborder: blue solid 50px;\nborder-radius: 10%;\n```\n\n\n\n## 如何裁剪\n\n这个就是自己的理解了，我们可以看到，对于存在了border的，当你的数值超过了一定值之后，你的content也会变成弧边，而这个值就是border的宽度。\n\n**所以这个裁剪的方法是：**\n\n- 先计算出radius的偏移量x，y\n\n- 然后从border的边框开始进行x，y的偏移，并且半径值也为x，y画弧，将border进行了裁剪。\n- 然后如果x，y的偏移量在content里面了（这个content是包含了padding的），那么就会再对content进行裁剪，而裁剪的半径就是x，y这个点到content边界的半径。\n\n示例：\n\n```\n<!DOCTYPE html>\n<html lang=\"zh\">\n<head>\n  <meta charset=\"UTF-8\">\n  <title>Title</title>\n  <style>\n    * {\n      padding: 0;\n      margin: 0;\n    }\n    .d {\n      width: 450px;\n      height: 450px;\n      background-color: #f00;\n      border: blue solid 25px;\n      border-top: blue solid 30px;\n      border-left: blue solid 10px;\n      padding: 50px;\n      margin: 10px;\n      border-top-left-radius: 30px 40px;\n    }\n  </style>\n</head>\n<body>\n<div class=\"d\">123</div>\n</body>\n</html>\n```\n\n结果：\n\n<img src=\"border-radius的原理和使用/image-20211025155459099.png\" alt=\"image-20211025155459099\" style=\"zoom:67%;\" />\n\n\n\n## 简写参数\n\n```\n\tborder-radius: top-left top-right bottom-right bottom-left;\n\t上左，上右，下右，下左，这是一个从上左开始的一个顺时针顺序。\n\t按此顺序设置每个 radii 的四个值。如果省略 bottom-left，则与 top-right 相同。如果省略 bottom-right，则与 top-left 相同。如果省略 top-right，则与 top-left 相同。\n\t\t参考链接：(https://www.w3school.com.cn/cssref/pr_border-radius.asp)\n\t意思就是，如果在省略的情况下，那么就是最后一个开始是没有值的，而前面的才有值，然后对没有值的那个，他的值就是对面的值，如果对面也没有值，那么他的值就和旁边的相等(此时就是只有一个参数)\n\t\n\t按照上面的意思来理解的话，那么很多简写参数都可以理解了。我这里就直接统计结果。\n```\n\n\n\n### 第一步，将参数从简写的个数化为完整个数\n\n#### 一个参数 `border-radius: 50px;`\n\n```\nborder-radius: 50px;\n\n只有一个 top-left \n那么，bottom-right = top-left = 50\n并且 bottom-left = top-right = top-left = 50\n\nborder-radius: 50px 50px 50px 50px;\n```\n\n\n\n#### 两个参数 `border-radius: 50px 30px;`\n\n```\nborder-radius: 50px 30px;\n\n有两个，那么这两个就是 top-left 和 top-right\n对应的 bottom-left = top-right = 30\nbottom-right = top-left = 50\n\nborder-radius: 50px 30px 50px 30px;\n```\n\n\n\n#### 三个参数 `border-radius: 50px 30px 40px;`\n\n```\nborder-radius: 50px 30px 40px;\n\n有三个，那么就只有最后一个 bottom-left 没有\n那么 bottom-left 等于对面的 top-right = 30px\n\nborder-radius: 50px 30px 40px 30px;\n```\n\n\n\n#### 四个参数 `border-radius: 50px 40px 30px 20px;`\n\n```\nborder-radius: 50px 40px 30px 20px;\n\n没啥说的。\n```\n\n\n\n#### 对于参数里面带有 `/` 符号的 `border-radius: 4px 3px 6px / 2px 4px;`\n\n```\nborder-radius: 4px 3px 6px / 2px 4px;\n\n这个分为两个部分\n第一部分 4 3 6 将其转化为对应的 horizontal\n\t所以为 4 3 6 3\n第二部分 2 4 将其转化为对应的 vertical\n\t所以为 2 4 2 4\n\t\nborder-radius: 4px 3px 6px 3px / 2px 4px 2px 4px;\n\t\n然后结果就是\nborder-top-left-radius:     4px 2px;\nborder-top-right-radius:    3px 4px;\nborder-bottom-right-radius: 6px 2px;\nborder-bottom-left-radius:  3px 4px;\n```\n\n\n\n### 第二步，将其转化为 `border-*-*-radius`\n\n#### 对于没有带 `/` 符号的 `border-radius: 50px 40px 30px 20px;`\n\n```\n其 horizontal 和 vertical 的值相等。\n\nborder-radius: 50px 40px 30px 20px;\n\nborder-top-left-radius:     50px 50px;\nborder-top-right-radius:    40px 40px;\nborder-bottom-right-radius: 30px 30px;\nborder-bottom-left-radius:  20px 20px;\n```\n\n\n\n#### 对于带有 `/` 符号的 `border-radius: 4px 3px 6px 3px / 2px 4px 2px 4px;`\n\n```\n会将 / 前的作为每一个的 horizontal \n/ 后的作为每一个的 vertical\n\nborder-radius: 4px 3px 6px 3px / 2px 4px 2px 4px;\n\nborder-top-left-radius:     4px 2px;\nborder-top-right-radius:    3px 4px;\nborder-bottom-right-radius: 6px 2px;\nborder-bottom-left-radius:  3px 4px;\n```\n\n\n\n","source":"_posts/CSS/border-radius的原理和使用.md","raw":"---\ntitle: border-radius的原理和使用\ndate: 2021-10-24 10:53:12\ntags:\n - CSS\n - border-radius\ncategories:\n - CSS\n---\n\n\n\n#  border-radius的原理和使用\n\n```\nhttps://developer.mozilla.org/zh-CN/docs/Web/CSS/border-radius\n```\n\n\n\n## 原理：\n\n首先我们可以知道 `border-radius` 是四个属性的简写，所以我们先理解四个属性的值的效果。\n\n`border-top-right-radius` `border-top-left-radius`\n\n `border-bottom-right-radius` `border-bottm-left-radius`\n\n我们取其中一个\n\n`border-top-right-radius`\n\n```\nhttps://developer.mozilla.org/zh-CN/docs/Web/CSS/border-top-right-radius\n```\n\n```\n\tborder-top-right-radius属性设置元素的右上角弧形，这个圆弧可能是一个椭圆，或者其中一个值是0的话，就是没有圆弧，换句话就是说拐角是方形的。\n```\n\n<img src=\"border-radius的原理和使用/image-20211025104917514.png\" alt=\"image-20211025104917514\" style=\"zoom:50%;\" />\n\n通过图片我们可以知道 `border-top-right-radius` 的值是一个据 top 和 right 的一个半径，然后画弧所裁剪出来的值。\n\n```\nborder-top-right-radius: radius               \n/* the corner is a circle    */  E.g. border-top-right-radius: 3px\nborder-top-right-radius: horizontal vertical  \n/* the corner is an ellipsis */  E.g. border-top-right-radius: 0.5em 1em\n```\n\n通过例子也可以知道，对于一个值，说明了 横轴`horizontal` 和 数轴`vertical` 的值相等，对于两个值，那么就说明了第一值是横轴，第二个值是数轴。\n\n然后得到横轴和数轴的半径后，相对进行偏移，然后画出一个圆形或者一个椭圆形，所裁剪出来的值。就是得到的效果。\n\n对于值是%的，那么宽度就会相对于宽度，高度就会相对于高度。\n\n\n\n### 对于超过 50% 的计算方式\n\n原文链接\n\n```\nhttps://zhuanlan.zhihu.com/p/20128284\n```\n\n简单来说就是对于 **相邻的角的半径和超过了对应的盒子的边的长度，那么浏览器要重新计算保证它们不会重合。**\n\n就是会同时进行缩放。来保证不会重合。\n\n\n\n## 水平和垂直从哪个位置开始偏移\n\n### 我们先看使用px的计算\n\n先说结果，结果是，**px的计算是相对于border的位置开始的偏移。**\n\n然后我们再看代码和执行结果\n\n```\n<!DOCTYPE html>\n<html lang=\"zh\">\n<head>\n  <meta charset=\"UTF-8\">\n  <title>Title</title>\n  <style>\n    .d {\n      width: 100px;\n      height: 100px;\n      background-color: #f00;\n      border: blue solid 10px;\n      padding: 10px;\n      margin: 10px;\n      border-radius: 10px;\n    }\n  </style>\n</head>\n<body>\n<div class=\"d\">123</div>\n</body>\n</html>\n```\n\n<img src=\"border-radius的原理和使用/image-20211025104342522.png\" alt=\"image-20211025104342522\" style=\"zoom:50%;\" />\n\n\n\n### 我们再看使用 百分号% 进行的计算\n\n意思是一样的，会按照你的宽高加上你的border的宽高，然后乘以 百分比。\n\n```\n开始我这样写，以为10%应该是 50px，但是忘了border有上有下，所以真正的宽高是550px，所以50%是55px，后面才搞清楚\n\nwidth: 450px;\nheight: 450px;\nbackground-color: #f00;\nborder: blue solid 50px;\nborder-radius: 10%;\n```\n\n\n\n## 如何裁剪\n\n这个就是自己的理解了，我们可以看到，对于存在了border的，当你的数值超过了一定值之后，你的content也会变成弧边，而这个值就是border的宽度。\n\n**所以这个裁剪的方法是：**\n\n- 先计算出radius的偏移量x，y\n\n- 然后从border的边框开始进行x，y的偏移，并且半径值也为x，y画弧，将border进行了裁剪。\n- 然后如果x，y的偏移量在content里面了（这个content是包含了padding的），那么就会再对content进行裁剪，而裁剪的半径就是x，y这个点到content边界的半径。\n\n示例：\n\n```\n<!DOCTYPE html>\n<html lang=\"zh\">\n<head>\n  <meta charset=\"UTF-8\">\n  <title>Title</title>\n  <style>\n    * {\n      padding: 0;\n      margin: 0;\n    }\n    .d {\n      width: 450px;\n      height: 450px;\n      background-color: #f00;\n      border: blue solid 25px;\n      border-top: blue solid 30px;\n      border-left: blue solid 10px;\n      padding: 50px;\n      margin: 10px;\n      border-top-left-radius: 30px 40px;\n    }\n  </style>\n</head>\n<body>\n<div class=\"d\">123</div>\n</body>\n</html>\n```\n\n结果：\n\n<img src=\"border-radius的原理和使用/image-20211025155459099.png\" alt=\"image-20211025155459099\" style=\"zoom:67%;\" />\n\n\n\n## 简写参数\n\n```\n\tborder-radius: top-left top-right bottom-right bottom-left;\n\t上左，上右，下右，下左，这是一个从上左开始的一个顺时针顺序。\n\t按此顺序设置每个 radii 的四个值。如果省略 bottom-left，则与 top-right 相同。如果省略 bottom-right，则与 top-left 相同。如果省略 top-right，则与 top-left 相同。\n\t\t参考链接：(https://www.w3school.com.cn/cssref/pr_border-radius.asp)\n\t意思就是，如果在省略的情况下，那么就是最后一个开始是没有值的，而前面的才有值，然后对没有值的那个，他的值就是对面的值，如果对面也没有值，那么他的值就和旁边的相等(此时就是只有一个参数)\n\t\n\t按照上面的意思来理解的话，那么很多简写参数都可以理解了。我这里就直接统计结果。\n```\n\n\n\n### 第一步，将参数从简写的个数化为完整个数\n\n#### 一个参数 `border-radius: 50px;`\n\n```\nborder-radius: 50px;\n\n只有一个 top-left \n那么，bottom-right = top-left = 50\n并且 bottom-left = top-right = top-left = 50\n\nborder-radius: 50px 50px 50px 50px;\n```\n\n\n\n#### 两个参数 `border-radius: 50px 30px;`\n\n```\nborder-radius: 50px 30px;\n\n有两个，那么这两个就是 top-left 和 top-right\n对应的 bottom-left = top-right = 30\nbottom-right = top-left = 50\n\nborder-radius: 50px 30px 50px 30px;\n```\n\n\n\n#### 三个参数 `border-radius: 50px 30px 40px;`\n\n```\nborder-radius: 50px 30px 40px;\n\n有三个，那么就只有最后一个 bottom-left 没有\n那么 bottom-left 等于对面的 top-right = 30px\n\nborder-radius: 50px 30px 40px 30px;\n```\n\n\n\n#### 四个参数 `border-radius: 50px 40px 30px 20px;`\n\n```\nborder-radius: 50px 40px 30px 20px;\n\n没啥说的。\n```\n\n\n\n#### 对于参数里面带有 `/` 符号的 `border-radius: 4px 3px 6px / 2px 4px;`\n\n```\nborder-radius: 4px 3px 6px / 2px 4px;\n\n这个分为两个部分\n第一部分 4 3 6 将其转化为对应的 horizontal\n\t所以为 4 3 6 3\n第二部分 2 4 将其转化为对应的 vertical\n\t所以为 2 4 2 4\n\t\nborder-radius: 4px 3px 6px 3px / 2px 4px 2px 4px;\n\t\n然后结果就是\nborder-top-left-radius:     4px 2px;\nborder-top-right-radius:    3px 4px;\nborder-bottom-right-radius: 6px 2px;\nborder-bottom-left-radius:  3px 4px;\n```\n\n\n\n### 第二步，将其转化为 `border-*-*-radius`\n\n#### 对于没有带 `/` 符号的 `border-radius: 50px 40px 30px 20px;`\n\n```\n其 horizontal 和 vertical 的值相等。\n\nborder-radius: 50px 40px 30px 20px;\n\nborder-top-left-radius:     50px 50px;\nborder-top-right-radius:    40px 40px;\nborder-bottom-right-radius: 30px 30px;\nborder-bottom-left-radius:  20px 20px;\n```\n\n\n\n#### 对于带有 `/` 符号的 `border-radius: 4px 3px 6px 3px / 2px 4px 2px 4px;`\n\n```\n会将 / 前的作为每一个的 horizontal \n/ 后的作为每一个的 vertical\n\nborder-radius: 4px 3px 6px 3px / 2px 4px 2px 4px;\n\nborder-top-left-radius:     4px 2px;\nborder-top-right-radius:    3px 4px;\nborder-bottom-right-radius: 6px 2px;\nborder-bottom-left-radius:  3px 4px;\n```\n\n\n\n","slug":"CSS/border-radius的原理和使用","published":1,"updated":"2021-12-09T01:56:49.388Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckznhkk7i0020ikubgfl40ktw","content":"<h1 id=\"border-radius的原理和使用\"><a href=\"#border-radius的原理和使用\" class=\"headerlink\" title=\"border-radius的原理和使用\"></a>border-radius的原理和使用</h1><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-radius</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"原理：\"><a href=\"#原理：\" class=\"headerlink\" title=\"原理：\"></a>原理：</h2><p>首先我们可以知道 <code>border-radius</code> 是四个属性的简写，所以我们先理解四个属性的值的效果。</p>\n<p><code>border-top-right-radius</code> <code>border-top-left-radius</code></p>\n<p> <code>border-bottom-right-radius</code> <code>border-bottm-left-radius</code></p>\n<p>我们取其中一个</p>\n<p><code>border-top-right-radius</code></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-top-right-radius</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">border-top-right-radius属性设置元素的右上角弧形，这个圆弧可能是一个椭圆，或者其中一个值是0的话，就是没有圆弧，换句话就是说拐角是方形的。</span><br></pre></td></tr></table></figure>\n\n<img src=\"/.io//image-20211025104917514.png\" alt=\"image-20211025104917514\" style=\"zoom:50%;\">\n\n<p>通过图片我们可以知道 <code>border-top-right-radius</code> 的值是一个据 top 和 right 的一个半径，然后画弧所裁剪出来的值。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">border-top-right-radius: radius               </span><br><span class=\"line\">/* the corner is a circle    */  E.g. border-top-right-radius: 3px</span><br><span class=\"line\">border-top-right-radius: horizontal vertical  </span><br><span class=\"line\">/* the corner is an ellipsis */  E.g. border-top-right-radius: 0.5em 1em</span><br></pre></td></tr></table></figure>\n\n<p>通过例子也可以知道，对于一个值，说明了 横轴<code>horizontal</code> 和 数轴<code>vertical</code> 的值相等，对于两个值，那么就说明了第一值是横轴，第二个值是数轴。</p>\n<p>然后得到横轴和数轴的半径后，相对进行偏移，然后画出一个圆形或者一个椭圆形，所裁剪出来的值。就是得到的效果。</p>\n<p>对于值是%的，那么宽度就会相对于宽度，高度就会相对于高度。</p>\n<h3 id=\"对于超过-50-的计算方式\"><a href=\"#对于超过-50-的计算方式\" class=\"headerlink\" title=\"对于超过 50% 的计算方式\"></a>对于超过 50% 的计算方式</h3><p>原文链接</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://zhuanlan.zhihu.com/p/20128284</span><br></pre></td></tr></table></figure>\n\n<p>简单来说就是对于 <strong>相邻的角的半径和超过了对应的盒子的边的长度，那么浏览器要重新计算保证它们不会重合。</strong></p>\n<p>就是会同时进行缩放。来保证不会重合。</p>\n<h2 id=\"水平和垂直从哪个位置开始偏移\"><a href=\"#水平和垂直从哪个位置开始偏移\" class=\"headerlink\" title=\"水平和垂直从哪个位置开始偏移\"></a>水平和垂直从哪个位置开始偏移</h2><h3 id=\"我们先看使用px的计算\"><a href=\"#我们先看使用px的计算\" class=\"headerlink\" title=\"我们先看使用px的计算\"></a>我们先看使用px的计算</h3><p>先说结果，结果是，<strong>px的计算是相对于border的位置开始的偏移。</strong></p>\n<p>然后我们再看代码和执行结果</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html lang=&quot;zh&quot;&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">  &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class=\"line\">  &lt;title&gt;Title&lt;/title&gt;</span><br><span class=\"line\">  &lt;style&gt;</span><br><span class=\"line\">    .d &#123;</span><br><span class=\"line\">      width: 100px;</span><br><span class=\"line\">      height: 100px;</span><br><span class=\"line\">      background-color: #f00;</span><br><span class=\"line\">      border: blue solid 10px;</span><br><span class=\"line\">      padding: 10px;</span><br><span class=\"line\">      margin: 10px;</span><br><span class=\"line\">      border-radius: 10px;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &lt;/style&gt;</span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">&lt;div class=&quot;d&quot;&gt;123&lt;/div&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n\n<img src=\"/.io//image-20211025104342522.png\" alt=\"image-20211025104342522\" style=\"zoom:50%;\">\n\n\n\n<h3 id=\"我们再看使用-百分号-进行的计算\"><a href=\"#我们再看使用-百分号-进行的计算\" class=\"headerlink\" title=\"我们再看使用 百分号% 进行的计算\"></a>我们再看使用 百分号% 进行的计算</h3><p>意思是一样的，会按照你的宽高加上你的border的宽高，然后乘以 百分比。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">开始我这样写，以为10%应该是 50px，但是忘了border有上有下，所以真正的宽高是550px，所以50%是55px，后面才搞清楚</span><br><span class=\"line\"></span><br><span class=\"line\">width: 450px;</span><br><span class=\"line\">height: 450px;</span><br><span class=\"line\">background-color: #f00;</span><br><span class=\"line\">border: blue solid 50px;</span><br><span class=\"line\">border-radius: 10%;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"如何裁剪\"><a href=\"#如何裁剪\" class=\"headerlink\" title=\"如何裁剪\"></a>如何裁剪</h2><p>这个就是自己的理解了，我们可以看到，对于存在了border的，当你的数值超过了一定值之后，你的content也会变成弧边，而这个值就是border的宽度。</p>\n<p><strong>所以这个裁剪的方法是：</strong></p>\n<ul>\n<li><p>先计算出radius的偏移量x，y</p>\n</li>\n<li><p>然后从border的边框开始进行x，y的偏移，并且半径值也为x，y画弧，将border进行了裁剪。</p>\n</li>\n<li><p>然后如果x，y的偏移量在content里面了（这个content是包含了padding的），那么就会再对content进行裁剪，而裁剪的半径就是x，y这个点到content边界的半径。</p>\n</li>\n</ul>\n<p>示例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html lang=&quot;zh&quot;&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">  &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class=\"line\">  &lt;title&gt;Title&lt;/title&gt;</span><br><span class=\"line\">  &lt;style&gt;</span><br><span class=\"line\">    * &#123;</span><br><span class=\"line\">      padding: 0;</span><br><span class=\"line\">      margin: 0;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    .d &#123;</span><br><span class=\"line\">      width: 450px;</span><br><span class=\"line\">      height: 450px;</span><br><span class=\"line\">      background-color: #f00;</span><br><span class=\"line\">      border: blue solid 25px;</span><br><span class=\"line\">      border-top: blue solid 30px;</span><br><span class=\"line\">      border-left: blue solid 10px;</span><br><span class=\"line\">      padding: 50px;</span><br><span class=\"line\">      margin: 10px;</span><br><span class=\"line\">      border-top-left-radius: 30px 40px;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &lt;/style&gt;</span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">&lt;div class=&quot;d&quot;&gt;123&lt;/div&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n\n<p>结果：</p>\n<img src=\"/.io//image-20211025155459099.png\" alt=\"image-20211025155459099\" style=\"zoom:67%;\">\n\n\n\n<h2 id=\"简写参数\"><a href=\"#简写参数\" class=\"headerlink\" title=\"简写参数\"></a>简写参数</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">border-radius: top-left top-right bottom-right bottom-left;</span><br><span class=\"line\">上左，上右，下右，下左，这是一个从上左开始的一个顺时针顺序。</span><br><span class=\"line\">按此顺序设置每个 radii 的四个值。如果省略 bottom-left，则与 top-right 相同。如果省略 bottom-right，则与 top-left 相同。如果省略 top-right，则与 top-left 相同。</span><br><span class=\"line\">\t参考链接：(https://www.w3school.com.cn/cssref/pr_border-radius.asp)</span><br><span class=\"line\">意思就是，如果在省略的情况下，那么就是最后一个开始是没有值的，而前面的才有值，然后对没有值的那个，他的值就是对面的值，如果对面也没有值，那么他的值就和旁边的相等(此时就是只有一个参数)</span><br><span class=\"line\"></span><br><span class=\"line\">按照上面的意思来理解的话，那么很多简写参数都可以理解了。我这里就直接统计结果。</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"第一步，将参数从简写的个数化为完整个数\"><a href=\"#第一步，将参数从简写的个数化为完整个数\" class=\"headerlink\" title=\"第一步，将参数从简写的个数化为完整个数\"></a>第一步，将参数从简写的个数化为完整个数</h3><h4 id=\"一个参数-border-radius-50px\"><a href=\"#一个参数-border-radius-50px\" class=\"headerlink\" title=\"一个参数 border-radius: 50px;\"></a>一个参数 <code>border-radius: 50px;</code></h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">border-radius: 50px;</span><br><span class=\"line\"></span><br><span class=\"line\">只有一个 top-left </span><br><span class=\"line\">那么，bottom-right = top-left = 50</span><br><span class=\"line\">并且 bottom-left = top-right = top-left = 50</span><br><span class=\"line\"></span><br><span class=\"line\">border-radius: 50px 50px 50px 50px;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"两个参数-border-radius-50px-30px\"><a href=\"#两个参数-border-radius-50px-30px\" class=\"headerlink\" title=\"两个参数 border-radius: 50px 30px;\"></a>两个参数 <code>border-radius: 50px 30px;</code></h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">border-radius: 50px 30px;</span><br><span class=\"line\"></span><br><span class=\"line\">有两个，那么这两个就是 top-left 和 top-right</span><br><span class=\"line\">对应的 bottom-left = top-right = 30</span><br><span class=\"line\">bottom-right = top-left = 50</span><br><span class=\"line\"></span><br><span class=\"line\">border-radius: 50px 30px 50px 30px;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"三个参数-border-radius-50px-30px-40px\"><a href=\"#三个参数-border-radius-50px-30px-40px\" class=\"headerlink\" title=\"三个参数 border-radius: 50px 30px 40px;\"></a>三个参数 <code>border-radius: 50px 30px 40px;</code></h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">border-radius: 50px 30px 40px;</span><br><span class=\"line\"></span><br><span class=\"line\">有三个，那么就只有最后一个 bottom-left 没有</span><br><span class=\"line\">那么 bottom-left 等于对面的 top-right = 30px</span><br><span class=\"line\"></span><br><span class=\"line\">border-radius: 50px 30px 40px 30px;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"四个参数-border-radius-50px-40px-30px-20px\"><a href=\"#四个参数-border-radius-50px-40px-30px-20px\" class=\"headerlink\" title=\"四个参数 border-radius: 50px 40px 30px 20px;\"></a>四个参数 <code>border-radius: 50px 40px 30px 20px;</code></h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">border-radius: 50px 40px 30px 20px;</span><br><span class=\"line\"></span><br><span class=\"line\">没啥说的。</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"对于参数里面带有-符号的-border-radius-4px-3px-6px-2px-4px\"><a href=\"#对于参数里面带有-符号的-border-radius-4px-3px-6px-2px-4px\" class=\"headerlink\" title=\"对于参数里面带有 / 符号的 border-radius: 4px 3px 6px / 2px 4px;\"></a>对于参数里面带有 <code>/</code> 符号的 <code>border-radius: 4px 3px 6px / 2px 4px;</code></h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">border-radius: 4px 3px 6px / 2px 4px;</span><br><span class=\"line\"></span><br><span class=\"line\">这个分为两个部分</span><br><span class=\"line\">第一部分 4 3 6 将其转化为对应的 horizontal</span><br><span class=\"line\">\t所以为 4 3 6 3</span><br><span class=\"line\">第二部分 2 4 将其转化为对应的 vertical</span><br><span class=\"line\">\t所以为 2 4 2 4</span><br><span class=\"line\">\t</span><br><span class=\"line\">border-radius: 4px 3px 6px 3px / 2px 4px 2px 4px;</span><br><span class=\"line\">\t</span><br><span class=\"line\">然后结果就是</span><br><span class=\"line\">border-top-left-radius:     4px 2px;</span><br><span class=\"line\">border-top-right-radius:    3px 4px;</span><br><span class=\"line\">border-bottom-right-radius: 6px 2px;</span><br><span class=\"line\">border-bottom-left-radius:  3px 4px;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"第二步，将其转化为-border-radius\"><a href=\"#第二步，将其转化为-border-radius\" class=\"headerlink\" title=\"第二步，将其转化为 border-*-*-radius\"></a>第二步，将其转化为 <code>border-*-*-radius</code></h3><h4 id=\"对于没有带-符号的-border-radius-50px-40px-30px-20px\"><a href=\"#对于没有带-符号的-border-radius-50px-40px-30px-20px\" class=\"headerlink\" title=\"对于没有带 / 符号的 border-radius: 50px 40px 30px 20px;\"></a>对于没有带 <code>/</code> 符号的 <code>border-radius: 50px 40px 30px 20px;</code></h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">其 horizontal 和 vertical 的值相等。</span><br><span class=\"line\"></span><br><span class=\"line\">border-radius: 50px 40px 30px 20px;</span><br><span class=\"line\"></span><br><span class=\"line\">border-top-left-radius:     50px 50px;</span><br><span class=\"line\">border-top-right-radius:    40px 40px;</span><br><span class=\"line\">border-bottom-right-radius: 30px 30px;</span><br><span class=\"line\">border-bottom-left-radius:  20px 20px;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"对于带有-符号的-border-radius-4px-3px-6px-3px-2px-4px-2px-4px\"><a href=\"#对于带有-符号的-border-radius-4px-3px-6px-3px-2px-4px-2px-4px\" class=\"headerlink\" title=\"对于带有 / 符号的 border-radius: 4px 3px 6px 3px / 2px 4px 2px 4px;\"></a>对于带有 <code>/</code> 符号的 <code>border-radius: 4px 3px 6px 3px / 2px 4px 2px 4px;</code></h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">会将 / 前的作为每一个的 horizontal </span><br><span class=\"line\">/ 后的作为每一个的 vertical</span><br><span class=\"line\"></span><br><span class=\"line\">border-radius: 4px 3px 6px 3px / 2px 4px 2px 4px;</span><br><span class=\"line\"></span><br><span class=\"line\">border-top-left-radius:     4px 2px;</span><br><span class=\"line\">border-top-right-radius:    3px 4px;</span><br><span class=\"line\">border-bottom-right-radius: 6px 2px;</span><br><span class=\"line\">border-bottom-left-radius:  3px 4px;</span><br></pre></td></tr></table></figure>\n\n\n\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"border-radius的原理和使用\"><a href=\"#border-radius的原理和使用\" class=\"headerlink\" title=\"border-radius的原理和使用\"></a>border-radius的原理和使用</h1><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-radius</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"原理：\"><a href=\"#原理：\" class=\"headerlink\" title=\"原理：\"></a>原理：</h2><p>首先我们可以知道 <code>border-radius</code> 是四个属性的简写，所以我们先理解四个属性的值的效果。</p>\n<p><code>border-top-right-radius</code> <code>border-top-left-radius</code></p>\n<p> <code>border-bottom-right-radius</code> <code>border-bottm-left-radius</code></p>\n<p>我们取其中一个</p>\n<p><code>border-top-right-radius</code></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-top-right-radius</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">border-top-right-radius属性设置元素的右上角弧形，这个圆弧可能是一个椭圆，或者其中一个值是0的话，就是没有圆弧，换句话就是说拐角是方形的。</span><br></pre></td></tr></table></figure>\n\n<img src=\"/.io//image-20211025104917514.png\" alt=\"image-20211025104917514\" style=\"zoom:50%;\">\n\n<p>通过图片我们可以知道 <code>border-top-right-radius</code> 的值是一个据 top 和 right 的一个半径，然后画弧所裁剪出来的值。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">border-top-right-radius: radius               </span><br><span class=\"line\">/* the corner is a circle    */  E.g. border-top-right-radius: 3px</span><br><span class=\"line\">border-top-right-radius: horizontal vertical  </span><br><span class=\"line\">/* the corner is an ellipsis */  E.g. border-top-right-radius: 0.5em 1em</span><br></pre></td></tr></table></figure>\n\n<p>通过例子也可以知道，对于一个值，说明了 横轴<code>horizontal</code> 和 数轴<code>vertical</code> 的值相等，对于两个值，那么就说明了第一值是横轴，第二个值是数轴。</p>\n<p>然后得到横轴和数轴的半径后，相对进行偏移，然后画出一个圆形或者一个椭圆形，所裁剪出来的值。就是得到的效果。</p>\n<p>对于值是%的，那么宽度就会相对于宽度，高度就会相对于高度。</p>\n<h3 id=\"对于超过-50-的计算方式\"><a href=\"#对于超过-50-的计算方式\" class=\"headerlink\" title=\"对于超过 50% 的计算方式\"></a>对于超过 50% 的计算方式</h3><p>原文链接</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://zhuanlan.zhihu.com/p/20128284</span><br></pre></td></tr></table></figure>\n\n<p>简单来说就是对于 <strong>相邻的角的半径和超过了对应的盒子的边的长度，那么浏览器要重新计算保证它们不会重合。</strong></p>\n<p>就是会同时进行缩放。来保证不会重合。</p>\n<h2 id=\"水平和垂直从哪个位置开始偏移\"><a href=\"#水平和垂直从哪个位置开始偏移\" class=\"headerlink\" title=\"水平和垂直从哪个位置开始偏移\"></a>水平和垂直从哪个位置开始偏移</h2><h3 id=\"我们先看使用px的计算\"><a href=\"#我们先看使用px的计算\" class=\"headerlink\" title=\"我们先看使用px的计算\"></a>我们先看使用px的计算</h3><p>先说结果，结果是，<strong>px的计算是相对于border的位置开始的偏移。</strong></p>\n<p>然后我们再看代码和执行结果</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html lang=&quot;zh&quot;&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">  &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class=\"line\">  &lt;title&gt;Title&lt;/title&gt;</span><br><span class=\"line\">  &lt;style&gt;</span><br><span class=\"line\">    .d &#123;</span><br><span class=\"line\">      width: 100px;</span><br><span class=\"line\">      height: 100px;</span><br><span class=\"line\">      background-color: #f00;</span><br><span class=\"line\">      border: blue solid 10px;</span><br><span class=\"line\">      padding: 10px;</span><br><span class=\"line\">      margin: 10px;</span><br><span class=\"line\">      border-radius: 10px;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &lt;/style&gt;</span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">&lt;div class=&quot;d&quot;&gt;123&lt;/div&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n\n<img src=\"/.io//image-20211025104342522.png\" alt=\"image-20211025104342522\" style=\"zoom:50%;\">\n\n\n\n<h3 id=\"我们再看使用-百分号-进行的计算\"><a href=\"#我们再看使用-百分号-进行的计算\" class=\"headerlink\" title=\"我们再看使用 百分号% 进行的计算\"></a>我们再看使用 百分号% 进行的计算</h3><p>意思是一样的，会按照你的宽高加上你的border的宽高，然后乘以 百分比。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">开始我这样写，以为10%应该是 50px，但是忘了border有上有下，所以真正的宽高是550px，所以50%是55px，后面才搞清楚</span><br><span class=\"line\"></span><br><span class=\"line\">width: 450px;</span><br><span class=\"line\">height: 450px;</span><br><span class=\"line\">background-color: #f00;</span><br><span class=\"line\">border: blue solid 50px;</span><br><span class=\"line\">border-radius: 10%;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"如何裁剪\"><a href=\"#如何裁剪\" class=\"headerlink\" title=\"如何裁剪\"></a>如何裁剪</h2><p>这个就是自己的理解了，我们可以看到，对于存在了border的，当你的数值超过了一定值之后，你的content也会变成弧边，而这个值就是border的宽度。</p>\n<p><strong>所以这个裁剪的方法是：</strong></p>\n<ul>\n<li><p>先计算出radius的偏移量x，y</p>\n</li>\n<li><p>然后从border的边框开始进行x，y的偏移，并且半径值也为x，y画弧，将border进行了裁剪。</p>\n</li>\n<li><p>然后如果x，y的偏移量在content里面了（这个content是包含了padding的），那么就会再对content进行裁剪，而裁剪的半径就是x，y这个点到content边界的半径。</p>\n</li>\n</ul>\n<p>示例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html lang=&quot;zh&quot;&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">  &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class=\"line\">  &lt;title&gt;Title&lt;/title&gt;</span><br><span class=\"line\">  &lt;style&gt;</span><br><span class=\"line\">    * &#123;</span><br><span class=\"line\">      padding: 0;</span><br><span class=\"line\">      margin: 0;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    .d &#123;</span><br><span class=\"line\">      width: 450px;</span><br><span class=\"line\">      height: 450px;</span><br><span class=\"line\">      background-color: #f00;</span><br><span class=\"line\">      border: blue solid 25px;</span><br><span class=\"line\">      border-top: blue solid 30px;</span><br><span class=\"line\">      border-left: blue solid 10px;</span><br><span class=\"line\">      padding: 50px;</span><br><span class=\"line\">      margin: 10px;</span><br><span class=\"line\">      border-top-left-radius: 30px 40px;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &lt;/style&gt;</span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">&lt;div class=&quot;d&quot;&gt;123&lt;/div&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n\n<p>结果：</p>\n<img src=\"/.io//image-20211025155459099.png\" alt=\"image-20211025155459099\" style=\"zoom:67%;\">\n\n\n\n<h2 id=\"简写参数\"><a href=\"#简写参数\" class=\"headerlink\" title=\"简写参数\"></a>简写参数</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">border-radius: top-left top-right bottom-right bottom-left;</span><br><span class=\"line\">上左，上右，下右，下左，这是一个从上左开始的一个顺时针顺序。</span><br><span class=\"line\">按此顺序设置每个 radii 的四个值。如果省略 bottom-left，则与 top-right 相同。如果省略 bottom-right，则与 top-left 相同。如果省略 top-right，则与 top-left 相同。</span><br><span class=\"line\">\t参考链接：(https://www.w3school.com.cn/cssref/pr_border-radius.asp)</span><br><span class=\"line\">意思就是，如果在省略的情况下，那么就是最后一个开始是没有值的，而前面的才有值，然后对没有值的那个，他的值就是对面的值，如果对面也没有值，那么他的值就和旁边的相等(此时就是只有一个参数)</span><br><span class=\"line\"></span><br><span class=\"line\">按照上面的意思来理解的话，那么很多简写参数都可以理解了。我这里就直接统计结果。</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"第一步，将参数从简写的个数化为完整个数\"><a href=\"#第一步，将参数从简写的个数化为完整个数\" class=\"headerlink\" title=\"第一步，将参数从简写的个数化为完整个数\"></a>第一步，将参数从简写的个数化为完整个数</h3><h4 id=\"一个参数-border-radius-50px\"><a href=\"#一个参数-border-radius-50px\" class=\"headerlink\" title=\"一个参数 border-radius: 50px;\"></a>一个参数 <code>border-radius: 50px;</code></h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">border-radius: 50px;</span><br><span class=\"line\"></span><br><span class=\"line\">只有一个 top-left </span><br><span class=\"line\">那么，bottom-right = top-left = 50</span><br><span class=\"line\">并且 bottom-left = top-right = top-left = 50</span><br><span class=\"line\"></span><br><span class=\"line\">border-radius: 50px 50px 50px 50px;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"两个参数-border-radius-50px-30px\"><a href=\"#两个参数-border-radius-50px-30px\" class=\"headerlink\" title=\"两个参数 border-radius: 50px 30px;\"></a>两个参数 <code>border-radius: 50px 30px;</code></h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">border-radius: 50px 30px;</span><br><span class=\"line\"></span><br><span class=\"line\">有两个，那么这两个就是 top-left 和 top-right</span><br><span class=\"line\">对应的 bottom-left = top-right = 30</span><br><span class=\"line\">bottom-right = top-left = 50</span><br><span class=\"line\"></span><br><span class=\"line\">border-radius: 50px 30px 50px 30px;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"三个参数-border-radius-50px-30px-40px\"><a href=\"#三个参数-border-radius-50px-30px-40px\" class=\"headerlink\" title=\"三个参数 border-radius: 50px 30px 40px;\"></a>三个参数 <code>border-radius: 50px 30px 40px;</code></h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">border-radius: 50px 30px 40px;</span><br><span class=\"line\"></span><br><span class=\"line\">有三个，那么就只有最后一个 bottom-left 没有</span><br><span class=\"line\">那么 bottom-left 等于对面的 top-right = 30px</span><br><span class=\"line\"></span><br><span class=\"line\">border-radius: 50px 30px 40px 30px;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"四个参数-border-radius-50px-40px-30px-20px\"><a href=\"#四个参数-border-radius-50px-40px-30px-20px\" class=\"headerlink\" title=\"四个参数 border-radius: 50px 40px 30px 20px;\"></a>四个参数 <code>border-radius: 50px 40px 30px 20px;</code></h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">border-radius: 50px 40px 30px 20px;</span><br><span class=\"line\"></span><br><span class=\"line\">没啥说的。</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"对于参数里面带有-符号的-border-radius-4px-3px-6px-2px-4px\"><a href=\"#对于参数里面带有-符号的-border-radius-4px-3px-6px-2px-4px\" class=\"headerlink\" title=\"对于参数里面带有 / 符号的 border-radius: 4px 3px 6px / 2px 4px;\"></a>对于参数里面带有 <code>/</code> 符号的 <code>border-radius: 4px 3px 6px / 2px 4px;</code></h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">border-radius: 4px 3px 6px / 2px 4px;</span><br><span class=\"line\"></span><br><span class=\"line\">这个分为两个部分</span><br><span class=\"line\">第一部分 4 3 6 将其转化为对应的 horizontal</span><br><span class=\"line\">\t所以为 4 3 6 3</span><br><span class=\"line\">第二部分 2 4 将其转化为对应的 vertical</span><br><span class=\"line\">\t所以为 2 4 2 4</span><br><span class=\"line\">\t</span><br><span class=\"line\">border-radius: 4px 3px 6px 3px / 2px 4px 2px 4px;</span><br><span class=\"line\">\t</span><br><span class=\"line\">然后结果就是</span><br><span class=\"line\">border-top-left-radius:     4px 2px;</span><br><span class=\"line\">border-top-right-radius:    3px 4px;</span><br><span class=\"line\">border-bottom-right-radius: 6px 2px;</span><br><span class=\"line\">border-bottom-left-radius:  3px 4px;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"第二步，将其转化为-border-radius\"><a href=\"#第二步，将其转化为-border-radius\" class=\"headerlink\" title=\"第二步，将其转化为 border-*-*-radius\"></a>第二步，将其转化为 <code>border-*-*-radius</code></h3><h4 id=\"对于没有带-符号的-border-radius-50px-40px-30px-20px\"><a href=\"#对于没有带-符号的-border-radius-50px-40px-30px-20px\" class=\"headerlink\" title=\"对于没有带 / 符号的 border-radius: 50px 40px 30px 20px;\"></a>对于没有带 <code>/</code> 符号的 <code>border-radius: 50px 40px 30px 20px;</code></h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">其 horizontal 和 vertical 的值相等。</span><br><span class=\"line\"></span><br><span class=\"line\">border-radius: 50px 40px 30px 20px;</span><br><span class=\"line\"></span><br><span class=\"line\">border-top-left-radius:     50px 50px;</span><br><span class=\"line\">border-top-right-radius:    40px 40px;</span><br><span class=\"line\">border-bottom-right-radius: 30px 30px;</span><br><span class=\"line\">border-bottom-left-radius:  20px 20px;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"对于带有-符号的-border-radius-4px-3px-6px-3px-2px-4px-2px-4px\"><a href=\"#对于带有-符号的-border-radius-4px-3px-6px-3px-2px-4px-2px-4px\" class=\"headerlink\" title=\"对于带有 / 符号的 border-radius: 4px 3px 6px 3px / 2px 4px 2px 4px;\"></a>对于带有 <code>/</code> 符号的 <code>border-radius: 4px 3px 6px 3px / 2px 4px 2px 4px;</code></h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">会将 / 前的作为每一个的 horizontal </span><br><span class=\"line\">/ 后的作为每一个的 vertical</span><br><span class=\"line\"></span><br><span class=\"line\">border-radius: 4px 3px 6px 3px / 2px 4px 2px 4px;</span><br><span class=\"line\"></span><br><span class=\"line\">border-top-left-radius:     4px 2px;</span><br><span class=\"line\">border-top-right-radius:    3px 4px;</span><br><span class=\"line\">border-bottom-right-radius: 6px 2px;</span><br><span class=\"line\">border-bottom-left-radius:  3px 4px;</span><br></pre></td></tr></table></figure>\n\n\n\n"},{"title":"CSS-flex","date":"2021-10-27T07:54:35.000Z","_content":"\n\n\n#  CSS-flex布局\n\n```\nhttps://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Flexible_Box_Layout/Basic_Concepts_of_Flexbox\n```\n\n​\t\tflex就是弹性布局。\n\n​\t\t基本使用\n\n```\ndisplay: flex;\n```\n\n\n\n## 主轴\n\n​\t\t`flex-direction` 定义主轴\n\n```\nrow，row-reverse\n代表inline，横向延申\n```\n\n```\ncolumn，column-reverse\n代表black，竖向排列\n```\n\n​\t\t其中 `reverse `代表翻转，就是反过来的排列顺序\n\n\n\n## 交叉轴，副轴\n\n​\t\t就是和主轴垂直的轴\n\n​\t\t如果主轴是横轴，那么交叉轴就是数轴。\n\n\n\n# 当使用了 Flex容器\n\n​\t\t在定义了 `display: flex;` 之后的一些默认行为\n\n```\n元素排列一行，(因为 flex-direction 的默认值是 row )\n从主轴的起始线开始，这里起始线一般就是如果是row，代表了从左向右，其他的\t情况查看MDN文档\n元素不会再主维度拉伸，但是可以缩小\n元素被拉伸来填充交叉轴大小\nflex-basis 为 auto\nflex-wrap 为 nowrap\n```\n\n\n\n# 对于flex属性值的行为\n\n## flex-direction 设置主轴\n\n​\t\t对定义了 `display: flex;` 的元素使用\n\n```\nflex-direction\n\trow\n\t\t横向，从左到右\n\trow-reverse\n\t\t横向，从右到左\n\t\t对于行内块元素和话，宽度的计算是和 Colum-reverse 类似的。\n\tcolumn\n\t\t纵向，从上到下\n\tcolumn-reverse\n\t\t纵向，从下到上\n\t\t对于没有设置高度的，就会按照最小高度进行计算，(意思就是说，高度和column的一样，只是方向反了而已。)\n```\n\n\n\n## flex-wrap 实现多行flex\n\n​\t\t对定义了 `display: flex;` 的元素使用\n\n​\t\t在这样做的时候，您应该把每一行看作一个新的`flex`容器。 任何空间分布都将在该行上发生，而不影响该空间分布的其他行。\n\n```\nwrap\n\t会换行，而不是进行缩小\nnowrap\n\t不会换行，会使用缩小的规则进行缩小，对于不能缩小的，会导致溢出。\n```\n\n**注意：**\n\n* 如果在使用 wrap 时，使用了 flex:1， 时，这个时候就需要注意要不要定义 flex-basis 了。\n\n​\t\t\t**原因**： 因为 `flex: 1`; 对应了 `flex-grow: 1` & `flex-shrink: 1` && `flex-basis: 0`  ，所以其实原因就是 flex-basis 为 0 了。所以如果不自己定义一个 flex-basis 的话，就不会进行换行。\n\n* 还有就是，对于每一个换行之后的元素，每一行都算是一个弹性行，所以对于以下代码\n\n  * ```\n    flex: 1 1 160px;\n    \n    子元素在160px，换行之后，会对每一行的每个元素进行 扩张 和 收缩 的重新计算。\n    ```\n\n  * ```\n    参考 MDN 链接：\n    https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Flexible_Box_Layout/Mastering_Wrapping_of_Flex_Items\n    ```\n\n\n\n## 简写属性 flex-flow\n\n​\t\t对定义了 `display: flex;` 的元素使用\n\n​\t\t是 `flex-direction` 和 `flex-wrap` 的组合\n\n​\t\t对于没有写的，就会使用默认值：row 和 nowrap\n\n**注：**\n\n* 从谷歌浏览器的显示来说:\n  * 如果设置 `flex-flow: column; `  ，就直接代表了 `flex-direction: column;` ，而不会定义 `flex-wrap`\n  * 如果设置 `flex-flow: wrap; `  ，就代表了 `flex-direction: initial;` 而  `flex-flow: wrap; ` \n\n\n\n## flex-basis 元素的空间大小\n\n​\t\t该属性的默认值是 `auto` ，此时，浏览器会检查这个元素是否具有确定的尺寸(width / heght ，这个看是使用 row 还是 Colum)，如果**具有确定的尺寸**，就会将该值设置为 flex-basis。如果没有设定尺寸，就会采用**元素内容的尺寸**。如果不使用  [`box-sizing`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/box-sizing) 改变盒模型的话，那么这个属性就决定了 flex 元素的内容盒（content-box）的尺寸。\n\n\n\n## flex-grow 延展比例\n\n​\t\t负值无效，默认为0\n\n​\t\t简单来说，这个是一个比例，对于存在可用空间的(可用空间：就是指在使用之后，父元素还存在剩余的空间。)， 子元素会根据这个比例将可用空间占据。\n\n​\t\t比如：两个子元素，一个为 1， 一个为 2，父元素的可用空间为 90，那么第一个就会扩张 1/(1+2) * 90 ， 第二个就会扩张 2/(1+2) * 90 。\n\n\n\n## flex-shrink 收缩比例\n\n​\t\t负值无效，默认为1\n\n​\t\t简单来说，就会对于如果容器不够排列 flex元素的空间。那么就会按照比例进行收缩。默认为1\n\n​\t\t计算方式： 这里的计算方式略和 `flex-grow` 有所不同。他的计算会和 `flex-basis` 相关联。这里给出计算的方法\n\n​\t\t\t每个元素的 `flex-basis` * `flex-shrink` 这个值作为一个比例**X1**，将所有参与计算的元素进行计算 **X1~Xi 的求和 Xs** ，然后再计算出超出的量，这个超出的量是 **overflow = 子元素的flex-basis 的总和 - 父元素的宽度**， 然后就是进行计算 **Xi / Xs * overflow**， 这个计算出的值就是需要减去的量，这里可能有点抽象，我们也给一个例子方便理解\n\n```\ndiv\twidth:600px\n\tdiv flex: 1 1 200px;\n\tdiv flex: 1 1 200px;\n\tdiv flex: 1 2 300px;\n\n首先我们可以看出，这个是超出了，所以需要收缩，\n超出的量 overflow = 600 - 200 - 200 - 300 = 100px\n然后比例的计算\n\tX1 = 1 * 200 = 200px\n\tX2 = 1 * 200 = 200px\n\tX3 = 2 * 300 = 600px\n所以 Xs = X1 + X2 + X3 = 1000px\n然后就是计算收缩的值\tXi / Xs * overflow\n\t200 / 1000 * 100 = 20\n\t200 / 1000 * 100 = 20\n\t600 / 1000 * 100 = 60\n\t\n所以最终的宽度是\ndiv width: 600px\n\tdiv width: 180px\n\tdiv width: 180px\n\tdiv width: 240px\n```\n\n在这里我也看到了一个更详细的一些计算教程，虽然里面的内容是否正确我没有进行参考，但是写的很详细，我就把链接贴出来\n\n```\nhttps://www.cnblogs.com/liyan-web/p/11217330.html\n```\n\n​\t**注意点：**\n\n```\nhttps://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Flexible_Box_Layout/Controlling_Ratios_of_Flex_Items_Along_the_Main_Ax\n```\n\n​\t\t这个元素在缩小的时候，不会小于最小宽度，至于这个最小宽度定义，我现在认为就是可以造成溢出的情况。举个例子：\n\n```\ndiv\n\t222222222222222222222222222222222222\n\t\n\t在这个情况，如果这个div想对于父元素的弹性布局，造成了溢出，但是因为最小的宽度为这个文字的一个长度，不会换行，所以会造成溢出。\n\t而 22222 222222 222222222 222222 2222，这里，因为在 文字里面加入了空格，在html文档里面一个最小宽度是一个空格隔开的一个距离，所以会出现换行而不会让宽度溢出的情况。\n\t这里记录一下会统计最小宽度的情况。\n\t\t' '(不能使用 &nbsp; ), '。'(。会在上一行), '，'(中文，号)，这里的原因应该是中文的。和， 里面的一个字符形势和 . ,不一样。\n\t注意：只能是 英文和数字，中文会自动换行。原因应该是 对于英文，如果不打空格，浏览器会认为是一个单词，所以不会换行。\n```\n\n**注意：**\n\n* `flex-grow` && `flex-shrink` 的值要为正数。\n\n\n\n\n## 简写属性 flex\n\n​\t\t对弹性布局的子元素使用。\n\n​\t\t包含了： `flex-grow`  、 `flex-shrink` 和 `flex-basis` \n\n​\t\t对于每个属性的值，都有理解了。我们就说几个简写的代表意思\n\n- `flex: initial`\n  - 代表初始值：`flex: 0 1 auto`\n- `flex: auto`\n  - 代表 `flex: 1 1 auto`\n- `flex: none`\n  - 代表 `flex: 0 0 auto`\n- `flex: <positive-number>`\n  - 代表 `flex: x x 0`\n\n\n\n## align-items 交叉轴方向对齐\n\n​\t\t默认为 `stretch `，默认会被拉伸到最高元素的高度。\n\n```\nstretch\n\t拉伸到最高元素的高度\nflex-start\n\t按flex容器的顶部对齐\nflex-end\n\t按flex容器的下部对齐\ncenter\n\t使它们居中对齐\n```\n\n\n\n## justify-content 主轴方向对齐\n\n​\t\t初始值是 `flex-start`， 元素从容器的起始线排列。\n\n```\nstretch\n\t不了解\nflex-start\n\t从容器的起始线排列\nflex-end\n\t从容器的终止线开始排列\ncenter\n\t在中间排列\nspace-around\n\t把元素排列好之后的剩余空间拿出来，平均分配到元素之间，所以元素之间间隔相等\nspace-between\n\t使每个元素的左右空间相等\n```\n\n\n\n# 对于flex的溢出：\n\n### 方式一\n\n```\n对一个元素设置了flex布局，其中的子元素的子元素的宽度可以造成溢出\n```\n\n```\ndiv.father\n\tdiv.children\n\t\nfather 元素设置了弹性布局， children 元素只设置一个宽度，会发现 children 的宽度不会高于father的宽度。主要是因为涉及了\n```\n\n<img src=\"CSS-flex/image-20211027210947232.png\" alt=\"image-20211027210947232\" style=\"zoom: 50%;\" />\n\n\n\n```\n但是\ndiv.father\n\tdiv.children\n\t\tdiv.cChildren\n\n这个对于 cChildren 的宽度就会将 children 的宽度顶出来，造成溢出。\n其中，这里的宽度，如果 cChildren 大于了 father 就会将 cChildren 和 children 顶出来。\n但是如果 cChildren 大于了 children 的话，就会再 children 到达他所定义的宽度之后，就不会继续扩张了。\n```\n\n<img src=\"CSS-flex/image-20211027211015004.png\" alt=\"image-20211027211015004\" style=\"zoom:50%;\" />\n\n\n\n<img src=\"CSS-flex/image-20211027212431340.png\" alt=\"image-20211027211015004\" style=\"zoom:50%;\" />\n\n\n\n​\t\t但是这里的计算方式我没有理解到为什么。\n\n\n\n### 方式二\n\n​\t\t设置 `flex-shrink: 0;` 属性，因为设置了0之后代表了不会对超过的部分进行处理。\n\n\n\n### 方式三\n\n​\t\t这个是文字超出导致的溢出，就是如果文字，或者 img图片的设置超过了宽高也会造成溢出。\n\n​\t\t这个的原因是因为，对于英文和数字，浏览器不能识别你的单词是否是一个，所以如果你输入一串英文和数字，中间没有分割(前面有说)，就会造成溢出，而汉字不行。\n\n<img src=\"CSS-flex/image-20211027213217557.png\" alt=\"image-20211027213217557\" style=\"zoom:50%;\" />\n\n\n\n### 方式四\n\n​\t\t我们可以发现，flex 对于溢出的处理，默认只是针对于主轴，所以对于侧轴是没有溢出处理的。\n\n```\n.father {\n    display: flex;\n    flex-direction: column;\n    width: 50px;\n}\n\n.children {\n\twidth: 60px;\n}\n```\n\n<img src=\"CSS-flex/image-20211027214029980.png\" alt=\"image-20211027214029980\" style=\"zoom:50%;\" />\n\n\n\n","source":"_posts/CSS/CSS-flex.md","raw":"---\ntitle: CSS-flex\ndate: 2021-10-27 15:54:35\ntags:\n - CSS\n - flex\ncategories:\n - CSS\n---\n\n\n\n#  CSS-flex布局\n\n```\nhttps://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Flexible_Box_Layout/Basic_Concepts_of_Flexbox\n```\n\n​\t\tflex就是弹性布局。\n\n​\t\t基本使用\n\n```\ndisplay: flex;\n```\n\n\n\n## 主轴\n\n​\t\t`flex-direction` 定义主轴\n\n```\nrow，row-reverse\n代表inline，横向延申\n```\n\n```\ncolumn，column-reverse\n代表black，竖向排列\n```\n\n​\t\t其中 `reverse `代表翻转，就是反过来的排列顺序\n\n\n\n## 交叉轴，副轴\n\n​\t\t就是和主轴垂直的轴\n\n​\t\t如果主轴是横轴，那么交叉轴就是数轴。\n\n\n\n# 当使用了 Flex容器\n\n​\t\t在定义了 `display: flex;` 之后的一些默认行为\n\n```\n元素排列一行，(因为 flex-direction 的默认值是 row )\n从主轴的起始线开始，这里起始线一般就是如果是row，代表了从左向右，其他的\t情况查看MDN文档\n元素不会再主维度拉伸，但是可以缩小\n元素被拉伸来填充交叉轴大小\nflex-basis 为 auto\nflex-wrap 为 nowrap\n```\n\n\n\n# 对于flex属性值的行为\n\n## flex-direction 设置主轴\n\n​\t\t对定义了 `display: flex;` 的元素使用\n\n```\nflex-direction\n\trow\n\t\t横向，从左到右\n\trow-reverse\n\t\t横向，从右到左\n\t\t对于行内块元素和话，宽度的计算是和 Colum-reverse 类似的。\n\tcolumn\n\t\t纵向，从上到下\n\tcolumn-reverse\n\t\t纵向，从下到上\n\t\t对于没有设置高度的，就会按照最小高度进行计算，(意思就是说，高度和column的一样，只是方向反了而已。)\n```\n\n\n\n## flex-wrap 实现多行flex\n\n​\t\t对定义了 `display: flex;` 的元素使用\n\n​\t\t在这样做的时候，您应该把每一行看作一个新的`flex`容器。 任何空间分布都将在该行上发生，而不影响该空间分布的其他行。\n\n```\nwrap\n\t会换行，而不是进行缩小\nnowrap\n\t不会换行，会使用缩小的规则进行缩小，对于不能缩小的，会导致溢出。\n```\n\n**注意：**\n\n* 如果在使用 wrap 时，使用了 flex:1， 时，这个时候就需要注意要不要定义 flex-basis 了。\n\n​\t\t\t**原因**： 因为 `flex: 1`; 对应了 `flex-grow: 1` & `flex-shrink: 1` && `flex-basis: 0`  ，所以其实原因就是 flex-basis 为 0 了。所以如果不自己定义一个 flex-basis 的话，就不会进行换行。\n\n* 还有就是，对于每一个换行之后的元素，每一行都算是一个弹性行，所以对于以下代码\n\n  * ```\n    flex: 1 1 160px;\n    \n    子元素在160px，换行之后，会对每一行的每个元素进行 扩张 和 收缩 的重新计算。\n    ```\n\n  * ```\n    参考 MDN 链接：\n    https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Flexible_Box_Layout/Mastering_Wrapping_of_Flex_Items\n    ```\n\n\n\n## 简写属性 flex-flow\n\n​\t\t对定义了 `display: flex;` 的元素使用\n\n​\t\t是 `flex-direction` 和 `flex-wrap` 的组合\n\n​\t\t对于没有写的，就会使用默认值：row 和 nowrap\n\n**注：**\n\n* 从谷歌浏览器的显示来说:\n  * 如果设置 `flex-flow: column; `  ，就直接代表了 `flex-direction: column;` ，而不会定义 `flex-wrap`\n  * 如果设置 `flex-flow: wrap; `  ，就代表了 `flex-direction: initial;` 而  `flex-flow: wrap; ` \n\n\n\n## flex-basis 元素的空间大小\n\n​\t\t该属性的默认值是 `auto` ，此时，浏览器会检查这个元素是否具有确定的尺寸(width / heght ，这个看是使用 row 还是 Colum)，如果**具有确定的尺寸**，就会将该值设置为 flex-basis。如果没有设定尺寸，就会采用**元素内容的尺寸**。如果不使用  [`box-sizing`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/box-sizing) 改变盒模型的话，那么这个属性就决定了 flex 元素的内容盒（content-box）的尺寸。\n\n\n\n## flex-grow 延展比例\n\n​\t\t负值无效，默认为0\n\n​\t\t简单来说，这个是一个比例，对于存在可用空间的(可用空间：就是指在使用之后，父元素还存在剩余的空间。)， 子元素会根据这个比例将可用空间占据。\n\n​\t\t比如：两个子元素，一个为 1， 一个为 2，父元素的可用空间为 90，那么第一个就会扩张 1/(1+2) * 90 ， 第二个就会扩张 2/(1+2) * 90 。\n\n\n\n## flex-shrink 收缩比例\n\n​\t\t负值无效，默认为1\n\n​\t\t简单来说，就会对于如果容器不够排列 flex元素的空间。那么就会按照比例进行收缩。默认为1\n\n​\t\t计算方式： 这里的计算方式略和 `flex-grow` 有所不同。他的计算会和 `flex-basis` 相关联。这里给出计算的方法\n\n​\t\t\t每个元素的 `flex-basis` * `flex-shrink` 这个值作为一个比例**X1**，将所有参与计算的元素进行计算 **X1~Xi 的求和 Xs** ，然后再计算出超出的量，这个超出的量是 **overflow = 子元素的flex-basis 的总和 - 父元素的宽度**， 然后就是进行计算 **Xi / Xs * overflow**， 这个计算出的值就是需要减去的量，这里可能有点抽象，我们也给一个例子方便理解\n\n```\ndiv\twidth:600px\n\tdiv flex: 1 1 200px;\n\tdiv flex: 1 1 200px;\n\tdiv flex: 1 2 300px;\n\n首先我们可以看出，这个是超出了，所以需要收缩，\n超出的量 overflow = 600 - 200 - 200 - 300 = 100px\n然后比例的计算\n\tX1 = 1 * 200 = 200px\n\tX2 = 1 * 200 = 200px\n\tX3 = 2 * 300 = 600px\n所以 Xs = X1 + X2 + X3 = 1000px\n然后就是计算收缩的值\tXi / Xs * overflow\n\t200 / 1000 * 100 = 20\n\t200 / 1000 * 100 = 20\n\t600 / 1000 * 100 = 60\n\t\n所以最终的宽度是\ndiv width: 600px\n\tdiv width: 180px\n\tdiv width: 180px\n\tdiv width: 240px\n```\n\n在这里我也看到了一个更详细的一些计算教程，虽然里面的内容是否正确我没有进行参考，但是写的很详细，我就把链接贴出来\n\n```\nhttps://www.cnblogs.com/liyan-web/p/11217330.html\n```\n\n​\t**注意点：**\n\n```\nhttps://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Flexible_Box_Layout/Controlling_Ratios_of_Flex_Items_Along_the_Main_Ax\n```\n\n​\t\t这个元素在缩小的时候，不会小于最小宽度，至于这个最小宽度定义，我现在认为就是可以造成溢出的情况。举个例子：\n\n```\ndiv\n\t222222222222222222222222222222222222\n\t\n\t在这个情况，如果这个div想对于父元素的弹性布局，造成了溢出，但是因为最小的宽度为这个文字的一个长度，不会换行，所以会造成溢出。\n\t而 22222 222222 222222222 222222 2222，这里，因为在 文字里面加入了空格，在html文档里面一个最小宽度是一个空格隔开的一个距离，所以会出现换行而不会让宽度溢出的情况。\n\t这里记录一下会统计最小宽度的情况。\n\t\t' '(不能使用 &nbsp; ), '。'(。会在上一行), '，'(中文，号)，这里的原因应该是中文的。和， 里面的一个字符形势和 . ,不一样。\n\t注意：只能是 英文和数字，中文会自动换行。原因应该是 对于英文，如果不打空格，浏览器会认为是一个单词，所以不会换行。\n```\n\n**注意：**\n\n* `flex-grow` && `flex-shrink` 的值要为正数。\n\n\n\n\n## 简写属性 flex\n\n​\t\t对弹性布局的子元素使用。\n\n​\t\t包含了： `flex-grow`  、 `flex-shrink` 和 `flex-basis` \n\n​\t\t对于每个属性的值，都有理解了。我们就说几个简写的代表意思\n\n- `flex: initial`\n  - 代表初始值：`flex: 0 1 auto`\n- `flex: auto`\n  - 代表 `flex: 1 1 auto`\n- `flex: none`\n  - 代表 `flex: 0 0 auto`\n- `flex: <positive-number>`\n  - 代表 `flex: x x 0`\n\n\n\n## align-items 交叉轴方向对齐\n\n​\t\t默认为 `stretch `，默认会被拉伸到最高元素的高度。\n\n```\nstretch\n\t拉伸到最高元素的高度\nflex-start\n\t按flex容器的顶部对齐\nflex-end\n\t按flex容器的下部对齐\ncenter\n\t使它们居中对齐\n```\n\n\n\n## justify-content 主轴方向对齐\n\n​\t\t初始值是 `flex-start`， 元素从容器的起始线排列。\n\n```\nstretch\n\t不了解\nflex-start\n\t从容器的起始线排列\nflex-end\n\t从容器的终止线开始排列\ncenter\n\t在中间排列\nspace-around\n\t把元素排列好之后的剩余空间拿出来，平均分配到元素之间，所以元素之间间隔相等\nspace-between\n\t使每个元素的左右空间相等\n```\n\n\n\n# 对于flex的溢出：\n\n### 方式一\n\n```\n对一个元素设置了flex布局，其中的子元素的子元素的宽度可以造成溢出\n```\n\n```\ndiv.father\n\tdiv.children\n\t\nfather 元素设置了弹性布局， children 元素只设置一个宽度，会发现 children 的宽度不会高于father的宽度。主要是因为涉及了\n```\n\n<img src=\"CSS-flex/image-20211027210947232.png\" alt=\"image-20211027210947232\" style=\"zoom: 50%;\" />\n\n\n\n```\n但是\ndiv.father\n\tdiv.children\n\t\tdiv.cChildren\n\n这个对于 cChildren 的宽度就会将 children 的宽度顶出来，造成溢出。\n其中，这里的宽度，如果 cChildren 大于了 father 就会将 cChildren 和 children 顶出来。\n但是如果 cChildren 大于了 children 的话，就会再 children 到达他所定义的宽度之后，就不会继续扩张了。\n```\n\n<img src=\"CSS-flex/image-20211027211015004.png\" alt=\"image-20211027211015004\" style=\"zoom:50%;\" />\n\n\n\n<img src=\"CSS-flex/image-20211027212431340.png\" alt=\"image-20211027211015004\" style=\"zoom:50%;\" />\n\n\n\n​\t\t但是这里的计算方式我没有理解到为什么。\n\n\n\n### 方式二\n\n​\t\t设置 `flex-shrink: 0;` 属性，因为设置了0之后代表了不会对超过的部分进行处理。\n\n\n\n### 方式三\n\n​\t\t这个是文字超出导致的溢出，就是如果文字，或者 img图片的设置超过了宽高也会造成溢出。\n\n​\t\t这个的原因是因为，对于英文和数字，浏览器不能识别你的单词是否是一个，所以如果你输入一串英文和数字，中间没有分割(前面有说)，就会造成溢出，而汉字不行。\n\n<img src=\"CSS-flex/image-20211027213217557.png\" alt=\"image-20211027213217557\" style=\"zoom:50%;\" />\n\n\n\n### 方式四\n\n​\t\t我们可以发现，flex 对于溢出的处理，默认只是针对于主轴，所以对于侧轴是没有溢出处理的。\n\n```\n.father {\n    display: flex;\n    flex-direction: column;\n    width: 50px;\n}\n\n.children {\n\twidth: 60px;\n}\n```\n\n<img src=\"CSS-flex/image-20211027214029980.png\" alt=\"image-20211027214029980\" style=\"zoom:50%;\" />\n\n\n\n","slug":"CSS/CSS-flex","published":1,"updated":"2021-12-09T01:56:49.388Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckznhkk7i0024ikub2aah4ina","content":"<h1 id=\"CSS-flex布局\"><a href=\"#CSS-flex布局\" class=\"headerlink\" title=\"CSS-flex布局\"></a>CSS-flex布局</h1><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Flexible_Box_Layout/Basic_Concepts_of_Flexbox</span><br></pre></td></tr></table></figure>\n\n<p>​        flex就是弹性布局。</p>\n<p>​        基本使用</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">display: flex;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"主轴\"><a href=\"#主轴\" class=\"headerlink\" title=\"主轴\"></a>主轴</h2><p>​        <code>flex-direction</code> 定义主轴</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">row，row-reverse</span><br><span class=\"line\">代表inline，横向延申</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">column，column-reverse</span><br><span class=\"line\">代表black，竖向排列</span><br></pre></td></tr></table></figure>\n\n<p>​        其中 <code>reverse </code>代表翻转，就是反过来的排列顺序</p>\n<h2 id=\"交叉轴，副轴\"><a href=\"#交叉轴，副轴\" class=\"headerlink\" title=\"交叉轴，副轴\"></a>交叉轴，副轴</h2><p>​        就是和主轴垂直的轴</p>\n<p>​        如果主轴是横轴，那么交叉轴就是数轴。</p>\n<h1 id=\"当使用了-Flex容器\"><a href=\"#当使用了-Flex容器\" class=\"headerlink\" title=\"当使用了 Flex容器\"></a>当使用了 Flex容器</h1><p>​        在定义了 <code>display: flex;</code> 之后的一些默认行为</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">元素排列一行，(因为 flex-direction 的默认值是 row )</span><br><span class=\"line\">从主轴的起始线开始，这里起始线一般就是如果是row，代表了从左向右，其他的\t情况查看MDN文档</span><br><span class=\"line\">元素不会再主维度拉伸，但是可以缩小</span><br><span class=\"line\">元素被拉伸来填充交叉轴大小</span><br><span class=\"line\">flex-basis 为 auto</span><br><span class=\"line\">flex-wrap 为 nowrap</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"对于flex属性值的行为\"><a href=\"#对于flex属性值的行为\" class=\"headerlink\" title=\"对于flex属性值的行为\"></a>对于flex属性值的行为</h1><h2 id=\"flex-direction-设置主轴\"><a href=\"#flex-direction-设置主轴\" class=\"headerlink\" title=\"flex-direction 设置主轴\"></a>flex-direction 设置主轴</h2><p>​        对定义了 <code>display: flex;</code> 的元素使用</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">flex-direction</span><br><span class=\"line\">\trow</span><br><span class=\"line\">\t\t横向，从左到右</span><br><span class=\"line\">\trow-reverse</span><br><span class=\"line\">\t\t横向，从右到左</span><br><span class=\"line\">\t\t对于行内块元素和话，宽度的计算是和 Colum-reverse 类似的。</span><br><span class=\"line\">\tcolumn</span><br><span class=\"line\">\t\t纵向，从上到下</span><br><span class=\"line\">\tcolumn-reverse</span><br><span class=\"line\">\t\t纵向，从下到上</span><br><span class=\"line\">\t\t对于没有设置高度的，就会按照最小高度进行计算，(意思就是说，高度和column的一样，只是方向反了而已。)</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"flex-wrap-实现多行flex\"><a href=\"#flex-wrap-实现多行flex\" class=\"headerlink\" title=\"flex-wrap 实现多行flex\"></a>flex-wrap 实现多行flex</h2><p>​        对定义了 <code>display: flex;</code> 的元素使用</p>\n<p>​        在这样做的时候，您应该把每一行看作一个新的<code>flex</code>容器。 任何空间分布都将在该行上发生，而不影响该空间分布的其他行。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wrap</span><br><span class=\"line\">\t会换行，而不是进行缩小</span><br><span class=\"line\">nowrap</span><br><span class=\"line\">\t不会换行，会使用缩小的规则进行缩小，对于不能缩小的，会导致溢出。</span><br></pre></td></tr></table></figure>\n\n<p><strong>注意：</strong></p>\n<ul>\n<li>如果在使用 wrap 时，使用了 flex:1， 时，这个时候就需要注意要不要定义 flex-basis 了。</li>\n</ul>\n<p>​            <strong>原因</strong>： 因为 <code>flex: 1</code>; 对应了 <code>flex-grow: 1</code> &amp; <code>flex-shrink: 1</code> &amp;&amp; <code>flex-basis: 0</code>  ，所以其实原因就是 flex-basis 为 0 了。所以如果不自己定义一个 flex-basis 的话，就不会进行换行。</p>\n<ul>\n<li><p>还有就是，对于每一个换行之后的元素，每一行都算是一个弹性行，所以对于以下代码</p>\n<ul>\n<li>```<br>flex: 1 1 160px;子元素在160px，换行之后，会对每一行的每个元素进行 扩张 和 收缩 的重新计算。<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">* ```</span><br><span class=\"line\">  参考 MDN 链接：</span><br><span class=\"line\">  https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Flexible_Box_Layout/Mastering_Wrapping_of_Flex_Items</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"简写属性-flex-flow\"><a href=\"#简写属性-flex-flow\" class=\"headerlink\" title=\"简写属性 flex-flow\"></a>简写属性 flex-flow</h2><p>​        对定义了 <code>display: flex;</code> 的元素使用</p>\n<p>​        是 <code>flex-direction</code> 和 <code>flex-wrap</code> 的组合</p>\n<p>​        对于没有写的，就会使用默认值：row 和 nowrap</p>\n<p><strong>注：</strong></p>\n<ul>\n<li>从谷歌浏览器的显示来说:<ul>\n<li>如果设置 <code>flex-flow: column; </code>  ，就直接代表了 <code>flex-direction: column;</code> ，而不会定义 <code>flex-wrap</code></li>\n<li>如果设置 <code>flex-flow: wrap; </code>  ，就代表了 <code>flex-direction: initial;</code> 而  <code>flex-flow: wrap; </code> </li>\n</ul>\n</li>\n</ul>\n<h2 id=\"flex-basis-元素的空间大小\"><a href=\"#flex-basis-元素的空间大小\" class=\"headerlink\" title=\"flex-basis 元素的空间大小\"></a>flex-basis 元素的空间大小</h2><p>​        该属性的默认值是 <code>auto</code> ，此时，浏览器会检查这个元素是否具有确定的尺寸(width / heght ，这个看是使用 row 还是 Colum)，如果<strong>具有确定的尺寸</strong>，就会将该值设置为 flex-basis。如果没有设定尺寸，就会采用<strong>元素内容的尺寸</strong>。如果不使用  <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/CSS/box-sizing\"><code>box-sizing</code></a> 改变盒模型的话，那么这个属性就决定了 flex 元素的内容盒（content-box）的尺寸。</p>\n<h2 id=\"flex-grow-延展比例\"><a href=\"#flex-grow-延展比例\" class=\"headerlink\" title=\"flex-grow 延展比例\"></a>flex-grow 延展比例</h2><p>​        负值无效，默认为0</p>\n<p>​        简单来说，这个是一个比例，对于存在可用空间的(可用空间：就是指在使用之后，父元素还存在剩余的空间。)， 子元素会根据这个比例将可用空间占据。</p>\n<p>​        比如：两个子元素，一个为 1， 一个为 2，父元素的可用空间为 90，那么第一个就会扩张 1/(1+2) * 90 ， 第二个就会扩张 2/(1+2) * 90 。</p>\n<h2 id=\"flex-shrink-收缩比例\"><a href=\"#flex-shrink-收缩比例\" class=\"headerlink\" title=\"flex-shrink 收缩比例\"></a>flex-shrink 收缩比例</h2><p>​        负值无效，默认为1</p>\n<p>​        简单来说，就会对于如果容器不够排列 flex元素的空间。那么就会按照比例进行收缩。默认为1</p>\n<p>​        计算方式： 这里的计算方式略和 <code>flex-grow</code> 有所不同。他的计算会和 <code>flex-basis</code> 相关联。这里给出计算的方法</p>\n<p>​            每个元素的 <code>flex-basis</code> * <code>flex-shrink</code> 这个值作为一个比例<strong>X1</strong>，将所有参与计算的元素进行计算 <strong>X1~Xi 的求和 Xs</strong> ，然后再计算出超出的量，这个超出的量是 <strong>overflow = 子元素的flex-basis 的总和 - 父元素的宽度</strong>， 然后就是进行计算 <strong>Xi / Xs * overflow</strong>， 这个计算出的值就是需要减去的量，这里可能有点抽象，我们也给一个例子方便理解</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">div\twidth:600px</span><br><span class=\"line\">\tdiv flex: 1 1 200px;</span><br><span class=\"line\">\tdiv flex: 1 1 200px;</span><br><span class=\"line\">\tdiv flex: 1 2 300px;</span><br><span class=\"line\"></span><br><span class=\"line\">首先我们可以看出，这个是超出了，所以需要收缩，</span><br><span class=\"line\">超出的量 overflow = 600 - 200 - 200 - 300 = 100px</span><br><span class=\"line\">然后比例的计算</span><br><span class=\"line\">\tX1 = 1 * 200 = 200px</span><br><span class=\"line\">\tX2 = 1 * 200 = 200px</span><br><span class=\"line\">\tX3 = 2 * 300 = 600px</span><br><span class=\"line\">所以 Xs = X1 + X2 + X3 = 1000px</span><br><span class=\"line\">然后就是计算收缩的值\tXi / Xs * overflow</span><br><span class=\"line\">\t200 / 1000 * 100 = 20</span><br><span class=\"line\">\t200 / 1000 * 100 = 20</span><br><span class=\"line\">\t600 / 1000 * 100 = 60</span><br><span class=\"line\">\t</span><br><span class=\"line\">所以最终的宽度是</span><br><span class=\"line\">div width: 600px</span><br><span class=\"line\">\tdiv width: 180px</span><br><span class=\"line\">\tdiv width: 180px</span><br><span class=\"line\">\tdiv width: 240px</span><br></pre></td></tr></table></figure>\n\n<p>在这里我也看到了一个更详细的一些计算教程，虽然里面的内容是否正确我没有进行参考，但是写的很详细，我就把链接贴出来</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://www.cnblogs.com/liyan-web/p/11217330.html</span><br></pre></td></tr></table></figure>\n\n<p>​    <strong>注意点：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Flexible_Box_Layout/Controlling_Ratios_of_Flex_Items_Along_the_Main_Ax</span><br></pre></td></tr></table></figure>\n\n<p>​        这个元素在缩小的时候，不会小于最小宽度，至于这个最小宽度定义，我现在认为就是可以造成溢出的情况。举个例子：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">div</span><br><span class=\"line\">\t222222222222222222222222222222222222</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t在这个情况，如果这个div想对于父元素的弹性布局，造成了溢出，但是因为最小的宽度为这个文字的一个长度，不会换行，所以会造成溢出。</span><br><span class=\"line\">\t而 22222 222222 222222222 222222 2222，这里，因为在 文字里面加入了空格，在html文档里面一个最小宽度是一个空格隔开的一个距离，所以会出现换行而不会让宽度溢出的情况。</span><br><span class=\"line\">\t这里记录一下会统计最小宽度的情况。</span><br><span class=\"line\">\t\t&#x27; &#x27;(不能使用 &amp;nbsp; ), &#x27;。&#x27;(。会在上一行), &#x27;，&#x27;(中文，号)，这里的原因应该是中文的。和， 里面的一个字符形势和 . ,不一样。</span><br><span class=\"line\">\t注意：只能是 英文和数字，中文会自动换行。原因应该是 对于英文，如果不打空格，浏览器会认为是一个单词，所以不会换行。</span><br></pre></td></tr></table></figure>\n\n<p><strong>注意：</strong></p>\n<ul>\n<li><code>flex-grow</code> &amp;&amp; <code>flex-shrink</code> 的值要为正数。</li>\n</ul>\n<h2 id=\"简写属性-flex\"><a href=\"#简写属性-flex\" class=\"headerlink\" title=\"简写属性 flex\"></a>简写属性 flex</h2><p>​        对弹性布局的子元素使用。</p>\n<p>​        包含了： <code>flex-grow</code>  、 <code>flex-shrink</code> 和 <code>flex-basis</code> </p>\n<p>​        对于每个属性的值，都有理解了。我们就说几个简写的代表意思</p>\n<ul>\n<li><code>flex: initial</code><ul>\n<li>代表初始值：<code>flex: 0 1 auto</code></li>\n</ul>\n</li>\n<li><code>flex: auto</code><ul>\n<li>代表 <code>flex: 1 1 auto</code></li>\n</ul>\n</li>\n<li><code>flex: none</code><ul>\n<li>代表 <code>flex: 0 0 auto</code></li>\n</ul>\n</li>\n<li><code>flex: &lt;positive-number&gt;</code><ul>\n<li>代表 <code>flex: x x 0</code></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"align-items-交叉轴方向对齐\"><a href=\"#align-items-交叉轴方向对齐\" class=\"headerlink\" title=\"align-items 交叉轴方向对齐\"></a>align-items 交叉轴方向对齐</h2><p>​        默认为 <code>stretch </code>，默认会被拉伸到最高元素的高度。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">stretch</span><br><span class=\"line\">\t拉伸到最高元素的高度</span><br><span class=\"line\">flex-start</span><br><span class=\"line\">\t按flex容器的顶部对齐</span><br><span class=\"line\">flex-end</span><br><span class=\"line\">\t按flex容器的下部对齐</span><br><span class=\"line\">center</span><br><span class=\"line\">\t使它们居中对齐</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"justify-content-主轴方向对齐\"><a href=\"#justify-content-主轴方向对齐\" class=\"headerlink\" title=\"justify-content 主轴方向对齐\"></a>justify-content 主轴方向对齐</h2><p>​        初始值是 <code>flex-start</code>， 元素从容器的起始线排列。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">stretch</span><br><span class=\"line\">\t不了解</span><br><span class=\"line\">flex-start</span><br><span class=\"line\">\t从容器的起始线排列</span><br><span class=\"line\">flex-end</span><br><span class=\"line\">\t从容器的终止线开始排列</span><br><span class=\"line\">center</span><br><span class=\"line\">\t在中间排列</span><br><span class=\"line\">space-around</span><br><span class=\"line\">\t把元素排列好之后的剩余空间拿出来，平均分配到元素之间，所以元素之间间隔相等</span><br><span class=\"line\">space-between</span><br><span class=\"line\">\t使每个元素的左右空间相等</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"对于flex的溢出：\"><a href=\"#对于flex的溢出：\" class=\"headerlink\" title=\"对于flex的溢出：\"></a>对于flex的溢出：</h1><h3 id=\"方式一\"><a href=\"#方式一\" class=\"headerlink\" title=\"方式一\"></a>方式一</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">对一个元素设置了flex布局，其中的子元素的子元素的宽度可以造成溢出</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">div.father</span><br><span class=\"line\">\tdiv.children</span><br><span class=\"line\">\t</span><br><span class=\"line\">father 元素设置了弹性布局， children 元素只设置一个宽度，会发现 children 的宽度不会高于father的宽度。主要是因为涉及了</span><br></pre></td></tr></table></figure>\n\n<img src=\"/.io//image-20211027210947232.png\" alt=\"image-20211027210947232\" style=\"zoom: 50%;\">\n\n\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">但是</span><br><span class=\"line\">div.father</span><br><span class=\"line\">\tdiv.children</span><br><span class=\"line\">\t\tdiv.cChildren</span><br><span class=\"line\"></span><br><span class=\"line\">这个对于 cChildren 的宽度就会将 children 的宽度顶出来，造成溢出。</span><br><span class=\"line\">其中，这里的宽度，如果 cChildren 大于了 father 就会将 cChildren 和 children 顶出来。</span><br><span class=\"line\">但是如果 cChildren 大于了 children 的话，就会再 children 到达他所定义的宽度之后，就不会继续扩张了。</span><br></pre></td></tr></table></figure>\n\n<img src=\"/.io//image-20211027211015004.png\" alt=\"image-20211027211015004\" style=\"zoom:50%;\">\n\n\n\n<img src=\"/.io//image-20211027212431340.png\" alt=\"image-20211027211015004\" style=\"zoom:50%;\">\n\n\n\n<p>​        但是这里的计算方式我没有理解到为什么。</p>\n<h3 id=\"方式二\"><a href=\"#方式二\" class=\"headerlink\" title=\"方式二\"></a>方式二</h3><p>​        设置 <code>flex-shrink: 0;</code> 属性，因为设置了0之后代表了不会对超过的部分进行处理。</p>\n<h3 id=\"方式三\"><a href=\"#方式三\" class=\"headerlink\" title=\"方式三\"></a>方式三</h3><p>​        这个是文字超出导致的溢出，就是如果文字，或者 img图片的设置超过了宽高也会造成溢出。</p>\n<p>​        这个的原因是因为，对于英文和数字，浏览器不能识别你的单词是否是一个，所以如果你输入一串英文和数字，中间没有分割(前面有说)，就会造成溢出，而汉字不行。</p>\n<img src=\"/.io//image-20211027213217557.png\" alt=\"image-20211027213217557\" style=\"zoom:50%;\">\n\n\n\n<h3 id=\"方式四\"><a href=\"#方式四\" class=\"headerlink\" title=\"方式四\"></a>方式四</h3><p>​        我们可以发现，flex 对于溢出的处理，默认只是针对于主轴，所以对于侧轴是没有溢出处理的。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.father &#123;</span><br><span class=\"line\">    display: flex;</span><br><span class=\"line\">    flex-direction: column;</span><br><span class=\"line\">    width: 50px;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.children &#123;</span><br><span class=\"line\">\twidth: 60px;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<img src=\"/.io//image-20211027214029980.png\" alt=\"image-20211027214029980\" style=\"zoom:50%;\">\n\n\n\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"CSS-flex布局\"><a href=\"#CSS-flex布局\" class=\"headerlink\" title=\"CSS-flex布局\"></a>CSS-flex布局</h1><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Flexible_Box_Layout/Basic_Concepts_of_Flexbox</span><br></pre></td></tr></table></figure>\n\n<p>​        flex就是弹性布局。</p>\n<p>​        基本使用</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">display: flex;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"主轴\"><a href=\"#主轴\" class=\"headerlink\" title=\"主轴\"></a>主轴</h2><p>​        <code>flex-direction</code> 定义主轴</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">row，row-reverse</span><br><span class=\"line\">代表inline，横向延申</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">column，column-reverse</span><br><span class=\"line\">代表black，竖向排列</span><br></pre></td></tr></table></figure>\n\n<p>​        其中 <code>reverse </code>代表翻转，就是反过来的排列顺序</p>\n<h2 id=\"交叉轴，副轴\"><a href=\"#交叉轴，副轴\" class=\"headerlink\" title=\"交叉轴，副轴\"></a>交叉轴，副轴</h2><p>​        就是和主轴垂直的轴</p>\n<p>​        如果主轴是横轴，那么交叉轴就是数轴。</p>\n<h1 id=\"当使用了-Flex容器\"><a href=\"#当使用了-Flex容器\" class=\"headerlink\" title=\"当使用了 Flex容器\"></a>当使用了 Flex容器</h1><p>​        在定义了 <code>display: flex;</code> 之后的一些默认行为</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">元素排列一行，(因为 flex-direction 的默认值是 row )</span><br><span class=\"line\">从主轴的起始线开始，这里起始线一般就是如果是row，代表了从左向右，其他的\t情况查看MDN文档</span><br><span class=\"line\">元素不会再主维度拉伸，但是可以缩小</span><br><span class=\"line\">元素被拉伸来填充交叉轴大小</span><br><span class=\"line\">flex-basis 为 auto</span><br><span class=\"line\">flex-wrap 为 nowrap</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"对于flex属性值的行为\"><a href=\"#对于flex属性值的行为\" class=\"headerlink\" title=\"对于flex属性值的行为\"></a>对于flex属性值的行为</h1><h2 id=\"flex-direction-设置主轴\"><a href=\"#flex-direction-设置主轴\" class=\"headerlink\" title=\"flex-direction 设置主轴\"></a>flex-direction 设置主轴</h2><p>​        对定义了 <code>display: flex;</code> 的元素使用</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">flex-direction</span><br><span class=\"line\">\trow</span><br><span class=\"line\">\t\t横向，从左到右</span><br><span class=\"line\">\trow-reverse</span><br><span class=\"line\">\t\t横向，从右到左</span><br><span class=\"line\">\t\t对于行内块元素和话，宽度的计算是和 Colum-reverse 类似的。</span><br><span class=\"line\">\tcolumn</span><br><span class=\"line\">\t\t纵向，从上到下</span><br><span class=\"line\">\tcolumn-reverse</span><br><span class=\"line\">\t\t纵向，从下到上</span><br><span class=\"line\">\t\t对于没有设置高度的，就会按照最小高度进行计算，(意思就是说，高度和column的一样，只是方向反了而已。)</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"flex-wrap-实现多行flex\"><a href=\"#flex-wrap-实现多行flex\" class=\"headerlink\" title=\"flex-wrap 实现多行flex\"></a>flex-wrap 实现多行flex</h2><p>​        对定义了 <code>display: flex;</code> 的元素使用</p>\n<p>​        在这样做的时候，您应该把每一行看作一个新的<code>flex</code>容器。 任何空间分布都将在该行上发生，而不影响该空间分布的其他行。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wrap</span><br><span class=\"line\">\t会换行，而不是进行缩小</span><br><span class=\"line\">nowrap</span><br><span class=\"line\">\t不会换行，会使用缩小的规则进行缩小，对于不能缩小的，会导致溢出。</span><br></pre></td></tr></table></figure>\n\n<p><strong>注意：</strong></p>\n<ul>\n<li>如果在使用 wrap 时，使用了 flex:1， 时，这个时候就需要注意要不要定义 flex-basis 了。</li>\n</ul>\n<p>​            <strong>原因</strong>： 因为 <code>flex: 1</code>; 对应了 <code>flex-grow: 1</code> &amp; <code>flex-shrink: 1</code> &amp;&amp; <code>flex-basis: 0</code>  ，所以其实原因就是 flex-basis 为 0 了。所以如果不自己定义一个 flex-basis 的话，就不会进行换行。</p>\n<ul>\n<li><p>还有就是，对于每一个换行之后的元素，每一行都算是一个弹性行，所以对于以下代码</p>\n<ul>\n<li>```<br>flex: 1 1 160px;子元素在160px，换行之后，会对每一行的每个元素进行 扩张 和 收缩 的重新计算。<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">* ```</span><br><span class=\"line\">  参考 MDN 链接：</span><br><span class=\"line\">  https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Flexible_Box_Layout/Mastering_Wrapping_of_Flex_Items</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"简写属性-flex-flow\"><a href=\"#简写属性-flex-flow\" class=\"headerlink\" title=\"简写属性 flex-flow\"></a>简写属性 flex-flow</h2><p>​        对定义了 <code>display: flex;</code> 的元素使用</p>\n<p>​        是 <code>flex-direction</code> 和 <code>flex-wrap</code> 的组合</p>\n<p>​        对于没有写的，就会使用默认值：row 和 nowrap</p>\n<p><strong>注：</strong></p>\n<ul>\n<li>从谷歌浏览器的显示来说:<ul>\n<li>如果设置 <code>flex-flow: column; </code>  ，就直接代表了 <code>flex-direction: column;</code> ，而不会定义 <code>flex-wrap</code></li>\n<li>如果设置 <code>flex-flow: wrap; </code>  ，就代表了 <code>flex-direction: initial;</code> 而  <code>flex-flow: wrap; </code> </li>\n</ul>\n</li>\n</ul>\n<h2 id=\"flex-basis-元素的空间大小\"><a href=\"#flex-basis-元素的空间大小\" class=\"headerlink\" title=\"flex-basis 元素的空间大小\"></a>flex-basis 元素的空间大小</h2><p>​        该属性的默认值是 <code>auto</code> ，此时，浏览器会检查这个元素是否具有确定的尺寸(width / heght ，这个看是使用 row 还是 Colum)，如果<strong>具有确定的尺寸</strong>，就会将该值设置为 flex-basis。如果没有设定尺寸，就会采用<strong>元素内容的尺寸</strong>。如果不使用  <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/CSS/box-sizing\"><code>box-sizing</code></a> 改变盒模型的话，那么这个属性就决定了 flex 元素的内容盒（content-box）的尺寸。</p>\n<h2 id=\"flex-grow-延展比例\"><a href=\"#flex-grow-延展比例\" class=\"headerlink\" title=\"flex-grow 延展比例\"></a>flex-grow 延展比例</h2><p>​        负值无效，默认为0</p>\n<p>​        简单来说，这个是一个比例，对于存在可用空间的(可用空间：就是指在使用之后，父元素还存在剩余的空间。)， 子元素会根据这个比例将可用空间占据。</p>\n<p>​        比如：两个子元素，一个为 1， 一个为 2，父元素的可用空间为 90，那么第一个就会扩张 1/(1+2) * 90 ， 第二个就会扩张 2/(1+2) * 90 。</p>\n<h2 id=\"flex-shrink-收缩比例\"><a href=\"#flex-shrink-收缩比例\" class=\"headerlink\" title=\"flex-shrink 收缩比例\"></a>flex-shrink 收缩比例</h2><p>​        负值无效，默认为1</p>\n<p>​        简单来说，就会对于如果容器不够排列 flex元素的空间。那么就会按照比例进行收缩。默认为1</p>\n<p>​        计算方式： 这里的计算方式略和 <code>flex-grow</code> 有所不同。他的计算会和 <code>flex-basis</code> 相关联。这里给出计算的方法</p>\n<p>​            每个元素的 <code>flex-basis</code> * <code>flex-shrink</code> 这个值作为一个比例<strong>X1</strong>，将所有参与计算的元素进行计算 <strong>X1~Xi 的求和 Xs</strong> ，然后再计算出超出的量，这个超出的量是 <strong>overflow = 子元素的flex-basis 的总和 - 父元素的宽度</strong>， 然后就是进行计算 <strong>Xi / Xs * overflow</strong>， 这个计算出的值就是需要减去的量，这里可能有点抽象，我们也给一个例子方便理解</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">div\twidth:600px</span><br><span class=\"line\">\tdiv flex: 1 1 200px;</span><br><span class=\"line\">\tdiv flex: 1 1 200px;</span><br><span class=\"line\">\tdiv flex: 1 2 300px;</span><br><span class=\"line\"></span><br><span class=\"line\">首先我们可以看出，这个是超出了，所以需要收缩，</span><br><span class=\"line\">超出的量 overflow = 600 - 200 - 200 - 300 = 100px</span><br><span class=\"line\">然后比例的计算</span><br><span class=\"line\">\tX1 = 1 * 200 = 200px</span><br><span class=\"line\">\tX2 = 1 * 200 = 200px</span><br><span class=\"line\">\tX3 = 2 * 300 = 600px</span><br><span class=\"line\">所以 Xs = X1 + X2 + X3 = 1000px</span><br><span class=\"line\">然后就是计算收缩的值\tXi / Xs * overflow</span><br><span class=\"line\">\t200 / 1000 * 100 = 20</span><br><span class=\"line\">\t200 / 1000 * 100 = 20</span><br><span class=\"line\">\t600 / 1000 * 100 = 60</span><br><span class=\"line\">\t</span><br><span class=\"line\">所以最终的宽度是</span><br><span class=\"line\">div width: 600px</span><br><span class=\"line\">\tdiv width: 180px</span><br><span class=\"line\">\tdiv width: 180px</span><br><span class=\"line\">\tdiv width: 240px</span><br></pre></td></tr></table></figure>\n\n<p>在这里我也看到了一个更详细的一些计算教程，虽然里面的内容是否正确我没有进行参考，但是写的很详细，我就把链接贴出来</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://www.cnblogs.com/liyan-web/p/11217330.html</span><br></pre></td></tr></table></figure>\n\n<p>​    <strong>注意点：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Flexible_Box_Layout/Controlling_Ratios_of_Flex_Items_Along_the_Main_Ax</span><br></pre></td></tr></table></figure>\n\n<p>​        这个元素在缩小的时候，不会小于最小宽度，至于这个最小宽度定义，我现在认为就是可以造成溢出的情况。举个例子：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">div</span><br><span class=\"line\">\t222222222222222222222222222222222222</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t在这个情况，如果这个div想对于父元素的弹性布局，造成了溢出，但是因为最小的宽度为这个文字的一个长度，不会换行，所以会造成溢出。</span><br><span class=\"line\">\t而 22222 222222 222222222 222222 2222，这里，因为在 文字里面加入了空格，在html文档里面一个最小宽度是一个空格隔开的一个距离，所以会出现换行而不会让宽度溢出的情况。</span><br><span class=\"line\">\t这里记录一下会统计最小宽度的情况。</span><br><span class=\"line\">\t\t&#x27; &#x27;(不能使用 &amp;nbsp; ), &#x27;。&#x27;(。会在上一行), &#x27;，&#x27;(中文，号)，这里的原因应该是中文的。和， 里面的一个字符形势和 . ,不一样。</span><br><span class=\"line\">\t注意：只能是 英文和数字，中文会自动换行。原因应该是 对于英文，如果不打空格，浏览器会认为是一个单词，所以不会换行。</span><br></pre></td></tr></table></figure>\n\n<p><strong>注意：</strong></p>\n<ul>\n<li><code>flex-grow</code> &amp;&amp; <code>flex-shrink</code> 的值要为正数。</li>\n</ul>\n<h2 id=\"简写属性-flex\"><a href=\"#简写属性-flex\" class=\"headerlink\" title=\"简写属性 flex\"></a>简写属性 flex</h2><p>​        对弹性布局的子元素使用。</p>\n<p>​        包含了： <code>flex-grow</code>  、 <code>flex-shrink</code> 和 <code>flex-basis</code> </p>\n<p>​        对于每个属性的值，都有理解了。我们就说几个简写的代表意思</p>\n<ul>\n<li><code>flex: initial</code><ul>\n<li>代表初始值：<code>flex: 0 1 auto</code></li>\n</ul>\n</li>\n<li><code>flex: auto</code><ul>\n<li>代表 <code>flex: 1 1 auto</code></li>\n</ul>\n</li>\n<li><code>flex: none</code><ul>\n<li>代表 <code>flex: 0 0 auto</code></li>\n</ul>\n</li>\n<li><code>flex: &lt;positive-number&gt;</code><ul>\n<li>代表 <code>flex: x x 0</code></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"align-items-交叉轴方向对齐\"><a href=\"#align-items-交叉轴方向对齐\" class=\"headerlink\" title=\"align-items 交叉轴方向对齐\"></a>align-items 交叉轴方向对齐</h2><p>​        默认为 <code>stretch </code>，默认会被拉伸到最高元素的高度。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">stretch</span><br><span class=\"line\">\t拉伸到最高元素的高度</span><br><span class=\"line\">flex-start</span><br><span class=\"line\">\t按flex容器的顶部对齐</span><br><span class=\"line\">flex-end</span><br><span class=\"line\">\t按flex容器的下部对齐</span><br><span class=\"line\">center</span><br><span class=\"line\">\t使它们居中对齐</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"justify-content-主轴方向对齐\"><a href=\"#justify-content-主轴方向对齐\" class=\"headerlink\" title=\"justify-content 主轴方向对齐\"></a>justify-content 主轴方向对齐</h2><p>​        初始值是 <code>flex-start</code>， 元素从容器的起始线排列。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">stretch</span><br><span class=\"line\">\t不了解</span><br><span class=\"line\">flex-start</span><br><span class=\"line\">\t从容器的起始线排列</span><br><span class=\"line\">flex-end</span><br><span class=\"line\">\t从容器的终止线开始排列</span><br><span class=\"line\">center</span><br><span class=\"line\">\t在中间排列</span><br><span class=\"line\">space-around</span><br><span class=\"line\">\t把元素排列好之后的剩余空间拿出来，平均分配到元素之间，所以元素之间间隔相等</span><br><span class=\"line\">space-between</span><br><span class=\"line\">\t使每个元素的左右空间相等</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"对于flex的溢出：\"><a href=\"#对于flex的溢出：\" class=\"headerlink\" title=\"对于flex的溢出：\"></a>对于flex的溢出：</h1><h3 id=\"方式一\"><a href=\"#方式一\" class=\"headerlink\" title=\"方式一\"></a>方式一</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">对一个元素设置了flex布局，其中的子元素的子元素的宽度可以造成溢出</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">div.father</span><br><span class=\"line\">\tdiv.children</span><br><span class=\"line\">\t</span><br><span class=\"line\">father 元素设置了弹性布局， children 元素只设置一个宽度，会发现 children 的宽度不会高于father的宽度。主要是因为涉及了</span><br></pre></td></tr></table></figure>\n\n<img src=\"/.io//image-20211027210947232.png\" alt=\"image-20211027210947232\" style=\"zoom: 50%;\">\n\n\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">但是</span><br><span class=\"line\">div.father</span><br><span class=\"line\">\tdiv.children</span><br><span class=\"line\">\t\tdiv.cChildren</span><br><span class=\"line\"></span><br><span class=\"line\">这个对于 cChildren 的宽度就会将 children 的宽度顶出来，造成溢出。</span><br><span class=\"line\">其中，这里的宽度，如果 cChildren 大于了 father 就会将 cChildren 和 children 顶出来。</span><br><span class=\"line\">但是如果 cChildren 大于了 children 的话，就会再 children 到达他所定义的宽度之后，就不会继续扩张了。</span><br></pre></td></tr></table></figure>\n\n<img src=\"/.io//image-20211027211015004.png\" alt=\"image-20211027211015004\" style=\"zoom:50%;\">\n\n\n\n<img src=\"/.io//image-20211027212431340.png\" alt=\"image-20211027211015004\" style=\"zoom:50%;\">\n\n\n\n<p>​        但是这里的计算方式我没有理解到为什么。</p>\n<h3 id=\"方式二\"><a href=\"#方式二\" class=\"headerlink\" title=\"方式二\"></a>方式二</h3><p>​        设置 <code>flex-shrink: 0;</code> 属性，因为设置了0之后代表了不会对超过的部分进行处理。</p>\n<h3 id=\"方式三\"><a href=\"#方式三\" class=\"headerlink\" title=\"方式三\"></a>方式三</h3><p>​        这个是文字超出导致的溢出，就是如果文字，或者 img图片的设置超过了宽高也会造成溢出。</p>\n<p>​        这个的原因是因为，对于英文和数字，浏览器不能识别你的单词是否是一个，所以如果你输入一串英文和数字，中间没有分割(前面有说)，就会造成溢出，而汉字不行。</p>\n<img src=\"/.io//image-20211027213217557.png\" alt=\"image-20211027213217557\" style=\"zoom:50%;\">\n\n\n\n<h3 id=\"方式四\"><a href=\"#方式四\" class=\"headerlink\" title=\"方式四\"></a>方式四</h3><p>​        我们可以发现，flex 对于溢出的处理，默认只是针对于主轴，所以对于侧轴是没有溢出处理的。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.father &#123;</span><br><span class=\"line\">    display: flex;</span><br><span class=\"line\">    flex-direction: column;</span><br><span class=\"line\">    width: 50px;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.children &#123;</span><br><span class=\"line\">\twidth: 60px;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<img src=\"/.io//image-20211027214029980.png\" alt=\"image-20211027214029980\" style=\"zoom:50%;\">\n\n\n\n"},{"title":"外边距合并","date":"2021-10-20T14:32:22.000Z","_content":"\n\n\n#  外边距合并问题\n\n\n\n## 首先，什么是外边距合并\n\n```\nhttps://www.w3school.com.cn/css/css_margin_collapse.asp\nhttps://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Box_Model/Mastering_margin_collapsing\nhttps://www.w3.org/TR/CSS2/box.html#collapsing-margins\n```\n\n\n\n**外边距合并指的是，当两个垂直外边距相遇时，它们将形成一个外边距。**\n\n**合并后的外边距的高度等于两个发生合并的外边距的高度中的较大者。**\n\n\n\n简单来说，这个的效果就是，两个外边距并不是进行的相加的边距，而是取了其中的最大值\n\n\n\n一个简单的例子\n\n```\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <title>Title</title>\n  <style>\n    * {\n      margin: 0;\n      padding: 0;\n    }\n\n    .f {\n      height: 400px;\n      width: 800px;\n      background-color: red;\n    }\n\n    .c {\n      height: 50%;\n      width: 50%;\n      background-color: blue;\n      margin-top: 25%;\n\n    }\n  </style>\n\n</head>\n<body>\n<div class=\"f\">\n  <div class=\"c\"></div>\n</div>\n</body>\n</html>\n```\n\n实际的效果\n\n<img src=\"外边距合并/image-20211020224217218.png\" alt=\"image-20211020224217218\" style=\"zoom:50%;\" />\n\n预想的效果\n\n<img src=\"外边距合并/image-20211020224237425.png\" alt=\"image-20211020224237425\" style=\"zoom:50%;\" />\n\n\n\n## 有几种情况会产生外边距合并\n\n### **同一层相邻元素之间**\n\n```\n\t相邻的两个元素之间的外边距重叠，除非后一个元素加上clear-fix清除浮动。\n```\n\n​\t相邻元素， 元素包含了，`块级元素`，`行内元素`，`行内块元素`\n\n但是对于 `行内元素`来说，不能使用margin-top，来进行扩张。\n\n对于 `行内块元素`  来说，因为他造成了 BFC，所以，margin-top，没有了合并的效果。\n\n所以，最后还是使用了块级元素。\n\n\n\n### **没有内容将父元素和后代元素分开**\n\n```\n原话：\n\t如果没有边框border，内边距padding，行内内容，也没有创建块级格式上下文或清除浮动来分开一个块级元素的上边界margin-top 与其内一个或多个后代块级元素的上边界margin-top；或没有边框，内边距，行内内容，高度height，最小高度min-height或 最大高度max-height 来分开一个块级元素的下边界margin-bottom与其内的一个或多个后代后代块元素的下边界margin-bottom，则就会出现父块元素和其内后代块元素外边界重叠，重叠部分最终会溢出到父级块元素外面。\n```\n\n这里的内容，包括了\n\n**第一部分：**\n\n​\t**边框：**border\t父元素使用，子元素使用并不会有效果。\n\n​\t同理，**内边距：**padding，也是一样的。\n\n​\t**创建块级格式上下文：**（BFC）我们后面再说：\n\n​\t现在我就直接贴上　MDN　的 url\n\n```\nhttps://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Block_formatting_context\n```\n\n​\t**清除浮动：**不知道是要进行什么操作的意思。不知道是不是对子元素进行一次浮动，然后再在父元素上进行清除浮动。\n\n\n\n**第二部分：**\n\n​\t父元素没有定义高度，所以最终高度会由子元素进行定义，因此，对于 `margin-bottom` 下边界会造成合并的效果。，然后重叠部分会溢出到父元素的外面。\n\n\n\n### **空的块级元素**\n\n```\n\t当一个块元素上边界margin-top 直接贴到元素下边界margin-bottom时也会发生边界折叠。这种情况会发生在一个块元素完全没有设定边框border、内边距padding、高度height、最小高度min-height 、最大高度max-height 、内容设定为inline或是加上clear-fix的时候。\n```\n\n简单来说，就是一个空的块级元素\n\n然后对其进行 上边距和下边距的 设置，最终的结果不会是两个相加，\n\n而是选择最大的。\n\n前提就是父元素不能设置\n\n​\tborder，padding，height，min-height， max-height， display：inline， 和 加上 clear-fix。\n\n对于最后一个clear-fix，有点没有理解清除，其他的还好， display：inline，就是设置成一个行内元素，因为是行内元素，所以外边距就没有效果了。其他的 border，padding，就是一些正常的解决合并问题的方法。\n\n\n\n对于空的块级元素，连续相邻的外边距也是会合并的。\n\n<img src=\"外边距合并.assets/image-20211021103824947.png\" alt=\"image-20211021103824947\" style=\"zoom:50%;\" />\n\n\n\n### 注意：\n\n- 一些情况的组合会产生更多复杂的外边距离收起。\n- 即使某些外边距为0，这些规则仍然适用。因此，父母元素的外边距是0，或最后一个外边距可能会“接触到第一个元素”到父母元素的外面。\n- 如果参与折叠的外边距中包含的负值，折叠后的外边距的值为最大的正边距和最大的负边距（即绝对值的最大负边距）和；如果有—— 13px 8px 100px 一叠，远景的技术就是100px -13px的87px。（有负有正，取最大最小相加）\n- 如果所有参与的户外边距都为负，折叠后的外边距的最大负边距值为多少。这个规则适用于户外元素和元素。 （全为负，取绝对值最大的。）\n\n```\n个人认为：\n\t这样正负的判断，在修改边距的时候，有一个逐渐的过程，而不会出现突变情况。\n```\n\n\n\n## 解决外边距合并的办法\n\n首先一点：\n\n​\t**只有普通文档流中块框的垂直外边距才会发生外边距合并。行内框、浮动框或绝对定位之间的外边距不会合并。**\n\n行内块不会合并的原因是，他形成了BFC，块格式化上下文。\n\n其他两个是因为他们脱离了普通文档流。\n\n\n\n### 解决兄弟元素的上下外边距合并\n\n#### 浮动\n\n虽然浮动可以解决，但是因为是兄弟元素的外边距合并，有时会产生更多的问题。\n\n\n\n### 行内块\n\n行内块 display: inline-block;\t感觉比上面的好处多了很多。\n\n\n\n### 使用绝对定位\n\n​\t\t在这里我知道了一个小知识点，一般对绝对定位的时候都会直接加上 left，top，如果不加的话，那么就会相对于原来的位置不变。虽然也脱离了文档流，不占据的位置，但是从视觉上来说，他是解决了外边框合并的问题。\n\n​\t但是如果父元素没有给定高度的话，那么将不会把这个高度计算在内。\n\n\n\n### 对于父子元素的外边距合并\n\n#### 设置边框或内边距\n\n避免父子的外边距相邻\n\n```\n给父元素加上 border: 1px solid transparent;\n```\n\n```\npadding: 1px;\n```\n\n\n\n#### 设置浮动，绝对定位，行内块布局，和overflow\n\n这种的实现就是进行 BFC 块级格式化。\n\n```\nfloat: left;\n```\n\n```\nposition: absolute;\n```\n\n```\ndisplay: inline-block;\n```\n\n```\noverflow: hidden;\n```\n\n```\noverflow: auto;\n```\n\n\n\n### 对于空的块级元素\n\n#### 设置边框，边距，高度\n\n```\nborder: 1px solid transparent;\n```\n\n```\npadding: 1px;\n```\n\n```\nheight: 1px;\n```\n\n#### 块环境上下文\n\n比如 \n\n```\ndisplay: inline-block;\noverflow: hidden;\n```\n\n","source":"_posts/CSS/外边距合并.md","raw":"---\ntitle: 外边距合并\ndate: 2021-10-20 22:32:22\ntags:\n - CSS\n - 外边距合并\ncategories:\n - CSS\n---\n\n\n\n#  外边距合并问题\n\n\n\n## 首先，什么是外边距合并\n\n```\nhttps://www.w3school.com.cn/css/css_margin_collapse.asp\nhttps://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Box_Model/Mastering_margin_collapsing\nhttps://www.w3.org/TR/CSS2/box.html#collapsing-margins\n```\n\n\n\n**外边距合并指的是，当两个垂直外边距相遇时，它们将形成一个外边距。**\n\n**合并后的外边距的高度等于两个发生合并的外边距的高度中的较大者。**\n\n\n\n简单来说，这个的效果就是，两个外边距并不是进行的相加的边距，而是取了其中的最大值\n\n\n\n一个简单的例子\n\n```\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <title>Title</title>\n  <style>\n    * {\n      margin: 0;\n      padding: 0;\n    }\n\n    .f {\n      height: 400px;\n      width: 800px;\n      background-color: red;\n    }\n\n    .c {\n      height: 50%;\n      width: 50%;\n      background-color: blue;\n      margin-top: 25%;\n\n    }\n  </style>\n\n</head>\n<body>\n<div class=\"f\">\n  <div class=\"c\"></div>\n</div>\n</body>\n</html>\n```\n\n实际的效果\n\n<img src=\"外边距合并/image-20211020224217218.png\" alt=\"image-20211020224217218\" style=\"zoom:50%;\" />\n\n预想的效果\n\n<img src=\"外边距合并/image-20211020224237425.png\" alt=\"image-20211020224237425\" style=\"zoom:50%;\" />\n\n\n\n## 有几种情况会产生外边距合并\n\n### **同一层相邻元素之间**\n\n```\n\t相邻的两个元素之间的外边距重叠，除非后一个元素加上clear-fix清除浮动。\n```\n\n​\t相邻元素， 元素包含了，`块级元素`，`行内元素`，`行内块元素`\n\n但是对于 `行内元素`来说，不能使用margin-top，来进行扩张。\n\n对于 `行内块元素`  来说，因为他造成了 BFC，所以，margin-top，没有了合并的效果。\n\n所以，最后还是使用了块级元素。\n\n\n\n### **没有内容将父元素和后代元素分开**\n\n```\n原话：\n\t如果没有边框border，内边距padding，行内内容，也没有创建块级格式上下文或清除浮动来分开一个块级元素的上边界margin-top 与其内一个或多个后代块级元素的上边界margin-top；或没有边框，内边距，行内内容，高度height，最小高度min-height或 最大高度max-height 来分开一个块级元素的下边界margin-bottom与其内的一个或多个后代后代块元素的下边界margin-bottom，则就会出现父块元素和其内后代块元素外边界重叠，重叠部分最终会溢出到父级块元素外面。\n```\n\n这里的内容，包括了\n\n**第一部分：**\n\n​\t**边框：**border\t父元素使用，子元素使用并不会有效果。\n\n​\t同理，**内边距：**padding，也是一样的。\n\n​\t**创建块级格式上下文：**（BFC）我们后面再说：\n\n​\t现在我就直接贴上　MDN　的 url\n\n```\nhttps://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Block_formatting_context\n```\n\n​\t**清除浮动：**不知道是要进行什么操作的意思。不知道是不是对子元素进行一次浮动，然后再在父元素上进行清除浮动。\n\n\n\n**第二部分：**\n\n​\t父元素没有定义高度，所以最终高度会由子元素进行定义，因此，对于 `margin-bottom` 下边界会造成合并的效果。，然后重叠部分会溢出到父元素的外面。\n\n\n\n### **空的块级元素**\n\n```\n\t当一个块元素上边界margin-top 直接贴到元素下边界margin-bottom时也会发生边界折叠。这种情况会发生在一个块元素完全没有设定边框border、内边距padding、高度height、最小高度min-height 、最大高度max-height 、内容设定为inline或是加上clear-fix的时候。\n```\n\n简单来说，就是一个空的块级元素\n\n然后对其进行 上边距和下边距的 设置，最终的结果不会是两个相加，\n\n而是选择最大的。\n\n前提就是父元素不能设置\n\n​\tborder，padding，height，min-height， max-height， display：inline， 和 加上 clear-fix。\n\n对于最后一个clear-fix，有点没有理解清除，其他的还好， display：inline，就是设置成一个行内元素，因为是行内元素，所以外边距就没有效果了。其他的 border，padding，就是一些正常的解决合并问题的方法。\n\n\n\n对于空的块级元素，连续相邻的外边距也是会合并的。\n\n<img src=\"外边距合并.assets/image-20211021103824947.png\" alt=\"image-20211021103824947\" style=\"zoom:50%;\" />\n\n\n\n### 注意：\n\n- 一些情况的组合会产生更多复杂的外边距离收起。\n- 即使某些外边距为0，这些规则仍然适用。因此，父母元素的外边距是0，或最后一个外边距可能会“接触到第一个元素”到父母元素的外面。\n- 如果参与折叠的外边距中包含的负值，折叠后的外边距的值为最大的正边距和最大的负边距（即绝对值的最大负边距）和；如果有—— 13px 8px 100px 一叠，远景的技术就是100px -13px的87px。（有负有正，取最大最小相加）\n- 如果所有参与的户外边距都为负，折叠后的外边距的最大负边距值为多少。这个规则适用于户外元素和元素。 （全为负，取绝对值最大的。）\n\n```\n个人认为：\n\t这样正负的判断，在修改边距的时候，有一个逐渐的过程，而不会出现突变情况。\n```\n\n\n\n## 解决外边距合并的办法\n\n首先一点：\n\n​\t**只有普通文档流中块框的垂直外边距才会发生外边距合并。行内框、浮动框或绝对定位之间的外边距不会合并。**\n\n行内块不会合并的原因是，他形成了BFC，块格式化上下文。\n\n其他两个是因为他们脱离了普通文档流。\n\n\n\n### 解决兄弟元素的上下外边距合并\n\n#### 浮动\n\n虽然浮动可以解决，但是因为是兄弟元素的外边距合并，有时会产生更多的问题。\n\n\n\n### 行内块\n\n行内块 display: inline-block;\t感觉比上面的好处多了很多。\n\n\n\n### 使用绝对定位\n\n​\t\t在这里我知道了一个小知识点，一般对绝对定位的时候都会直接加上 left，top，如果不加的话，那么就会相对于原来的位置不变。虽然也脱离了文档流，不占据的位置，但是从视觉上来说，他是解决了外边框合并的问题。\n\n​\t但是如果父元素没有给定高度的话，那么将不会把这个高度计算在内。\n\n\n\n### 对于父子元素的外边距合并\n\n#### 设置边框或内边距\n\n避免父子的外边距相邻\n\n```\n给父元素加上 border: 1px solid transparent;\n```\n\n```\npadding: 1px;\n```\n\n\n\n#### 设置浮动，绝对定位，行内块布局，和overflow\n\n这种的实现就是进行 BFC 块级格式化。\n\n```\nfloat: left;\n```\n\n```\nposition: absolute;\n```\n\n```\ndisplay: inline-block;\n```\n\n```\noverflow: hidden;\n```\n\n```\noverflow: auto;\n```\n\n\n\n### 对于空的块级元素\n\n#### 设置边框，边距，高度\n\n```\nborder: 1px solid transparent;\n```\n\n```\npadding: 1px;\n```\n\n```\nheight: 1px;\n```\n\n#### 块环境上下文\n\n比如 \n\n```\ndisplay: inline-block;\noverflow: hidden;\n```\n\n","slug":"CSS/外边距合并","published":1,"updated":"2021-12-09T01:56:49.388Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckznhkk7j0027ikubcmolcfn3","content":"<h1 id=\"外边距合并问题\"><a href=\"#外边距合并问题\" class=\"headerlink\" title=\"外边距合并问题\"></a>外边距合并问题</h1><h2 id=\"首先，什么是外边距合并\"><a href=\"#首先，什么是外边距合并\" class=\"headerlink\" title=\"首先，什么是外边距合并\"></a>首先，什么是外边距合并</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://www.w3school.com.cn/css/css_margin_collapse.asp</span><br><span class=\"line\">https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Box_Model/Mastering_margin_collapsing</span><br><span class=\"line\">https://www.w3.org/TR/CSS2/box.html#collapsing-margins</span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>外边距合并指的是，当两个垂直外边距相遇时，它们将形成一个外边距。</strong></p>\n<p><strong>合并后的外边距的高度等于两个发生合并的外边距的高度中的较大者。</strong></p>\n<p>简单来说，这个的效果就是，两个外边距并不是进行的相加的边距，而是取了其中的最大值</p>\n<p>一个简单的例子</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html lang=&quot;en&quot;&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">  &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class=\"line\">  &lt;title&gt;Title&lt;/title&gt;</span><br><span class=\"line\">  &lt;style&gt;</span><br><span class=\"line\">    * &#123;</span><br><span class=\"line\">      margin: 0;</span><br><span class=\"line\">      padding: 0;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    .f &#123;</span><br><span class=\"line\">      height: 400px;</span><br><span class=\"line\">      width: 800px;</span><br><span class=\"line\">      background-color: red;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    .c &#123;</span><br><span class=\"line\">      height: 50%;</span><br><span class=\"line\">      width: 50%;</span><br><span class=\"line\">      background-color: blue;</span><br><span class=\"line\">      margin-top: 25%;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &lt;/style&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">&lt;div class=&quot;f&quot;&gt;</span><br><span class=\"line\">  &lt;div class=&quot;c&quot;&gt;&lt;/div&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n\n<p>实际的效果</p>\n<img src=\"/.io//image-20211020224217218.png\" alt=\"image-20211020224217218\" style=\"zoom:50%;\">\n\n<p>预想的效果</p>\n<img src=\"/.io//image-20211020224237425.png\" alt=\"image-20211020224237425\" style=\"zoom:50%;\">\n\n\n\n<h2 id=\"有几种情况会产生外边距合并\"><a href=\"#有几种情况会产生外边距合并\" class=\"headerlink\" title=\"有几种情况会产生外边距合并\"></a>有几种情况会产生外边距合并</h2><h3 id=\"同一层相邻元素之间\"><a href=\"#同一层相邻元素之间\" class=\"headerlink\" title=\"同一层相邻元素之间\"></a><strong>同一层相邻元素之间</strong></h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">相邻的两个元素之间的外边距重叠，除非后一个元素加上clear-fix清除浮动。</span><br></pre></td></tr></table></figure>\n\n<p>​    相邻元素， 元素包含了，<code>块级元素</code>，<code>行内元素</code>，<code>行内块元素</code></p>\n<p>但是对于 <code>行内元素</code>来说，不能使用margin-top，来进行扩张。</p>\n<p>对于 <code>行内块元素</code>  来说，因为他造成了 BFC，所以，margin-top，没有了合并的效果。</p>\n<p>所以，最后还是使用了块级元素。</p>\n<h3 id=\"没有内容将父元素和后代元素分开\"><a href=\"#没有内容将父元素和后代元素分开\" class=\"headerlink\" title=\"没有内容将父元素和后代元素分开\"></a><strong>没有内容将父元素和后代元素分开</strong></h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">原话：</span><br><span class=\"line\">\t如果没有边框border，内边距padding，行内内容，也没有创建块级格式上下文或清除浮动来分开一个块级元素的上边界margin-top 与其内一个或多个后代块级元素的上边界margin-top；或没有边框，内边距，行内内容，高度height，最小高度min-height或 最大高度max-height 来分开一个块级元素的下边界margin-bottom与其内的一个或多个后代后代块元素的下边界margin-bottom，则就会出现父块元素和其内后代块元素外边界重叠，重叠部分最终会溢出到父级块元素外面。</span><br></pre></td></tr></table></figure>\n\n<p>这里的内容，包括了</p>\n<p><strong>第一部分：</strong></p>\n<p>​    <strong>边框：</strong>border    父元素使用，子元素使用并不会有效果。</p>\n<p>​    同理，<strong>内边距：</strong>padding，也是一样的。</p>\n<p>​    <strong>创建块级格式上下文：</strong>（BFC）我们后面再说：</p>\n<p>​    现在我就直接贴上　MDN　的 url</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Block_formatting_context</span><br></pre></td></tr></table></figure>\n\n<p>​    <strong>清除浮动：</strong>不知道是要进行什么操作的意思。不知道是不是对子元素进行一次浮动，然后再在父元素上进行清除浮动。</p>\n<p><strong>第二部分：</strong></p>\n<p>​    父元素没有定义高度，所以最终高度会由子元素进行定义，因此，对于 <code>margin-bottom</code> 下边界会造成合并的效果。，然后重叠部分会溢出到父元素的外面。</p>\n<h3 id=\"空的块级元素\"><a href=\"#空的块级元素\" class=\"headerlink\" title=\"空的块级元素\"></a><strong>空的块级元素</strong></h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">当一个块元素上边界margin-top 直接贴到元素下边界margin-bottom时也会发生边界折叠。这种情况会发生在一个块元素完全没有设定边框border、内边距padding、高度height、最小高度min-height 、最大高度max-height 、内容设定为inline或是加上clear-fix的时候。</span><br></pre></td></tr></table></figure>\n\n<p>简单来说，就是一个空的块级元素</p>\n<p>然后对其进行 上边距和下边距的 设置，最终的结果不会是两个相加，</p>\n<p>而是选择最大的。</p>\n<p>前提就是父元素不能设置</p>\n<p>​    border，padding，height，min-height， max-height， display：inline， 和 加上 clear-fix。</p>\n<p>对于最后一个clear-fix，有点没有理解清除，其他的还好， display：inline，就是设置成一个行内元素，因为是行内元素，所以外边距就没有效果了。其他的 border，padding，就是一些正常的解决合并问题的方法。</p>\n<p>对于空的块级元素，连续相邻的外边距也是会合并的。</p>\n<img src=\"/.io//image-20211021103824947.png\" alt=\"image-20211021103824947\" style=\"zoom:50%;\">\n\n\n\n<h3 id=\"注意：\"><a href=\"#注意：\" class=\"headerlink\" title=\"注意：\"></a>注意：</h3><ul>\n<li>一些情况的组合会产生更多复杂的外边距离收起。</li>\n<li>即使某些外边距为0，这些规则仍然适用。因此，父母元素的外边距是0，或最后一个外边距可能会“接触到第一个元素”到父母元素的外面。</li>\n<li>如果参与折叠的外边距中包含的负值，折叠后的外边距的值为最大的正边距和最大的负边距（即绝对值的最大负边距）和；如果有—— 13px 8px 100px 一叠，远景的技术就是100px -13px的87px。（有负有正，取最大最小相加）</li>\n<li>如果所有参与的户外边距都为负，折叠后的外边距的最大负边距值为多少。这个规则适用于户外元素和元素。 （全为负，取绝对值最大的。）</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">个人认为：</span><br><span class=\"line\">\t这样正负的判断，在修改边距的时候，有一个逐渐的过程，而不会出现突变情况。</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"解决外边距合并的办法\"><a href=\"#解决外边距合并的办法\" class=\"headerlink\" title=\"解决外边距合并的办法\"></a>解决外边距合并的办法</h2><p>首先一点：</p>\n<p>​    <strong>只有普通文档流中块框的垂直外边距才会发生外边距合并。行内框、浮动框或绝对定位之间的外边距不会合并。</strong></p>\n<p>行内块不会合并的原因是，他形成了BFC，块格式化上下文。</p>\n<p>其他两个是因为他们脱离了普通文档流。</p>\n<h3 id=\"解决兄弟元素的上下外边距合并\"><a href=\"#解决兄弟元素的上下外边距合并\" class=\"headerlink\" title=\"解决兄弟元素的上下外边距合并\"></a>解决兄弟元素的上下外边距合并</h3><h4 id=\"浮动\"><a href=\"#浮动\" class=\"headerlink\" title=\"浮动\"></a>浮动</h4><p>虽然浮动可以解决，但是因为是兄弟元素的外边距合并，有时会产生更多的问题。</p>\n<h3 id=\"行内块\"><a href=\"#行内块\" class=\"headerlink\" title=\"行内块\"></a>行内块</h3><p>行内块 display: inline-block;    感觉比上面的好处多了很多。</p>\n<h3 id=\"使用绝对定位\"><a href=\"#使用绝对定位\" class=\"headerlink\" title=\"使用绝对定位\"></a>使用绝对定位</h3><p>​        在这里我知道了一个小知识点，一般对绝对定位的时候都会直接加上 left，top，如果不加的话，那么就会相对于原来的位置不变。虽然也脱离了文档流，不占据的位置，但是从视觉上来说，他是解决了外边框合并的问题。</p>\n<p>​    但是如果父元素没有给定高度的话，那么将不会把这个高度计算在内。</p>\n<h3 id=\"对于父子元素的外边距合并\"><a href=\"#对于父子元素的外边距合并\" class=\"headerlink\" title=\"对于父子元素的外边距合并\"></a>对于父子元素的外边距合并</h3><h4 id=\"设置边框或内边距\"><a href=\"#设置边框或内边距\" class=\"headerlink\" title=\"设置边框或内边距\"></a>设置边框或内边距</h4><p>避免父子的外边距相邻</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">给父元素加上 border: 1px solid transparent;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">padding: 1px;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"设置浮动，绝对定位，行内块布局，和overflow\"><a href=\"#设置浮动，绝对定位，行内块布局，和overflow\" class=\"headerlink\" title=\"设置浮动，绝对定位，行内块布局，和overflow\"></a>设置浮动，绝对定位，行内块布局，和overflow</h4><p>这种的实现就是进行 BFC 块级格式化。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">float: left;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">position: absolute;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">display: inline-block;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">overflow: hidden;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">overflow: auto;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"对于空的块级元素\"><a href=\"#对于空的块级元素\" class=\"headerlink\" title=\"对于空的块级元素\"></a>对于空的块级元素</h3><h4 id=\"设置边框，边距，高度\"><a href=\"#设置边框，边距，高度\" class=\"headerlink\" title=\"设置边框，边距，高度\"></a>设置边框，边距，高度</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">border: 1px solid transparent;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">padding: 1px;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">height: 1px;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"块环境上下文\"><a href=\"#块环境上下文\" class=\"headerlink\" title=\"块环境上下文\"></a>块环境上下文</h4><p>比如 </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">display: inline-block;</span><br><span class=\"line\">overflow: hidden;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"外边距合并问题\"><a href=\"#外边距合并问题\" class=\"headerlink\" title=\"外边距合并问题\"></a>外边距合并问题</h1><h2 id=\"首先，什么是外边距合并\"><a href=\"#首先，什么是外边距合并\" class=\"headerlink\" title=\"首先，什么是外边距合并\"></a>首先，什么是外边距合并</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://www.w3school.com.cn/css/css_margin_collapse.asp</span><br><span class=\"line\">https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Box_Model/Mastering_margin_collapsing</span><br><span class=\"line\">https://www.w3.org/TR/CSS2/box.html#collapsing-margins</span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>外边距合并指的是，当两个垂直外边距相遇时，它们将形成一个外边距。</strong></p>\n<p><strong>合并后的外边距的高度等于两个发生合并的外边距的高度中的较大者。</strong></p>\n<p>简单来说，这个的效果就是，两个外边距并不是进行的相加的边距，而是取了其中的最大值</p>\n<p>一个简单的例子</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html lang=&quot;en&quot;&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">  &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class=\"line\">  &lt;title&gt;Title&lt;/title&gt;</span><br><span class=\"line\">  &lt;style&gt;</span><br><span class=\"line\">    * &#123;</span><br><span class=\"line\">      margin: 0;</span><br><span class=\"line\">      padding: 0;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    .f &#123;</span><br><span class=\"line\">      height: 400px;</span><br><span class=\"line\">      width: 800px;</span><br><span class=\"line\">      background-color: red;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    .c &#123;</span><br><span class=\"line\">      height: 50%;</span><br><span class=\"line\">      width: 50%;</span><br><span class=\"line\">      background-color: blue;</span><br><span class=\"line\">      margin-top: 25%;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &lt;/style&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">&lt;div class=&quot;f&quot;&gt;</span><br><span class=\"line\">  &lt;div class=&quot;c&quot;&gt;&lt;/div&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n\n<p>实际的效果</p>\n<img src=\"/.io//image-20211020224217218.png\" alt=\"image-20211020224217218\" style=\"zoom:50%;\">\n\n<p>预想的效果</p>\n<img src=\"/.io//image-20211020224237425.png\" alt=\"image-20211020224237425\" style=\"zoom:50%;\">\n\n\n\n<h2 id=\"有几种情况会产生外边距合并\"><a href=\"#有几种情况会产生外边距合并\" class=\"headerlink\" title=\"有几种情况会产生外边距合并\"></a>有几种情况会产生外边距合并</h2><h3 id=\"同一层相邻元素之间\"><a href=\"#同一层相邻元素之间\" class=\"headerlink\" title=\"同一层相邻元素之间\"></a><strong>同一层相邻元素之间</strong></h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">相邻的两个元素之间的外边距重叠，除非后一个元素加上clear-fix清除浮动。</span><br></pre></td></tr></table></figure>\n\n<p>​    相邻元素， 元素包含了，<code>块级元素</code>，<code>行内元素</code>，<code>行内块元素</code></p>\n<p>但是对于 <code>行内元素</code>来说，不能使用margin-top，来进行扩张。</p>\n<p>对于 <code>行内块元素</code>  来说，因为他造成了 BFC，所以，margin-top，没有了合并的效果。</p>\n<p>所以，最后还是使用了块级元素。</p>\n<h3 id=\"没有内容将父元素和后代元素分开\"><a href=\"#没有内容将父元素和后代元素分开\" class=\"headerlink\" title=\"没有内容将父元素和后代元素分开\"></a><strong>没有内容将父元素和后代元素分开</strong></h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">原话：</span><br><span class=\"line\">\t如果没有边框border，内边距padding，行内内容，也没有创建块级格式上下文或清除浮动来分开一个块级元素的上边界margin-top 与其内一个或多个后代块级元素的上边界margin-top；或没有边框，内边距，行内内容，高度height，最小高度min-height或 最大高度max-height 来分开一个块级元素的下边界margin-bottom与其内的一个或多个后代后代块元素的下边界margin-bottom，则就会出现父块元素和其内后代块元素外边界重叠，重叠部分最终会溢出到父级块元素外面。</span><br></pre></td></tr></table></figure>\n\n<p>这里的内容，包括了</p>\n<p><strong>第一部分：</strong></p>\n<p>​    <strong>边框：</strong>border    父元素使用，子元素使用并不会有效果。</p>\n<p>​    同理，<strong>内边距：</strong>padding，也是一样的。</p>\n<p>​    <strong>创建块级格式上下文：</strong>（BFC）我们后面再说：</p>\n<p>​    现在我就直接贴上　MDN　的 url</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Block_formatting_context</span><br></pre></td></tr></table></figure>\n\n<p>​    <strong>清除浮动：</strong>不知道是要进行什么操作的意思。不知道是不是对子元素进行一次浮动，然后再在父元素上进行清除浮动。</p>\n<p><strong>第二部分：</strong></p>\n<p>​    父元素没有定义高度，所以最终高度会由子元素进行定义，因此，对于 <code>margin-bottom</code> 下边界会造成合并的效果。，然后重叠部分会溢出到父元素的外面。</p>\n<h3 id=\"空的块级元素\"><a href=\"#空的块级元素\" class=\"headerlink\" title=\"空的块级元素\"></a><strong>空的块级元素</strong></h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">当一个块元素上边界margin-top 直接贴到元素下边界margin-bottom时也会发生边界折叠。这种情况会发生在一个块元素完全没有设定边框border、内边距padding、高度height、最小高度min-height 、最大高度max-height 、内容设定为inline或是加上clear-fix的时候。</span><br></pre></td></tr></table></figure>\n\n<p>简单来说，就是一个空的块级元素</p>\n<p>然后对其进行 上边距和下边距的 设置，最终的结果不会是两个相加，</p>\n<p>而是选择最大的。</p>\n<p>前提就是父元素不能设置</p>\n<p>​    border，padding，height，min-height， max-height， display：inline， 和 加上 clear-fix。</p>\n<p>对于最后一个clear-fix，有点没有理解清除，其他的还好， display：inline，就是设置成一个行内元素，因为是行内元素，所以外边距就没有效果了。其他的 border，padding，就是一些正常的解决合并问题的方法。</p>\n<p>对于空的块级元素，连续相邻的外边距也是会合并的。</p>\n<img src=\"/.io//image-20211021103824947.png\" alt=\"image-20211021103824947\" style=\"zoom:50%;\">\n\n\n\n<h3 id=\"注意：\"><a href=\"#注意：\" class=\"headerlink\" title=\"注意：\"></a>注意：</h3><ul>\n<li>一些情况的组合会产生更多复杂的外边距离收起。</li>\n<li>即使某些外边距为0，这些规则仍然适用。因此，父母元素的外边距是0，或最后一个外边距可能会“接触到第一个元素”到父母元素的外面。</li>\n<li>如果参与折叠的外边距中包含的负值，折叠后的外边距的值为最大的正边距和最大的负边距（即绝对值的最大负边距）和；如果有—— 13px 8px 100px 一叠，远景的技术就是100px -13px的87px。（有负有正，取最大最小相加）</li>\n<li>如果所有参与的户外边距都为负，折叠后的外边距的最大负边距值为多少。这个规则适用于户外元素和元素。 （全为负，取绝对值最大的。）</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">个人认为：</span><br><span class=\"line\">\t这样正负的判断，在修改边距的时候，有一个逐渐的过程，而不会出现突变情况。</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"解决外边距合并的办法\"><a href=\"#解决外边距合并的办法\" class=\"headerlink\" title=\"解决外边距合并的办法\"></a>解决外边距合并的办法</h2><p>首先一点：</p>\n<p>​    <strong>只有普通文档流中块框的垂直外边距才会发生外边距合并。行内框、浮动框或绝对定位之间的外边距不会合并。</strong></p>\n<p>行内块不会合并的原因是，他形成了BFC，块格式化上下文。</p>\n<p>其他两个是因为他们脱离了普通文档流。</p>\n<h3 id=\"解决兄弟元素的上下外边距合并\"><a href=\"#解决兄弟元素的上下外边距合并\" class=\"headerlink\" title=\"解决兄弟元素的上下外边距合并\"></a>解决兄弟元素的上下外边距合并</h3><h4 id=\"浮动\"><a href=\"#浮动\" class=\"headerlink\" title=\"浮动\"></a>浮动</h4><p>虽然浮动可以解决，但是因为是兄弟元素的外边距合并，有时会产生更多的问题。</p>\n<h3 id=\"行内块\"><a href=\"#行内块\" class=\"headerlink\" title=\"行内块\"></a>行内块</h3><p>行内块 display: inline-block;    感觉比上面的好处多了很多。</p>\n<h3 id=\"使用绝对定位\"><a href=\"#使用绝对定位\" class=\"headerlink\" title=\"使用绝对定位\"></a>使用绝对定位</h3><p>​        在这里我知道了一个小知识点，一般对绝对定位的时候都会直接加上 left，top，如果不加的话，那么就会相对于原来的位置不变。虽然也脱离了文档流，不占据的位置，但是从视觉上来说，他是解决了外边框合并的问题。</p>\n<p>​    但是如果父元素没有给定高度的话，那么将不会把这个高度计算在内。</p>\n<h3 id=\"对于父子元素的外边距合并\"><a href=\"#对于父子元素的外边距合并\" class=\"headerlink\" title=\"对于父子元素的外边距合并\"></a>对于父子元素的外边距合并</h3><h4 id=\"设置边框或内边距\"><a href=\"#设置边框或内边距\" class=\"headerlink\" title=\"设置边框或内边距\"></a>设置边框或内边距</h4><p>避免父子的外边距相邻</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">给父元素加上 border: 1px solid transparent;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">padding: 1px;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"设置浮动，绝对定位，行内块布局，和overflow\"><a href=\"#设置浮动，绝对定位，行内块布局，和overflow\" class=\"headerlink\" title=\"设置浮动，绝对定位，行内块布局，和overflow\"></a>设置浮动，绝对定位，行内块布局，和overflow</h4><p>这种的实现就是进行 BFC 块级格式化。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">float: left;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">position: absolute;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">display: inline-block;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">overflow: hidden;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">overflow: auto;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"对于空的块级元素\"><a href=\"#对于空的块级元素\" class=\"headerlink\" title=\"对于空的块级元素\"></a>对于空的块级元素</h3><h4 id=\"设置边框，边距，高度\"><a href=\"#设置边框，边距，高度\" class=\"headerlink\" title=\"设置边框，边距，高度\"></a>设置边框，边距，高度</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">border: 1px solid transparent;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">padding: 1px;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">height: 1px;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"块环境上下文\"><a href=\"#块环境上下文\" class=\"headerlink\" title=\"块环境上下文\"></a>块环境上下文</h4><p>比如 </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">display: inline-block;</span><br><span class=\"line\">overflow: hidden;</span><br></pre></td></tr></table></figure>\n\n"},{"title":"rem","date":"2021-10-16T06:14:53.000Z","_content":"\n\n\n MDN 参考\n\n```\nhttps://developer.mozilla.org/zh-CN/docs/Learn/CSS/Building_blocks/Values_and_units\n```\n\n\n\n# rem 和 em\n\n## em\n\n再说rem之前，先说一下em\n\n```\n\t在 font-size 中使用是相对于父元素的字体大小，在其他属性中使用是相对于自身的字体大小，如 width\n```\n\n## rem\n\n```\n\trem 就是 root em\n\t根元素的字体大小\n```\n\nrem是相对于根元素html的字号进行了等比例的计算。\n\nfor example\n\n```\nhtml { font-size: 16px; }\n\nohter { width: 300/16 rem; }\n```\n\n## rem使用方式\n\n​\t\t简单来说，就是从px转化成了一个rem，所以为了方便计算，常用的方式就是 1rem 转化成 10px 或者 100px。\n\n​\t\t所以对于一个 750px 的设计图，就将其除以 75或者7.5，` font-size=10px | 100px` \n\n\n\n# vh 和 vw\n\n简单来说就是相对于视窗宽度和高度的百分比，会计算出视窗的高度和宽度\n\n```\nvw：视窗宽度的1%\nvh：视窗高度的1%\n```\n\n如果将浏览器缩小了，对应的百分比值也会缩小。\n\n\n\n# vmin 和 vmax\n\n```\nvmin：视窗较小尺寸的1%\nvmax：视图大尺寸的1%\n```\n\n大致和上面的那个一样一个意思。\n\n\n\n# 百分比\n\n​\t\t百分比简单来说，就是相对于父级，但是对于边距是不一样的方式。\n\n```\n\t如果将元素的字体大小设置为百分比，那么它将是元素父元素字体大小的百分比。如果使用百分比作为宽度值，那么它将是父值宽度的百分比。\n```\n\n","source":"_posts/CSS/rem.md","raw":"---\ntitle: rem\ndate: 2021-10-16 14:14:53\ntags: \n - CSS\n - 长度单位\ncategories:\n - CSS\n---\n\n\n\n MDN 参考\n\n```\nhttps://developer.mozilla.org/zh-CN/docs/Learn/CSS/Building_blocks/Values_and_units\n```\n\n\n\n# rem 和 em\n\n## em\n\n再说rem之前，先说一下em\n\n```\n\t在 font-size 中使用是相对于父元素的字体大小，在其他属性中使用是相对于自身的字体大小，如 width\n```\n\n## rem\n\n```\n\trem 就是 root em\n\t根元素的字体大小\n```\n\nrem是相对于根元素html的字号进行了等比例的计算。\n\nfor example\n\n```\nhtml { font-size: 16px; }\n\nohter { width: 300/16 rem; }\n```\n\n## rem使用方式\n\n​\t\t简单来说，就是从px转化成了一个rem，所以为了方便计算，常用的方式就是 1rem 转化成 10px 或者 100px。\n\n​\t\t所以对于一个 750px 的设计图，就将其除以 75或者7.5，` font-size=10px | 100px` \n\n\n\n# vh 和 vw\n\n简单来说就是相对于视窗宽度和高度的百分比，会计算出视窗的高度和宽度\n\n```\nvw：视窗宽度的1%\nvh：视窗高度的1%\n```\n\n如果将浏览器缩小了，对应的百分比值也会缩小。\n\n\n\n# vmin 和 vmax\n\n```\nvmin：视窗较小尺寸的1%\nvmax：视图大尺寸的1%\n```\n\n大致和上面的那个一样一个意思。\n\n\n\n# 百分比\n\n​\t\t百分比简单来说，就是相对于父级，但是对于边距是不一样的方式。\n\n```\n\t如果将元素的字体大小设置为百分比，那么它将是元素父元素字体大小的百分比。如果使用百分比作为宽度值，那么它将是父值宽度的百分比。\n```\n\n","slug":"CSS/rem","published":1,"updated":"2021-12-09T01:56:49.388Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckznhkk7k002cikub7q6idg9h","content":"<p> MDN 参考</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://developer.mozilla.org/zh-CN/docs/Learn/CSS/Building_blocks/Values_and_units</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"rem-和-em\"><a href=\"#rem-和-em\" class=\"headerlink\" title=\"rem 和 em\"></a>rem 和 em</h1><h2 id=\"em\"><a href=\"#em\" class=\"headerlink\" title=\"em\"></a>em</h2><p>再说rem之前，先说一下em</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">在 font-size 中使用是相对于父元素的字体大小，在其他属性中使用是相对于自身的字体大小，如 width</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"rem\"><a href=\"#rem\" class=\"headerlink\" title=\"rem\"></a>rem</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rem 就是 root em</span><br><span class=\"line\">根元素的字体大小</span><br></pre></td></tr></table></figure>\n\n<p>rem是相对于根元素html的字号进行了等比例的计算。</p>\n<p>for example</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">html &#123; font-size: 16px; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">ohter &#123; width: 300/16 rem; &#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"rem使用方式\"><a href=\"#rem使用方式\" class=\"headerlink\" title=\"rem使用方式\"></a>rem使用方式</h2><p>​        简单来说，就是从px转化成了一个rem，所以为了方便计算，常用的方式就是 1rem 转化成 10px 或者 100px。</p>\n<p>​        所以对于一个 750px 的设计图，就将其除以 75或者7.5，<code> font-size=10px | 100px</code> </p>\n<h1 id=\"vh-和-vw\"><a href=\"#vh-和-vw\" class=\"headerlink\" title=\"vh 和 vw\"></a>vh 和 vw</h1><p>简单来说就是相对于视窗宽度和高度的百分比，会计算出视窗的高度和宽度</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vw：视窗宽度的1%</span><br><span class=\"line\">vh：视窗高度的1%</span><br></pre></td></tr></table></figure>\n\n<p>如果将浏览器缩小了，对应的百分比值也会缩小。</p>\n<h1 id=\"vmin-和-vmax\"><a href=\"#vmin-和-vmax\" class=\"headerlink\" title=\"vmin 和 vmax\"></a>vmin 和 vmax</h1><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vmin：视窗较小尺寸的1%</span><br><span class=\"line\">vmax：视图大尺寸的1%</span><br></pre></td></tr></table></figure>\n\n<p>大致和上面的那个一样一个意思。</p>\n<h1 id=\"百分比\"><a href=\"#百分比\" class=\"headerlink\" title=\"百分比\"></a>百分比</h1><p>​        百分比简单来说，就是相对于父级，但是对于边距是不一样的方式。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">如果将元素的字体大小设置为百分比，那么它将是元素父元素字体大小的百分比。如果使用百分比作为宽度值，那么它将是父值宽度的百分比。</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<p> MDN 参考</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://developer.mozilla.org/zh-CN/docs/Learn/CSS/Building_blocks/Values_and_units</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"rem-和-em\"><a href=\"#rem-和-em\" class=\"headerlink\" title=\"rem 和 em\"></a>rem 和 em</h1><h2 id=\"em\"><a href=\"#em\" class=\"headerlink\" title=\"em\"></a>em</h2><p>再说rem之前，先说一下em</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">在 font-size 中使用是相对于父元素的字体大小，在其他属性中使用是相对于自身的字体大小，如 width</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"rem\"><a href=\"#rem\" class=\"headerlink\" title=\"rem\"></a>rem</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rem 就是 root em</span><br><span class=\"line\">根元素的字体大小</span><br></pre></td></tr></table></figure>\n\n<p>rem是相对于根元素html的字号进行了等比例的计算。</p>\n<p>for example</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">html &#123; font-size: 16px; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">ohter &#123; width: 300/16 rem; &#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"rem使用方式\"><a href=\"#rem使用方式\" class=\"headerlink\" title=\"rem使用方式\"></a>rem使用方式</h2><p>​        简单来说，就是从px转化成了一个rem，所以为了方便计算，常用的方式就是 1rem 转化成 10px 或者 100px。</p>\n<p>​        所以对于一个 750px 的设计图，就将其除以 75或者7.5，<code> font-size=10px | 100px</code> </p>\n<h1 id=\"vh-和-vw\"><a href=\"#vh-和-vw\" class=\"headerlink\" title=\"vh 和 vw\"></a>vh 和 vw</h1><p>简单来说就是相对于视窗宽度和高度的百分比，会计算出视窗的高度和宽度</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vw：视窗宽度的1%</span><br><span class=\"line\">vh：视窗高度的1%</span><br></pre></td></tr></table></figure>\n\n<p>如果将浏览器缩小了，对应的百分比值也会缩小。</p>\n<h1 id=\"vmin-和-vmax\"><a href=\"#vmin-和-vmax\" class=\"headerlink\" title=\"vmin 和 vmax\"></a>vmin 和 vmax</h1><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vmin：视窗较小尺寸的1%</span><br><span class=\"line\">vmax：视图大尺寸的1%</span><br></pre></td></tr></table></figure>\n\n<p>大致和上面的那个一样一个意思。</p>\n<h1 id=\"百分比\"><a href=\"#百分比\" class=\"headerlink\" title=\"百分比\"></a>百分比</h1><p>​        百分比简单来说，就是相对于父级，但是对于边距是不一样的方式。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">如果将元素的字体大小设置为百分比，那么它将是元素父元素字体大小的百分比。如果使用百分比作为宽度值，那么它将是父值宽度的百分比。</span><br></pre></td></tr></table></figure>\n\n"},{"title":"CSS-元素选择器","date":"2021-10-25T11:51:58.000Z","_content":"\n\n\n#  CSS-元素选择器\n\n\n\n## 相邻兄弟选择器\n\n```\nhttps://developer.mozilla.org/zh-CN/docs/Web/CSS/Adjacent_sibling_combinator\n```\n\n​\t\t**相邻兄弟选择器** (`+`) 介于两个选择器之间，当第二个元素*紧跟在*第一个元素之后，并且两个元素都是属于同一个父`元素`的子元素，则第二个元素将被选中。\n\n**注：**\n\n​\t第一，要相邻之后的，不相邻的，在前面的不管。 \n\n​\t只会选择一个，就算第二个元素有多个满足，只会选择最开始的一个。\n\n​\t但是对于第一个元素就可以有很多个。\n\n```\n.f + .b {\n\t...\n}\n```\n\n\n\n## 属性选择器\n\n```\nhttps://developer.mozilla.org/zh-CN/docs/Web/CSS/Attribute_selectors\n```\n\n​\t\tCSS **属性选择器**通过已经存在的属性名或属性值匹配元素。\n\n选择存在这个属性的元素，这个属性不一定要含有意义，也不一定有值\n\n```\ndiv[cc] {\n\t...\n}\n\n存在cc，但是cc是一个没有意义的属性，也可以被选中。\n<div class=\"b\" cc>1</div>\n```\n\n\n\n### 属性选择器值的匹配\n\n```\n存在属性cc，并且值为xxx\n[cc='xxx']\n\n<div class=\"b\" cc=\"xxx\">1</div>\n```\n\n```\n存在属性cc，并且值包含了xx\ncc *= 'xx'\n\n<div class=\"b\" cc=\"111xxasf\">1</div>\n```\n\n```\n存在属性cc，并且该属性是一个以空格作为分隔的值列表，其中至少有一个值为 xx。\ncc ~= 'xx'\n\n<div class=\"b\" cc=\"111 xx asf\">1</div>\n```\n\n```\n存在属性cc，并且属性值为“xx”或是以“xx-”为前缀\ncc |= 'xx'\n\n<div class=\"b\" cc=\"xx-asf\">1</div>\n```\n\n```\n存在属性cc，并且属性值是以 xx 开头的元素。\ncc ^= 'xx'\n\n<div class=\"b\" cc=\"xxasf\">1</div>\n```\n\n```\n存在属性cc，并且属性值是以 xx 结尾的元素。\ncc $= 'xx'\n\n<div class=\"b\" cc=\"awwxx\">1</div>\n```\n\n```\n存在属性cc，并且属性值是以 xx 结尾的元素。\ncc $= 'xx'\n\n<div class=\"b\" cc=\"awwxx\">1</div>\n```\n\n```\n在属性选择器右方括号前加 i用空格隔开，表示忽略大小写\n[cc $= 'xx' i]\n\ndiv[cc $= 'xx' i] {\n\t...\n}\n```\n\n```\n同上，使用 s，表示区分大小写\n```\n\n\n\n## 子选择器\n\n```\nhttps://developer.mozilla.org/zh-CN/docs/Web/CSS/Child_combinator\n```\n\n​\t\t当使用  `>` 选择符分隔两个元素时,它只会匹配那些作为第一个元素的**直接后代(**子元素)的第二元素. \n\n**重点是 直接后代，而不是孙子代**\n\n```\nele1 > ele2 {\n\t...\n}\n```\n\n\n\n## 类选择器\n\n```\nhttps://developer.mozilla.org/zh-CN/docs/Web/CSS/Class_selectors\n```\n\n​\t\t在一个HTML文档中，CSS类选择器会根据元素的类属性中的内容匹配元素。类属性被定义为一个以空格分隔的列表项，在这组类名中，必须有一项与类选择器中的类名完全匹配，此条样式声明才会生效。\n\n​\t简单来说，就是class的属性，值是以空格进行的分割，需要其中一个值满足类选择器的属性值，才能有作用。\n\n\n\n```\n.class { ... }\n\n他和属性选择器的具有相同的作用。\n[class ~= 'class'] { ... }\n```\n\n\n\n## 后代选择器\n\n```\nhttps://developer.mozilla.org/zh-CN/docs/Web/CSS/Descendant_combinator\n```\n\n​\t\t**后代组合器**（通常用单个空格（` `）字符表示）组合了两个选择器，如果第二个选择器匹配的元素具有与第一个选择器匹配的祖先（父母，父母的父母，父母的父母的父母等）元素，则它们将被选择。利用后代组合器的选择器称为后代选择器。\n\n​\t简单来说，就是，第二个元素是第一个元素的后代，但是可以不是直接后代。\n\n```\n.a .c { ... }\n\n<div class=\"a\">\n  <div>\n    <div class=\"c\"></div>\n  </div>\n</div>\n如同上面这样，a存在后代c，但是不是直接后代，可以使用后代选择器(` `), 而不能使用子选择器(`>`)\n```\n\n\n\n## 通用兄弟选择器\n\n```\nhttps://developer.mozilla.org/zh-CN/docs/Web/CSS/General_sibling_combinator\n```\n\n​\t\t兄弟选择符，位置无须紧邻，只须同层级，`A~B` 选择`A`元素之后所有同层级`B`元素。\n\n```\nele1 ~ ele2 { ... }\n```\n\n\n\n## ID 选择器\n\n```\nhttps://developer.mozilla.org/zh-CN/docs/Web/CSS/ID_selectors\n```\n\n​\t\tCSS ID 选择器会根据该元素的 ID 属性中的内容匹配元素,元素 ID 属性名必须与选择器中的 ID 属性名完全匹配，此条样式声明才会生效。\n\n**注：**\n\n​\t一般一个html里面，一个id只能一个，如果有多个，那么这个就会选中多个。\n\n​\tid属性的值只有一个，不像使用class属性那样，可以有空格划分\n\n``` \n#id { ... }\n\n同属性选择器的\n[id=value] { ... }\n```\n\n\n\n## 选择器列表\n\n选择器分组\n\n​\t\tCSS **选择器列表**（`,`），常被称为并集选择器或并集组合器，选择所有能被列表中的任意一个选择器选中的节点。\n\n```\nh1,\n#id,\n.class,\n.a > span {\n\t...\n}\n```\n\n**注意点：**\n\n​\t\t选择器列表无效化，说的是当一个选择器不被支持，就会出现整条规则全部失效，我这里看了一个人写的，[出现无效的伪选择器](https://www.xinran001.com/frontend/248.html) 他的说明是如果是一个伪选择器无效的话，就会出现这个问题。但是如果是一个选择器的写法满足一个浏览器的cssom的构建，那么就不会出现这个问题。\n\n​\t\t\t解决这个问题的一个方法是使用 [`:is()`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/:is) 选择器，它会忽视它的参数列表中失效的选择器，但是由于 [`:is()`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/:is) 会影响优先级的计算方式，这么做的代价是，其中的所有选择器都会拥有相同的优先级。\n\n\n\n## 元素选择器\n\n```\nhttps://developer.mozilla.org/zh-CN/docs/Web/CSS/Type_selectors\n```\n\n​\t\tCSS元素选择器(也称为类型选择器)通过node节点名称匹配元素.\n\n```\nele { ... }\n\nspan { ... }\n```\n\n\n\n## 通配选择器\n\n```\nhttps://developer.mozilla.org/zh-CN/docs/Web/CSS/Universal_selectors\n```\n\n​\t\t在CSS中,一个星号(`*`)就是一个通配选择器.它可以匹配任意类型的HTML元素\n\n```\n* { ... }\n```\n\n​\t\tCSS3里面，*可以和命名空间搭配使用，命名空间，我现在也没有了解，我们后面在学。\n\n```\nns|* - 会匹配ns命名空间下的所有元素\n*|* - 会匹配所有命名空间下的所有元素\n|* - 会匹配所有没有命名空间的元素\n```\n\n\n\n## 伪类选择器\n\n```\nhttps://developer.mozilla.org/zh-CN/docs/Web/CSS/Pseudo-classes\n```\n\n### 常用的\n\n**active**\n\n```\na:active \n可以代表按下按键和松开按键。常用于按钮和链接\n```\n\n**focus**\n\n```\n获得焦点时\n```\n\n**hover**\n\n```\n鼠标放在上面时触发\n```\n\nMDN上有个描述\n\n```\n\t:hover CSS伪类适用于用户使用指示设备虚指一个元素（没有激活它）的情况。这个样式会被任何与链接相关的伪类重写，像:link, :visited, 和 :active等。为了确保生效，:hover规则需要放在:link和:visited规则之后，但是在:active规则之前，按照LVHA的循顺序声明:link－:visited－:hover－:active。\n\t\n\t大致意思就是说， link会覆盖掉其他的样式，如果写在后面，其他的样式不会显示出来。\n```\n\n**link**\n\n```\n\t应该只能用于 a 标签，我使用span标签没有成功\n\t:link伪类选择器是用来选中元素当中的链接，所有未访问的链接（如果定义了visited伪元素），但是如果没有定义visited伪元素的话，那么就会将所有链接都选中，不管是不是访问过的。\n\t对于一个链接是否访问过，应该是通过href的值来进行的判断。\n\t因为link会覆盖其他伪元素的样式，所以书写顺序是：\n\t\t:link — :visited — :hover — :active。:focus伪类选择器常伴随在:hover伪类选择器左右，需要根据你想要实现的效果确定它们的顺序。\n```\n\n\n\n**disabled**\n\n```\n表示被禁用的元素\n```\n\n**enabled**\n\n```\n没有被禁用的元素\n```\n\n\n\n**invalid**\n\n```\n:invalid CSS 伪类 表示任意内容未通过验证的 <input> 或其他 <form> 元素 .\n```\n\n**valid**\n\n```\n:valid CSS 伪类表示内容验证正确的<input> 或其他 <form> 元素。这能简单地将校验字段展示为一种能让用户辨别出其输入数据的正确性的样式。\n\n验证正确的展示\n```\n\n**optional**\n\n```\n:optional\n表示 任意没有 required 属性的  <input>，<select> 或  <textarea> 元素\n```\n\n**required**\n\n```\n:required\n表示设置了 required 属性的 <input>，<select> 或  <textarea> 元素\n```\n\n**read-only**\n\n```\n:read-only\n\t选中其中元素不可被用户编辑的状态\n与之对应的\n\tread-write\n```\n\n\n\n**first-child**\n\n```\n一组兄弟元素中的第一个元素。\n\np:first-child，代表的是p的第一个\n```\n\n**last-child**\n\n```\n一组兄弟元素中的最后一个元素。\n```\n\n**not**\n\n```\n反选\n\n:not(p)\n不要p标签的\n```\n\n**nth-child**\n\n```\n\t:nth-child(an+b) 这个 CSS 伪类首先找到所有当前元素的兄弟元素，然后按照位置先后顺序从1开始排序，选择的结果为CSS伪类:nth-child括号中表达式（an+b）匹配到的元素集合（n=0，1，2，3...）。\n\t\n\t简单来说，:nth-child(an+b)，其中 an+b 的值的范围是 1~n，超过范围的不会显示，虽然 an+b 的范围是 1~n，但是n的范围却是 0~，因为我们使用 n+1 可以发现，每个都还是有，说明了这个事实。\n\t\n\t几个特殊值：使用后，不要再加n和b了\n\t\todd，奇数行\n\t\teven，偶数行\n```\n\n**注意：**\n\n​\t不能写成 b+an 的形式，只能是 an+b\n\n​\t可以使用减号，`-`, 但是要注意一个问题，就是n的取值，貌似不是从 0~n，而是从0开始，不知道最终值是多少，所以对于 :nth-child(n-10)，还是会全部显示，但是使用 :nth-child(2n - 1)，就会发现不同。\n\n​\t所以一般要找前面n个，都是使用的 `-n+b`。\n\n​\t第二个不能使用n  2n-n，没有效果。\n\n\n\n**nth-last-child**\n\n​\t从兄弟节点中从后往前匹配处于某些位置的元素\n\n**注意:** 这个伪类和 [`:nth-child`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/:nth-child) 基本一致, 但它是从*结尾*计数, 而不是从开始计数.\n\n\n\n**only-child**\n\n```\n匹配没有任何兄弟的元素\n\n.b\n\t.c\n\t.c\n.b\n\t.c\n\t\n\t类似于上面的，不是通过 .b:only-child，因为在同层中，.b没有只存在一个的情况，使用 .c:only-child 就能找到。\n\n\t等效的选择器还可以写成 :first-child:last-child或者:nth-child(1):nth-last-child(1),当然,前者的权重会低一点.\n```\n\n\n\n**root**\n\n```\n\t:root 这个 CSS 伪类匹配文档树的根元素。对于 HTML 来说，:root 表示 <html> 元素，除了优先级更高之外，与 html 选择器相同。\n```\n\n**target**\n\n```\n对目标元素的id进行一个匹配，当url中出现了这个id时显示，url的构造形式类似于vue-router 的hash模式\n\n<div id=\"12\"></div>\n\ndiv:target { } \n当url为 http://xxxx#12 时，这里面的效果就会展示出来\n```\n\n\n\n# 选择器优先级\n\n```\nhttps://developer.mozilla.org/zh-CN/docs/Web/CSS/Specificity\n```\n\n简单来说，\n\n**!important > 行内样式>ID选择器 > 类选择器 > 标签 > 通配符 > 继承 > 浏览器默认属性**\n\n\n\n我们是使用的权重方式进行的判断优先级\n\n**内联的权重是：1 0 0 0**\n\n**id的权重是 1 0 0**\n\n**class的权重是 1 0**\n\n**标签的权重是 1**\n\n**注意：**\n\n​\t权重是不会进位的，不会因为有11个class，就可以超过id","source":"_posts/CSS/CSS-元素选择器.md","raw":"---\ntitle: CSS-元素选择器\ndate: 2021-10-25 19:51:58\ntags:\n - CSS\n - 元素选择器\ncategories:\n - CSS\n---\n\n\n\n#  CSS-元素选择器\n\n\n\n## 相邻兄弟选择器\n\n```\nhttps://developer.mozilla.org/zh-CN/docs/Web/CSS/Adjacent_sibling_combinator\n```\n\n​\t\t**相邻兄弟选择器** (`+`) 介于两个选择器之间，当第二个元素*紧跟在*第一个元素之后，并且两个元素都是属于同一个父`元素`的子元素，则第二个元素将被选中。\n\n**注：**\n\n​\t第一，要相邻之后的，不相邻的，在前面的不管。 \n\n​\t只会选择一个，就算第二个元素有多个满足，只会选择最开始的一个。\n\n​\t但是对于第一个元素就可以有很多个。\n\n```\n.f + .b {\n\t...\n}\n```\n\n\n\n## 属性选择器\n\n```\nhttps://developer.mozilla.org/zh-CN/docs/Web/CSS/Attribute_selectors\n```\n\n​\t\tCSS **属性选择器**通过已经存在的属性名或属性值匹配元素。\n\n选择存在这个属性的元素，这个属性不一定要含有意义，也不一定有值\n\n```\ndiv[cc] {\n\t...\n}\n\n存在cc，但是cc是一个没有意义的属性，也可以被选中。\n<div class=\"b\" cc>1</div>\n```\n\n\n\n### 属性选择器值的匹配\n\n```\n存在属性cc，并且值为xxx\n[cc='xxx']\n\n<div class=\"b\" cc=\"xxx\">1</div>\n```\n\n```\n存在属性cc，并且值包含了xx\ncc *= 'xx'\n\n<div class=\"b\" cc=\"111xxasf\">1</div>\n```\n\n```\n存在属性cc，并且该属性是一个以空格作为分隔的值列表，其中至少有一个值为 xx。\ncc ~= 'xx'\n\n<div class=\"b\" cc=\"111 xx asf\">1</div>\n```\n\n```\n存在属性cc，并且属性值为“xx”或是以“xx-”为前缀\ncc |= 'xx'\n\n<div class=\"b\" cc=\"xx-asf\">1</div>\n```\n\n```\n存在属性cc，并且属性值是以 xx 开头的元素。\ncc ^= 'xx'\n\n<div class=\"b\" cc=\"xxasf\">1</div>\n```\n\n```\n存在属性cc，并且属性值是以 xx 结尾的元素。\ncc $= 'xx'\n\n<div class=\"b\" cc=\"awwxx\">1</div>\n```\n\n```\n存在属性cc，并且属性值是以 xx 结尾的元素。\ncc $= 'xx'\n\n<div class=\"b\" cc=\"awwxx\">1</div>\n```\n\n```\n在属性选择器右方括号前加 i用空格隔开，表示忽略大小写\n[cc $= 'xx' i]\n\ndiv[cc $= 'xx' i] {\n\t...\n}\n```\n\n```\n同上，使用 s，表示区分大小写\n```\n\n\n\n## 子选择器\n\n```\nhttps://developer.mozilla.org/zh-CN/docs/Web/CSS/Child_combinator\n```\n\n​\t\t当使用  `>` 选择符分隔两个元素时,它只会匹配那些作为第一个元素的**直接后代(**子元素)的第二元素. \n\n**重点是 直接后代，而不是孙子代**\n\n```\nele1 > ele2 {\n\t...\n}\n```\n\n\n\n## 类选择器\n\n```\nhttps://developer.mozilla.org/zh-CN/docs/Web/CSS/Class_selectors\n```\n\n​\t\t在一个HTML文档中，CSS类选择器会根据元素的类属性中的内容匹配元素。类属性被定义为一个以空格分隔的列表项，在这组类名中，必须有一项与类选择器中的类名完全匹配，此条样式声明才会生效。\n\n​\t简单来说，就是class的属性，值是以空格进行的分割，需要其中一个值满足类选择器的属性值，才能有作用。\n\n\n\n```\n.class { ... }\n\n他和属性选择器的具有相同的作用。\n[class ~= 'class'] { ... }\n```\n\n\n\n## 后代选择器\n\n```\nhttps://developer.mozilla.org/zh-CN/docs/Web/CSS/Descendant_combinator\n```\n\n​\t\t**后代组合器**（通常用单个空格（` `）字符表示）组合了两个选择器，如果第二个选择器匹配的元素具有与第一个选择器匹配的祖先（父母，父母的父母，父母的父母的父母等）元素，则它们将被选择。利用后代组合器的选择器称为后代选择器。\n\n​\t简单来说，就是，第二个元素是第一个元素的后代，但是可以不是直接后代。\n\n```\n.a .c { ... }\n\n<div class=\"a\">\n  <div>\n    <div class=\"c\"></div>\n  </div>\n</div>\n如同上面这样，a存在后代c，但是不是直接后代，可以使用后代选择器(` `), 而不能使用子选择器(`>`)\n```\n\n\n\n## 通用兄弟选择器\n\n```\nhttps://developer.mozilla.org/zh-CN/docs/Web/CSS/General_sibling_combinator\n```\n\n​\t\t兄弟选择符，位置无须紧邻，只须同层级，`A~B` 选择`A`元素之后所有同层级`B`元素。\n\n```\nele1 ~ ele2 { ... }\n```\n\n\n\n## ID 选择器\n\n```\nhttps://developer.mozilla.org/zh-CN/docs/Web/CSS/ID_selectors\n```\n\n​\t\tCSS ID 选择器会根据该元素的 ID 属性中的内容匹配元素,元素 ID 属性名必须与选择器中的 ID 属性名完全匹配，此条样式声明才会生效。\n\n**注：**\n\n​\t一般一个html里面，一个id只能一个，如果有多个，那么这个就会选中多个。\n\n​\tid属性的值只有一个，不像使用class属性那样，可以有空格划分\n\n``` \n#id { ... }\n\n同属性选择器的\n[id=value] { ... }\n```\n\n\n\n## 选择器列表\n\n选择器分组\n\n​\t\tCSS **选择器列表**（`,`），常被称为并集选择器或并集组合器，选择所有能被列表中的任意一个选择器选中的节点。\n\n```\nh1,\n#id,\n.class,\n.a > span {\n\t...\n}\n```\n\n**注意点：**\n\n​\t\t选择器列表无效化，说的是当一个选择器不被支持，就会出现整条规则全部失效，我这里看了一个人写的，[出现无效的伪选择器](https://www.xinran001.com/frontend/248.html) 他的说明是如果是一个伪选择器无效的话，就会出现这个问题。但是如果是一个选择器的写法满足一个浏览器的cssom的构建，那么就不会出现这个问题。\n\n​\t\t\t解决这个问题的一个方法是使用 [`:is()`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/:is) 选择器，它会忽视它的参数列表中失效的选择器，但是由于 [`:is()`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/:is) 会影响优先级的计算方式，这么做的代价是，其中的所有选择器都会拥有相同的优先级。\n\n\n\n## 元素选择器\n\n```\nhttps://developer.mozilla.org/zh-CN/docs/Web/CSS/Type_selectors\n```\n\n​\t\tCSS元素选择器(也称为类型选择器)通过node节点名称匹配元素.\n\n```\nele { ... }\n\nspan { ... }\n```\n\n\n\n## 通配选择器\n\n```\nhttps://developer.mozilla.org/zh-CN/docs/Web/CSS/Universal_selectors\n```\n\n​\t\t在CSS中,一个星号(`*`)就是一个通配选择器.它可以匹配任意类型的HTML元素\n\n```\n* { ... }\n```\n\n​\t\tCSS3里面，*可以和命名空间搭配使用，命名空间，我现在也没有了解，我们后面在学。\n\n```\nns|* - 会匹配ns命名空间下的所有元素\n*|* - 会匹配所有命名空间下的所有元素\n|* - 会匹配所有没有命名空间的元素\n```\n\n\n\n## 伪类选择器\n\n```\nhttps://developer.mozilla.org/zh-CN/docs/Web/CSS/Pseudo-classes\n```\n\n### 常用的\n\n**active**\n\n```\na:active \n可以代表按下按键和松开按键。常用于按钮和链接\n```\n\n**focus**\n\n```\n获得焦点时\n```\n\n**hover**\n\n```\n鼠标放在上面时触发\n```\n\nMDN上有个描述\n\n```\n\t:hover CSS伪类适用于用户使用指示设备虚指一个元素（没有激活它）的情况。这个样式会被任何与链接相关的伪类重写，像:link, :visited, 和 :active等。为了确保生效，:hover规则需要放在:link和:visited规则之后，但是在:active规则之前，按照LVHA的循顺序声明:link－:visited－:hover－:active。\n\t\n\t大致意思就是说， link会覆盖掉其他的样式，如果写在后面，其他的样式不会显示出来。\n```\n\n**link**\n\n```\n\t应该只能用于 a 标签，我使用span标签没有成功\n\t:link伪类选择器是用来选中元素当中的链接，所有未访问的链接（如果定义了visited伪元素），但是如果没有定义visited伪元素的话，那么就会将所有链接都选中，不管是不是访问过的。\n\t对于一个链接是否访问过，应该是通过href的值来进行的判断。\n\t因为link会覆盖其他伪元素的样式，所以书写顺序是：\n\t\t:link — :visited — :hover — :active。:focus伪类选择器常伴随在:hover伪类选择器左右，需要根据你想要实现的效果确定它们的顺序。\n```\n\n\n\n**disabled**\n\n```\n表示被禁用的元素\n```\n\n**enabled**\n\n```\n没有被禁用的元素\n```\n\n\n\n**invalid**\n\n```\n:invalid CSS 伪类 表示任意内容未通过验证的 <input> 或其他 <form> 元素 .\n```\n\n**valid**\n\n```\n:valid CSS 伪类表示内容验证正确的<input> 或其他 <form> 元素。这能简单地将校验字段展示为一种能让用户辨别出其输入数据的正确性的样式。\n\n验证正确的展示\n```\n\n**optional**\n\n```\n:optional\n表示 任意没有 required 属性的  <input>，<select> 或  <textarea> 元素\n```\n\n**required**\n\n```\n:required\n表示设置了 required 属性的 <input>，<select> 或  <textarea> 元素\n```\n\n**read-only**\n\n```\n:read-only\n\t选中其中元素不可被用户编辑的状态\n与之对应的\n\tread-write\n```\n\n\n\n**first-child**\n\n```\n一组兄弟元素中的第一个元素。\n\np:first-child，代表的是p的第一个\n```\n\n**last-child**\n\n```\n一组兄弟元素中的最后一个元素。\n```\n\n**not**\n\n```\n反选\n\n:not(p)\n不要p标签的\n```\n\n**nth-child**\n\n```\n\t:nth-child(an+b) 这个 CSS 伪类首先找到所有当前元素的兄弟元素，然后按照位置先后顺序从1开始排序，选择的结果为CSS伪类:nth-child括号中表达式（an+b）匹配到的元素集合（n=0，1，2，3...）。\n\t\n\t简单来说，:nth-child(an+b)，其中 an+b 的值的范围是 1~n，超过范围的不会显示，虽然 an+b 的范围是 1~n，但是n的范围却是 0~，因为我们使用 n+1 可以发现，每个都还是有，说明了这个事实。\n\t\n\t几个特殊值：使用后，不要再加n和b了\n\t\todd，奇数行\n\t\teven，偶数行\n```\n\n**注意：**\n\n​\t不能写成 b+an 的形式，只能是 an+b\n\n​\t可以使用减号，`-`, 但是要注意一个问题，就是n的取值，貌似不是从 0~n，而是从0开始，不知道最终值是多少，所以对于 :nth-child(n-10)，还是会全部显示，但是使用 :nth-child(2n - 1)，就会发现不同。\n\n​\t所以一般要找前面n个，都是使用的 `-n+b`。\n\n​\t第二个不能使用n  2n-n，没有效果。\n\n\n\n**nth-last-child**\n\n​\t从兄弟节点中从后往前匹配处于某些位置的元素\n\n**注意:** 这个伪类和 [`:nth-child`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/:nth-child) 基本一致, 但它是从*结尾*计数, 而不是从开始计数.\n\n\n\n**only-child**\n\n```\n匹配没有任何兄弟的元素\n\n.b\n\t.c\n\t.c\n.b\n\t.c\n\t\n\t类似于上面的，不是通过 .b:only-child，因为在同层中，.b没有只存在一个的情况，使用 .c:only-child 就能找到。\n\n\t等效的选择器还可以写成 :first-child:last-child或者:nth-child(1):nth-last-child(1),当然,前者的权重会低一点.\n```\n\n\n\n**root**\n\n```\n\t:root 这个 CSS 伪类匹配文档树的根元素。对于 HTML 来说，:root 表示 <html> 元素，除了优先级更高之外，与 html 选择器相同。\n```\n\n**target**\n\n```\n对目标元素的id进行一个匹配，当url中出现了这个id时显示，url的构造形式类似于vue-router 的hash模式\n\n<div id=\"12\"></div>\n\ndiv:target { } \n当url为 http://xxxx#12 时，这里面的效果就会展示出来\n```\n\n\n\n# 选择器优先级\n\n```\nhttps://developer.mozilla.org/zh-CN/docs/Web/CSS/Specificity\n```\n\n简单来说，\n\n**!important > 行内样式>ID选择器 > 类选择器 > 标签 > 通配符 > 继承 > 浏览器默认属性**\n\n\n\n我们是使用的权重方式进行的判断优先级\n\n**内联的权重是：1 0 0 0**\n\n**id的权重是 1 0 0**\n\n**class的权重是 1 0**\n\n**标签的权重是 1**\n\n**注意：**\n\n​\t权重是不会进位的，不会因为有11个class，就可以超过id","slug":"CSS/CSS-元素选择器","published":1,"updated":"2021-12-09T01:56:49.388Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckznhkk7l002eikuba9fvg9es","content":"<h1 id=\"CSS-元素选择器\"><a href=\"#CSS-元素选择器\" class=\"headerlink\" title=\"CSS-元素选择器\"></a>CSS-元素选择器</h1><h2 id=\"相邻兄弟选择器\"><a href=\"#相邻兄弟选择器\" class=\"headerlink\" title=\"相邻兄弟选择器\"></a>相邻兄弟选择器</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://developer.mozilla.org/zh-CN/docs/Web/CSS/Adjacent_sibling_combinator</span><br></pre></td></tr></table></figure>\n\n<p>​        <strong>相邻兄弟选择器</strong> (<code>+</code>) 介于两个选择器之间，当第二个元素<em>紧跟在</em>第一个元素之后，并且两个元素都是属于同一个父<code>元素</code>的子元素，则第二个元素将被选中。</p>\n<p><strong>注：</strong></p>\n<p>​    第一，要相邻之后的，不相邻的，在前面的不管。 </p>\n<p>​    只会选择一个，就算第二个元素有多个满足，只会选择最开始的一个。</p>\n<p>​    但是对于第一个元素就可以有很多个。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.f + .b &#123;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"属性选择器\"><a href=\"#属性选择器\" class=\"headerlink\" title=\"属性选择器\"></a>属性选择器</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://developer.mozilla.org/zh-CN/docs/Web/CSS/Attribute_selectors</span><br></pre></td></tr></table></figure>\n\n<p>​        CSS <strong>属性选择器</strong>通过已经存在的属性名或属性值匹配元素。</p>\n<p>选择存在这个属性的元素，这个属性不一定要含有意义，也不一定有值</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">div[cc] &#123;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">存在cc，但是cc是一个没有意义的属性，也可以被选中。</span><br><span class=\"line\">&lt;div class=&quot;b&quot; cc&gt;1&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"属性选择器值的匹配\"><a href=\"#属性选择器值的匹配\" class=\"headerlink\" title=\"属性选择器值的匹配\"></a>属性选择器值的匹配</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">存在属性cc，并且值为xxx</span><br><span class=\"line\">[cc=&#x27;xxx&#x27;]</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;div class=&quot;b&quot; cc=&quot;xxx&quot;&gt;1&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">存在属性cc，并且值包含了xx</span><br><span class=\"line\">cc *= &#x27;xx&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;div class=&quot;b&quot; cc=&quot;111xxasf&quot;&gt;1&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">存在属性cc，并且该属性是一个以空格作为分隔的值列表，其中至少有一个值为 xx。</span><br><span class=\"line\">cc ~= &#x27;xx&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;div class=&quot;b&quot; cc=&quot;111 xx asf&quot;&gt;1&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">存在属性cc，并且属性值为“xx”或是以“xx-”为前缀</span><br><span class=\"line\">cc |= &#x27;xx&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;div class=&quot;b&quot; cc=&quot;xx-asf&quot;&gt;1&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">存在属性cc，并且属性值是以 xx 开头的元素。</span><br><span class=\"line\">cc ^= &#x27;xx&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;div class=&quot;b&quot; cc=&quot;xxasf&quot;&gt;1&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">存在属性cc，并且属性值是以 xx 结尾的元素。</span><br><span class=\"line\">cc $= &#x27;xx&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;div class=&quot;b&quot; cc=&quot;awwxx&quot;&gt;1&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">存在属性cc，并且属性值是以 xx 结尾的元素。</span><br><span class=\"line\">cc $= &#x27;xx&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;div class=&quot;b&quot; cc=&quot;awwxx&quot;&gt;1&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">在属性选择器右方括号前加 i用空格隔开，表示忽略大小写</span><br><span class=\"line\">[cc $= &#x27;xx&#x27; i]</span><br><span class=\"line\"></span><br><span class=\"line\">div[cc $= &#x27;xx&#x27; i] &#123;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">同上，使用 s，表示区分大小写</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"子选择器\"><a href=\"#子选择器\" class=\"headerlink\" title=\"子选择器\"></a>子选择器</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://developer.mozilla.org/zh-CN/docs/Web/CSS/Child_combinator</span><br></pre></td></tr></table></figure>\n\n<p>​        当使用  <code>&gt;</code> 选择符分隔两个元素时,它只会匹配那些作为第一个元素的**直接后代(**子元素)的第二元素. </p>\n<p><strong>重点是 直接后代，而不是孙子代</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ele1 &gt; ele2 &#123;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"类选择器\"><a href=\"#类选择器\" class=\"headerlink\" title=\"类选择器\"></a>类选择器</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://developer.mozilla.org/zh-CN/docs/Web/CSS/Class_selectors</span><br></pre></td></tr></table></figure>\n\n<p>​        在一个HTML文档中，CSS类选择器会根据元素的类属性中的内容匹配元素。类属性被定义为一个以空格分隔的列表项，在这组类名中，必须有一项与类选择器中的类名完全匹配，此条样式声明才会生效。</p>\n<p>​    简单来说，就是class的属性，值是以空格进行的分割，需要其中一个值满足类选择器的属性值，才能有作用。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.class &#123; ... &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">他和属性选择器的具有相同的作用。</span><br><span class=\"line\">[class ~= &#x27;class&#x27;] &#123; ... &#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"后代选择器\"><a href=\"#后代选择器\" class=\"headerlink\" title=\"后代选择器\"></a>后代选择器</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://developer.mozilla.org/zh-CN/docs/Web/CSS/Descendant_combinator</span><br></pre></td></tr></table></figure>\n\n<p>​        <strong>后代组合器</strong>（通常用单个空格（<code> </code>）字符表示）组合了两个选择器，如果第二个选择器匹配的元素具有与第一个选择器匹配的祖先（父母，父母的父母，父母的父母的父母等）元素，则它们将被选择。利用后代组合器的选择器称为后代选择器。</p>\n<p>​    简单来说，就是，第二个元素是第一个元素的后代，但是可以不是直接后代。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.a .c &#123; ... &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;div class=&quot;a&quot;&gt;</span><br><span class=\"line\">  &lt;div&gt;</span><br><span class=\"line\">    &lt;div class=&quot;c&quot;&gt;&lt;/div&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">如同上面这样，a存在后代c，但是不是直接后代，可以使用后代选择器(` `), 而不能使用子选择器(`&gt;`)</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"通用兄弟选择器\"><a href=\"#通用兄弟选择器\" class=\"headerlink\" title=\"通用兄弟选择器\"></a>通用兄弟选择器</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://developer.mozilla.org/zh-CN/docs/Web/CSS/General_sibling_combinator</span><br></pre></td></tr></table></figure>\n\n<p>​        兄弟选择符，位置无须紧邻，只须同层级，<code>A~B</code> 选择<code>A</code>元素之后所有同层级<code>B</code>元素。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ele1 ~ ele2 &#123; ... &#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"ID-选择器\"><a href=\"#ID-选择器\" class=\"headerlink\" title=\"ID 选择器\"></a>ID 选择器</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://developer.mozilla.org/zh-CN/docs/Web/CSS/ID_selectors</span><br></pre></td></tr></table></figure>\n\n<p>​        CSS ID 选择器会根据该元素的 ID 属性中的内容匹配元素,元素 ID 属性名必须与选择器中的 ID 属性名完全匹配，此条样式声明才会生效。</p>\n<p><strong>注：</strong></p>\n<p>​    一般一个html里面，一个id只能一个，如果有多个，那么这个就会选中多个。</p>\n<p>​    id属性的值只有一个，不像使用class属性那样，可以有空格划分</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#id &#123; ... &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">同属性选择器的</span><br><span class=\"line\">[id=value] &#123; ... &#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"选择器列表\"><a href=\"#选择器列表\" class=\"headerlink\" title=\"选择器列表\"></a>选择器列表</h2><p>选择器分组</p>\n<p>​        CSS <strong>选择器列表</strong>（<code>,</code>），常被称为并集选择器或并集组合器，选择所有能被列表中的任意一个选择器选中的节点。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">h1,</span><br><span class=\"line\">#id,</span><br><span class=\"line\">.class,</span><br><span class=\"line\">.a &gt; span &#123;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>注意点：</strong></p>\n<p>​        选择器列表无效化，说的是当一个选择器不被支持，就会出现整条规则全部失效，我这里看了一个人写的，<a href=\"https://www.xinran001.com/frontend/248.html\">出现无效的伪选择器</a> 他的说明是如果是一个伪选择器无效的话，就会出现这个问题。但是如果是一个选择器的写法满足一个浏览器的cssom的构建，那么就不会出现这个问题。</p>\n<p>​            解决这个问题的一个方法是使用 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/CSS/:is\"><code>:is()</code></a> 选择器，它会忽视它的参数列表中失效的选择器，但是由于 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/CSS/:is\"><code>:is()</code></a> 会影响优先级的计算方式，这么做的代价是，其中的所有选择器都会拥有相同的优先级。</p>\n<h2 id=\"元素选择器\"><a href=\"#元素选择器\" class=\"headerlink\" title=\"元素选择器\"></a>元素选择器</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://developer.mozilla.org/zh-CN/docs/Web/CSS/Type_selectors</span><br></pre></td></tr></table></figure>\n\n<p>​        CSS元素选择器(也称为类型选择器)通过node节点名称匹配元素.</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ele &#123; ... &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">span &#123; ... &#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"通配选择器\"><a href=\"#通配选择器\" class=\"headerlink\" title=\"通配选择器\"></a>通配选择器</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://developer.mozilla.org/zh-CN/docs/Web/CSS/Universal_selectors</span><br></pre></td></tr></table></figure>\n\n<p>​        在CSS中,一个星号(<code>*</code>)就是一个通配选择器.它可以匹配任意类型的HTML元素</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">* &#123; ... &#125;</span><br></pre></td></tr></table></figure>\n\n<p>​        CSS3里面，*可以和命名空间搭配使用，命名空间，我现在也没有了解，我们后面在学。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ns|* - 会匹配ns命名空间下的所有元素</span><br><span class=\"line\">*|* - 会匹配所有命名空间下的所有元素</span><br><span class=\"line\">|* - 会匹配所有没有命名空间的元素</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"伪类选择器\"><a href=\"#伪类选择器\" class=\"headerlink\" title=\"伪类选择器\"></a>伪类选择器</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://developer.mozilla.org/zh-CN/docs/Web/CSS/Pseudo-classes</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"常用的\"><a href=\"#常用的\" class=\"headerlink\" title=\"常用的\"></a>常用的</h3><p><strong>active</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a:active </span><br><span class=\"line\">可以代表按下按键和松开按键。常用于按钮和链接</span><br></pre></td></tr></table></figure>\n\n<p><strong>focus</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">获得焦点时</span><br></pre></td></tr></table></figure>\n\n<p><strong>hover</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">鼠标放在上面时触发</span><br></pre></td></tr></table></figure>\n\n<p>MDN上有个描述</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:hover CSS伪类适用于用户使用指示设备虚指一个元素（没有激活它）的情况。这个样式会被任何与链接相关的伪类重写，像:link, :visited, 和 :active等。为了确保生效，:hover规则需要放在:link和:visited规则之后，但是在:active规则之前，按照LVHA的循顺序声明:link－:visited－:hover－:active。</span><br><span class=\"line\"></span><br><span class=\"line\">大致意思就是说， link会覆盖掉其他的样式，如果写在后面，其他的样式不会显示出来。</span><br></pre></td></tr></table></figure>\n\n<p><strong>link</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">应该只能用于 a 标签，我使用span标签没有成功</span><br><span class=\"line\">:link伪类选择器是用来选中元素当中的链接，所有未访问的链接（如果定义了visited伪元素），但是如果没有定义visited伪元素的话，那么就会将所有链接都选中，不管是不是访问过的。</span><br><span class=\"line\">对于一个链接是否访问过，应该是通过href的值来进行的判断。</span><br><span class=\"line\">因为link会覆盖其他伪元素的样式，所以书写顺序是：</span><br><span class=\"line\">\t:link — :visited — :hover — :active。:focus伪类选择器常伴随在:hover伪类选择器左右，需要根据你想要实现的效果确定它们的顺序。</span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>disabled</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">表示被禁用的元素</span><br></pre></td></tr></table></figure>\n\n<p><strong>enabled</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">没有被禁用的元素</span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>invalid</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:invalid CSS 伪类 表示任意内容未通过验证的 &lt;input&gt; 或其他 &lt;form&gt; 元素 .</span><br></pre></td></tr></table></figure>\n\n<p><strong>valid</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:valid CSS 伪类表示内容验证正确的&lt;input&gt; 或其他 &lt;form&gt; 元素。这能简单地将校验字段展示为一种能让用户辨别出其输入数据的正确性的样式。</span><br><span class=\"line\"></span><br><span class=\"line\">验证正确的展示</span><br></pre></td></tr></table></figure>\n\n<p><strong>optional</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:optional</span><br><span class=\"line\">表示 任意没有 required 属性的  &lt;input&gt;，&lt;select&gt; 或  &lt;textarea&gt; 元素</span><br></pre></td></tr></table></figure>\n\n<p><strong>required</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:required</span><br><span class=\"line\">表示设置了 required 属性的 &lt;input&gt;，&lt;select&gt; 或  &lt;textarea&gt; 元素</span><br></pre></td></tr></table></figure>\n\n<p><strong>read-only</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:read-only</span><br><span class=\"line\">\t选中其中元素不可被用户编辑的状态</span><br><span class=\"line\">与之对应的</span><br><span class=\"line\">\tread-write</span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>first-child</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">一组兄弟元素中的第一个元素。</span><br><span class=\"line\"></span><br><span class=\"line\">p:first-child，代表的是p的第一个</span><br></pre></td></tr></table></figure>\n\n<p><strong>last-child</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">一组兄弟元素中的最后一个元素。</span><br></pre></td></tr></table></figure>\n\n<p><strong>not</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">反选</span><br><span class=\"line\"></span><br><span class=\"line\">:not(p)</span><br><span class=\"line\">不要p标签的</span><br></pre></td></tr></table></figure>\n\n<p><strong>nth-child</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:nth-child(an+b) 这个 CSS 伪类首先找到所有当前元素的兄弟元素，然后按照位置先后顺序从1开始排序，选择的结果为CSS伪类:nth-child括号中表达式（an+b）匹配到的元素集合（n=0，1，2，3...）。</span><br><span class=\"line\"></span><br><span class=\"line\">简单来说，:nth-child(an+b)，其中 an+b 的值的范围是 1~n，超过范围的不会显示，虽然 an+b 的范围是 1~n，但是n的范围却是 0~，因为我们使用 n+1 可以发现，每个都还是有，说明了这个事实。</span><br><span class=\"line\"></span><br><span class=\"line\">几个特殊值：使用后，不要再加n和b了</span><br><span class=\"line\">\todd，奇数行</span><br><span class=\"line\">\teven，偶数行</span><br></pre></td></tr></table></figure>\n\n<p><strong>注意：</strong></p>\n<p>​    不能写成 b+an 的形式，只能是 an+b</p>\n<p>​    可以使用减号，<code>-</code>, 但是要注意一个问题，就是n的取值，貌似不是从 0~n，而是从0开始，不知道最终值是多少，所以对于 :nth-child(n-10)，还是会全部显示，但是使用 :nth-child(2n - 1)，就会发现不同。</p>\n<p>​    所以一般要找前面n个，都是使用的 <code>-n+b</code>。</p>\n<p>​    第二个不能使用n  2n-n，没有效果。</p>\n<p><strong>nth-last-child</strong></p>\n<p>​    从兄弟节点中从后往前匹配处于某些位置的元素</p>\n<p><strong>注意:</strong> 这个伪类和 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/CSS/:nth-child\"><code>:nth-child</code></a> 基本一致, 但它是从<em>结尾</em>计数, 而不是从开始计数.</p>\n<p><strong>only-child</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">匹配没有任何兄弟的元素</span><br><span class=\"line\"></span><br><span class=\"line\">.b</span><br><span class=\"line\">\t.c</span><br><span class=\"line\">\t.c</span><br><span class=\"line\">.b</span><br><span class=\"line\">\t.c</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t类似于上面的，不是通过 .b:only-child，因为在同层中，.b没有只存在一个的情况，使用 .c:only-child 就能找到。</span><br><span class=\"line\"></span><br><span class=\"line\">\t等效的选择器还可以写成 :first-child:last-child或者:nth-child(1):nth-last-child(1),当然,前者的权重会低一点.</span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>root</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:root 这个 CSS 伪类匹配文档树的根元素。对于 HTML 来说，:root 表示 &lt;html&gt; 元素，除了优先级更高之外，与 html 选择器相同。</span><br></pre></td></tr></table></figure>\n\n<p><strong>target</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">对目标元素的id进行一个匹配，当url中出现了这个id时显示，url的构造形式类似于vue-router 的hash模式</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;div id=&quot;12&quot;&gt;&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">div:target &#123; &#125; </span><br><span class=\"line\">当url为 http://xxxx#12 时，这里面的效果就会展示出来</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"选择器优先级\"><a href=\"#选择器优先级\" class=\"headerlink\" title=\"选择器优先级\"></a>选择器优先级</h1><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://developer.mozilla.org/zh-CN/docs/Web/CSS/Specificity</span><br></pre></td></tr></table></figure>\n\n<p>简单来说，</p>\n<p><strong>!important &gt; 行内样式&gt;ID选择器 &gt; 类选择器 &gt; 标签 &gt; 通配符 &gt; 继承 &gt; 浏览器默认属性</strong></p>\n<p>我们是使用的权重方式进行的判断优先级</p>\n<p><strong>内联的权重是：1 0 0 0</strong></p>\n<p><strong>id的权重是 1 0 0</strong></p>\n<p><strong>class的权重是 1 0</strong></p>\n<p><strong>标签的权重是 1</strong></p>\n<p><strong>注意：</strong></p>\n<p>​    权重是不会进位的，不会因为有11个class，就可以超过id</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"CSS-元素选择器\"><a href=\"#CSS-元素选择器\" class=\"headerlink\" title=\"CSS-元素选择器\"></a>CSS-元素选择器</h1><h2 id=\"相邻兄弟选择器\"><a href=\"#相邻兄弟选择器\" class=\"headerlink\" title=\"相邻兄弟选择器\"></a>相邻兄弟选择器</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://developer.mozilla.org/zh-CN/docs/Web/CSS/Adjacent_sibling_combinator</span><br></pre></td></tr></table></figure>\n\n<p>​        <strong>相邻兄弟选择器</strong> (<code>+</code>) 介于两个选择器之间，当第二个元素<em>紧跟在</em>第一个元素之后，并且两个元素都是属于同一个父<code>元素</code>的子元素，则第二个元素将被选中。</p>\n<p><strong>注：</strong></p>\n<p>​    第一，要相邻之后的，不相邻的，在前面的不管。 </p>\n<p>​    只会选择一个，就算第二个元素有多个满足，只会选择最开始的一个。</p>\n<p>​    但是对于第一个元素就可以有很多个。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.f + .b &#123;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"属性选择器\"><a href=\"#属性选择器\" class=\"headerlink\" title=\"属性选择器\"></a>属性选择器</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://developer.mozilla.org/zh-CN/docs/Web/CSS/Attribute_selectors</span><br></pre></td></tr></table></figure>\n\n<p>​        CSS <strong>属性选择器</strong>通过已经存在的属性名或属性值匹配元素。</p>\n<p>选择存在这个属性的元素，这个属性不一定要含有意义，也不一定有值</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">div[cc] &#123;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">存在cc，但是cc是一个没有意义的属性，也可以被选中。</span><br><span class=\"line\">&lt;div class=&quot;b&quot; cc&gt;1&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"属性选择器值的匹配\"><a href=\"#属性选择器值的匹配\" class=\"headerlink\" title=\"属性选择器值的匹配\"></a>属性选择器值的匹配</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">存在属性cc，并且值为xxx</span><br><span class=\"line\">[cc=&#x27;xxx&#x27;]</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;div class=&quot;b&quot; cc=&quot;xxx&quot;&gt;1&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">存在属性cc，并且值包含了xx</span><br><span class=\"line\">cc *= &#x27;xx&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;div class=&quot;b&quot; cc=&quot;111xxasf&quot;&gt;1&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">存在属性cc，并且该属性是一个以空格作为分隔的值列表，其中至少有一个值为 xx。</span><br><span class=\"line\">cc ~= &#x27;xx&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;div class=&quot;b&quot; cc=&quot;111 xx asf&quot;&gt;1&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">存在属性cc，并且属性值为“xx”或是以“xx-”为前缀</span><br><span class=\"line\">cc |= &#x27;xx&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;div class=&quot;b&quot; cc=&quot;xx-asf&quot;&gt;1&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">存在属性cc，并且属性值是以 xx 开头的元素。</span><br><span class=\"line\">cc ^= &#x27;xx&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;div class=&quot;b&quot; cc=&quot;xxasf&quot;&gt;1&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">存在属性cc，并且属性值是以 xx 结尾的元素。</span><br><span class=\"line\">cc $= &#x27;xx&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;div class=&quot;b&quot; cc=&quot;awwxx&quot;&gt;1&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">存在属性cc，并且属性值是以 xx 结尾的元素。</span><br><span class=\"line\">cc $= &#x27;xx&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;div class=&quot;b&quot; cc=&quot;awwxx&quot;&gt;1&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">在属性选择器右方括号前加 i用空格隔开，表示忽略大小写</span><br><span class=\"line\">[cc $= &#x27;xx&#x27; i]</span><br><span class=\"line\"></span><br><span class=\"line\">div[cc $= &#x27;xx&#x27; i] &#123;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">同上，使用 s，表示区分大小写</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"子选择器\"><a href=\"#子选择器\" class=\"headerlink\" title=\"子选择器\"></a>子选择器</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://developer.mozilla.org/zh-CN/docs/Web/CSS/Child_combinator</span><br></pre></td></tr></table></figure>\n\n<p>​        当使用  <code>&gt;</code> 选择符分隔两个元素时,它只会匹配那些作为第一个元素的**直接后代(**子元素)的第二元素. </p>\n<p><strong>重点是 直接后代，而不是孙子代</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ele1 &gt; ele2 &#123;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"类选择器\"><a href=\"#类选择器\" class=\"headerlink\" title=\"类选择器\"></a>类选择器</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://developer.mozilla.org/zh-CN/docs/Web/CSS/Class_selectors</span><br></pre></td></tr></table></figure>\n\n<p>​        在一个HTML文档中，CSS类选择器会根据元素的类属性中的内容匹配元素。类属性被定义为一个以空格分隔的列表项，在这组类名中，必须有一项与类选择器中的类名完全匹配，此条样式声明才会生效。</p>\n<p>​    简单来说，就是class的属性，值是以空格进行的分割，需要其中一个值满足类选择器的属性值，才能有作用。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.class &#123; ... &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">他和属性选择器的具有相同的作用。</span><br><span class=\"line\">[class ~= &#x27;class&#x27;] &#123; ... &#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"后代选择器\"><a href=\"#后代选择器\" class=\"headerlink\" title=\"后代选择器\"></a>后代选择器</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://developer.mozilla.org/zh-CN/docs/Web/CSS/Descendant_combinator</span><br></pre></td></tr></table></figure>\n\n<p>​        <strong>后代组合器</strong>（通常用单个空格（<code> </code>）字符表示）组合了两个选择器，如果第二个选择器匹配的元素具有与第一个选择器匹配的祖先（父母，父母的父母，父母的父母的父母等）元素，则它们将被选择。利用后代组合器的选择器称为后代选择器。</p>\n<p>​    简单来说，就是，第二个元素是第一个元素的后代，但是可以不是直接后代。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.a .c &#123; ... &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;div class=&quot;a&quot;&gt;</span><br><span class=\"line\">  &lt;div&gt;</span><br><span class=\"line\">    &lt;div class=&quot;c&quot;&gt;&lt;/div&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">如同上面这样，a存在后代c，但是不是直接后代，可以使用后代选择器(` `), 而不能使用子选择器(`&gt;`)</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"通用兄弟选择器\"><a href=\"#通用兄弟选择器\" class=\"headerlink\" title=\"通用兄弟选择器\"></a>通用兄弟选择器</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://developer.mozilla.org/zh-CN/docs/Web/CSS/General_sibling_combinator</span><br></pre></td></tr></table></figure>\n\n<p>​        兄弟选择符，位置无须紧邻，只须同层级，<code>A~B</code> 选择<code>A</code>元素之后所有同层级<code>B</code>元素。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ele1 ~ ele2 &#123; ... &#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"ID-选择器\"><a href=\"#ID-选择器\" class=\"headerlink\" title=\"ID 选择器\"></a>ID 选择器</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://developer.mozilla.org/zh-CN/docs/Web/CSS/ID_selectors</span><br></pre></td></tr></table></figure>\n\n<p>​        CSS ID 选择器会根据该元素的 ID 属性中的内容匹配元素,元素 ID 属性名必须与选择器中的 ID 属性名完全匹配，此条样式声明才会生效。</p>\n<p><strong>注：</strong></p>\n<p>​    一般一个html里面，一个id只能一个，如果有多个，那么这个就会选中多个。</p>\n<p>​    id属性的值只有一个，不像使用class属性那样，可以有空格划分</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#id &#123; ... &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">同属性选择器的</span><br><span class=\"line\">[id=value] &#123; ... &#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"选择器列表\"><a href=\"#选择器列表\" class=\"headerlink\" title=\"选择器列表\"></a>选择器列表</h2><p>选择器分组</p>\n<p>​        CSS <strong>选择器列表</strong>（<code>,</code>），常被称为并集选择器或并集组合器，选择所有能被列表中的任意一个选择器选中的节点。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">h1,</span><br><span class=\"line\">#id,</span><br><span class=\"line\">.class,</span><br><span class=\"line\">.a &gt; span &#123;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>注意点：</strong></p>\n<p>​        选择器列表无效化，说的是当一个选择器不被支持，就会出现整条规则全部失效，我这里看了一个人写的，<a href=\"https://www.xinran001.com/frontend/248.html\">出现无效的伪选择器</a> 他的说明是如果是一个伪选择器无效的话，就会出现这个问题。但是如果是一个选择器的写法满足一个浏览器的cssom的构建，那么就不会出现这个问题。</p>\n<p>​            解决这个问题的一个方法是使用 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/CSS/:is\"><code>:is()</code></a> 选择器，它会忽视它的参数列表中失效的选择器，但是由于 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/CSS/:is\"><code>:is()</code></a> 会影响优先级的计算方式，这么做的代价是，其中的所有选择器都会拥有相同的优先级。</p>\n<h2 id=\"元素选择器\"><a href=\"#元素选择器\" class=\"headerlink\" title=\"元素选择器\"></a>元素选择器</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://developer.mozilla.org/zh-CN/docs/Web/CSS/Type_selectors</span><br></pre></td></tr></table></figure>\n\n<p>​        CSS元素选择器(也称为类型选择器)通过node节点名称匹配元素.</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ele &#123; ... &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">span &#123; ... &#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"通配选择器\"><a href=\"#通配选择器\" class=\"headerlink\" title=\"通配选择器\"></a>通配选择器</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://developer.mozilla.org/zh-CN/docs/Web/CSS/Universal_selectors</span><br></pre></td></tr></table></figure>\n\n<p>​        在CSS中,一个星号(<code>*</code>)就是一个通配选择器.它可以匹配任意类型的HTML元素</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">* &#123; ... &#125;</span><br></pre></td></tr></table></figure>\n\n<p>​        CSS3里面，*可以和命名空间搭配使用，命名空间，我现在也没有了解，我们后面在学。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ns|* - 会匹配ns命名空间下的所有元素</span><br><span class=\"line\">*|* - 会匹配所有命名空间下的所有元素</span><br><span class=\"line\">|* - 会匹配所有没有命名空间的元素</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"伪类选择器\"><a href=\"#伪类选择器\" class=\"headerlink\" title=\"伪类选择器\"></a>伪类选择器</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://developer.mozilla.org/zh-CN/docs/Web/CSS/Pseudo-classes</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"常用的\"><a href=\"#常用的\" class=\"headerlink\" title=\"常用的\"></a>常用的</h3><p><strong>active</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a:active </span><br><span class=\"line\">可以代表按下按键和松开按键。常用于按钮和链接</span><br></pre></td></tr></table></figure>\n\n<p><strong>focus</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">获得焦点时</span><br></pre></td></tr></table></figure>\n\n<p><strong>hover</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">鼠标放在上面时触发</span><br></pre></td></tr></table></figure>\n\n<p>MDN上有个描述</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:hover CSS伪类适用于用户使用指示设备虚指一个元素（没有激活它）的情况。这个样式会被任何与链接相关的伪类重写，像:link, :visited, 和 :active等。为了确保生效，:hover规则需要放在:link和:visited规则之后，但是在:active规则之前，按照LVHA的循顺序声明:link－:visited－:hover－:active。</span><br><span class=\"line\"></span><br><span class=\"line\">大致意思就是说， link会覆盖掉其他的样式，如果写在后面，其他的样式不会显示出来。</span><br></pre></td></tr></table></figure>\n\n<p><strong>link</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">应该只能用于 a 标签，我使用span标签没有成功</span><br><span class=\"line\">:link伪类选择器是用来选中元素当中的链接，所有未访问的链接（如果定义了visited伪元素），但是如果没有定义visited伪元素的话，那么就会将所有链接都选中，不管是不是访问过的。</span><br><span class=\"line\">对于一个链接是否访问过，应该是通过href的值来进行的判断。</span><br><span class=\"line\">因为link会覆盖其他伪元素的样式，所以书写顺序是：</span><br><span class=\"line\">\t:link — :visited — :hover — :active。:focus伪类选择器常伴随在:hover伪类选择器左右，需要根据你想要实现的效果确定它们的顺序。</span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>disabled</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">表示被禁用的元素</span><br></pre></td></tr></table></figure>\n\n<p><strong>enabled</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">没有被禁用的元素</span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>invalid</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:invalid CSS 伪类 表示任意内容未通过验证的 &lt;input&gt; 或其他 &lt;form&gt; 元素 .</span><br></pre></td></tr></table></figure>\n\n<p><strong>valid</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:valid CSS 伪类表示内容验证正确的&lt;input&gt; 或其他 &lt;form&gt; 元素。这能简单地将校验字段展示为一种能让用户辨别出其输入数据的正确性的样式。</span><br><span class=\"line\"></span><br><span class=\"line\">验证正确的展示</span><br></pre></td></tr></table></figure>\n\n<p><strong>optional</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:optional</span><br><span class=\"line\">表示 任意没有 required 属性的  &lt;input&gt;，&lt;select&gt; 或  &lt;textarea&gt; 元素</span><br></pre></td></tr></table></figure>\n\n<p><strong>required</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:required</span><br><span class=\"line\">表示设置了 required 属性的 &lt;input&gt;，&lt;select&gt; 或  &lt;textarea&gt; 元素</span><br></pre></td></tr></table></figure>\n\n<p><strong>read-only</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:read-only</span><br><span class=\"line\">\t选中其中元素不可被用户编辑的状态</span><br><span class=\"line\">与之对应的</span><br><span class=\"line\">\tread-write</span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>first-child</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">一组兄弟元素中的第一个元素。</span><br><span class=\"line\"></span><br><span class=\"line\">p:first-child，代表的是p的第一个</span><br></pre></td></tr></table></figure>\n\n<p><strong>last-child</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">一组兄弟元素中的最后一个元素。</span><br></pre></td></tr></table></figure>\n\n<p><strong>not</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">反选</span><br><span class=\"line\"></span><br><span class=\"line\">:not(p)</span><br><span class=\"line\">不要p标签的</span><br></pre></td></tr></table></figure>\n\n<p><strong>nth-child</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:nth-child(an+b) 这个 CSS 伪类首先找到所有当前元素的兄弟元素，然后按照位置先后顺序从1开始排序，选择的结果为CSS伪类:nth-child括号中表达式（an+b）匹配到的元素集合（n=0，1，2，3...）。</span><br><span class=\"line\"></span><br><span class=\"line\">简单来说，:nth-child(an+b)，其中 an+b 的值的范围是 1~n，超过范围的不会显示，虽然 an+b 的范围是 1~n，但是n的范围却是 0~，因为我们使用 n+1 可以发现，每个都还是有，说明了这个事实。</span><br><span class=\"line\"></span><br><span class=\"line\">几个特殊值：使用后，不要再加n和b了</span><br><span class=\"line\">\todd，奇数行</span><br><span class=\"line\">\teven，偶数行</span><br></pre></td></tr></table></figure>\n\n<p><strong>注意：</strong></p>\n<p>​    不能写成 b+an 的形式，只能是 an+b</p>\n<p>​    可以使用减号，<code>-</code>, 但是要注意一个问题，就是n的取值，貌似不是从 0~n，而是从0开始，不知道最终值是多少，所以对于 :nth-child(n-10)，还是会全部显示，但是使用 :nth-child(2n - 1)，就会发现不同。</p>\n<p>​    所以一般要找前面n个，都是使用的 <code>-n+b</code>。</p>\n<p>​    第二个不能使用n  2n-n，没有效果。</p>\n<p><strong>nth-last-child</strong></p>\n<p>​    从兄弟节点中从后往前匹配处于某些位置的元素</p>\n<p><strong>注意:</strong> 这个伪类和 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/CSS/:nth-child\"><code>:nth-child</code></a> 基本一致, 但它是从<em>结尾</em>计数, 而不是从开始计数.</p>\n<p><strong>only-child</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">匹配没有任何兄弟的元素</span><br><span class=\"line\"></span><br><span class=\"line\">.b</span><br><span class=\"line\">\t.c</span><br><span class=\"line\">\t.c</span><br><span class=\"line\">.b</span><br><span class=\"line\">\t.c</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t类似于上面的，不是通过 .b:only-child，因为在同层中，.b没有只存在一个的情况，使用 .c:only-child 就能找到。</span><br><span class=\"line\"></span><br><span class=\"line\">\t等效的选择器还可以写成 :first-child:last-child或者:nth-child(1):nth-last-child(1),当然,前者的权重会低一点.</span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>root</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:root 这个 CSS 伪类匹配文档树的根元素。对于 HTML 来说，:root 表示 &lt;html&gt; 元素，除了优先级更高之外，与 html 选择器相同。</span><br></pre></td></tr></table></figure>\n\n<p><strong>target</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">对目标元素的id进行一个匹配，当url中出现了这个id时显示，url的构造形式类似于vue-router 的hash模式</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;div id=&quot;12&quot;&gt;&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">div:target &#123; &#125; </span><br><span class=\"line\">当url为 http://xxxx#12 时，这里面的效果就会展示出来</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"选择器优先级\"><a href=\"#选择器优先级\" class=\"headerlink\" title=\"选择器优先级\"></a>选择器优先级</h1><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://developer.mozilla.org/zh-CN/docs/Web/CSS/Specificity</span><br></pre></td></tr></table></figure>\n\n<p>简单来说，</p>\n<p><strong>!important &gt; 行内样式&gt;ID选择器 &gt; 类选择器 &gt; 标签 &gt; 通配符 &gt; 继承 &gt; 浏览器默认属性</strong></p>\n<p>我们是使用的权重方式进行的判断优先级</p>\n<p><strong>内联的权重是：1 0 0 0</strong></p>\n<p><strong>id的权重是 1 0 0</strong></p>\n<p><strong>class的权重是 1 0</strong></p>\n<p><strong>标签的权重是 1</strong></p>\n<p><strong>注意：</strong></p>\n<p>​    权重是不会进位的，不会因为有11个class，就可以超过id</p>\n"},{"title":"margin使用百分号值","date":"2021-10-12T16:00:00.000Z","_content":"\n\n\n#  CSS margin\n\n```\nhttps://www.w3school.com.cn/cssref/pr_margin-top.asp\n```\n\n对于使用 % 为单位的，为父元素的宽度，\n\n```\nmargin-top: 50%\n是相对于父节点的宽度。其他同样\npadding-top: 25%;\n\n\nborder: black solid 25%; 使用会报错\n\n对于宽度和高度的50%，就是针对的父元素的宽度和高度了。\n```\n\n\n\n```\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <title>Title</title>\n  <style>\n    * {\n      margin: 0;\n      padding: 0;\n    }\n\n    .f {\n      height: 400px;\n      width: 800px;\n      background-color: red;\n      /*这里使用 overflow: hidden;\n       解决外边距合并，外边距塌陷问题 */\n      overflow: hidden;\n    }\n\n    .c {\n      height: 100px;\n      width: 200px;\n      background-color: blue;\n      margin-top: 25%;\n    }\n\n  </style>\n\n</head>\n<body>\n<div class=\"f\">\n  <div class=\"c\"></div>\n</div>\n</body>\n</html>\n```\n\n","source":"_posts/CSS/margin使用百分号值.md","raw":"---\ntitle: margin使用百分号值\ndate: 2021/10/13\ntags: \n - CSS\n - margin\ncategories:\n - CSS\n---\n\n\n\n#  CSS margin\n\n```\nhttps://www.w3school.com.cn/cssref/pr_margin-top.asp\n```\n\n对于使用 % 为单位的，为父元素的宽度，\n\n```\nmargin-top: 50%\n是相对于父节点的宽度。其他同样\npadding-top: 25%;\n\n\nborder: black solid 25%; 使用会报错\n\n对于宽度和高度的50%，就是针对的父元素的宽度和高度了。\n```\n\n\n\n```\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <title>Title</title>\n  <style>\n    * {\n      margin: 0;\n      padding: 0;\n    }\n\n    .f {\n      height: 400px;\n      width: 800px;\n      background-color: red;\n      /*这里使用 overflow: hidden;\n       解决外边距合并，外边距塌陷问题 */\n      overflow: hidden;\n    }\n\n    .c {\n      height: 100px;\n      width: 200px;\n      background-color: blue;\n      margin-top: 25%;\n    }\n\n  </style>\n\n</head>\n<body>\n<div class=\"f\">\n  <div class=\"c\"></div>\n</div>\n</body>\n</html>\n```\n\n","slug":"CSS/margin使用百分号值","published":1,"updated":"2021-12-09T01:56:49.388Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckznhkk7m002iikub97p72ld1","content":"<h1 id=\"CSS-margin\"><a href=\"#CSS-margin\" class=\"headerlink\" title=\"CSS margin\"></a>CSS margin</h1><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://www.w3school.com.cn/cssref/pr_margin-top.asp</span><br></pre></td></tr></table></figure>\n\n<p>对于使用 % 为单位的，为父元素的宽度，</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">margin-top: 50%</span><br><span class=\"line\">是相对于父节点的宽度。其他同样</span><br><span class=\"line\">padding-top: 25%;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">border: black solid 25%; 使用会报错</span><br><span class=\"line\"></span><br><span class=\"line\">对于宽度和高度的50%，就是针对的父元素的宽度和高度了。</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html lang=&quot;en&quot;&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">  &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class=\"line\">  &lt;title&gt;Title&lt;/title&gt;</span><br><span class=\"line\">  &lt;style&gt;</span><br><span class=\"line\">    * &#123;</span><br><span class=\"line\">      margin: 0;</span><br><span class=\"line\">      padding: 0;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    .f &#123;</span><br><span class=\"line\">      height: 400px;</span><br><span class=\"line\">      width: 800px;</span><br><span class=\"line\">      background-color: red;</span><br><span class=\"line\">      /*这里使用 overflow: hidden;</span><br><span class=\"line\">       解决外边距合并，外边距塌陷问题 */</span><br><span class=\"line\">      overflow: hidden;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    .c &#123;</span><br><span class=\"line\">      height: 100px;</span><br><span class=\"line\">      width: 200px;</span><br><span class=\"line\">      background-color: blue;</span><br><span class=\"line\">      margin-top: 25%;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  &lt;/style&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">&lt;div class=&quot;f&quot;&gt;</span><br><span class=\"line\">  &lt;div class=&quot;c&quot;&gt;&lt;/div&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"CSS-margin\"><a href=\"#CSS-margin\" class=\"headerlink\" title=\"CSS margin\"></a>CSS margin</h1><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://www.w3school.com.cn/cssref/pr_margin-top.asp</span><br></pre></td></tr></table></figure>\n\n<p>对于使用 % 为单位的，为父元素的宽度，</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">margin-top: 50%</span><br><span class=\"line\">是相对于父节点的宽度。其他同样</span><br><span class=\"line\">padding-top: 25%;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">border: black solid 25%; 使用会报错</span><br><span class=\"line\"></span><br><span class=\"line\">对于宽度和高度的50%，就是针对的父元素的宽度和高度了。</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html lang=&quot;en&quot;&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">  &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class=\"line\">  &lt;title&gt;Title&lt;/title&gt;</span><br><span class=\"line\">  &lt;style&gt;</span><br><span class=\"line\">    * &#123;</span><br><span class=\"line\">      margin: 0;</span><br><span class=\"line\">      padding: 0;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    .f &#123;</span><br><span class=\"line\">      height: 400px;</span><br><span class=\"line\">      width: 800px;</span><br><span class=\"line\">      background-color: red;</span><br><span class=\"line\">      /*这里使用 overflow: hidden;</span><br><span class=\"line\">       解决外边距合并，外边距塌陷问题 */</span><br><span class=\"line\">      overflow: hidden;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    .c &#123;</span><br><span class=\"line\">      height: 100px;</span><br><span class=\"line\">      width: 200px;</span><br><span class=\"line\">      background-color: blue;</span><br><span class=\"line\">      margin-top: 25%;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  &lt;/style&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">&lt;div class=&quot;f&quot;&gt;</span><br><span class=\"line\">  &lt;div class=&quot;c&quot;&gt;&lt;/div&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n\n"},{"title":"水平垂直居中方法","date":"2021-10-17T06:51:23.000Z","_content":"\n\n\n\n#  水平垂直居中方法\n\n\n\n### 弹性布局\n\n```\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <title>Title</title>\n  <style>\n    * {\n      margin: 0;\n      padding: 0;\n    }\n\n    body {\n      height: 100vh;\n      display: flex;\n      justify-content: center;\n      align-items: center;\n    }\n\n    div {\n      width: 200px;\n      height: 200px;\n      background-color: red;\n\n    }\n  </style>\n\n</head>\n<body>\n<div></div>\n</body>\n</html>\n```\n\n\n\n\n\n### 定位\n\n","source":"_posts/CSS/水平垂直居中方法.md","raw":"---\ntitle: 水平垂直居中方法\ndate: 2021-10-17 14:51:23\ntags:\n  - CSS\n  - HTML\ncategories:\n - CSS\n---\n\n\n\n\n#  水平垂直居中方法\n\n\n\n### 弹性布局\n\n```\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <title>Title</title>\n  <style>\n    * {\n      margin: 0;\n      padding: 0;\n    }\n\n    body {\n      height: 100vh;\n      display: flex;\n      justify-content: center;\n      align-items: center;\n    }\n\n    div {\n      width: 200px;\n      height: 200px;\n      background-color: red;\n\n    }\n  </style>\n\n</head>\n<body>\n<div></div>\n</body>\n</html>\n```\n\n\n\n\n\n### 定位\n\n","slug":"CSS/水平垂直居中方法","published":1,"updated":"2021-12-09T01:56:49.388Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckznhkk7m002kikub9vskbmr5","content":"<h1 id=\"水平垂直居中方法\"><a href=\"#水平垂直居中方法\" class=\"headerlink\" title=\"水平垂直居中方法\"></a>水平垂直居中方法</h1><h3 id=\"弹性布局\"><a href=\"#弹性布局\" class=\"headerlink\" title=\"弹性布局\"></a>弹性布局</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html lang=&quot;en&quot;&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">  &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class=\"line\">  &lt;title&gt;Title&lt;/title&gt;</span><br><span class=\"line\">  &lt;style&gt;</span><br><span class=\"line\">    * &#123;</span><br><span class=\"line\">      margin: 0;</span><br><span class=\"line\">      padding: 0;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    body &#123;</span><br><span class=\"line\">      height: 100vh;</span><br><span class=\"line\">      display: flex;</span><br><span class=\"line\">      justify-content: center;</span><br><span class=\"line\">      align-items: center;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    div &#123;</span><br><span class=\"line\">      width: 200px;</span><br><span class=\"line\">      height: 200px;</span><br><span class=\"line\">      background-color: red;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &lt;/style&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">&lt;div&gt;&lt;/div&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h3 id=\"定位\"><a href=\"#定位\" class=\"headerlink\" title=\"定位\"></a>定位</h3>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"水平垂直居中方法\"><a href=\"#水平垂直居中方法\" class=\"headerlink\" title=\"水平垂直居中方法\"></a>水平垂直居中方法</h1><h3 id=\"弹性布局\"><a href=\"#弹性布局\" class=\"headerlink\" title=\"弹性布局\"></a>弹性布局</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html lang=&quot;en&quot;&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">  &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class=\"line\">  &lt;title&gt;Title&lt;/title&gt;</span><br><span class=\"line\">  &lt;style&gt;</span><br><span class=\"line\">    * &#123;</span><br><span class=\"line\">      margin: 0;</span><br><span class=\"line\">      padding: 0;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    body &#123;</span><br><span class=\"line\">      height: 100vh;</span><br><span class=\"line\">      display: flex;</span><br><span class=\"line\">      justify-content: center;</span><br><span class=\"line\">      align-items: center;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    div &#123;</span><br><span class=\"line\">      width: 200px;</span><br><span class=\"line\">      height: 200px;</span><br><span class=\"line\">      background-color: red;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &lt;/style&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">&lt;div&gt;&lt;/div&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h3 id=\"定位\"><a href=\"#定位\" class=\"headerlink\" title=\"定位\"></a>定位</h3>"},{"title":"JavaScript-parseInt函数","date":"2021-10-25T11:41:27.000Z","_content":"\n\n\n#  parseInt函数\n\n```\nhttps://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/parseInt\n```\n\n​\t**parseInt(\\*string\\*, \\*radix\\*)**  解析一个字符串并返回指定基数的十进制整数， `radix` 是2-36之间的整数，表示被解析字符串的基数。\n\n\n\n## 参数解析\n\n**string**\n\n​\t\t要被解析的值。如果参数不是一个字符串，则将其转换为字符串(使用  `ToString `抽象操作)。字符串开头的空白符将会被忽略。\n\n**radix**\n\n​\t\t从 `2` 到 `36`，表示字符串的基数。例如指定 16 表示被解析值是十六进制数。请注意，10不是默认值！简单来说就是设置进制，一个2~36的进制\n\n\n\n## 返回值\n\n一个整数，\n\n或者NaN\n\n​\t转换NaN的情况\n\n​\t\t`radix` 小于 `2` 或大于 `36` ，或\n\n​\t\t第一个非空格字符不能转换为数字。\n\n\n\n**注意：**\n\n​\t这个在进行进制运算时，不是先转为十进制在运算，而是直接进行对应的进制转换，\n\n​\t\t比如：\t33 ， 2 此时是：33转为2进制的转换，因为2进制每位数最大值是1，所以33直接NaN，但是如果是12，就会转化为1.\n\n\n\n## 面试问到的：\n\n```\nconst arr = [1, 2, 3, 10, 111];\narr.map(parseInt)\n```\n\n```\n简单的解析一下，\n首先map内部的回调函数的三个参数分别为 value，index，array\n然后parseInt会使用两个参数，一个是要转换的字符串，一个是进制\n所以 按照顺序就会变成： 1,0\t2,1\t\t3,2\t\t10,3\t111,4\n\t对于0，会使用默认形式，对于1，会直接NaN，对于后面的就按照正常进制的运算\n\t所以结果是： 1,NaN,NaN,3,21\n```\n\n","source":"_posts/JavaScript/JavaScript-parseInt函数.md","raw":"---\ntitle: JavaScript-parseInt函数\ndate: 2021-10-25 19:41:27\ntags:\n - JavaScript\n - parseInt\ncategories:\n - JavaScript\n - Global_Objects\n---\n\n\n\n#  parseInt函数\n\n```\nhttps://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/parseInt\n```\n\n​\t**parseInt(\\*string\\*, \\*radix\\*)**  解析一个字符串并返回指定基数的十进制整数， `radix` 是2-36之间的整数，表示被解析字符串的基数。\n\n\n\n## 参数解析\n\n**string**\n\n​\t\t要被解析的值。如果参数不是一个字符串，则将其转换为字符串(使用  `ToString `抽象操作)。字符串开头的空白符将会被忽略。\n\n**radix**\n\n​\t\t从 `2` 到 `36`，表示字符串的基数。例如指定 16 表示被解析值是十六进制数。请注意，10不是默认值！简单来说就是设置进制，一个2~36的进制\n\n\n\n## 返回值\n\n一个整数，\n\n或者NaN\n\n​\t转换NaN的情况\n\n​\t\t`radix` 小于 `2` 或大于 `36` ，或\n\n​\t\t第一个非空格字符不能转换为数字。\n\n\n\n**注意：**\n\n​\t这个在进行进制运算时，不是先转为十进制在运算，而是直接进行对应的进制转换，\n\n​\t\t比如：\t33 ， 2 此时是：33转为2进制的转换，因为2进制每位数最大值是1，所以33直接NaN，但是如果是12，就会转化为1.\n\n\n\n## 面试问到的：\n\n```\nconst arr = [1, 2, 3, 10, 111];\narr.map(parseInt)\n```\n\n```\n简单的解析一下，\n首先map内部的回调函数的三个参数分别为 value，index，array\n然后parseInt会使用两个参数，一个是要转换的字符串，一个是进制\n所以 按照顺序就会变成： 1,0\t2,1\t\t3,2\t\t10,3\t111,4\n\t对于0，会使用默认形式，对于1，会直接NaN，对于后面的就按照正常进制的运算\n\t所以结果是： 1,NaN,NaN,3,21\n```\n\n","slug":"JavaScript/JavaScript-parseInt函数","published":1,"updated":"2021-12-09T01:56:49.404Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckznhkk7n002pikub5cnnavii","content":"<h1 id=\"parseInt函数\"><a href=\"#parseInt函数\" class=\"headerlink\" title=\"parseInt函数\"></a>parseInt函数</h1><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/parseInt</span><br></pre></td></tr></table></figure>\n\n<p>​    <strong>parseInt(*string*, *radix*)</strong>  解析一个字符串并返回指定基数的十进制整数， <code>radix</code> 是2-36之间的整数，表示被解析字符串的基数。</p>\n<h2 id=\"参数解析\"><a href=\"#参数解析\" class=\"headerlink\" title=\"参数解析\"></a>参数解析</h2><p><strong>string</strong></p>\n<p>​        要被解析的值。如果参数不是一个字符串，则将其转换为字符串(使用  <code>ToString </code>抽象操作)。字符串开头的空白符将会被忽略。</p>\n<p><strong>radix</strong></p>\n<p>​        从 <code>2</code> 到 <code>36</code>，表示字符串的基数。例如指定 16 表示被解析值是十六进制数。请注意，10不是默认值！简单来说就是设置进制，一个2~36的进制</p>\n<h2 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h2><p>一个整数，</p>\n<p>或者NaN</p>\n<p>​    转换NaN的情况</p>\n<p>​        <code>radix</code> 小于 <code>2</code> 或大于 <code>36</code> ，或</p>\n<p>​        第一个非空格字符不能转换为数字。</p>\n<p><strong>注意：</strong></p>\n<p>​    这个在进行进制运算时，不是先转为十进制在运算，而是直接进行对应的进制转换，</p>\n<p>​        比如：    33 ， 2 此时是：33转为2进制的转换，因为2进制每位数最大值是1，所以33直接NaN，但是如果是12，就会转化为1.</p>\n<h2 id=\"面试问到的：\"><a href=\"#面试问到的：\" class=\"headerlink\" title=\"面试问到的：\"></a>面试问到的：</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const arr = [1, 2, 3, 10, 111];</span><br><span class=\"line\">arr.map(parseInt)</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">简单的解析一下，</span><br><span class=\"line\">首先map内部的回调函数的三个参数分别为 value，index，array</span><br><span class=\"line\">然后parseInt会使用两个参数，一个是要转换的字符串，一个是进制</span><br><span class=\"line\">所以 按照顺序就会变成： 1,0\t2,1\t\t3,2\t\t10,3\t111,4</span><br><span class=\"line\">\t对于0，会使用默认形式，对于1，会直接NaN，对于后面的就按照正常进制的运算</span><br><span class=\"line\">\t所以结果是： 1,NaN,NaN,3,21</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"parseInt函数\"><a href=\"#parseInt函数\" class=\"headerlink\" title=\"parseInt函数\"></a>parseInt函数</h1><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/parseInt</span><br></pre></td></tr></table></figure>\n\n<p>​    <strong>parseInt(*string*, *radix*)</strong>  解析一个字符串并返回指定基数的十进制整数， <code>radix</code> 是2-36之间的整数，表示被解析字符串的基数。</p>\n<h2 id=\"参数解析\"><a href=\"#参数解析\" class=\"headerlink\" title=\"参数解析\"></a>参数解析</h2><p><strong>string</strong></p>\n<p>​        要被解析的值。如果参数不是一个字符串，则将其转换为字符串(使用  <code>ToString </code>抽象操作)。字符串开头的空白符将会被忽略。</p>\n<p><strong>radix</strong></p>\n<p>​        从 <code>2</code> 到 <code>36</code>，表示字符串的基数。例如指定 16 表示被解析值是十六进制数。请注意，10不是默认值！简单来说就是设置进制，一个2~36的进制</p>\n<h2 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h2><p>一个整数，</p>\n<p>或者NaN</p>\n<p>​    转换NaN的情况</p>\n<p>​        <code>radix</code> 小于 <code>2</code> 或大于 <code>36</code> ，或</p>\n<p>​        第一个非空格字符不能转换为数字。</p>\n<p><strong>注意：</strong></p>\n<p>​    这个在进行进制运算时，不是先转为十进制在运算，而是直接进行对应的进制转换，</p>\n<p>​        比如：    33 ， 2 此时是：33转为2进制的转换，因为2进制每位数最大值是1，所以33直接NaN，但是如果是12，就会转化为1.</p>\n<h2 id=\"面试问到的：\"><a href=\"#面试问到的：\" class=\"headerlink\" title=\"面试问到的：\"></a>面试问到的：</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const arr = [1, 2, 3, 10, 111];</span><br><span class=\"line\">arr.map(parseInt)</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">简单的解析一下，</span><br><span class=\"line\">首先map内部的回调函数的三个参数分别为 value，index，array</span><br><span class=\"line\">然后parseInt会使用两个参数，一个是要转换的字符串，一个是进制</span><br><span class=\"line\">所以 按照顺序就会变成： 1,0\t2,1\t\t3,2\t\t10,3\t111,4</span><br><span class=\"line\">\t对于0，会使用默认形式，对于1，会直接NaN，对于后面的就按照正常进制的运算</span><br><span class=\"line\">\t所以结果是： 1,NaN,NaN,3,21</span><br></pre></td></tr></table></figure>\n\n"},{"title":"JavaScript浅拷贝和深拷贝","date":"2021-10-19T07:28:12.000Z","_content":"\n\n\n# 浅拷贝\n\n\n\n很简单，就是只拷贝一层，不拷贝多层，因为对于引用数据类型，\n\n他的数据是存放在堆中的，我们只是在栈中存放了他的地址。所以浅拷贝的问题就是对于引用数据类型还是没有进行拷贝。\n\n```\n一个简单的demo\n\n这里，有两个循环操作。对于forin，他会循着原型链向上查找，\n而对于 Object.keys() 和 Object.getOwnPropertyNames()，他只会返回属于自身的属性。\n而不会向上寻找原型链\n```\n\n```\nlet obj1 = {\n  a: 1\n};\n\nlet obj2 = {\n  b: 2\n};\nobj2.__proto__ = obj1;\n\nfor (const obj2Key in obj2) {\n  console.log(obj2Key);\n}\nconsole.log(Object.keys(obj2))\nconsole.log(Object.getOwnPropertyNames(obj2))\n```\n\n```\nb\na\n\n[ 'b' ]\n\n[ 'b' ]\n```\n\n\n\n所以我们考虑到是否要将原型链上的一起拷贝之后，再进行拷贝\n\n```\nkeys代表了要拷贝的key\n\nconst obj = {}\n\nfor (const key in keys) {\n  obj[keys[key]] = obj2[keys[key]];\n}\n```\n\n这个就是浅拷贝了。比较简单\n\n\n\n## 同时也可以使用 `Object.assign()` 进行浅拷贝\n\n```\nhttps://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/assign\n```\n\n```\nObject.assign(target, source);\n\n第一个参数是目标对象, 第二个参数是源对象,\n我们会将源对象的值拷贝给目标对象,对于重复的会被覆盖.\n然后再将目标对象返回.\n```\n\n```\nconst target = { a: 1, b: 2 };\nconst source = { b: 4, c: 5, x: {\n    a: 1\n  } };\n\nconst returnedTarget = Object.assign(target, source);\n\nconsole.log(target);\n// expected output: Object { a: 1, b: 4, c: 5, x: { a: 1 } }\nconsole.log(returnedTarget);\n// expected output: Object { a: 1, b: 4, c: 5, x: { a: 1 } }\n\nsource.x.a = 3;\nconsole.log(target);\n// expected output: Object { a: 1, b: 4, c: 5, x: { a: 3 } }\nconsole.log(returnedTarget);\n// expected output: Object { a: 1, b: 4, c: 5, x: { a: 3 } }\n```\n\n\n\n# 深拷贝\n\n和浅拷贝不同的是，深拷贝，是要进行递归，吧对象里面的对象也要拷贝出来。\n\n\n\n## 第一种：使用 JSON的方法，这个方法我也觉得很巧妙，\n\n除了不能拷贝 function，正则，Symbol之外，其他都很不错。\n\n```\n方法也很简单\n\n先对其进行string化，然后再json化，所以简单的使用没有问题。\nJSON.parse(JSON.stringify(obj))\n```\n\n\n\n```\nlet obj = {\n  reg : /^aaa$/,\n  fun: function(){ console.log(1) },\n  syb:Symbol('foo'),\n  aa:'aa'\n};\nlet cp = JSON.parse(JSON.stringify(obj));\nconsole.log(cp);\n```\n\n```\n{ reg: {}, aa: 'aa' }\n```\n\n\n\n## 第二种，就是简单的类型判断加递归了\n\n就判断是否为基本数据类型，如果是那么就进行复制，如果不是那么就进入递归\n\n其中，对于正则，基本数据类型，可以直接赋值。\n\n对于对象，使用递归，\n\n对于函数，我这里下面再讲\n\n\n\n#### 类型判断\n\n这里，先用`typeof`判断是否为 `object`，\n\n然后，对于object，存在 null，对象，数组，正则和使用new进行创建的基本数据类型\n\n​\t在这里，我把使用new方法创建的基本数据类型也算为基本数据类型。\n\n对于非object，有function，和基本数据类型。\n\n```\nfunction getType(target) {\n\n  const type = typeof target;\n  if (type == 'object') {\n    if (target === null) {\n      // 空\n      return 'null';\n    } else if (Array.isArray(target)) {\n      // 数组\n      return 'array';\n    } else if (target.constructor === RegExp) {\n      //正则\n      return 'regexp'\n    } else {\n      // 对象，这里还要判断是否为map和set对象。\n      //并且，map，set只能使用 forof 进行循环，或者使用自带的 oreach 进行循环。\n      if (typeof target.valueOf() === 'object') {\n        return 'object';\n      } else {\n        return 'basic';\n      }\n    }\n  } else if (type == 'function') {\n    return 'function';\n  } else {\n    return 'basic';\n  }\n}\n```\n\n```\n这里也可以使用 Object.prototype.toString.call(); 方法进行调用来判断是什么类型的.这个就比较方便,直接可以将map,set,对象,数组,基本数据类型等都辨别出来.\n可以看看我写的另一个关于 类型判断的blog ,里面有.\n```\n\n\n\n#### 然后就是递归\n\n```\nfunction deepClone(target) {\n  let result;\n\n  for (const key in target) {\n    result[key] = recursion(target[key]);\n  }\n\n  return result;\n  \n  function recursion(target) {\n    if ('基本数据类型') {\n      return target;\n    } else if ('函数') {\n\t\t\n    } else {\n      //对象\n      return recursion(target)\n    }\n  }\n}\n```\n\n\n\n#### 对于函数如何进行拷贝\n\n前几天面试问到了..\n\n我的想法，有三种方式，\n\n​\t**第一种：使用toString，然后再使用eval。**\t\n\n```\nlet fn = function () {\n  console.log(1);\n}\n\nfunction fn1() {\n  console.log(1)\n}\n\n这里我对于eval函数的使用还是不够了解。\n这里，我不知道为什么， eval(fn.toString()) 没有返回值，所以我写了一个箭头函数字符串进行包装和执行。\n\t这里，需要使用一个箭头函数进行包装，如果使用普通函数进行包装。也没有用处。\nlet fn2 = eval('() => ' + fn1.toString())(); //这里，fn和fn1都可以运行。\n\n\n这样写也可以。\neval(`\n  (() => fn)()\n`)()\n```\n\n```\n应该是因为需要使用()进行包裹.\nlet a = eval(`\n  (function fn() {\n    console.log(1);\n    return 1;\n  })\n`);\na()\nconsole.log(a.toString())\n```\n\n```\n1\nfunction fn() {\n    console.log(1);\n    return 1;\n  }\n```\n\n​\t\n\n**第二种：使用new Function('return ' + func.toString())();**\n\n```\nlet f = new Function('return ' + fn.toString())()\n\nf();\n```\n\n​\t**第三种：使用bind函数进行一次绑定。但是这个对于有传参的函数会有所不同。**\n\n```\n这个有个要求，因为bind函数实则就是对于一个函数进行了call方法，但是是一个延迟的调用。\n\n从一个简单的逻辑来说，应该是并没有进行一个从底层复制操作的。因为是直接进行的 简单赋值。\n\nlet f = fn.bind()\nf();\n```\n\n","source":"_posts/JavaScript/JavaScript浅拷贝和深拷贝.md","raw":"---\ntitle: JavaScript浅拷贝和深拷贝\ndate: 2021-10-19 15:28:12\ntags:\n - JavaScript\n - 浅拷贝\n - 深拷贝\ncategories:\n - JavaScript\n---\n\n\n\n# 浅拷贝\n\n\n\n很简单，就是只拷贝一层，不拷贝多层，因为对于引用数据类型，\n\n他的数据是存放在堆中的，我们只是在栈中存放了他的地址。所以浅拷贝的问题就是对于引用数据类型还是没有进行拷贝。\n\n```\n一个简单的demo\n\n这里，有两个循环操作。对于forin，他会循着原型链向上查找，\n而对于 Object.keys() 和 Object.getOwnPropertyNames()，他只会返回属于自身的属性。\n而不会向上寻找原型链\n```\n\n```\nlet obj1 = {\n  a: 1\n};\n\nlet obj2 = {\n  b: 2\n};\nobj2.__proto__ = obj1;\n\nfor (const obj2Key in obj2) {\n  console.log(obj2Key);\n}\nconsole.log(Object.keys(obj2))\nconsole.log(Object.getOwnPropertyNames(obj2))\n```\n\n```\nb\na\n\n[ 'b' ]\n\n[ 'b' ]\n```\n\n\n\n所以我们考虑到是否要将原型链上的一起拷贝之后，再进行拷贝\n\n```\nkeys代表了要拷贝的key\n\nconst obj = {}\n\nfor (const key in keys) {\n  obj[keys[key]] = obj2[keys[key]];\n}\n```\n\n这个就是浅拷贝了。比较简单\n\n\n\n## 同时也可以使用 `Object.assign()` 进行浅拷贝\n\n```\nhttps://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/assign\n```\n\n```\nObject.assign(target, source);\n\n第一个参数是目标对象, 第二个参数是源对象,\n我们会将源对象的值拷贝给目标对象,对于重复的会被覆盖.\n然后再将目标对象返回.\n```\n\n```\nconst target = { a: 1, b: 2 };\nconst source = { b: 4, c: 5, x: {\n    a: 1\n  } };\n\nconst returnedTarget = Object.assign(target, source);\n\nconsole.log(target);\n// expected output: Object { a: 1, b: 4, c: 5, x: { a: 1 } }\nconsole.log(returnedTarget);\n// expected output: Object { a: 1, b: 4, c: 5, x: { a: 1 } }\n\nsource.x.a = 3;\nconsole.log(target);\n// expected output: Object { a: 1, b: 4, c: 5, x: { a: 3 } }\nconsole.log(returnedTarget);\n// expected output: Object { a: 1, b: 4, c: 5, x: { a: 3 } }\n```\n\n\n\n# 深拷贝\n\n和浅拷贝不同的是，深拷贝，是要进行递归，吧对象里面的对象也要拷贝出来。\n\n\n\n## 第一种：使用 JSON的方法，这个方法我也觉得很巧妙，\n\n除了不能拷贝 function，正则，Symbol之外，其他都很不错。\n\n```\n方法也很简单\n\n先对其进行string化，然后再json化，所以简单的使用没有问题。\nJSON.parse(JSON.stringify(obj))\n```\n\n\n\n```\nlet obj = {\n  reg : /^aaa$/,\n  fun: function(){ console.log(1) },\n  syb:Symbol('foo'),\n  aa:'aa'\n};\nlet cp = JSON.parse(JSON.stringify(obj));\nconsole.log(cp);\n```\n\n```\n{ reg: {}, aa: 'aa' }\n```\n\n\n\n## 第二种，就是简单的类型判断加递归了\n\n就判断是否为基本数据类型，如果是那么就进行复制，如果不是那么就进入递归\n\n其中，对于正则，基本数据类型，可以直接赋值。\n\n对于对象，使用递归，\n\n对于函数，我这里下面再讲\n\n\n\n#### 类型判断\n\n这里，先用`typeof`判断是否为 `object`，\n\n然后，对于object，存在 null，对象，数组，正则和使用new进行创建的基本数据类型\n\n​\t在这里，我把使用new方法创建的基本数据类型也算为基本数据类型。\n\n对于非object，有function，和基本数据类型。\n\n```\nfunction getType(target) {\n\n  const type = typeof target;\n  if (type == 'object') {\n    if (target === null) {\n      // 空\n      return 'null';\n    } else if (Array.isArray(target)) {\n      // 数组\n      return 'array';\n    } else if (target.constructor === RegExp) {\n      //正则\n      return 'regexp'\n    } else {\n      // 对象，这里还要判断是否为map和set对象。\n      //并且，map，set只能使用 forof 进行循环，或者使用自带的 oreach 进行循环。\n      if (typeof target.valueOf() === 'object') {\n        return 'object';\n      } else {\n        return 'basic';\n      }\n    }\n  } else if (type == 'function') {\n    return 'function';\n  } else {\n    return 'basic';\n  }\n}\n```\n\n```\n这里也可以使用 Object.prototype.toString.call(); 方法进行调用来判断是什么类型的.这个就比较方便,直接可以将map,set,对象,数组,基本数据类型等都辨别出来.\n可以看看我写的另一个关于 类型判断的blog ,里面有.\n```\n\n\n\n#### 然后就是递归\n\n```\nfunction deepClone(target) {\n  let result;\n\n  for (const key in target) {\n    result[key] = recursion(target[key]);\n  }\n\n  return result;\n  \n  function recursion(target) {\n    if ('基本数据类型') {\n      return target;\n    } else if ('函数') {\n\t\t\n    } else {\n      //对象\n      return recursion(target)\n    }\n  }\n}\n```\n\n\n\n#### 对于函数如何进行拷贝\n\n前几天面试问到了..\n\n我的想法，有三种方式，\n\n​\t**第一种：使用toString，然后再使用eval。**\t\n\n```\nlet fn = function () {\n  console.log(1);\n}\n\nfunction fn1() {\n  console.log(1)\n}\n\n这里我对于eval函数的使用还是不够了解。\n这里，我不知道为什么， eval(fn.toString()) 没有返回值，所以我写了一个箭头函数字符串进行包装和执行。\n\t这里，需要使用一个箭头函数进行包装，如果使用普通函数进行包装。也没有用处。\nlet fn2 = eval('() => ' + fn1.toString())(); //这里，fn和fn1都可以运行。\n\n\n这样写也可以。\neval(`\n  (() => fn)()\n`)()\n```\n\n```\n应该是因为需要使用()进行包裹.\nlet a = eval(`\n  (function fn() {\n    console.log(1);\n    return 1;\n  })\n`);\na()\nconsole.log(a.toString())\n```\n\n```\n1\nfunction fn() {\n    console.log(1);\n    return 1;\n  }\n```\n\n​\t\n\n**第二种：使用new Function('return ' + func.toString())();**\n\n```\nlet f = new Function('return ' + fn.toString())()\n\nf();\n```\n\n​\t**第三种：使用bind函数进行一次绑定。但是这个对于有传参的函数会有所不同。**\n\n```\n这个有个要求，因为bind函数实则就是对于一个函数进行了call方法，但是是一个延迟的调用。\n\n从一个简单的逻辑来说，应该是并没有进行一个从底层复制操作的。因为是直接进行的 简单赋值。\n\nlet f = fn.bind()\nf();\n```\n\n","slug":"JavaScript/JavaScript浅拷贝和深拷贝","published":1,"updated":"2021-12-09T01:56:49.404Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckznhkk7o002rikub3jp03am5","content":"<h1 id=\"浅拷贝\"><a href=\"#浅拷贝\" class=\"headerlink\" title=\"浅拷贝\"></a>浅拷贝</h1><p>很简单，就是只拷贝一层，不拷贝多层，因为对于引用数据类型，</p>\n<p>他的数据是存放在堆中的，我们只是在栈中存放了他的地址。所以浅拷贝的问题就是对于引用数据类型还是没有进行拷贝。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">一个简单的demo</span><br><span class=\"line\"></span><br><span class=\"line\">这里，有两个循环操作。对于forin，他会循着原型链向上查找，</span><br><span class=\"line\">而对于 Object.keys() 和 Object.getOwnPropertyNames()，他只会返回属于自身的属性。</span><br><span class=\"line\">而不会向上寻找原型链</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let obj1 = &#123;</span><br><span class=\"line\">  a: 1</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">let obj2 = &#123;</span><br><span class=\"line\">  b: 2</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">obj2.__proto__ = obj1;</span><br><span class=\"line\"></span><br><span class=\"line\">for (const obj2Key in obj2) &#123;</span><br><span class=\"line\">  console.log(obj2Key);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">console.log(Object.keys(obj2))</span><br><span class=\"line\">console.log(Object.getOwnPropertyNames(obj2))</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">b</span><br><span class=\"line\">a</span><br><span class=\"line\"></span><br><span class=\"line\">[ &#x27;b&#x27; ]</span><br><span class=\"line\"></span><br><span class=\"line\">[ &#x27;b&#x27; ]</span><br></pre></td></tr></table></figure>\n\n\n\n<p>所以我们考虑到是否要将原型链上的一起拷贝之后，再进行拷贝</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">keys代表了要拷贝的key</span><br><span class=\"line\"></span><br><span class=\"line\">const obj = &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">for (const key in keys) &#123;</span><br><span class=\"line\">  obj[keys[key]] = obj2[keys[key]];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个就是浅拷贝了。比较简单</p>\n<h2 id=\"同时也可以使用-Object-assign-进行浅拷贝\"><a href=\"#同时也可以使用-Object-assign-进行浅拷贝\" class=\"headerlink\" title=\"同时也可以使用 Object.assign() 进行浅拷贝\"></a>同时也可以使用 <code>Object.assign()</code> 进行浅拷贝</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/assign</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Object.assign(target, source);</span><br><span class=\"line\"></span><br><span class=\"line\">第一个参数是目标对象, 第二个参数是源对象,</span><br><span class=\"line\">我们会将源对象的值拷贝给目标对象,对于重复的会被覆盖.</span><br><span class=\"line\">然后再将目标对象返回.</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const target = &#123; a: 1, b: 2 &#125;;</span><br><span class=\"line\">const source = &#123; b: 4, c: 5, x: &#123;</span><br><span class=\"line\">    a: 1</span><br><span class=\"line\">  &#125; &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">const returnedTarget = Object.assign(target, source);</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(target);</span><br><span class=\"line\">// expected output: Object &#123; a: 1, b: 4, c: 5, x: &#123; a: 1 &#125; &#125;</span><br><span class=\"line\">console.log(returnedTarget);</span><br><span class=\"line\">// expected output: Object &#123; a: 1, b: 4, c: 5, x: &#123; a: 1 &#125; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">source.x.a = 3;</span><br><span class=\"line\">console.log(target);</span><br><span class=\"line\">// expected output: Object &#123; a: 1, b: 4, c: 5, x: &#123; a: 3 &#125; &#125;</span><br><span class=\"line\">console.log(returnedTarget);</span><br><span class=\"line\">// expected output: Object &#123; a: 1, b: 4, c: 5, x: &#123; a: 3 &#125; &#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"深拷贝\"><a href=\"#深拷贝\" class=\"headerlink\" title=\"深拷贝\"></a>深拷贝</h1><p>和浅拷贝不同的是，深拷贝，是要进行递归，吧对象里面的对象也要拷贝出来。</p>\n<h2 id=\"第一种：使用-JSON的方法，这个方法我也觉得很巧妙，\"><a href=\"#第一种：使用-JSON的方法，这个方法我也觉得很巧妙，\" class=\"headerlink\" title=\"第一种：使用 JSON的方法，这个方法我也觉得很巧妙，\"></a>第一种：使用 JSON的方法，这个方法我也觉得很巧妙，</h2><p>除了不能拷贝 function，正则，Symbol之外，其他都很不错。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">方法也很简单</span><br><span class=\"line\"></span><br><span class=\"line\">先对其进行string化，然后再json化，所以简单的使用没有问题。</span><br><span class=\"line\">JSON.parse(JSON.stringify(obj))</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let obj = &#123;</span><br><span class=\"line\">  reg : /^aaa$/,</span><br><span class=\"line\">  fun: function()&#123; console.log(1) &#125;,</span><br><span class=\"line\">  syb:Symbol(&#x27;foo&#x27;),</span><br><span class=\"line\">  aa:&#x27;aa&#x27;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">let cp = JSON.parse(JSON.stringify(obj));</span><br><span class=\"line\">console.log(cp);</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123; reg: &#123;&#125;, aa: &#x27;aa&#x27; &#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"第二种，就是简单的类型判断加递归了\"><a href=\"#第二种，就是简单的类型判断加递归了\" class=\"headerlink\" title=\"第二种，就是简单的类型判断加递归了\"></a>第二种，就是简单的类型判断加递归了</h2><p>就判断是否为基本数据类型，如果是那么就进行复制，如果不是那么就进入递归</p>\n<p>其中，对于正则，基本数据类型，可以直接赋值。</p>\n<p>对于对象，使用递归，</p>\n<p>对于函数，我这里下面再讲</p>\n<h4 id=\"类型判断\"><a href=\"#类型判断\" class=\"headerlink\" title=\"类型判断\"></a>类型判断</h4><p>这里，先用<code>typeof</code>判断是否为 <code>object</code>，</p>\n<p>然后，对于object，存在 null，对象，数组，正则和使用new进行创建的基本数据类型</p>\n<p>​    在这里，我把使用new方法创建的基本数据类型也算为基本数据类型。</p>\n<p>对于非object，有function，和基本数据类型。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function getType(target) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  const type = typeof target;</span><br><span class=\"line\">  if (type == &#x27;object&#x27;) &#123;</span><br><span class=\"line\">    if (target === null) &#123;</span><br><span class=\"line\">      // 空</span><br><span class=\"line\">      return &#x27;null&#x27;;</span><br><span class=\"line\">    &#125; else if (Array.isArray(target)) &#123;</span><br><span class=\"line\">      // 数组</span><br><span class=\"line\">      return &#x27;array&#x27;;</span><br><span class=\"line\">    &#125; else if (target.constructor === RegExp) &#123;</span><br><span class=\"line\">      //正则</span><br><span class=\"line\">      return &#x27;regexp&#x27;</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">      // 对象，这里还要判断是否为map和set对象。</span><br><span class=\"line\">      //并且，map，set只能使用 forof 进行循环，或者使用自带的 oreach 进行循环。</span><br><span class=\"line\">      if (typeof target.valueOf() === &#x27;object&#x27;) &#123;</span><br><span class=\"line\">        return &#x27;object&#x27;;</span><br><span class=\"line\">      &#125; else &#123;</span><br><span class=\"line\">        return &#x27;basic&#x27;;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125; else if (type == &#x27;function&#x27;) &#123;</span><br><span class=\"line\">    return &#x27;function&#x27;;</span><br><span class=\"line\">  &#125; else &#123;</span><br><span class=\"line\">    return &#x27;basic&#x27;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">这里也可以使用 Object.prototype.toString.call(); 方法进行调用来判断是什么类型的.这个就比较方便,直接可以将map,set,对象,数组,基本数据类型等都辨别出来.</span><br><span class=\"line\">可以看看我写的另一个关于 类型判断的blog ,里面有.</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"然后就是递归\"><a href=\"#然后就是递归\" class=\"headerlink\" title=\"然后就是递归\"></a>然后就是递归</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function deepClone(target) &#123;</span><br><span class=\"line\">  let result;</span><br><span class=\"line\"></span><br><span class=\"line\">  for (const key in target) &#123;</span><br><span class=\"line\">    result[key] = recursion(target[key]);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  return result;</span><br><span class=\"line\">  </span><br><span class=\"line\">  function recursion(target) &#123;</span><br><span class=\"line\">    if (&#x27;基本数据类型&#x27;) &#123;</span><br><span class=\"line\">      return target;</span><br><span class=\"line\">    &#125; else if (&#x27;函数&#x27;) &#123;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">      //对象</span><br><span class=\"line\">      return recursion(target)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"对于函数如何进行拷贝\"><a href=\"#对于函数如何进行拷贝\" class=\"headerlink\" title=\"对于函数如何进行拷贝\"></a>对于函数如何进行拷贝</h4><p>前几天面试问到了..</p>\n<p>我的想法，有三种方式，</p>\n<p>​    <strong>第一种：使用toString，然后再使用eval。</strong>    </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let fn = function () &#123;</span><br><span class=\"line\">  console.log(1);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function fn1() &#123;</span><br><span class=\"line\">  console.log(1)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">这里我对于eval函数的使用还是不够了解。</span><br><span class=\"line\">这里，我不知道为什么， eval(fn.toString()) 没有返回值，所以我写了一个箭头函数字符串进行包装和执行。</span><br><span class=\"line\">\t这里，需要使用一个箭头函数进行包装，如果使用普通函数进行包装。也没有用处。</span><br><span class=\"line\">let fn2 = eval(&#x27;() =&gt; &#x27; + fn1.toString())(); //这里，fn和fn1都可以运行。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">这样写也可以。</span><br><span class=\"line\">eval(`</span><br><span class=\"line\">  (() =&gt; fn)()</span><br><span class=\"line\">`)()</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">应该是因为需要使用()进行包裹.</span><br><span class=\"line\">let a = eval(`</span><br><span class=\"line\">  (function fn() &#123;</span><br><span class=\"line\">    console.log(1);</span><br><span class=\"line\">    return 1;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">`);</span><br><span class=\"line\">a()</span><br><span class=\"line\">console.log(a.toString())</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1</span><br><span class=\"line\">function fn() &#123;</span><br><span class=\"line\">    console.log(1);</span><br><span class=\"line\">    return 1;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<p>​    </p>\n<p><strong>第二种：使用new Function(‘return ‘ + func.toString())();</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let f = new Function(&#x27;return &#x27; + fn.toString())()</span><br><span class=\"line\"></span><br><span class=\"line\">f();</span><br></pre></td></tr></table></figure>\n\n<p>​    <strong>第三种：使用bind函数进行一次绑定。但是这个对于有传参的函数会有所不同。</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">这个有个要求，因为bind函数实则就是对于一个函数进行了call方法，但是是一个延迟的调用。</span><br><span class=\"line\"></span><br><span class=\"line\">从一个简单的逻辑来说，应该是并没有进行一个从底层复制操作的。因为是直接进行的 简单赋值。</span><br><span class=\"line\"></span><br><span class=\"line\">let f = fn.bind()</span><br><span class=\"line\">f();</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"浅拷贝\"><a href=\"#浅拷贝\" class=\"headerlink\" title=\"浅拷贝\"></a>浅拷贝</h1><p>很简单，就是只拷贝一层，不拷贝多层，因为对于引用数据类型，</p>\n<p>他的数据是存放在堆中的，我们只是在栈中存放了他的地址。所以浅拷贝的问题就是对于引用数据类型还是没有进行拷贝。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">一个简单的demo</span><br><span class=\"line\"></span><br><span class=\"line\">这里，有两个循环操作。对于forin，他会循着原型链向上查找，</span><br><span class=\"line\">而对于 Object.keys() 和 Object.getOwnPropertyNames()，他只会返回属于自身的属性。</span><br><span class=\"line\">而不会向上寻找原型链</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let obj1 = &#123;</span><br><span class=\"line\">  a: 1</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">let obj2 = &#123;</span><br><span class=\"line\">  b: 2</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">obj2.__proto__ = obj1;</span><br><span class=\"line\"></span><br><span class=\"line\">for (const obj2Key in obj2) &#123;</span><br><span class=\"line\">  console.log(obj2Key);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">console.log(Object.keys(obj2))</span><br><span class=\"line\">console.log(Object.getOwnPropertyNames(obj2))</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">b</span><br><span class=\"line\">a</span><br><span class=\"line\"></span><br><span class=\"line\">[ &#x27;b&#x27; ]</span><br><span class=\"line\"></span><br><span class=\"line\">[ &#x27;b&#x27; ]</span><br></pre></td></tr></table></figure>\n\n\n\n<p>所以我们考虑到是否要将原型链上的一起拷贝之后，再进行拷贝</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">keys代表了要拷贝的key</span><br><span class=\"line\"></span><br><span class=\"line\">const obj = &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">for (const key in keys) &#123;</span><br><span class=\"line\">  obj[keys[key]] = obj2[keys[key]];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个就是浅拷贝了。比较简单</p>\n<h2 id=\"同时也可以使用-Object-assign-进行浅拷贝\"><a href=\"#同时也可以使用-Object-assign-进行浅拷贝\" class=\"headerlink\" title=\"同时也可以使用 Object.assign() 进行浅拷贝\"></a>同时也可以使用 <code>Object.assign()</code> 进行浅拷贝</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/assign</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Object.assign(target, source);</span><br><span class=\"line\"></span><br><span class=\"line\">第一个参数是目标对象, 第二个参数是源对象,</span><br><span class=\"line\">我们会将源对象的值拷贝给目标对象,对于重复的会被覆盖.</span><br><span class=\"line\">然后再将目标对象返回.</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const target = &#123; a: 1, b: 2 &#125;;</span><br><span class=\"line\">const source = &#123; b: 4, c: 5, x: &#123;</span><br><span class=\"line\">    a: 1</span><br><span class=\"line\">  &#125; &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">const returnedTarget = Object.assign(target, source);</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(target);</span><br><span class=\"line\">// expected output: Object &#123; a: 1, b: 4, c: 5, x: &#123; a: 1 &#125; &#125;</span><br><span class=\"line\">console.log(returnedTarget);</span><br><span class=\"line\">// expected output: Object &#123; a: 1, b: 4, c: 5, x: &#123; a: 1 &#125; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">source.x.a = 3;</span><br><span class=\"line\">console.log(target);</span><br><span class=\"line\">// expected output: Object &#123; a: 1, b: 4, c: 5, x: &#123; a: 3 &#125; &#125;</span><br><span class=\"line\">console.log(returnedTarget);</span><br><span class=\"line\">// expected output: Object &#123; a: 1, b: 4, c: 5, x: &#123; a: 3 &#125; &#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"深拷贝\"><a href=\"#深拷贝\" class=\"headerlink\" title=\"深拷贝\"></a>深拷贝</h1><p>和浅拷贝不同的是，深拷贝，是要进行递归，吧对象里面的对象也要拷贝出来。</p>\n<h2 id=\"第一种：使用-JSON的方法，这个方法我也觉得很巧妙，\"><a href=\"#第一种：使用-JSON的方法，这个方法我也觉得很巧妙，\" class=\"headerlink\" title=\"第一种：使用 JSON的方法，这个方法我也觉得很巧妙，\"></a>第一种：使用 JSON的方法，这个方法我也觉得很巧妙，</h2><p>除了不能拷贝 function，正则，Symbol之外，其他都很不错。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">方法也很简单</span><br><span class=\"line\"></span><br><span class=\"line\">先对其进行string化，然后再json化，所以简单的使用没有问题。</span><br><span class=\"line\">JSON.parse(JSON.stringify(obj))</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let obj = &#123;</span><br><span class=\"line\">  reg : /^aaa$/,</span><br><span class=\"line\">  fun: function()&#123; console.log(1) &#125;,</span><br><span class=\"line\">  syb:Symbol(&#x27;foo&#x27;),</span><br><span class=\"line\">  aa:&#x27;aa&#x27;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">let cp = JSON.parse(JSON.stringify(obj));</span><br><span class=\"line\">console.log(cp);</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123; reg: &#123;&#125;, aa: &#x27;aa&#x27; &#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"第二种，就是简单的类型判断加递归了\"><a href=\"#第二种，就是简单的类型判断加递归了\" class=\"headerlink\" title=\"第二种，就是简单的类型判断加递归了\"></a>第二种，就是简单的类型判断加递归了</h2><p>就判断是否为基本数据类型，如果是那么就进行复制，如果不是那么就进入递归</p>\n<p>其中，对于正则，基本数据类型，可以直接赋值。</p>\n<p>对于对象，使用递归，</p>\n<p>对于函数，我这里下面再讲</p>\n<h4 id=\"类型判断\"><a href=\"#类型判断\" class=\"headerlink\" title=\"类型判断\"></a>类型判断</h4><p>这里，先用<code>typeof</code>判断是否为 <code>object</code>，</p>\n<p>然后，对于object，存在 null，对象，数组，正则和使用new进行创建的基本数据类型</p>\n<p>​    在这里，我把使用new方法创建的基本数据类型也算为基本数据类型。</p>\n<p>对于非object，有function，和基本数据类型。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function getType(target) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  const type = typeof target;</span><br><span class=\"line\">  if (type == &#x27;object&#x27;) &#123;</span><br><span class=\"line\">    if (target === null) &#123;</span><br><span class=\"line\">      // 空</span><br><span class=\"line\">      return &#x27;null&#x27;;</span><br><span class=\"line\">    &#125; else if (Array.isArray(target)) &#123;</span><br><span class=\"line\">      // 数组</span><br><span class=\"line\">      return &#x27;array&#x27;;</span><br><span class=\"line\">    &#125; else if (target.constructor === RegExp) &#123;</span><br><span class=\"line\">      //正则</span><br><span class=\"line\">      return &#x27;regexp&#x27;</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">      // 对象，这里还要判断是否为map和set对象。</span><br><span class=\"line\">      //并且，map，set只能使用 forof 进行循环，或者使用自带的 oreach 进行循环。</span><br><span class=\"line\">      if (typeof target.valueOf() === &#x27;object&#x27;) &#123;</span><br><span class=\"line\">        return &#x27;object&#x27;;</span><br><span class=\"line\">      &#125; else &#123;</span><br><span class=\"line\">        return &#x27;basic&#x27;;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125; else if (type == &#x27;function&#x27;) &#123;</span><br><span class=\"line\">    return &#x27;function&#x27;;</span><br><span class=\"line\">  &#125; else &#123;</span><br><span class=\"line\">    return &#x27;basic&#x27;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">这里也可以使用 Object.prototype.toString.call(); 方法进行调用来判断是什么类型的.这个就比较方便,直接可以将map,set,对象,数组,基本数据类型等都辨别出来.</span><br><span class=\"line\">可以看看我写的另一个关于 类型判断的blog ,里面有.</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"然后就是递归\"><a href=\"#然后就是递归\" class=\"headerlink\" title=\"然后就是递归\"></a>然后就是递归</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function deepClone(target) &#123;</span><br><span class=\"line\">  let result;</span><br><span class=\"line\"></span><br><span class=\"line\">  for (const key in target) &#123;</span><br><span class=\"line\">    result[key] = recursion(target[key]);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  return result;</span><br><span class=\"line\">  </span><br><span class=\"line\">  function recursion(target) &#123;</span><br><span class=\"line\">    if (&#x27;基本数据类型&#x27;) &#123;</span><br><span class=\"line\">      return target;</span><br><span class=\"line\">    &#125; else if (&#x27;函数&#x27;) &#123;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">      //对象</span><br><span class=\"line\">      return recursion(target)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"对于函数如何进行拷贝\"><a href=\"#对于函数如何进行拷贝\" class=\"headerlink\" title=\"对于函数如何进行拷贝\"></a>对于函数如何进行拷贝</h4><p>前几天面试问到了..</p>\n<p>我的想法，有三种方式，</p>\n<p>​    <strong>第一种：使用toString，然后再使用eval。</strong>    </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let fn = function () &#123;</span><br><span class=\"line\">  console.log(1);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function fn1() &#123;</span><br><span class=\"line\">  console.log(1)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">这里我对于eval函数的使用还是不够了解。</span><br><span class=\"line\">这里，我不知道为什么， eval(fn.toString()) 没有返回值，所以我写了一个箭头函数字符串进行包装和执行。</span><br><span class=\"line\">\t这里，需要使用一个箭头函数进行包装，如果使用普通函数进行包装。也没有用处。</span><br><span class=\"line\">let fn2 = eval(&#x27;() =&gt; &#x27; + fn1.toString())(); //这里，fn和fn1都可以运行。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">这样写也可以。</span><br><span class=\"line\">eval(`</span><br><span class=\"line\">  (() =&gt; fn)()</span><br><span class=\"line\">`)()</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">应该是因为需要使用()进行包裹.</span><br><span class=\"line\">let a = eval(`</span><br><span class=\"line\">  (function fn() &#123;</span><br><span class=\"line\">    console.log(1);</span><br><span class=\"line\">    return 1;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">`);</span><br><span class=\"line\">a()</span><br><span class=\"line\">console.log(a.toString())</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1</span><br><span class=\"line\">function fn() &#123;</span><br><span class=\"line\">    console.log(1);</span><br><span class=\"line\">    return 1;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<p>​    </p>\n<p><strong>第二种：使用new Function(‘return ‘ + func.toString())();</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let f = new Function(&#x27;return &#x27; + fn.toString())()</span><br><span class=\"line\"></span><br><span class=\"line\">f();</span><br></pre></td></tr></table></figure>\n\n<p>​    <strong>第三种：使用bind函数进行一次绑定。但是这个对于有传参的函数会有所不同。</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">这个有个要求，因为bind函数实则就是对于一个函数进行了call方法，但是是一个延迟的调用。</span><br><span class=\"line\"></span><br><span class=\"line\">从一个简单的逻辑来说，应该是并没有进行一个从底层复制操作的。因为是直接进行的 简单赋值。</span><br><span class=\"line\"></span><br><span class=\"line\">let f = fn.bind()</span><br><span class=\"line\">f();</span><br></pre></td></tr></table></figure>\n\n"},{"title":"call,apply,bind实现","date":"2021-10-18T06:04:16.000Z","_content":"\n\n\n#  call,apply,bind源码的实现\n\n\n\n## call方法\n\n使用，就是替换了this的指向，传参使用的基本传参。\n\n```\n这里将方法写在了Function函数的原型里面，这样因为通过原型链就可以找到这个方法了。\nFunction.prototype.myCall = function (ctx) {\n  ctx = ctx || window;\n\n  //这里这个this，指向的就是方法。这里使用Symbol，用于避免出现方法重复。\n  const fn = Symbol('fn');\n  ctx[fn] = this;\n\n  // 获取参数\n  const args = [...arguments].slice(1);\n  // 使用ctx来进行调用。替换了this指向。\n  const result = ctx[fn](...args);\n\n  delete ctx[fn];\n  return result;\n}\n```\n\n```\nfn.call(db, 'cc', 1);\n```\n\n\n\n## apply方法\n\n同上，传参使用的是数组传参。\n\n```\nFunction.prototype.myApply = function (ctx, args) {\n  ctx = ctx || window;\n  \n  const fn = Symbol('fn');\n  ctx[fn] = this;\n  \n  const result = ctx[fn](...args);\n  \n  delete ctx[fn];\n  return result;\n}\n```\n\n```\nfn.apply(db, ['cc', 1]);\n```\n\n\n\n## bind方法\n\n同call方法的参数，但是不是马上执行，需要自己执行一次\n\n```\nFunction.prototype.myBind = function (ctx) {\n  ctx = ctx || window;\n  \n  const fn = Symbol('fn');\n  const args = [...arguments].slice(1);\n  \n  ctx[fn] = this;\n  \n  return () => {\n    const result = ctx[fn](...args);\n    delete ctx[fn];\n    \n    return result;\n  }\n}\n```\n\n```\nfn.bind(db, 'cc', 1)();\n```\n\n","source":"_posts/JavaScript/call-apply-bind实现.md","raw":"---\ntitle: 'call,apply,bind实现'\ndate: 2021-10-18 14:04:16\ntags:\n - JavaScript\n - call\n - apply\n - bind\n - 源码\ncategories:\n - [JavaScript, Global_Objects]\n - [JavaScript, Global_Objects]\n - [JavaScript, Global_Objects]\n---\n\n\n\n#  call,apply,bind源码的实现\n\n\n\n## call方法\n\n使用，就是替换了this的指向，传参使用的基本传参。\n\n```\n这里将方法写在了Function函数的原型里面，这样因为通过原型链就可以找到这个方法了。\nFunction.prototype.myCall = function (ctx) {\n  ctx = ctx || window;\n\n  //这里这个this，指向的就是方法。这里使用Symbol，用于避免出现方法重复。\n  const fn = Symbol('fn');\n  ctx[fn] = this;\n\n  // 获取参数\n  const args = [...arguments].slice(1);\n  // 使用ctx来进行调用。替换了this指向。\n  const result = ctx[fn](...args);\n\n  delete ctx[fn];\n  return result;\n}\n```\n\n```\nfn.call(db, 'cc', 1);\n```\n\n\n\n## apply方法\n\n同上，传参使用的是数组传参。\n\n```\nFunction.prototype.myApply = function (ctx, args) {\n  ctx = ctx || window;\n  \n  const fn = Symbol('fn');\n  ctx[fn] = this;\n  \n  const result = ctx[fn](...args);\n  \n  delete ctx[fn];\n  return result;\n}\n```\n\n```\nfn.apply(db, ['cc', 1]);\n```\n\n\n\n## bind方法\n\n同call方法的参数，但是不是马上执行，需要自己执行一次\n\n```\nFunction.prototype.myBind = function (ctx) {\n  ctx = ctx || window;\n  \n  const fn = Symbol('fn');\n  const args = [...arguments].slice(1);\n  \n  ctx[fn] = this;\n  \n  return () => {\n    const result = ctx[fn](...args);\n    delete ctx[fn];\n    \n    return result;\n  }\n}\n```\n\n```\nfn.bind(db, 'cc', 1)();\n```\n\n","slug":"JavaScript/call-apply-bind实现","published":1,"updated":"2021-12-09T01:56:49.404Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckznhkk7o002wikub98x1hrlt","content":"<h1 id=\"call-apply-bind源码的实现\"><a href=\"#call-apply-bind源码的实现\" class=\"headerlink\" title=\"call,apply,bind源码的实现\"></a>call,apply,bind源码的实现</h1><h2 id=\"call方法\"><a href=\"#call方法\" class=\"headerlink\" title=\"call方法\"></a>call方法</h2><p>使用，就是替换了this的指向，传参使用的基本传参。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">这里将方法写在了Function函数的原型里面，这样因为通过原型链就可以找到这个方法了。</span><br><span class=\"line\">Function.prototype.myCall = function (ctx) &#123;</span><br><span class=\"line\">  ctx = ctx || window;</span><br><span class=\"line\"></span><br><span class=\"line\">  //这里这个this，指向的就是方法。这里使用Symbol，用于避免出现方法重复。</span><br><span class=\"line\">  const fn = Symbol(&#x27;fn&#x27;);</span><br><span class=\"line\">  ctx[fn] = this;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 获取参数</span><br><span class=\"line\">  const args = [...arguments].slice(1);</span><br><span class=\"line\">  // 使用ctx来进行调用。替换了this指向。</span><br><span class=\"line\">  const result = ctx[fn](...args);</span><br><span class=\"line\"></span><br><span class=\"line\">  delete ctx[fn];</span><br><span class=\"line\">  return result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fn.call(db, &#x27;cc&#x27;, 1);</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"apply方法\"><a href=\"#apply方法\" class=\"headerlink\" title=\"apply方法\"></a>apply方法</h2><p>同上，传参使用的是数组传参。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Function.prototype.myApply = function (ctx, args) &#123;</span><br><span class=\"line\">  ctx = ctx || window;</span><br><span class=\"line\">  </span><br><span class=\"line\">  const fn = Symbol(&#x27;fn&#x27;);</span><br><span class=\"line\">  ctx[fn] = this;</span><br><span class=\"line\">  </span><br><span class=\"line\">  const result = ctx[fn](...args);</span><br><span class=\"line\">  </span><br><span class=\"line\">  delete ctx[fn];</span><br><span class=\"line\">  return result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fn.apply(db, [&#x27;cc&#x27;, 1]);</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"bind方法\"><a href=\"#bind方法\" class=\"headerlink\" title=\"bind方法\"></a>bind方法</h2><p>同call方法的参数，但是不是马上执行，需要自己执行一次</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Function.prototype.myBind = function (ctx) &#123;</span><br><span class=\"line\">  ctx = ctx || window;</span><br><span class=\"line\">  </span><br><span class=\"line\">  const fn = Symbol(&#x27;fn&#x27;);</span><br><span class=\"line\">  const args = [...arguments].slice(1);</span><br><span class=\"line\">  </span><br><span class=\"line\">  ctx[fn] = this;</span><br><span class=\"line\">  </span><br><span class=\"line\">  return () =&gt; &#123;</span><br><span class=\"line\">    const result = ctx[fn](...args);</span><br><span class=\"line\">    delete ctx[fn];</span><br><span class=\"line\">    </span><br><span class=\"line\">    return result;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fn.bind(db, &#x27;cc&#x27;, 1)();</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"call-apply-bind源码的实现\"><a href=\"#call-apply-bind源码的实现\" class=\"headerlink\" title=\"call,apply,bind源码的实现\"></a>call,apply,bind源码的实现</h1><h2 id=\"call方法\"><a href=\"#call方法\" class=\"headerlink\" title=\"call方法\"></a>call方法</h2><p>使用，就是替换了this的指向，传参使用的基本传参。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">这里将方法写在了Function函数的原型里面，这样因为通过原型链就可以找到这个方法了。</span><br><span class=\"line\">Function.prototype.myCall = function (ctx) &#123;</span><br><span class=\"line\">  ctx = ctx || window;</span><br><span class=\"line\"></span><br><span class=\"line\">  //这里这个this，指向的就是方法。这里使用Symbol，用于避免出现方法重复。</span><br><span class=\"line\">  const fn = Symbol(&#x27;fn&#x27;);</span><br><span class=\"line\">  ctx[fn] = this;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 获取参数</span><br><span class=\"line\">  const args = [...arguments].slice(1);</span><br><span class=\"line\">  // 使用ctx来进行调用。替换了this指向。</span><br><span class=\"line\">  const result = ctx[fn](...args);</span><br><span class=\"line\"></span><br><span class=\"line\">  delete ctx[fn];</span><br><span class=\"line\">  return result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fn.call(db, &#x27;cc&#x27;, 1);</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"apply方法\"><a href=\"#apply方法\" class=\"headerlink\" title=\"apply方法\"></a>apply方法</h2><p>同上，传参使用的是数组传参。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Function.prototype.myApply = function (ctx, args) &#123;</span><br><span class=\"line\">  ctx = ctx || window;</span><br><span class=\"line\">  </span><br><span class=\"line\">  const fn = Symbol(&#x27;fn&#x27;);</span><br><span class=\"line\">  ctx[fn] = this;</span><br><span class=\"line\">  </span><br><span class=\"line\">  const result = ctx[fn](...args);</span><br><span class=\"line\">  </span><br><span class=\"line\">  delete ctx[fn];</span><br><span class=\"line\">  return result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fn.apply(db, [&#x27;cc&#x27;, 1]);</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"bind方法\"><a href=\"#bind方法\" class=\"headerlink\" title=\"bind方法\"></a>bind方法</h2><p>同call方法的参数，但是不是马上执行，需要自己执行一次</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Function.prototype.myBind = function (ctx) &#123;</span><br><span class=\"line\">  ctx = ctx || window;</span><br><span class=\"line\">  </span><br><span class=\"line\">  const fn = Symbol(&#x27;fn&#x27;);</span><br><span class=\"line\">  const args = [...arguments].slice(1);</span><br><span class=\"line\">  </span><br><span class=\"line\">  ctx[fn] = this;</span><br><span class=\"line\">  </span><br><span class=\"line\">  return () =&gt; &#123;</span><br><span class=\"line\">    const result = ctx[fn](...args);</span><br><span class=\"line\">    delete ctx[fn];</span><br><span class=\"line\">    </span><br><span class=\"line\">    return result;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fn.bind(db, &#x27;cc&#x27;, 1)();</span><br></pre></td></tr></table></figure>\n\n"},{"title":"WebWorker","date":"2021-11-06T06:49:25.000Z","_content":"\n\n\n#  WebWorker\n\n参考文章\n\n```\nhttp://www.ruanyifeng.com/blog/2018/07/web-worker.html\nhttps://developer.mozilla.org/zh-CN/docs/Web/API/Web_Workers_API\n```\n\n\n\n## 是什么\n\n​\t\t简单来说就是为JavaScript提供了多线程。一些计算密集型或高延迟的任务，被 Worker 线程负担了，主线程（通常负责 UI 交互）就会很流畅，不会被阻塞或拖慢。\n\n\n\n**注意点**：\n\n* 同源的限制\n* 无法使用DOM对象，document，window，parent对象，可以使用navigator 和 location 对象。\n* 和主线程通过消息进行通信\n* 不能使用 alert 和 confirm 方法，但是可以使用 XMLHttpRequest 对象发出 AJAX 请求。\n* 无法读取本地文件。\n\n\n\n**用法**：\n\n使用 new 调用 worker 函数，创建一个线程\n\n```\nconst worker = new Worker('xx.js');\n```\n\n​\t\t参数是一个脚本文件，这个文件必须来自网络\n\n\n\n### 主线程：\n\n主线程通过 worker.postMessage() 向Worker发送消息\n\n```\nworker.postMessage('Hello World');\nworker.postMessage({method: 'echo', args: ['Work']});\n```\n\n​\t\t参数就是传给worker的数据\n\n\n\n主线程通过 worker.onmessage 监听函数，接收子线程发回的消息\n\n```\nworker.onmessage = function (event) {\n\tevent.data.log;\n}\n```\n\n​\t\t事件对象的data属性可以获取 worker发来的数据\n\n\n\n主线程关闭worker线程\n\n```\nworker.terminate();\n```\n\n\n\n### Worker线程\n\nworker线程需要一个监听函数，监听 message 事件\n\n```\nself.addEventListener('message', function(e) {\n\tself.postMessage('said: ', e.data);\n})\n```\n\n​\t\t`self`代表子线程自身，即子线程的全局对象\n\n所以等同于 this. 和 直接创建\n\n```\nthis.addEventListener();\naddEventListener();\n```\n\n​\t\t也可以使用 self.onmessage 指定\n\n```\nself.onmessage = function (e) {\n\tself.postMessage('said: ', e.data);\n}\n```\n\n​\t\t监听函数的参数是一个事件对象，data属性是主线程发来的数据\n\n\n\nself.postMessage() 方法用来向主线程发送消息\n\n\n\nself.close() 用于在Worker内部关闭自身。\n\n\n\n# API\n\n## 创建API\n\n```\nconst worker = new Worker(jsUrl, options);\n\nvar myWorker = new Worker('worker.js', { name : 'myWorker' });\n```\n\n​\t\tjsUrl,脚本网址,遵守同源策略，必须且是js脚本\n\n​\t\toptions是一个配置对象，其中一个作用就是指定worker名称用来区分线程。\n\n\n\n## 主线程使用API\n\n```\nWorker.onerror\n\t指定 error 事件的监听函数。\nWorker.onmessage\n\t指定 message 事件的监听函数，发送过来的数据在Event.data属性中。\nWorker.onmessageerror\n\t指定 messageerror 事件的监听函数。发送的数据无法序列化成字符串时，会触发这个事件。\nWorker.postMessage()\n\t向 Worker 线程发送消息。\nWorker.terminate()\n\t立即终止 Worker 线程。\n```\n\n\n\n## Worker线程使用API\n\n```\nself.name\n\tWorker 的名字。该属性只读，由构造函数指定。\nself.onmessage\n\t指定message事件的监听函数。\nself.onmessageerror\n\t指定 messageerror 事件的监听函数。发送的数据无法序列化成字符串时，会触发这个事件。\nself.close()\n\t关闭 Worker 线程。\nself.postMessage()\n\t向产生这个 Worker 线程发送消息。\nself.importScripts()\n\t加载 JS 脚本。\n```\n\n","source":"_posts/JavaScript/WebWorker.md","raw":"---\ntitle: WebWorker\ndate: 2021-11-06 14:49:25\ntags:\n - JavaScript\n - WebWorker\n - 随笔\ncategories:\n - 随笔\n---\n\n\n\n#  WebWorker\n\n参考文章\n\n```\nhttp://www.ruanyifeng.com/blog/2018/07/web-worker.html\nhttps://developer.mozilla.org/zh-CN/docs/Web/API/Web_Workers_API\n```\n\n\n\n## 是什么\n\n​\t\t简单来说就是为JavaScript提供了多线程。一些计算密集型或高延迟的任务，被 Worker 线程负担了，主线程（通常负责 UI 交互）就会很流畅，不会被阻塞或拖慢。\n\n\n\n**注意点**：\n\n* 同源的限制\n* 无法使用DOM对象，document，window，parent对象，可以使用navigator 和 location 对象。\n* 和主线程通过消息进行通信\n* 不能使用 alert 和 confirm 方法，但是可以使用 XMLHttpRequest 对象发出 AJAX 请求。\n* 无法读取本地文件。\n\n\n\n**用法**：\n\n使用 new 调用 worker 函数，创建一个线程\n\n```\nconst worker = new Worker('xx.js');\n```\n\n​\t\t参数是一个脚本文件，这个文件必须来自网络\n\n\n\n### 主线程：\n\n主线程通过 worker.postMessage() 向Worker发送消息\n\n```\nworker.postMessage('Hello World');\nworker.postMessage({method: 'echo', args: ['Work']});\n```\n\n​\t\t参数就是传给worker的数据\n\n\n\n主线程通过 worker.onmessage 监听函数，接收子线程发回的消息\n\n```\nworker.onmessage = function (event) {\n\tevent.data.log;\n}\n```\n\n​\t\t事件对象的data属性可以获取 worker发来的数据\n\n\n\n主线程关闭worker线程\n\n```\nworker.terminate();\n```\n\n\n\n### Worker线程\n\nworker线程需要一个监听函数，监听 message 事件\n\n```\nself.addEventListener('message', function(e) {\n\tself.postMessage('said: ', e.data);\n})\n```\n\n​\t\t`self`代表子线程自身，即子线程的全局对象\n\n所以等同于 this. 和 直接创建\n\n```\nthis.addEventListener();\naddEventListener();\n```\n\n​\t\t也可以使用 self.onmessage 指定\n\n```\nself.onmessage = function (e) {\n\tself.postMessage('said: ', e.data);\n}\n```\n\n​\t\t监听函数的参数是一个事件对象，data属性是主线程发来的数据\n\n\n\nself.postMessage() 方法用来向主线程发送消息\n\n\n\nself.close() 用于在Worker内部关闭自身。\n\n\n\n# API\n\n## 创建API\n\n```\nconst worker = new Worker(jsUrl, options);\n\nvar myWorker = new Worker('worker.js', { name : 'myWorker' });\n```\n\n​\t\tjsUrl,脚本网址,遵守同源策略，必须且是js脚本\n\n​\t\toptions是一个配置对象，其中一个作用就是指定worker名称用来区分线程。\n\n\n\n## 主线程使用API\n\n```\nWorker.onerror\n\t指定 error 事件的监听函数。\nWorker.onmessage\n\t指定 message 事件的监听函数，发送过来的数据在Event.data属性中。\nWorker.onmessageerror\n\t指定 messageerror 事件的监听函数。发送的数据无法序列化成字符串时，会触发这个事件。\nWorker.postMessage()\n\t向 Worker 线程发送消息。\nWorker.terminate()\n\t立即终止 Worker 线程。\n```\n\n\n\n## Worker线程使用API\n\n```\nself.name\n\tWorker 的名字。该属性只读，由构造函数指定。\nself.onmessage\n\t指定message事件的监听函数。\nself.onmessageerror\n\t指定 messageerror 事件的监听函数。发送的数据无法序列化成字符串时，会触发这个事件。\nself.close()\n\t关闭 Worker 线程。\nself.postMessage()\n\t向产生这个 Worker 线程发送消息。\nself.importScripts()\n\t加载 JS 脚本。\n```\n\n","slug":"JavaScript/WebWorker","published":1,"updated":"2021-12-09T01:56:49.404Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckznhkk7p002xikubfy49ht31","content":"<h1 id=\"WebWorker\"><a href=\"#WebWorker\" class=\"headerlink\" title=\"WebWorker\"></a>WebWorker</h1><p>参考文章</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http://www.ruanyifeng.com/blog/2018/07/web-worker.html</span><br><span class=\"line\">https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Workers_API</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"是什么\"><a href=\"#是什么\" class=\"headerlink\" title=\"是什么\"></a>是什么</h2><p>​        简单来说就是为JavaScript提供了多线程。一些计算密集型或高延迟的任务，被 Worker 线程负担了，主线程（通常负责 UI 交互）就会很流畅，不会被阻塞或拖慢。</p>\n<p><strong>注意点</strong>：</p>\n<ul>\n<li>同源的限制</li>\n<li>无法使用DOM对象，document，window，parent对象，可以使用navigator 和 location 对象。</li>\n<li>和主线程通过消息进行通信</li>\n<li>不能使用 alert 和 confirm 方法，但是可以使用 XMLHttpRequest 对象发出 AJAX 请求。</li>\n<li>无法读取本地文件。</li>\n</ul>\n<p><strong>用法</strong>：</p>\n<p>使用 new 调用 worker 函数，创建一个线程</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const worker = new Worker(&#x27;xx.js&#x27;);</span><br></pre></td></tr></table></figure>\n\n<p>​        参数是一个脚本文件，这个文件必须来自网络</p>\n<h3 id=\"主线程：\"><a href=\"#主线程：\" class=\"headerlink\" title=\"主线程：\"></a>主线程：</h3><p>主线程通过 worker.postMessage() 向Worker发送消息</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">worker.postMessage(&#x27;Hello World&#x27;);</span><br><span class=\"line\">worker.postMessage(&#123;method: &#x27;echo&#x27;, args: [&#x27;Work&#x27;]&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>​        参数就是传给worker的数据</p>\n<p>主线程通过 worker.onmessage 监听函数，接收子线程发回的消息</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">worker.onmessage = function (event) &#123;</span><br><span class=\"line\">\tevent.data.log;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>​        事件对象的data属性可以获取 worker发来的数据</p>\n<p>主线程关闭worker线程</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">worker.terminate();</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"Worker线程\"><a href=\"#Worker线程\" class=\"headerlink\" title=\"Worker线程\"></a>Worker线程</h3><p>worker线程需要一个监听函数，监听 message 事件</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">self.addEventListener(&#x27;message&#x27;, function(e) &#123;</span><br><span class=\"line\">\tself.postMessage(&#x27;said: &#x27;, e.data);</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>​        <code>self</code>代表子线程自身，即子线程的全局对象</p>\n<p>所以等同于 this. 和 直接创建</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">this.addEventListener();</span><br><span class=\"line\">addEventListener();</span><br></pre></td></tr></table></figure>\n\n<p>​        也可以使用 self.onmessage 指定</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">self.onmessage = function (e) &#123;</span><br><span class=\"line\">\tself.postMessage(&#x27;said: &#x27;, e.data);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>​        监听函数的参数是一个事件对象，data属性是主线程发来的数据</p>\n<p>self.postMessage() 方法用来向主线程发送消息</p>\n<p>self.close() 用于在Worker内部关闭自身。</p>\n<h1 id=\"API\"><a href=\"#API\" class=\"headerlink\" title=\"API\"></a>API</h1><h2 id=\"创建API\"><a href=\"#创建API\" class=\"headerlink\" title=\"创建API\"></a>创建API</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const worker = new Worker(jsUrl, options);</span><br><span class=\"line\"></span><br><span class=\"line\">var myWorker = new Worker(&#x27;worker.js&#x27;, &#123; name : &#x27;myWorker&#x27; &#125;);</span><br></pre></td></tr></table></figure>\n\n<p>​        jsUrl,脚本网址,遵守同源策略，必须且是js脚本</p>\n<p>​        options是一个配置对象，其中一个作用就是指定worker名称用来区分线程。</p>\n<h2 id=\"主线程使用API\"><a href=\"#主线程使用API\" class=\"headerlink\" title=\"主线程使用API\"></a>主线程使用API</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Worker.onerror</span><br><span class=\"line\">\t指定 error 事件的监听函数。</span><br><span class=\"line\">Worker.onmessage</span><br><span class=\"line\">\t指定 message 事件的监听函数，发送过来的数据在Event.data属性中。</span><br><span class=\"line\">Worker.onmessageerror</span><br><span class=\"line\">\t指定 messageerror 事件的监听函数。发送的数据无法序列化成字符串时，会触发这个事件。</span><br><span class=\"line\">Worker.postMessage()</span><br><span class=\"line\">\t向 Worker 线程发送消息。</span><br><span class=\"line\">Worker.terminate()</span><br><span class=\"line\">\t立即终止 Worker 线程。</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"Worker线程使用API\"><a href=\"#Worker线程使用API\" class=\"headerlink\" title=\"Worker线程使用API\"></a>Worker线程使用API</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">self.name</span><br><span class=\"line\">\tWorker 的名字。该属性只读，由构造函数指定。</span><br><span class=\"line\">self.onmessage</span><br><span class=\"line\">\t指定message事件的监听函数。</span><br><span class=\"line\">self.onmessageerror</span><br><span class=\"line\">\t指定 messageerror 事件的监听函数。发送的数据无法序列化成字符串时，会触发这个事件。</span><br><span class=\"line\">self.close()</span><br><span class=\"line\">\t关闭 Worker 线程。</span><br><span class=\"line\">self.postMessage()</span><br><span class=\"line\">\t向产生这个 Worker 线程发送消息。</span><br><span class=\"line\">self.importScripts()</span><br><span class=\"line\">\t加载 JS 脚本。</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"WebWorker\"><a href=\"#WebWorker\" class=\"headerlink\" title=\"WebWorker\"></a>WebWorker</h1><p>参考文章</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http://www.ruanyifeng.com/blog/2018/07/web-worker.html</span><br><span class=\"line\">https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Workers_API</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"是什么\"><a href=\"#是什么\" class=\"headerlink\" title=\"是什么\"></a>是什么</h2><p>​        简单来说就是为JavaScript提供了多线程。一些计算密集型或高延迟的任务，被 Worker 线程负担了，主线程（通常负责 UI 交互）就会很流畅，不会被阻塞或拖慢。</p>\n<p><strong>注意点</strong>：</p>\n<ul>\n<li>同源的限制</li>\n<li>无法使用DOM对象，document，window，parent对象，可以使用navigator 和 location 对象。</li>\n<li>和主线程通过消息进行通信</li>\n<li>不能使用 alert 和 confirm 方法，但是可以使用 XMLHttpRequest 对象发出 AJAX 请求。</li>\n<li>无法读取本地文件。</li>\n</ul>\n<p><strong>用法</strong>：</p>\n<p>使用 new 调用 worker 函数，创建一个线程</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const worker = new Worker(&#x27;xx.js&#x27;);</span><br></pre></td></tr></table></figure>\n\n<p>​        参数是一个脚本文件，这个文件必须来自网络</p>\n<h3 id=\"主线程：\"><a href=\"#主线程：\" class=\"headerlink\" title=\"主线程：\"></a>主线程：</h3><p>主线程通过 worker.postMessage() 向Worker发送消息</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">worker.postMessage(&#x27;Hello World&#x27;);</span><br><span class=\"line\">worker.postMessage(&#123;method: &#x27;echo&#x27;, args: [&#x27;Work&#x27;]&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>​        参数就是传给worker的数据</p>\n<p>主线程通过 worker.onmessage 监听函数，接收子线程发回的消息</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">worker.onmessage = function (event) &#123;</span><br><span class=\"line\">\tevent.data.log;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>​        事件对象的data属性可以获取 worker发来的数据</p>\n<p>主线程关闭worker线程</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">worker.terminate();</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"Worker线程\"><a href=\"#Worker线程\" class=\"headerlink\" title=\"Worker线程\"></a>Worker线程</h3><p>worker线程需要一个监听函数，监听 message 事件</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">self.addEventListener(&#x27;message&#x27;, function(e) &#123;</span><br><span class=\"line\">\tself.postMessage(&#x27;said: &#x27;, e.data);</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>​        <code>self</code>代表子线程自身，即子线程的全局对象</p>\n<p>所以等同于 this. 和 直接创建</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">this.addEventListener();</span><br><span class=\"line\">addEventListener();</span><br></pre></td></tr></table></figure>\n\n<p>​        也可以使用 self.onmessage 指定</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">self.onmessage = function (e) &#123;</span><br><span class=\"line\">\tself.postMessage(&#x27;said: &#x27;, e.data);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>​        监听函数的参数是一个事件对象，data属性是主线程发来的数据</p>\n<p>self.postMessage() 方法用来向主线程发送消息</p>\n<p>self.close() 用于在Worker内部关闭自身。</p>\n<h1 id=\"API\"><a href=\"#API\" class=\"headerlink\" title=\"API\"></a>API</h1><h2 id=\"创建API\"><a href=\"#创建API\" class=\"headerlink\" title=\"创建API\"></a>创建API</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const worker = new Worker(jsUrl, options);</span><br><span class=\"line\"></span><br><span class=\"line\">var myWorker = new Worker(&#x27;worker.js&#x27;, &#123; name : &#x27;myWorker&#x27; &#125;);</span><br></pre></td></tr></table></figure>\n\n<p>​        jsUrl,脚本网址,遵守同源策略，必须且是js脚本</p>\n<p>​        options是一个配置对象，其中一个作用就是指定worker名称用来区分线程。</p>\n<h2 id=\"主线程使用API\"><a href=\"#主线程使用API\" class=\"headerlink\" title=\"主线程使用API\"></a>主线程使用API</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Worker.onerror</span><br><span class=\"line\">\t指定 error 事件的监听函数。</span><br><span class=\"line\">Worker.onmessage</span><br><span class=\"line\">\t指定 message 事件的监听函数，发送过来的数据在Event.data属性中。</span><br><span class=\"line\">Worker.onmessageerror</span><br><span class=\"line\">\t指定 messageerror 事件的监听函数。发送的数据无法序列化成字符串时，会触发这个事件。</span><br><span class=\"line\">Worker.postMessage()</span><br><span class=\"line\">\t向 Worker 线程发送消息。</span><br><span class=\"line\">Worker.terminate()</span><br><span class=\"line\">\t立即终止 Worker 线程。</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"Worker线程使用API\"><a href=\"#Worker线程使用API\" class=\"headerlink\" title=\"Worker线程使用API\"></a>Worker线程使用API</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">self.name</span><br><span class=\"line\">\tWorker 的名字。该属性只读，由构造函数指定。</span><br><span class=\"line\">self.onmessage</span><br><span class=\"line\">\t指定message事件的监听函数。</span><br><span class=\"line\">self.onmessageerror</span><br><span class=\"line\">\t指定 messageerror 事件的监听函数。发送的数据无法序列化成字符串时，会触发这个事件。</span><br><span class=\"line\">self.close()</span><br><span class=\"line\">\t关闭 Worker 线程。</span><br><span class=\"line\">self.postMessage()</span><br><span class=\"line\">\t向产生这个 Worker 线程发送消息。</span><br><span class=\"line\">self.importScripts()</span><br><span class=\"line\">\t加载 JS 脚本。</span><br></pre></td></tr></table></figure>\n\n"},{"title":"eval函数","date":"2021-10-20T03:01:49.000Z","_content":"\n\n\n#  eval函数\n\n**文档**\n\n```\nhttps://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/eval\n```\n\n\n\n这里学习使用eval函数的原因是, 前几天遇到一个问题是拷贝函数, \n\n所以我就想说,先使用tostring, 然后再使用eval转为函数返回进行使用, 这样就进行了一次函数的复制.\n\n\n\n```\nlet f = eval(`\nfunction fn() {\n  console.log(1);\n  return 2;\n}\n`);\n\nconsole.log(f);\n```\n\n```\n你会发现结果 是不如人意的?我的想法就是这个字符串方法会被转义为一个函数赋值给f.但是却什么都没有,函数没有执行,并且没有返回值.\n\nundefined\n```\n\n然后转念一想.可能是因为虽然转义为函数了,但是没有执行和返回.他只是定义了一下函数而已.\n\n```\nlet f = eval(`\nfunction fn () {\n  console.log(1);\n  return 2;\n};\n`);\n\nfn();\n```\n\n```\n结果真的有输出.所以这样一想.我可以在内部加上一个立即执行函数啊\n```\n\n```\nfunction fn () {\n  console.log(1);\n  return 2;\n};\n\n//我这里只是定义立即执行函数,但是没有执行.只需要使用 f(), 便可以进行函数调用了.\nlet f = eval(`\n  (${fn.toString()})\n`);\n\nconsole.log(f.toString());\nconsole.log(f());\n```\n\n```\n执行结果:\nfunction fn () {\n  console.log(1);\n  return 2;\n}\n1\n2\n```\n\n","source":"_posts/JavaScript/eval函数.md","raw":"---\ntitle: eval函数\ndate: 2021-10-20 11:01:49\ntags:\n - JavaScript\n - eval\ncategories:\n - JavaScript\n - Global_Objects\n---\n\n\n\n#  eval函数\n\n**文档**\n\n```\nhttps://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/eval\n```\n\n\n\n这里学习使用eval函数的原因是, 前几天遇到一个问题是拷贝函数, \n\n所以我就想说,先使用tostring, 然后再使用eval转为函数返回进行使用, 这样就进行了一次函数的复制.\n\n\n\n```\nlet f = eval(`\nfunction fn() {\n  console.log(1);\n  return 2;\n}\n`);\n\nconsole.log(f);\n```\n\n```\n你会发现结果 是不如人意的?我的想法就是这个字符串方法会被转义为一个函数赋值给f.但是却什么都没有,函数没有执行,并且没有返回值.\n\nundefined\n```\n\n然后转念一想.可能是因为虽然转义为函数了,但是没有执行和返回.他只是定义了一下函数而已.\n\n```\nlet f = eval(`\nfunction fn () {\n  console.log(1);\n  return 2;\n};\n`);\n\nfn();\n```\n\n```\n结果真的有输出.所以这样一想.我可以在内部加上一个立即执行函数啊\n```\n\n```\nfunction fn () {\n  console.log(1);\n  return 2;\n};\n\n//我这里只是定义立即执行函数,但是没有执行.只需要使用 f(), 便可以进行函数调用了.\nlet f = eval(`\n  (${fn.toString()})\n`);\n\nconsole.log(f.toString());\nconsole.log(f());\n```\n\n```\n执行结果:\nfunction fn () {\n  console.log(1);\n  return 2;\n}\n1\n2\n```\n\n","slug":"JavaScript/eval函数","published":1,"updated":"2021-12-09T01:56:49.404Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckznhkk7p0030ikub6ztw308p","content":"<h1 id=\"eval函数\"><a href=\"#eval函数\" class=\"headerlink\" title=\"eval函数\"></a>eval函数</h1><p><strong>文档</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/eval</span><br></pre></td></tr></table></figure>\n\n\n\n<p>这里学习使用eval函数的原因是, 前几天遇到一个问题是拷贝函数, </p>\n<p>所以我就想说,先使用tostring, 然后再使用eval转为函数返回进行使用, 这样就进行了一次函数的复制.</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let f = eval(`</span><br><span class=\"line\">function fn() &#123;</span><br><span class=\"line\">  console.log(1);</span><br><span class=\"line\">  return 2;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">`);</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(f);</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">你会发现结果 是不如人意的?我的想法就是这个字符串方法会被转义为一个函数赋值给f.但是却什么都没有,函数没有执行,并且没有返回值.</span><br><span class=\"line\"></span><br><span class=\"line\">undefined</span><br></pre></td></tr></table></figure>\n\n<p>然后转念一想.可能是因为虽然转义为函数了,但是没有执行和返回.他只是定义了一下函数而已.</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let f = eval(`</span><br><span class=\"line\">function fn () &#123;</span><br><span class=\"line\">  console.log(1);</span><br><span class=\"line\">  return 2;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">`);</span><br><span class=\"line\"></span><br><span class=\"line\">fn();</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">结果真的有输出.所以这样一想.我可以在内部加上一个立即执行函数啊</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function fn () &#123;</span><br><span class=\"line\">  console.log(1);</span><br><span class=\"line\">  return 2;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">//我这里只是定义立即执行函数,但是没有执行.只需要使用 f(), 便可以进行函数调用了.</span><br><span class=\"line\">let f = eval(`</span><br><span class=\"line\">  ($&#123;fn.toString()&#125;)</span><br><span class=\"line\">`);</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(f.toString());</span><br><span class=\"line\">console.log(f());</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">执行结果:</span><br><span class=\"line\">function fn () &#123;</span><br><span class=\"line\">  console.log(1);</span><br><span class=\"line\">  return 2;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"eval函数\"><a href=\"#eval函数\" class=\"headerlink\" title=\"eval函数\"></a>eval函数</h1><p><strong>文档</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/eval</span><br></pre></td></tr></table></figure>\n\n\n\n<p>这里学习使用eval函数的原因是, 前几天遇到一个问题是拷贝函数, </p>\n<p>所以我就想说,先使用tostring, 然后再使用eval转为函数返回进行使用, 这样就进行了一次函数的复制.</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let f = eval(`</span><br><span class=\"line\">function fn() &#123;</span><br><span class=\"line\">  console.log(1);</span><br><span class=\"line\">  return 2;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">`);</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(f);</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">你会发现结果 是不如人意的?我的想法就是这个字符串方法会被转义为一个函数赋值给f.但是却什么都没有,函数没有执行,并且没有返回值.</span><br><span class=\"line\"></span><br><span class=\"line\">undefined</span><br></pre></td></tr></table></figure>\n\n<p>然后转念一想.可能是因为虽然转义为函数了,但是没有执行和返回.他只是定义了一下函数而已.</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let f = eval(`</span><br><span class=\"line\">function fn () &#123;</span><br><span class=\"line\">  console.log(1);</span><br><span class=\"line\">  return 2;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">`);</span><br><span class=\"line\"></span><br><span class=\"line\">fn();</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">结果真的有输出.所以这样一想.我可以在内部加上一个立即执行函数啊</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function fn () &#123;</span><br><span class=\"line\">  console.log(1);</span><br><span class=\"line\">  return 2;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">//我这里只是定义立即执行函数,但是没有执行.只需要使用 f(), 便可以进行函数调用了.</span><br><span class=\"line\">let f = eval(`</span><br><span class=\"line\">  ($&#123;fn.toString()&#125;)</span><br><span class=\"line\">`);</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(f.toString());</span><br><span class=\"line\">console.log(f());</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">执行结果:</span><br><span class=\"line\">function fn () &#123;</span><br><span class=\"line\">  console.log(1);</span><br><span class=\"line\">  return 2;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td></tr></table></figure>\n\n"},{"title":"数组的方法","date":"2021-11-14T02:04:13.000Z","_content":"\n\n\n#  数组的方法\n\n```\nhttps://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array\n```\n\n\n\n## 静态方法\n\n### from\n\n[`Array.from()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/from)\n\n​\t\t从类数组对象或者可迭代对象中创建一个新的数组实例\n\n​\t\t就是生成一个数组\n\n### isArray\n\n[`Array.isArray()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray)\n\n​\t\t用来判断某个变量是否是一个数组对象\n\n### of\n\n[`Array.of()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/of)\n\n​\t根据一组参数来创建新的数组实例，支持任意的参数数量和类型\n\n```\nArray.of(1, 4)\n[1, 4]\n```\n\n\n\n## 实例方法\n\n### concat\n\n[`Array.prototype.concat()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/concat)\n\n​\t\t用于合并两个或多个数组。此方法不会更改现有数组，而是返回一个新数组\n\n```\na.concat(b)\n也可以使用下面这个方式进行合并。\n[...a, ...b]\n```\n\n\n\n### copyWithin\n\n[`Array.prototype.copyWithin()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin)\n\n​\t\t浅复制数组的一部分到同一数组中的另一个位置，并返回它，不会改变原数组的长度\n\n​\t\t注意，这个是浅复制。\n\n\n\n### entries\n\n[`Array.prototype.entries()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/entries)\n\n​\t\t返回一个新的 `Array Iterator` 对象，该对象包含数组中每个索引的键/值对\n\n​\t\tIterator 是一个迭代器，有的循环需要使用迭代器进行循环。\n\n\n\n### every\n\n[`Array.prototype.every()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/every)\n\n​\t\t测试一个数组内的所有元素是否都能通过某个指定函数的测试。它返回一个布尔值\n\n​\t\tevery里面有两个参数，一个是回调函数，一个是this的指向。\n\n​\t\tevery里面是一个回调函数，然后回调函数的参数分别为 值，下标和原数组本身，然后会执行里面的方法，进行Boolean进行判断是否为true，只有所有的数组都为true才为true。\n\n​\t\t这里，为什么我会认为是使用的Boolean()来对返回值进行的判断呢。因为如果你 return []; 发现是true，但是如果你对 []==true 发现是false，所以他是使用的Boolean进行的判断。\n\n```\nconsole.log(a.every((value, index, arr) => {\n  return value == index;\n}))\n```\n\n​\t\t简易实现：\n\n```\nArray.prototype.every = function (callback, thisArg) {\n  let arr = this;\n  thisArg = thisArg || this;\n  for (const key in arr) {\n    if (!Boolean(callback.call(thisArg, arr[key], key, arr))) {\n      return false;\n    }\n  }\n  return true;\n}\n```\n\n\n\n### fill\n\n[`Array.prototype.fill()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/fill)\n\n​\t\t用一个固定值填充一个数组中从起始索引到终止索引内的全部元素\n\n​\t\t有三个参数，第一个是必须的。三个参数分别是：填充值value，起始索引start，终止索引end。\n\n\n\n### filter\n\n[`Array.prototype.filter()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/filter)\n\n​\t\t创建一个新数组, 其包含通过所提供函数实现的测试的所有元素\n\n​\t\t里面的参数也是一样，一个回调和一个this指向。\n\n​\t\t使用方式和上面的every一样，这个回调函数的作用是将返回true的加入一个数组，最后再将这个数组返回，常用于过滤条件。\n\n\n\n### find\n\n[`Array.prototype.find()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/find)\n\n​\t\t返回数组中满足提供的测试函数的第一个元素的值。否则返回 `undefined`\n\n​\t\t参数还是一样，一个回调一个this指向\n\n​\t\t会将第一个满足的尽心返回便结束，并不会返回一个数组，只是返回单个元素。 或者 undefined\n\n\n\n### findIndex\n\n[`Array.prototype.findIndex()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex)\n\n​\t\t返回数组中满足提供的测试函数的第一个元素的**索引**。若没有找到对应元素则返回 `-1`\n\n​\t\t同上 callback，thisArg\n\n​\t\t效果：返回通过的第一个的索引，或者 -1\n\n\n\n### flat\n\n[`Array.prototype.flat()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/flat)\n\n​\t\t按照一个可指定的深度递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回\n\n​\t\t常用于数组的扁平化操作，参数是递归的深度。\n\n```\nlet a = [1, 5, 2, [1], [[[[[[[[[2, 3]]]]]]]]]];\nconsole.log(a.flat(Infinity))\n\n[ 1, 5, 2, 1, 2, 3 ]\n```\n\n\n\n### flatMap\n\n[`Array.prototype.flatMap()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/flatMap)\n\n​\t\t使用映射函数映射每个元素，然后将结果压缩成一个新数组\n\n​\t\t简单来说，就是先使用map生成一系列新的数组，然后再使用flat进行扁平化操作，记住是1层的扁平化。\n\n\n\n### forEach\n\n[`Array.prototype.forEach()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach)\n\n​\t\t对数组的每个元素执行一次给定的函数\n\n​\t\t分别是回调函数和一个this指向。会对每个参数都执行一次里面的方法，没有返回值。\n\n\n\n### includes\n\n[`Array.prototype.includes()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/includes)\n\n​\t\t判断一个数组是否包含一个指定的值，如果包含则返回 `true`，否则返回 `false`\n\n​\t\t第一个是指定值，第二个是可选参数index\n\n\n\n### indexOf\n\n[`Array.prototype.indexOf()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf)\n\n​\t\t返回在数组中可以找到一个给定元素的第一个索引，如果不存在，则返回 `-1`\n\n​\t\t第一个是要查找的参数，第一个是从index值开始查找。包含index值\n\n\n\n### join\n\n[`Array.prototype.join()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/join)\n\n​\t\t将一个数组的所有元素连接成一个字符串并返回这个字符串\n\n​\t\t参数是一个分隔符。默认是 ，\n\n\n\n### keys\n\n[`Array.prototype.keys()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/keys)\n\n​\t\t返回一个包含数组中每个索引键的 `Array Iterator` 对象\n\n\n\n### lastIndexOf\n\n[`Array.prototype.lastIndexOf()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/lastIndexOf)\n\n​\t\t返回指定元素在数组中的最后一个的索引，如果不存在则返回 `-1`\n\n​\t\t第一个是要查找的元素，第二个是从此位置开始逆向查找。默认为数组的长度减 1(`arr.length - 1`)，即整个数组都被查找。如果该值大于或等于数组的长度，则整个数组会被查找。如果为负值，将其视为从数组末尾向前的偏移（-1就是最后一个位置。）。即使该值为负，数组仍然会被从后向前查找。如果该值为负时，其绝对值大于数组长度，则方法返回 -1，即数组不会被查找。\n\n```\nlet a = [0, 1, 2];\nconsole.log(a.lastIndexOf(0, 0))\t//0\nconsole.log(a.lastIndexOf(2, -1))\t//2\n```\n\n\n\n### map\n\n[`Array.prototype.map()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/map)\n\n​\t\t返回一个新数组，其结果是该数组中的每个元素是调用一次提供的函数后的返回值\n\n​\t\t第一个是回调函数，第二个是this指向。返回的是调用回调函数之后返回的结果组成的数组。\n\n\n\n### pop\n\n[`Array.prototype.pop()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/pop)\n\n​\t\t从数组中删除最后一个元素，并返回该元素的值\n\n​\t\t是通过的length属性进行的操作，所以如果是在类数组上进行操作，没有length或者length不能转成数字则为0，并返回undefined。\n\n\n\n### push\n\n[`Array.prototype.push()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/push)\n\n​\t\t将一个或多个元素添加到数组的末尾，并返回该数组的新长度\n\n​\t\t同上，使用的length。\n\n\n\n### reduce\n\n[`Array.prototype.reduce()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce)\n\n​\t\t对数组中的每个元素执行一个由您提供的reducer函数（升序执行），将其结果汇总为单个返回值\n\n​\t\t回调函数和一个初始值的参数，回调函数的参数分别为：累计值，当前值，下标和数组\n\n​\t\t行为简单来说就是，如果有初始值则取初始值，如果没有初始值那么便为0，这个初始值会作为回调函数的第一个参数，然后再调用数组进行循环，然后将值返回，用于下一次回调函数的初始值，常用于累加操作。\n\n```\nlet a = [1, 2, 3];\na.reduce((total, cur) => {\n\treturn total + cur;\n}, 0);\n//6\n```\n\n​\t\t回调函数第一次执行时，`accumulator` 和`currentValue`的取值有两种情况：如果调用`reduce()`时提供了`initialValue`，`accumulator`取值为`initialValue`，`currentValue`取数组中的第一个值；如果没有提供 `initialValue`，那么`accumulator`取数组中的第一个值，`currentValue`取数组中的第二个值。\n\n\n\n### reduceRight\n\n[`Array.prototype.reduceRight()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/ReduceRight)\n\n​\t\t接受一个函数作为累加器（accumulator）和数组的每个值（从右到左）将其减少为单个值\n\n​\t\t和reduce差不多，就是这个是从右向左进行的操作。\n\n\n\n### reverse\n\n[`Array.prototype.reverse()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/reverse)\n\n​\t\t将数组中元素的位置颠倒，并返回该数组。该方法会改变原数组\n\n\n\n### shift\n\n[`Array.prototype.shift()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/shift)\n\n​\t\t从数组中删除第一个元素，并返回该元素的值\n\n\n\n### slice\n\n[`Array.prototype.slice()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/slice)\n\n​\t\t提取源数组的一部分并返回一个新数组\n\n​\t\t第一个参数，起始值，默认0。第二个参数结束值。\n\n​\t\t不包含结束值，但是包含起始值\n\n\n\n### come\n\n[`Array.prototype.some()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/some)\n\n​\t\t测试数组中是不是至少有一个元素通过了被提供的函数测试\n\n​\t\t同every，但是一个通过即可。\n\n\n\n### sort\n\n[`Array.prototype.sort()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/sort)\n\n​\t\t对数组元素进行原地排序并返回此数组\n\n​\t\t默认是使用的字符串进行的排序，所以需要自己定义一个排序的形式。\n\n​\t\t参数可选，是一个回调函数**compareFunction**，代表了用于比较的元素。\n\n```\ncompareFunction(a, b) 小于0， 那么a会排到b之前。\ncompareFunction(a, b) 等于0， 那么a和b的位置不会发生改变。\ncompareFunction(a, b) 大于0， 那么b会排到a之前。\n```\n\n\n\n### splice\n\n[`Array.prototype.splice()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/splice)\n\n​\t\t通过删除或替换现有元素或者原地添加新的元素来修改数组,并以数组形式返回被修改的内容\n\n​\t\t参数：startIndex，开始的位置， deleteCount，要删除的个数，默认后面全部删除， item1，item2，要添加的元素。默认不添加。\n\n\n\n### toLocaleString\n\n[`Array.prototype.toLocaleString()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/toLocaleString)\n\n​\t\t返回一个字符串表示数组中的元素。数组中的元素将使用各自的 [`Object.prototype.toLocaleString()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/toLocaleString) 方法转成字符串\n\n​\t\t这个我没有看懂，好像是将数组的内容，按照区域或者类型的规则转换成特殊的字符串。\n\n​\t\t不会修改原数组。\n\n```\nvar prices = ['￥7', 500, 8123, 12];\nprices.toLocaleString('ja-JP', { style: 'currency', currency: 'JPY' });\n\n// \"￥7,￥500,￥8,123,￥12\"\n```\n\n\n\n### toString\n\n[`Array.prototype.toString()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/toString)\n\n​\t\t返回一个字符串表示指定的数组及其元素。数组中的元素将使用各自的 [`Object.prototype.toString()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/toString) 方法转成字符串\n\n​\t\ttoString方法，没啥可说的。\n\n\n\n### unshift\n\n[`Array.prototype.unshift()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/unshift)\n\n​\t\t将一个或多个元素添加到数组的头部，并返回该数组的新长度\n\n\n\n下面这两个和迭代器相关，现在我没有学迭代器，代我们迭代器学了之后再进行了解。\n\n### values\n\n[`Array.prototype.values()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/values)\n\n​\t\t返回一个新的 `Array Iterator 对象`，该对象包含数组每个索引的值\n\n​\t\t返回的是一个迭代器的对象，iterator，使用forof进行循环可以取出值。\n\n\n\n### iterator\n\n[`Array.prototype[@@iterator]()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/@@iterator)\n\n​\t\t返回一个新的 `Array Iterator 对象`，该对象包含数组每个索引的值\n\n​\t\t\n\n","source":"_posts/JavaScript/数组的方法.md","raw":"---\ntitle: 数组的方法\ndate: 2021-11-14 10:04:13\ntags:\n - JavaScript\n - Array\ncategories:\n - JavaScript\n - Array\n---\n\n\n\n#  数组的方法\n\n```\nhttps://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array\n```\n\n\n\n## 静态方法\n\n### from\n\n[`Array.from()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/from)\n\n​\t\t从类数组对象或者可迭代对象中创建一个新的数组实例\n\n​\t\t就是生成一个数组\n\n### isArray\n\n[`Array.isArray()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray)\n\n​\t\t用来判断某个变量是否是一个数组对象\n\n### of\n\n[`Array.of()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/of)\n\n​\t根据一组参数来创建新的数组实例，支持任意的参数数量和类型\n\n```\nArray.of(1, 4)\n[1, 4]\n```\n\n\n\n## 实例方法\n\n### concat\n\n[`Array.prototype.concat()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/concat)\n\n​\t\t用于合并两个或多个数组。此方法不会更改现有数组，而是返回一个新数组\n\n```\na.concat(b)\n也可以使用下面这个方式进行合并。\n[...a, ...b]\n```\n\n\n\n### copyWithin\n\n[`Array.prototype.copyWithin()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin)\n\n​\t\t浅复制数组的一部分到同一数组中的另一个位置，并返回它，不会改变原数组的长度\n\n​\t\t注意，这个是浅复制。\n\n\n\n### entries\n\n[`Array.prototype.entries()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/entries)\n\n​\t\t返回一个新的 `Array Iterator` 对象，该对象包含数组中每个索引的键/值对\n\n​\t\tIterator 是一个迭代器，有的循环需要使用迭代器进行循环。\n\n\n\n### every\n\n[`Array.prototype.every()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/every)\n\n​\t\t测试一个数组内的所有元素是否都能通过某个指定函数的测试。它返回一个布尔值\n\n​\t\tevery里面有两个参数，一个是回调函数，一个是this的指向。\n\n​\t\tevery里面是一个回调函数，然后回调函数的参数分别为 值，下标和原数组本身，然后会执行里面的方法，进行Boolean进行判断是否为true，只有所有的数组都为true才为true。\n\n​\t\t这里，为什么我会认为是使用的Boolean()来对返回值进行的判断呢。因为如果你 return []; 发现是true，但是如果你对 []==true 发现是false，所以他是使用的Boolean进行的判断。\n\n```\nconsole.log(a.every((value, index, arr) => {\n  return value == index;\n}))\n```\n\n​\t\t简易实现：\n\n```\nArray.prototype.every = function (callback, thisArg) {\n  let arr = this;\n  thisArg = thisArg || this;\n  for (const key in arr) {\n    if (!Boolean(callback.call(thisArg, arr[key], key, arr))) {\n      return false;\n    }\n  }\n  return true;\n}\n```\n\n\n\n### fill\n\n[`Array.prototype.fill()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/fill)\n\n​\t\t用一个固定值填充一个数组中从起始索引到终止索引内的全部元素\n\n​\t\t有三个参数，第一个是必须的。三个参数分别是：填充值value，起始索引start，终止索引end。\n\n\n\n### filter\n\n[`Array.prototype.filter()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/filter)\n\n​\t\t创建一个新数组, 其包含通过所提供函数实现的测试的所有元素\n\n​\t\t里面的参数也是一样，一个回调和一个this指向。\n\n​\t\t使用方式和上面的every一样，这个回调函数的作用是将返回true的加入一个数组，最后再将这个数组返回，常用于过滤条件。\n\n\n\n### find\n\n[`Array.prototype.find()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/find)\n\n​\t\t返回数组中满足提供的测试函数的第一个元素的值。否则返回 `undefined`\n\n​\t\t参数还是一样，一个回调一个this指向\n\n​\t\t会将第一个满足的尽心返回便结束，并不会返回一个数组，只是返回单个元素。 或者 undefined\n\n\n\n### findIndex\n\n[`Array.prototype.findIndex()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex)\n\n​\t\t返回数组中满足提供的测试函数的第一个元素的**索引**。若没有找到对应元素则返回 `-1`\n\n​\t\t同上 callback，thisArg\n\n​\t\t效果：返回通过的第一个的索引，或者 -1\n\n\n\n### flat\n\n[`Array.prototype.flat()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/flat)\n\n​\t\t按照一个可指定的深度递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回\n\n​\t\t常用于数组的扁平化操作，参数是递归的深度。\n\n```\nlet a = [1, 5, 2, [1], [[[[[[[[[2, 3]]]]]]]]]];\nconsole.log(a.flat(Infinity))\n\n[ 1, 5, 2, 1, 2, 3 ]\n```\n\n\n\n### flatMap\n\n[`Array.prototype.flatMap()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/flatMap)\n\n​\t\t使用映射函数映射每个元素，然后将结果压缩成一个新数组\n\n​\t\t简单来说，就是先使用map生成一系列新的数组，然后再使用flat进行扁平化操作，记住是1层的扁平化。\n\n\n\n### forEach\n\n[`Array.prototype.forEach()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach)\n\n​\t\t对数组的每个元素执行一次给定的函数\n\n​\t\t分别是回调函数和一个this指向。会对每个参数都执行一次里面的方法，没有返回值。\n\n\n\n### includes\n\n[`Array.prototype.includes()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/includes)\n\n​\t\t判断一个数组是否包含一个指定的值，如果包含则返回 `true`，否则返回 `false`\n\n​\t\t第一个是指定值，第二个是可选参数index\n\n\n\n### indexOf\n\n[`Array.prototype.indexOf()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf)\n\n​\t\t返回在数组中可以找到一个给定元素的第一个索引，如果不存在，则返回 `-1`\n\n​\t\t第一个是要查找的参数，第一个是从index值开始查找。包含index值\n\n\n\n### join\n\n[`Array.prototype.join()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/join)\n\n​\t\t将一个数组的所有元素连接成一个字符串并返回这个字符串\n\n​\t\t参数是一个分隔符。默认是 ，\n\n\n\n### keys\n\n[`Array.prototype.keys()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/keys)\n\n​\t\t返回一个包含数组中每个索引键的 `Array Iterator` 对象\n\n\n\n### lastIndexOf\n\n[`Array.prototype.lastIndexOf()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/lastIndexOf)\n\n​\t\t返回指定元素在数组中的最后一个的索引，如果不存在则返回 `-1`\n\n​\t\t第一个是要查找的元素，第二个是从此位置开始逆向查找。默认为数组的长度减 1(`arr.length - 1`)，即整个数组都被查找。如果该值大于或等于数组的长度，则整个数组会被查找。如果为负值，将其视为从数组末尾向前的偏移（-1就是最后一个位置。）。即使该值为负，数组仍然会被从后向前查找。如果该值为负时，其绝对值大于数组长度，则方法返回 -1，即数组不会被查找。\n\n```\nlet a = [0, 1, 2];\nconsole.log(a.lastIndexOf(0, 0))\t//0\nconsole.log(a.lastIndexOf(2, -1))\t//2\n```\n\n\n\n### map\n\n[`Array.prototype.map()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/map)\n\n​\t\t返回一个新数组，其结果是该数组中的每个元素是调用一次提供的函数后的返回值\n\n​\t\t第一个是回调函数，第二个是this指向。返回的是调用回调函数之后返回的结果组成的数组。\n\n\n\n### pop\n\n[`Array.prototype.pop()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/pop)\n\n​\t\t从数组中删除最后一个元素，并返回该元素的值\n\n​\t\t是通过的length属性进行的操作，所以如果是在类数组上进行操作，没有length或者length不能转成数字则为0，并返回undefined。\n\n\n\n### push\n\n[`Array.prototype.push()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/push)\n\n​\t\t将一个或多个元素添加到数组的末尾，并返回该数组的新长度\n\n​\t\t同上，使用的length。\n\n\n\n### reduce\n\n[`Array.prototype.reduce()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce)\n\n​\t\t对数组中的每个元素执行一个由您提供的reducer函数（升序执行），将其结果汇总为单个返回值\n\n​\t\t回调函数和一个初始值的参数，回调函数的参数分别为：累计值，当前值，下标和数组\n\n​\t\t行为简单来说就是，如果有初始值则取初始值，如果没有初始值那么便为0，这个初始值会作为回调函数的第一个参数，然后再调用数组进行循环，然后将值返回，用于下一次回调函数的初始值，常用于累加操作。\n\n```\nlet a = [1, 2, 3];\na.reduce((total, cur) => {\n\treturn total + cur;\n}, 0);\n//6\n```\n\n​\t\t回调函数第一次执行时，`accumulator` 和`currentValue`的取值有两种情况：如果调用`reduce()`时提供了`initialValue`，`accumulator`取值为`initialValue`，`currentValue`取数组中的第一个值；如果没有提供 `initialValue`，那么`accumulator`取数组中的第一个值，`currentValue`取数组中的第二个值。\n\n\n\n### reduceRight\n\n[`Array.prototype.reduceRight()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/ReduceRight)\n\n​\t\t接受一个函数作为累加器（accumulator）和数组的每个值（从右到左）将其减少为单个值\n\n​\t\t和reduce差不多，就是这个是从右向左进行的操作。\n\n\n\n### reverse\n\n[`Array.prototype.reverse()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/reverse)\n\n​\t\t将数组中元素的位置颠倒，并返回该数组。该方法会改变原数组\n\n\n\n### shift\n\n[`Array.prototype.shift()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/shift)\n\n​\t\t从数组中删除第一个元素，并返回该元素的值\n\n\n\n### slice\n\n[`Array.prototype.slice()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/slice)\n\n​\t\t提取源数组的一部分并返回一个新数组\n\n​\t\t第一个参数，起始值，默认0。第二个参数结束值。\n\n​\t\t不包含结束值，但是包含起始值\n\n\n\n### come\n\n[`Array.prototype.some()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/some)\n\n​\t\t测试数组中是不是至少有一个元素通过了被提供的函数测试\n\n​\t\t同every，但是一个通过即可。\n\n\n\n### sort\n\n[`Array.prototype.sort()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/sort)\n\n​\t\t对数组元素进行原地排序并返回此数组\n\n​\t\t默认是使用的字符串进行的排序，所以需要自己定义一个排序的形式。\n\n​\t\t参数可选，是一个回调函数**compareFunction**，代表了用于比较的元素。\n\n```\ncompareFunction(a, b) 小于0， 那么a会排到b之前。\ncompareFunction(a, b) 等于0， 那么a和b的位置不会发生改变。\ncompareFunction(a, b) 大于0， 那么b会排到a之前。\n```\n\n\n\n### splice\n\n[`Array.prototype.splice()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/splice)\n\n​\t\t通过删除或替换现有元素或者原地添加新的元素来修改数组,并以数组形式返回被修改的内容\n\n​\t\t参数：startIndex，开始的位置， deleteCount，要删除的个数，默认后面全部删除， item1，item2，要添加的元素。默认不添加。\n\n\n\n### toLocaleString\n\n[`Array.prototype.toLocaleString()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/toLocaleString)\n\n​\t\t返回一个字符串表示数组中的元素。数组中的元素将使用各自的 [`Object.prototype.toLocaleString()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/toLocaleString) 方法转成字符串\n\n​\t\t这个我没有看懂，好像是将数组的内容，按照区域或者类型的规则转换成特殊的字符串。\n\n​\t\t不会修改原数组。\n\n```\nvar prices = ['￥7', 500, 8123, 12];\nprices.toLocaleString('ja-JP', { style: 'currency', currency: 'JPY' });\n\n// \"￥7,￥500,￥8,123,￥12\"\n```\n\n\n\n### toString\n\n[`Array.prototype.toString()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/toString)\n\n​\t\t返回一个字符串表示指定的数组及其元素。数组中的元素将使用各自的 [`Object.prototype.toString()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/toString) 方法转成字符串\n\n​\t\ttoString方法，没啥可说的。\n\n\n\n### unshift\n\n[`Array.prototype.unshift()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/unshift)\n\n​\t\t将一个或多个元素添加到数组的头部，并返回该数组的新长度\n\n\n\n下面这两个和迭代器相关，现在我没有学迭代器，代我们迭代器学了之后再进行了解。\n\n### values\n\n[`Array.prototype.values()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/values)\n\n​\t\t返回一个新的 `Array Iterator 对象`，该对象包含数组每个索引的值\n\n​\t\t返回的是一个迭代器的对象，iterator，使用forof进行循环可以取出值。\n\n\n\n### iterator\n\n[`Array.prototype[@@iterator]()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/@@iterator)\n\n​\t\t返回一个新的 `Array Iterator 对象`，该对象包含数组每个索引的值\n\n​\t\t\n\n","slug":"JavaScript/数组的方法","published":1,"updated":"2021-12-09T01:56:49.404Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckznhkk7q0033ikub2p07d91q","content":"<h1 id=\"数组的方法\"><a href=\"#数组的方法\" class=\"headerlink\" title=\"数组的方法\"></a>数组的方法</h1><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"静态方法\"><a href=\"#静态方法\" class=\"headerlink\" title=\"静态方法\"></a>静态方法</h2><h3 id=\"from\"><a href=\"#from\" class=\"headerlink\" title=\"from\"></a>from</h3><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/from\"><code>Array.from()</code></a></p>\n<p>​        从类数组对象或者可迭代对象中创建一个新的数组实例</p>\n<p>​        就是生成一个数组</p>\n<h3 id=\"isArray\"><a href=\"#isArray\" class=\"headerlink\" title=\"isArray\"></a>isArray</h3><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray\"><code>Array.isArray()</code></a></p>\n<p>​        用来判断某个变量是否是一个数组对象</p>\n<h3 id=\"of\"><a href=\"#of\" class=\"headerlink\" title=\"of\"></a>of</h3><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/of\"><code>Array.of()</code></a></p>\n<p>​    根据一组参数来创建新的数组实例，支持任意的参数数量和类型</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Array.of(1, 4)</span><br><span class=\"line\">[1, 4]</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"实例方法\"><a href=\"#实例方法\" class=\"headerlink\" title=\"实例方法\"></a>实例方法</h2><h3 id=\"concat\"><a href=\"#concat\" class=\"headerlink\" title=\"concat\"></a>concat</h3><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/concat\"><code>Array.prototype.concat()</code></a></p>\n<p>​        用于合并两个或多个数组。此方法不会更改现有数组，而是返回一个新数组</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a.concat(b)</span><br><span class=\"line\">也可以使用下面这个方式进行合并。</span><br><span class=\"line\">[...a, ...b]</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"copyWithin\"><a href=\"#copyWithin\" class=\"headerlink\" title=\"copyWithin\"></a>copyWithin</h3><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin\"><code>Array.prototype.copyWithin()</code></a></p>\n<p>​        浅复制数组的一部分到同一数组中的另一个位置，并返回它，不会改变原数组的长度</p>\n<p>​        注意，这个是浅复制。</p>\n<h3 id=\"entries\"><a href=\"#entries\" class=\"headerlink\" title=\"entries\"></a>entries</h3><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/entries\"><code>Array.prototype.entries()</code></a></p>\n<p>​        返回一个新的 <code>Array Iterator</code> 对象，该对象包含数组中每个索引的键/值对</p>\n<p>​        Iterator 是一个迭代器，有的循环需要使用迭代器进行循环。</p>\n<h3 id=\"every\"><a href=\"#every\" class=\"headerlink\" title=\"every\"></a>every</h3><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/every\"><code>Array.prototype.every()</code></a></p>\n<p>​        测试一个数组内的所有元素是否都能通过某个指定函数的测试。它返回一个布尔值</p>\n<p>​        every里面有两个参数，一个是回调函数，一个是this的指向。</p>\n<p>​        every里面是一个回调函数，然后回调函数的参数分别为 值，下标和原数组本身，然后会执行里面的方法，进行Boolean进行判断是否为true，只有所有的数组都为true才为true。</p>\n<p>​        这里，为什么我会认为是使用的Boolean()来对返回值进行的判断呢。因为如果你 return []; 发现是true，但是如果你对 []==true 发现是false，所以他是使用的Boolean进行的判断。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(a.every((value, index, arr) =&gt; &#123;</span><br><span class=\"line\">  return value == index;</span><br><span class=\"line\">&#125;))</span><br></pre></td></tr></table></figure>\n\n<p>​        简易实现：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Array.prototype.every = function (callback, thisArg) &#123;</span><br><span class=\"line\">  let arr = this;</span><br><span class=\"line\">  thisArg = thisArg || this;</span><br><span class=\"line\">  for (const key in arr) &#123;</span><br><span class=\"line\">    if (!Boolean(callback.call(thisArg, arr[key], key, arr))) &#123;</span><br><span class=\"line\">      return false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return true;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"fill\"><a href=\"#fill\" class=\"headerlink\" title=\"fill\"></a>fill</h3><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/fill\"><code>Array.prototype.fill()</code></a></p>\n<p>​        用一个固定值填充一个数组中从起始索引到终止索引内的全部元素</p>\n<p>​        有三个参数，第一个是必须的。三个参数分别是：填充值value，起始索引start，终止索引end。</p>\n<h3 id=\"filter\"><a href=\"#filter\" class=\"headerlink\" title=\"filter\"></a>filter</h3><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/filter\"><code>Array.prototype.filter()</code></a></p>\n<p>​        创建一个新数组, 其包含通过所提供函数实现的测试的所有元素</p>\n<p>​        里面的参数也是一样，一个回调和一个this指向。</p>\n<p>​        使用方式和上面的every一样，这个回调函数的作用是将返回true的加入一个数组，最后再将这个数组返回，常用于过滤条件。</p>\n<h3 id=\"find\"><a href=\"#find\" class=\"headerlink\" title=\"find\"></a>find</h3><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/find\"><code>Array.prototype.find()</code></a></p>\n<p>​        返回数组中满足提供的测试函数的第一个元素的值。否则返回 <code>undefined</code></p>\n<p>​        参数还是一样，一个回调一个this指向</p>\n<p>​        会将第一个满足的尽心返回便结束，并不会返回一个数组，只是返回单个元素。 或者 undefined</p>\n<h3 id=\"findIndex\"><a href=\"#findIndex\" class=\"headerlink\" title=\"findIndex\"></a>findIndex</h3><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex\"><code>Array.prototype.findIndex()</code></a></p>\n<p>​        返回数组中满足提供的测试函数的第一个元素的<strong>索引</strong>。若没有找到对应元素则返回 <code>-1</code></p>\n<p>​        同上 callback，thisArg</p>\n<p>​        效果：返回通过的第一个的索引，或者 -1</p>\n<h3 id=\"flat\"><a href=\"#flat\" class=\"headerlink\" title=\"flat\"></a>flat</h3><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/flat\"><code>Array.prototype.flat()</code></a></p>\n<p>​        按照一个可指定的深度递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回</p>\n<p>​        常用于数组的扁平化操作，参数是递归的深度。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let a = [1, 5, 2, [1], [[[[[[[[[2, 3]]]]]]]]]];</span><br><span class=\"line\">console.log(a.flat(Infinity))</span><br><span class=\"line\"></span><br><span class=\"line\">[ 1, 5, 2, 1, 2, 3 ]</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"flatMap\"><a href=\"#flatMap\" class=\"headerlink\" title=\"flatMap\"></a>flatMap</h3><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/flatMap\"><code>Array.prototype.flatMap()</code></a></p>\n<p>​        使用映射函数映射每个元素，然后将结果压缩成一个新数组</p>\n<p>​        简单来说，就是先使用map生成一系列新的数组，然后再使用flat进行扁平化操作，记住是1层的扁平化。</p>\n<h3 id=\"forEach\"><a href=\"#forEach\" class=\"headerlink\" title=\"forEach\"></a>forEach</h3><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach\"><code>Array.prototype.forEach()</code></a></p>\n<p>​        对数组的每个元素执行一次给定的函数</p>\n<p>​        分别是回调函数和一个this指向。会对每个参数都执行一次里面的方法，没有返回值。</p>\n<h3 id=\"includes\"><a href=\"#includes\" class=\"headerlink\" title=\"includes\"></a>includes</h3><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/includes\"><code>Array.prototype.includes()</code></a></p>\n<p>​        判断一个数组是否包含一个指定的值，如果包含则返回 <code>true</code>，否则返回 <code>false</code></p>\n<p>​        第一个是指定值，第二个是可选参数index</p>\n<h3 id=\"indexOf\"><a href=\"#indexOf\" class=\"headerlink\" title=\"indexOf\"></a>indexOf</h3><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf\"><code>Array.prototype.indexOf()</code></a></p>\n<p>​        返回在数组中可以找到一个给定元素的第一个索引，如果不存在，则返回 <code>-1</code></p>\n<p>​        第一个是要查找的参数，第一个是从index值开始查找。包含index值</p>\n<h3 id=\"join\"><a href=\"#join\" class=\"headerlink\" title=\"join\"></a>join</h3><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/join\"><code>Array.prototype.join()</code></a></p>\n<p>​        将一个数组的所有元素连接成一个字符串并返回这个字符串</p>\n<p>​        参数是一个分隔符。默认是 ，</p>\n<h3 id=\"keys\"><a href=\"#keys\" class=\"headerlink\" title=\"keys\"></a>keys</h3><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/keys\"><code>Array.prototype.keys()</code></a></p>\n<p>​        返回一个包含数组中每个索引键的 <code>Array Iterator</code> 对象</p>\n<h3 id=\"lastIndexOf\"><a href=\"#lastIndexOf\" class=\"headerlink\" title=\"lastIndexOf\"></a>lastIndexOf</h3><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/lastIndexOf\"><code>Array.prototype.lastIndexOf()</code></a></p>\n<p>​        返回指定元素在数组中的最后一个的索引，如果不存在则返回 <code>-1</code></p>\n<p>​        第一个是要查找的元素，第二个是从此位置开始逆向查找。默认为数组的长度减 1(<code>arr.length - 1</code>)，即整个数组都被查找。如果该值大于或等于数组的长度，则整个数组会被查找。如果为负值，将其视为从数组末尾向前的偏移（-1就是最后一个位置。）。即使该值为负，数组仍然会被从后向前查找。如果该值为负时，其绝对值大于数组长度，则方法返回 -1，即数组不会被查找。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let a = [0, 1, 2];</span><br><span class=\"line\">console.log(a.lastIndexOf(0, 0))\t//0</span><br><span class=\"line\">console.log(a.lastIndexOf(2, -1))\t//2</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"map\"><a href=\"#map\" class=\"headerlink\" title=\"map\"></a>map</h3><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/map\"><code>Array.prototype.map()</code></a></p>\n<p>​        返回一个新数组，其结果是该数组中的每个元素是调用一次提供的函数后的返回值</p>\n<p>​        第一个是回调函数，第二个是this指向。返回的是调用回调函数之后返回的结果组成的数组。</p>\n<h3 id=\"pop\"><a href=\"#pop\" class=\"headerlink\" title=\"pop\"></a>pop</h3><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/pop\"><code>Array.prototype.pop()</code></a></p>\n<p>​        从数组中删除最后一个元素，并返回该元素的值</p>\n<p>​        是通过的length属性进行的操作，所以如果是在类数组上进行操作，没有length或者length不能转成数字则为0，并返回undefined。</p>\n<h3 id=\"push\"><a href=\"#push\" class=\"headerlink\" title=\"push\"></a>push</h3><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/push\"><code>Array.prototype.push()</code></a></p>\n<p>​        将一个或多个元素添加到数组的末尾，并返回该数组的新长度</p>\n<p>​        同上，使用的length。</p>\n<h3 id=\"reduce\"><a href=\"#reduce\" class=\"headerlink\" title=\"reduce\"></a>reduce</h3><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce\"><code>Array.prototype.reduce()</code></a></p>\n<p>​        对数组中的每个元素执行一个由您提供的reducer函数（升序执行），将其结果汇总为单个返回值</p>\n<p>​        回调函数和一个初始值的参数，回调函数的参数分别为：累计值，当前值，下标和数组</p>\n<p>​        行为简单来说就是，如果有初始值则取初始值，如果没有初始值那么便为0，这个初始值会作为回调函数的第一个参数，然后再调用数组进行循环，然后将值返回，用于下一次回调函数的初始值，常用于累加操作。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let a = [1, 2, 3];</span><br><span class=\"line\">a.reduce((total, cur) =&gt; &#123;</span><br><span class=\"line\">\treturn total + cur;</span><br><span class=\"line\">&#125;, 0);</span><br><span class=\"line\">//6</span><br></pre></td></tr></table></figure>\n\n<p>​        回调函数第一次执行时，<code>accumulator</code> 和<code>currentValue</code>的取值有两种情况：如果调用<code>reduce()</code>时提供了<code>initialValue</code>，<code>accumulator</code>取值为<code>initialValue</code>，<code>currentValue</code>取数组中的第一个值；如果没有提供 <code>initialValue</code>，那么<code>accumulator</code>取数组中的第一个值，<code>currentValue</code>取数组中的第二个值。</p>\n<h3 id=\"reduceRight\"><a href=\"#reduceRight\" class=\"headerlink\" title=\"reduceRight\"></a>reduceRight</h3><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/ReduceRight\"><code>Array.prototype.reduceRight()</code></a></p>\n<p>​        接受一个函数作为累加器（accumulator）和数组的每个值（从右到左）将其减少为单个值</p>\n<p>​        和reduce差不多，就是这个是从右向左进行的操作。</p>\n<h3 id=\"reverse\"><a href=\"#reverse\" class=\"headerlink\" title=\"reverse\"></a>reverse</h3><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/reverse\"><code>Array.prototype.reverse()</code></a></p>\n<p>​        将数组中元素的位置颠倒，并返回该数组。该方法会改变原数组</p>\n<h3 id=\"shift\"><a href=\"#shift\" class=\"headerlink\" title=\"shift\"></a>shift</h3><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/shift\"><code>Array.prototype.shift()</code></a></p>\n<p>​        从数组中删除第一个元素，并返回该元素的值</p>\n<h3 id=\"slice\"><a href=\"#slice\" class=\"headerlink\" title=\"slice\"></a>slice</h3><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/slice\"><code>Array.prototype.slice()</code></a></p>\n<p>​        提取源数组的一部分并返回一个新数组</p>\n<p>​        第一个参数，起始值，默认0。第二个参数结束值。</p>\n<p>​        不包含结束值，但是包含起始值</p>\n<h3 id=\"come\"><a href=\"#come\" class=\"headerlink\" title=\"come\"></a>come</h3><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/some\"><code>Array.prototype.some()</code></a></p>\n<p>​        测试数组中是不是至少有一个元素通过了被提供的函数测试</p>\n<p>​        同every，但是一个通过即可。</p>\n<h3 id=\"sort\"><a href=\"#sort\" class=\"headerlink\" title=\"sort\"></a>sort</h3><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/sort\"><code>Array.prototype.sort()</code></a></p>\n<p>​        对数组元素进行原地排序并返回此数组</p>\n<p>​        默认是使用的字符串进行的排序，所以需要自己定义一个排序的形式。</p>\n<p>​        参数可选，是一个回调函数<strong>compareFunction</strong>，代表了用于比较的元素。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">compareFunction(a, b) 小于0， 那么a会排到b之前。</span><br><span class=\"line\">compareFunction(a, b) 等于0， 那么a和b的位置不会发生改变。</span><br><span class=\"line\">compareFunction(a, b) 大于0， 那么b会排到a之前。</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"splice\"><a href=\"#splice\" class=\"headerlink\" title=\"splice\"></a>splice</h3><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/splice\"><code>Array.prototype.splice()</code></a></p>\n<p>​        通过删除或替换现有元素或者原地添加新的元素来修改数组,并以数组形式返回被修改的内容</p>\n<p>​        参数：startIndex，开始的位置， deleteCount，要删除的个数，默认后面全部删除， item1，item2，要添加的元素。默认不添加。</p>\n<h3 id=\"toLocaleString-NaN\"><a href=\"#toLocaleString-NaN\" class=\"headerlink\" title=\"toLocaleString\"></a>toLocaleString</h3><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/toLocaleString\"><code>Array.prototype.toLocaleString()</code></a></p>\n<p>​        返回一个字符串表示数组中的元素。数组中的元素将使用各自的 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/toLocaleString\"><code>Object.prototype.toLocaleString()</code></a> 方法转成字符串</p>\n<p>​        这个我没有看懂，好像是将数组的内容，按照区域或者类型的规则转换成特殊的字符串。</p>\n<p>​        不会修改原数组。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var prices = [&#x27;￥7&#x27;, 500, 8123, 12];</span><br><span class=\"line\">prices.toLocaleString(&#x27;ja-JP&#x27;, &#123; style: &#x27;currency&#x27;, currency: &#x27;JPY&#x27; &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">// &quot;￥7,￥500,￥8,123,￥12&quot;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"toString-NaN\"><a href=\"#toString-NaN\" class=\"headerlink\" title=\"toString\"></a>toString</h3><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/toString\"><code>Array.prototype.toString()</code></a></p>\n<p>​        返回一个字符串表示指定的数组及其元素。数组中的元素将使用各自的 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/toString\"><code>Object.prototype.toString()</code></a> 方法转成字符串</p>\n<p>​        toString方法，没啥可说的。</p>\n<h3 id=\"unshift\"><a href=\"#unshift\" class=\"headerlink\" title=\"unshift\"></a>unshift</h3><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/unshift\"><code>Array.prototype.unshift()</code></a></p>\n<p>​        将一个或多个元素添加到数组的头部，并返回该数组的新长度</p>\n<p>下面这两个和迭代器相关，现在我没有学迭代器，代我们迭代器学了之后再进行了解。</p>\n<h3 id=\"values\"><a href=\"#values\" class=\"headerlink\" title=\"values\"></a>values</h3><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/values\"><code>Array.prototype.values()</code></a></p>\n<p>​        返回一个新的 <code>Array Iterator 对象</code>，该对象包含数组每个索引的值</p>\n<p>​        返回的是一个迭代器的对象，iterator，使用forof进行循环可以取出值。</p>\n<h3 id=\"iterator\"><a href=\"#iterator\" class=\"headerlink\" title=\"iterator\"></a>iterator</h3><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/@@iterator\"><code>Array.prototype[@@iterator]()</code></a></p>\n<p>​        返回一个新的 <code>Array Iterator 对象</code>，该对象包含数组每个索引的值</p>\n<p>​        </p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"数组的方法\"><a href=\"#数组的方法\" class=\"headerlink\" title=\"数组的方法\"></a>数组的方法</h1><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"静态方法\"><a href=\"#静态方法\" class=\"headerlink\" title=\"静态方法\"></a>静态方法</h2><h3 id=\"from\"><a href=\"#from\" class=\"headerlink\" title=\"from\"></a>from</h3><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/from\"><code>Array.from()</code></a></p>\n<p>​        从类数组对象或者可迭代对象中创建一个新的数组实例</p>\n<p>​        就是生成一个数组</p>\n<h3 id=\"isArray\"><a href=\"#isArray\" class=\"headerlink\" title=\"isArray\"></a>isArray</h3><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray\"><code>Array.isArray()</code></a></p>\n<p>​        用来判断某个变量是否是一个数组对象</p>\n<h3 id=\"of\"><a href=\"#of\" class=\"headerlink\" title=\"of\"></a>of</h3><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/of\"><code>Array.of()</code></a></p>\n<p>​    根据一组参数来创建新的数组实例，支持任意的参数数量和类型</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Array.of(1, 4)</span><br><span class=\"line\">[1, 4]</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"实例方法\"><a href=\"#实例方法\" class=\"headerlink\" title=\"实例方法\"></a>实例方法</h2><h3 id=\"concat\"><a href=\"#concat\" class=\"headerlink\" title=\"concat\"></a>concat</h3><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/concat\"><code>Array.prototype.concat()</code></a></p>\n<p>​        用于合并两个或多个数组。此方法不会更改现有数组，而是返回一个新数组</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a.concat(b)</span><br><span class=\"line\">也可以使用下面这个方式进行合并。</span><br><span class=\"line\">[...a, ...b]</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"copyWithin\"><a href=\"#copyWithin\" class=\"headerlink\" title=\"copyWithin\"></a>copyWithin</h3><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin\"><code>Array.prototype.copyWithin()</code></a></p>\n<p>​        浅复制数组的一部分到同一数组中的另一个位置，并返回它，不会改变原数组的长度</p>\n<p>​        注意，这个是浅复制。</p>\n<h3 id=\"entries\"><a href=\"#entries\" class=\"headerlink\" title=\"entries\"></a>entries</h3><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/entries\"><code>Array.prototype.entries()</code></a></p>\n<p>​        返回一个新的 <code>Array Iterator</code> 对象，该对象包含数组中每个索引的键/值对</p>\n<p>​        Iterator 是一个迭代器，有的循环需要使用迭代器进行循环。</p>\n<h3 id=\"every\"><a href=\"#every\" class=\"headerlink\" title=\"every\"></a>every</h3><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/every\"><code>Array.prototype.every()</code></a></p>\n<p>​        测试一个数组内的所有元素是否都能通过某个指定函数的测试。它返回一个布尔值</p>\n<p>​        every里面有两个参数，一个是回调函数，一个是this的指向。</p>\n<p>​        every里面是一个回调函数，然后回调函数的参数分别为 值，下标和原数组本身，然后会执行里面的方法，进行Boolean进行判断是否为true，只有所有的数组都为true才为true。</p>\n<p>​        这里，为什么我会认为是使用的Boolean()来对返回值进行的判断呢。因为如果你 return []; 发现是true，但是如果你对 []==true 发现是false，所以他是使用的Boolean进行的判断。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(a.every((value, index, arr) =&gt; &#123;</span><br><span class=\"line\">  return value == index;</span><br><span class=\"line\">&#125;))</span><br></pre></td></tr></table></figure>\n\n<p>​        简易实现：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Array.prototype.every = function (callback, thisArg) &#123;</span><br><span class=\"line\">  let arr = this;</span><br><span class=\"line\">  thisArg = thisArg || this;</span><br><span class=\"line\">  for (const key in arr) &#123;</span><br><span class=\"line\">    if (!Boolean(callback.call(thisArg, arr[key], key, arr))) &#123;</span><br><span class=\"line\">      return false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return true;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"fill\"><a href=\"#fill\" class=\"headerlink\" title=\"fill\"></a>fill</h3><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/fill\"><code>Array.prototype.fill()</code></a></p>\n<p>​        用一个固定值填充一个数组中从起始索引到终止索引内的全部元素</p>\n<p>​        有三个参数，第一个是必须的。三个参数分别是：填充值value，起始索引start，终止索引end。</p>\n<h3 id=\"filter\"><a href=\"#filter\" class=\"headerlink\" title=\"filter\"></a>filter</h3><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/filter\"><code>Array.prototype.filter()</code></a></p>\n<p>​        创建一个新数组, 其包含通过所提供函数实现的测试的所有元素</p>\n<p>​        里面的参数也是一样，一个回调和一个this指向。</p>\n<p>​        使用方式和上面的every一样，这个回调函数的作用是将返回true的加入一个数组，最后再将这个数组返回，常用于过滤条件。</p>\n<h3 id=\"find\"><a href=\"#find\" class=\"headerlink\" title=\"find\"></a>find</h3><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/find\"><code>Array.prototype.find()</code></a></p>\n<p>​        返回数组中满足提供的测试函数的第一个元素的值。否则返回 <code>undefined</code></p>\n<p>​        参数还是一样，一个回调一个this指向</p>\n<p>​        会将第一个满足的尽心返回便结束，并不会返回一个数组，只是返回单个元素。 或者 undefined</p>\n<h3 id=\"findIndex\"><a href=\"#findIndex\" class=\"headerlink\" title=\"findIndex\"></a>findIndex</h3><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex\"><code>Array.prototype.findIndex()</code></a></p>\n<p>​        返回数组中满足提供的测试函数的第一个元素的<strong>索引</strong>。若没有找到对应元素则返回 <code>-1</code></p>\n<p>​        同上 callback，thisArg</p>\n<p>​        效果：返回通过的第一个的索引，或者 -1</p>\n<h3 id=\"flat\"><a href=\"#flat\" class=\"headerlink\" title=\"flat\"></a>flat</h3><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/flat\"><code>Array.prototype.flat()</code></a></p>\n<p>​        按照一个可指定的深度递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回</p>\n<p>​        常用于数组的扁平化操作，参数是递归的深度。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let a = [1, 5, 2, [1], [[[[[[[[[2, 3]]]]]]]]]];</span><br><span class=\"line\">console.log(a.flat(Infinity))</span><br><span class=\"line\"></span><br><span class=\"line\">[ 1, 5, 2, 1, 2, 3 ]</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"flatMap\"><a href=\"#flatMap\" class=\"headerlink\" title=\"flatMap\"></a>flatMap</h3><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/flatMap\"><code>Array.prototype.flatMap()</code></a></p>\n<p>​        使用映射函数映射每个元素，然后将结果压缩成一个新数组</p>\n<p>​        简单来说，就是先使用map生成一系列新的数组，然后再使用flat进行扁平化操作，记住是1层的扁平化。</p>\n<h3 id=\"forEach\"><a href=\"#forEach\" class=\"headerlink\" title=\"forEach\"></a>forEach</h3><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach\"><code>Array.prototype.forEach()</code></a></p>\n<p>​        对数组的每个元素执行一次给定的函数</p>\n<p>​        分别是回调函数和一个this指向。会对每个参数都执行一次里面的方法，没有返回值。</p>\n<h3 id=\"includes\"><a href=\"#includes\" class=\"headerlink\" title=\"includes\"></a>includes</h3><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/includes\"><code>Array.prototype.includes()</code></a></p>\n<p>​        判断一个数组是否包含一个指定的值，如果包含则返回 <code>true</code>，否则返回 <code>false</code></p>\n<p>​        第一个是指定值，第二个是可选参数index</p>\n<h3 id=\"indexOf\"><a href=\"#indexOf\" class=\"headerlink\" title=\"indexOf\"></a>indexOf</h3><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf\"><code>Array.prototype.indexOf()</code></a></p>\n<p>​        返回在数组中可以找到一个给定元素的第一个索引，如果不存在，则返回 <code>-1</code></p>\n<p>​        第一个是要查找的参数，第一个是从index值开始查找。包含index值</p>\n<h3 id=\"join\"><a href=\"#join\" class=\"headerlink\" title=\"join\"></a>join</h3><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/join\"><code>Array.prototype.join()</code></a></p>\n<p>​        将一个数组的所有元素连接成一个字符串并返回这个字符串</p>\n<p>​        参数是一个分隔符。默认是 ，</p>\n<h3 id=\"keys\"><a href=\"#keys\" class=\"headerlink\" title=\"keys\"></a>keys</h3><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/keys\"><code>Array.prototype.keys()</code></a></p>\n<p>​        返回一个包含数组中每个索引键的 <code>Array Iterator</code> 对象</p>\n<h3 id=\"lastIndexOf\"><a href=\"#lastIndexOf\" class=\"headerlink\" title=\"lastIndexOf\"></a>lastIndexOf</h3><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/lastIndexOf\"><code>Array.prototype.lastIndexOf()</code></a></p>\n<p>​        返回指定元素在数组中的最后一个的索引，如果不存在则返回 <code>-1</code></p>\n<p>​        第一个是要查找的元素，第二个是从此位置开始逆向查找。默认为数组的长度减 1(<code>arr.length - 1</code>)，即整个数组都被查找。如果该值大于或等于数组的长度，则整个数组会被查找。如果为负值，将其视为从数组末尾向前的偏移（-1就是最后一个位置。）。即使该值为负，数组仍然会被从后向前查找。如果该值为负时，其绝对值大于数组长度，则方法返回 -1，即数组不会被查找。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let a = [0, 1, 2];</span><br><span class=\"line\">console.log(a.lastIndexOf(0, 0))\t//0</span><br><span class=\"line\">console.log(a.lastIndexOf(2, -1))\t//2</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"map\"><a href=\"#map\" class=\"headerlink\" title=\"map\"></a>map</h3><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/map\"><code>Array.prototype.map()</code></a></p>\n<p>​        返回一个新数组，其结果是该数组中的每个元素是调用一次提供的函数后的返回值</p>\n<p>​        第一个是回调函数，第二个是this指向。返回的是调用回调函数之后返回的结果组成的数组。</p>\n<h3 id=\"pop\"><a href=\"#pop\" class=\"headerlink\" title=\"pop\"></a>pop</h3><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/pop\"><code>Array.prototype.pop()</code></a></p>\n<p>​        从数组中删除最后一个元素，并返回该元素的值</p>\n<p>​        是通过的length属性进行的操作，所以如果是在类数组上进行操作，没有length或者length不能转成数字则为0，并返回undefined。</p>\n<h3 id=\"push\"><a href=\"#push\" class=\"headerlink\" title=\"push\"></a>push</h3><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/push\"><code>Array.prototype.push()</code></a></p>\n<p>​        将一个或多个元素添加到数组的末尾，并返回该数组的新长度</p>\n<p>​        同上，使用的length。</p>\n<h3 id=\"reduce\"><a href=\"#reduce\" class=\"headerlink\" title=\"reduce\"></a>reduce</h3><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce\"><code>Array.prototype.reduce()</code></a></p>\n<p>​        对数组中的每个元素执行一个由您提供的reducer函数（升序执行），将其结果汇总为单个返回值</p>\n<p>​        回调函数和一个初始值的参数，回调函数的参数分别为：累计值，当前值，下标和数组</p>\n<p>​        行为简单来说就是，如果有初始值则取初始值，如果没有初始值那么便为0，这个初始值会作为回调函数的第一个参数，然后再调用数组进行循环，然后将值返回，用于下一次回调函数的初始值，常用于累加操作。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let a = [1, 2, 3];</span><br><span class=\"line\">a.reduce((total, cur) =&gt; &#123;</span><br><span class=\"line\">\treturn total + cur;</span><br><span class=\"line\">&#125;, 0);</span><br><span class=\"line\">//6</span><br></pre></td></tr></table></figure>\n\n<p>​        回调函数第一次执行时，<code>accumulator</code> 和<code>currentValue</code>的取值有两种情况：如果调用<code>reduce()</code>时提供了<code>initialValue</code>，<code>accumulator</code>取值为<code>initialValue</code>，<code>currentValue</code>取数组中的第一个值；如果没有提供 <code>initialValue</code>，那么<code>accumulator</code>取数组中的第一个值，<code>currentValue</code>取数组中的第二个值。</p>\n<h3 id=\"reduceRight\"><a href=\"#reduceRight\" class=\"headerlink\" title=\"reduceRight\"></a>reduceRight</h3><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/ReduceRight\"><code>Array.prototype.reduceRight()</code></a></p>\n<p>​        接受一个函数作为累加器（accumulator）和数组的每个值（从右到左）将其减少为单个值</p>\n<p>​        和reduce差不多，就是这个是从右向左进行的操作。</p>\n<h3 id=\"reverse\"><a href=\"#reverse\" class=\"headerlink\" title=\"reverse\"></a>reverse</h3><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/reverse\"><code>Array.prototype.reverse()</code></a></p>\n<p>​        将数组中元素的位置颠倒，并返回该数组。该方法会改变原数组</p>\n<h3 id=\"shift\"><a href=\"#shift\" class=\"headerlink\" title=\"shift\"></a>shift</h3><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/shift\"><code>Array.prototype.shift()</code></a></p>\n<p>​        从数组中删除第一个元素，并返回该元素的值</p>\n<h3 id=\"slice\"><a href=\"#slice\" class=\"headerlink\" title=\"slice\"></a>slice</h3><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/slice\"><code>Array.prototype.slice()</code></a></p>\n<p>​        提取源数组的一部分并返回一个新数组</p>\n<p>​        第一个参数，起始值，默认0。第二个参数结束值。</p>\n<p>​        不包含结束值，但是包含起始值</p>\n<h3 id=\"come\"><a href=\"#come\" class=\"headerlink\" title=\"come\"></a>come</h3><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/some\"><code>Array.prototype.some()</code></a></p>\n<p>​        测试数组中是不是至少有一个元素通过了被提供的函数测试</p>\n<p>​        同every，但是一个通过即可。</p>\n<h3 id=\"sort\"><a href=\"#sort\" class=\"headerlink\" title=\"sort\"></a>sort</h3><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/sort\"><code>Array.prototype.sort()</code></a></p>\n<p>​        对数组元素进行原地排序并返回此数组</p>\n<p>​        默认是使用的字符串进行的排序，所以需要自己定义一个排序的形式。</p>\n<p>​        参数可选，是一个回调函数<strong>compareFunction</strong>，代表了用于比较的元素。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">compareFunction(a, b) 小于0， 那么a会排到b之前。</span><br><span class=\"line\">compareFunction(a, b) 等于0， 那么a和b的位置不会发生改变。</span><br><span class=\"line\">compareFunction(a, b) 大于0， 那么b会排到a之前。</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"splice\"><a href=\"#splice\" class=\"headerlink\" title=\"splice\"></a>splice</h3><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/splice\"><code>Array.prototype.splice()</code></a></p>\n<p>​        通过删除或替换现有元素或者原地添加新的元素来修改数组,并以数组形式返回被修改的内容</p>\n<p>​        参数：startIndex，开始的位置， deleteCount，要删除的个数，默认后面全部删除， item1，item2，要添加的元素。默认不添加。</p>\n<h3 id=\"toLocaleString-NaN\"><a href=\"#toLocaleString-NaN\" class=\"headerlink\" title=\"toLocaleString\"></a>toLocaleString</h3><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/toLocaleString\"><code>Array.prototype.toLocaleString()</code></a></p>\n<p>​        返回一个字符串表示数组中的元素。数组中的元素将使用各自的 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/toLocaleString\"><code>Object.prototype.toLocaleString()</code></a> 方法转成字符串</p>\n<p>​        这个我没有看懂，好像是将数组的内容，按照区域或者类型的规则转换成特殊的字符串。</p>\n<p>​        不会修改原数组。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var prices = [&#x27;￥7&#x27;, 500, 8123, 12];</span><br><span class=\"line\">prices.toLocaleString(&#x27;ja-JP&#x27;, &#123; style: &#x27;currency&#x27;, currency: &#x27;JPY&#x27; &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">// &quot;￥7,￥500,￥8,123,￥12&quot;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"toString-NaN\"><a href=\"#toString-NaN\" class=\"headerlink\" title=\"toString\"></a>toString</h3><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/toString\"><code>Array.prototype.toString()</code></a></p>\n<p>​        返回一个字符串表示指定的数组及其元素。数组中的元素将使用各自的 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/toString\"><code>Object.prototype.toString()</code></a> 方法转成字符串</p>\n<p>​        toString方法，没啥可说的。</p>\n<h3 id=\"unshift\"><a href=\"#unshift\" class=\"headerlink\" title=\"unshift\"></a>unshift</h3><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/unshift\"><code>Array.prototype.unshift()</code></a></p>\n<p>​        将一个或多个元素添加到数组的头部，并返回该数组的新长度</p>\n<p>下面这两个和迭代器相关，现在我没有学迭代器，代我们迭代器学了之后再进行了解。</p>\n<h3 id=\"values\"><a href=\"#values\" class=\"headerlink\" title=\"values\"></a>values</h3><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/values\"><code>Array.prototype.values()</code></a></p>\n<p>​        返回一个新的 <code>Array Iterator 对象</code>，该对象包含数组每个索引的值</p>\n<p>​        返回的是一个迭代器的对象，iterator，使用forof进行循环可以取出值。</p>\n<h3 id=\"iterator\"><a href=\"#iterator\" class=\"headerlink\" title=\"iterator\"></a>iterator</h3><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/@@iterator\"><code>Array.prototype[@@iterator]()</code></a></p>\n<p>​        返回一个新的 <code>Array Iterator 对象</code>，该对象包含数组每个索引的值</p>\n<p>​        </p>\n"},{"title":"HTML-标签的title","date":"2021-10-30T14:35:32.000Z","_content":"\n\n\n#  HTML-标签的title\n\n在学习的时候发现\n\n\n\n```\n<span title=\"停滞的span\">显示的span</span>\n```\n\n<img src=\"HTML-span/image-20211030223916508.png\" alt=\"image-20211030223916508\" style=\"zoom: 67%;\" />\n\n在页面上，鼠标进行放置可以显示 title，这个是一个html的title的特点。我们可以尝试对很多标签设置title，可以看看是否有效果。\n\n## title\n\n对一个标签添加 **title** 就可以实现。\n\n## 出现方式\n\n在一个标签的范围内，进行移动，超过了一定的时间就会显示。\n\n## 对于嵌套\n\n```\n<div style=\"height: 200px; border: 1px red solid;\" title=\"div\">\n  <span title=\"停滞的span\">显示的span</span>\n</div> \n```\n\n```\n在外面的会显示的是div，在span内部的会显示span，这个就像极了，在冒泡阶段进行stop。\n```\n\n","source":"_posts/HTML/HTML-标签的title.md","raw":"---\ntitle: HTML-标签的title\ndate: 2021-10-30 22:35:32\ntags:\n - 随笔\n - HTML\ncategories:\n - HTML\n - 随笔\n---\n\n\n\n#  HTML-标签的title\n\n在学习的时候发现\n\n\n\n```\n<span title=\"停滞的span\">显示的span</span>\n```\n\n<img src=\"HTML-span/image-20211030223916508.png\" alt=\"image-20211030223916508\" style=\"zoom: 67%;\" />\n\n在页面上，鼠标进行放置可以显示 title，这个是一个html的title的特点。我们可以尝试对很多标签设置title，可以看看是否有效果。\n\n## title\n\n对一个标签添加 **title** 就可以实现。\n\n## 出现方式\n\n在一个标签的范围内，进行移动，超过了一定的时间就会显示。\n\n## 对于嵌套\n\n```\n<div style=\"height: 200px; border: 1px red solid;\" title=\"div\">\n  <span title=\"停滞的span\">显示的span</span>\n</div> \n```\n\n```\n在外面的会显示的是div，在span内部的会显示span，这个就像极了，在冒泡阶段进行stop。\n```\n\n","slug":"HTML/HTML-标签的title","published":1,"updated":"2021-12-09T01:56:49.388Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckznhkk7q0034ikub3suddnho","content":"<h1 id=\"HTML-标签的title\"><a href=\"#HTML-标签的title\" class=\"headerlink\" title=\"HTML-标签的title\"></a>HTML-标签的title</h1><p>在学习的时候发现</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;span title=&quot;停滞的span&quot;&gt;显示的span&lt;/span&gt;</span><br></pre></td></tr></table></figure>\n\n<img src=\"/.io//image-20211030223916508.png\" alt=\"image-20211030223916508\" style=\"zoom: 67%;\">\n\n<p>在页面上，鼠标进行放置可以显示 title，这个是一个html的title的特点。我们可以尝试对很多标签设置title，可以看看是否有效果。</p>\n<h2 id=\"title\"><a href=\"#title\" class=\"headerlink\" title=\"title\"></a>title</h2><p>对一个标签添加 <strong>title</strong> 就可以实现。</p>\n<h2 id=\"出现方式\"><a href=\"#出现方式\" class=\"headerlink\" title=\"出现方式\"></a>出现方式</h2><p>在一个标签的范围内，进行移动，超过了一定的时间就会显示。</p>\n<h2 id=\"对于嵌套\"><a href=\"#对于嵌套\" class=\"headerlink\" title=\"对于嵌套\"></a>对于嵌套</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div style=&quot;height: 200px; border: 1px red solid;&quot; title=&quot;div&quot;&gt;</span><br><span class=\"line\">  &lt;span title=&quot;停滞的span&quot;&gt;显示的span&lt;/span&gt;</span><br><span class=\"line\">&lt;/div&gt; </span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">在外面的会显示的是div，在span内部的会显示span，这个就像极了，在冒泡阶段进行stop。</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"HTML-标签的title\"><a href=\"#HTML-标签的title\" class=\"headerlink\" title=\"HTML-标签的title\"></a>HTML-标签的title</h1><p>在学习的时候发现</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;span title=&quot;停滞的span&quot;&gt;显示的span&lt;/span&gt;</span><br></pre></td></tr></table></figure>\n\n<img src=\"/.io//image-20211030223916508.png\" alt=\"image-20211030223916508\" style=\"zoom: 67%;\">\n\n<p>在页面上，鼠标进行放置可以显示 title，这个是一个html的title的特点。我们可以尝试对很多标签设置title，可以看看是否有效果。</p>\n<h2 id=\"title\"><a href=\"#title\" class=\"headerlink\" title=\"title\"></a>title</h2><p>对一个标签添加 <strong>title</strong> 就可以实现。</p>\n<h2 id=\"出现方式\"><a href=\"#出现方式\" class=\"headerlink\" title=\"出现方式\"></a>出现方式</h2><p>在一个标签的范围内，进行移动，超过了一定的时间就会显示。</p>\n<h2 id=\"对于嵌套\"><a href=\"#对于嵌套\" class=\"headerlink\" title=\"对于嵌套\"></a>对于嵌套</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div style=&quot;height: 200px; border: 1px red solid;&quot; title=&quot;div&quot;&gt;</span><br><span class=\"line\">  &lt;span title=&quot;停滞的span&quot;&gt;显示的span&lt;/span&gt;</span><br><span class=\"line\">&lt;/div&gt; </span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">在外面的会显示的是div，在span内部的会显示span，这个就像极了，在冒泡阶段进行stop。</span><br></pre></td></tr></table></figure>\n\n"},{"title":"JavaScript-map函数","date":"2021-10-25T08:48:23.000Z","_content":"\n\n\n#  JavaScript之Array.map函数\n\n\n\n## 使用方法\n\n```\nhttps://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/map\n```\n\n`**map()**` 方法创建一个新数组，其结果是该数组中的每个元素是调用一次提供的函数后的返回值。\n\n\n\n**参数**\n\n​\t**回调函数，callback**\n\n​\t\t参数分别为，value，index，array，第二个和第三个参数是可选的。\n\n```\nconst array1 = [1, 4, 9, 16];\n\n// pass a function to map\nconst map1 = array1.map(x => x * 2);\n\nconsole.log(map1);\n// expected output: Array [2, 8, 18, 32]\n```\n\n​\t**thisArg**\n\n​\t\t在执行callabck函数时，被用作 `this`\n\n## 简单的源码实现\n\n通过上面的参数描述，我们可以知道，\n\n我们需要先对数组进行循环，然后将其带入callback，返回值会push入一个res数组，\n\n然后因为第二个参数是this的指向，所以我们需要在判断是否携带了第二个参数**(  const _this = thisArg || this;)**\n\n将其this的指向进行改变，使用了call方法。\n\n```\nfunction myMap(callback, thisArg) {\n  const result = [];\n  const arr = this;\n  const _this = thisArg || this;\n\n  for (let i = 0; i < arr.length; i++) {\n    result.push(callback.call(_this, arr[i], i, arr));\n  }\n\n  return result;\n}\n```\n\n\n\n## 一些面试时遇到的问题\n\n```\nconst arr = [1, 2, 3, 10, 111];\n\narr.map(parseInt)\n\n这个可能有的没有理解的话会有点懵逼\n其实理解了就很简单了。\n这就是把parseInt作为一个回调函数传递给了map，\nmap的回调函数的参数是，value， index， arr\n而parseInt，可以带两个参数，这两个参数，一个是要转化的字符串（数字也可以），一个是要转化的进制。\n\n所以我们就能够理解了，\n对于 arr 1， 2， 3， 10， 111\n会分别传递\n\t1， 0\n\t2， 1\n\t3， 2\n\t10， 3\n\t111， 4\n其中，0代表了默认转换，对于字符串没有进制前缀的，就是默认十进制，具体的转换规则后续写 parseInt 的时候再说明。\n\n我们可以看出，1对应的默认进制转换，2对应的1进制，3对应的2进制，10对应的3进制，111对应的4进制，因为parseInt的第二个参数范围是2-36，所以对于其他的除0以外直接NaN。\n所以对应的结果是 1, NaN, NaN, 3, 21.\n```\n\n对于其他的就也可以按照这个思路进行思考了。","source":"_posts/JavaScript/JavaScript-map函数.md","raw":"---\ntitle: JavaScript-map函数\ndate: 2021-10-25 16:48:23\ntags:\n - JavaScript\n - Array\n - map函数\n - 源码\ncategories:\n - JavaScript\n - Array\n---\n\n\n\n#  JavaScript之Array.map函数\n\n\n\n## 使用方法\n\n```\nhttps://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/map\n```\n\n`**map()**` 方法创建一个新数组，其结果是该数组中的每个元素是调用一次提供的函数后的返回值。\n\n\n\n**参数**\n\n​\t**回调函数，callback**\n\n​\t\t参数分别为，value，index，array，第二个和第三个参数是可选的。\n\n```\nconst array1 = [1, 4, 9, 16];\n\n// pass a function to map\nconst map1 = array1.map(x => x * 2);\n\nconsole.log(map1);\n// expected output: Array [2, 8, 18, 32]\n```\n\n​\t**thisArg**\n\n​\t\t在执行callabck函数时，被用作 `this`\n\n## 简单的源码实现\n\n通过上面的参数描述，我们可以知道，\n\n我们需要先对数组进行循环，然后将其带入callback，返回值会push入一个res数组，\n\n然后因为第二个参数是this的指向，所以我们需要在判断是否携带了第二个参数**(  const _this = thisArg || this;)**\n\n将其this的指向进行改变，使用了call方法。\n\n```\nfunction myMap(callback, thisArg) {\n  const result = [];\n  const arr = this;\n  const _this = thisArg || this;\n\n  for (let i = 0; i < arr.length; i++) {\n    result.push(callback.call(_this, arr[i], i, arr));\n  }\n\n  return result;\n}\n```\n\n\n\n## 一些面试时遇到的问题\n\n```\nconst arr = [1, 2, 3, 10, 111];\n\narr.map(parseInt)\n\n这个可能有的没有理解的话会有点懵逼\n其实理解了就很简单了。\n这就是把parseInt作为一个回调函数传递给了map，\nmap的回调函数的参数是，value， index， arr\n而parseInt，可以带两个参数，这两个参数，一个是要转化的字符串（数字也可以），一个是要转化的进制。\n\n所以我们就能够理解了，\n对于 arr 1， 2， 3， 10， 111\n会分别传递\n\t1， 0\n\t2， 1\n\t3， 2\n\t10， 3\n\t111， 4\n其中，0代表了默认转换，对于字符串没有进制前缀的，就是默认十进制，具体的转换规则后续写 parseInt 的时候再说明。\n\n我们可以看出，1对应的默认进制转换，2对应的1进制，3对应的2进制，10对应的3进制，111对应的4进制，因为parseInt的第二个参数范围是2-36，所以对于其他的除0以外直接NaN。\n所以对应的结果是 1, NaN, NaN, 3, 21.\n```\n\n对于其他的就也可以按照这个思路进行思考了。","slug":"JavaScript/JavaScript-map函数","published":1,"updated":"2021-12-09T01:56:49.404Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckznhkk7r0038ikub3ppr34cs","content":"<h1 id=\"JavaScript之Array-map函数\"><a href=\"#JavaScript之Array-map函数\" class=\"headerlink\" title=\"JavaScript之Array.map函数\"></a>JavaScript之Array.map函数</h1><h2 id=\"使用方法\"><a href=\"#使用方法\" class=\"headerlink\" title=\"使用方法\"></a>使用方法</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/map</span><br></pre></td></tr></table></figure>\n\n<p><code>**map()**</code> 方法创建一个新数组，其结果是该数组中的每个元素是调用一次提供的函数后的返回值。</p>\n<p><strong>参数</strong></p>\n<p>​    <strong>回调函数，callback</strong></p>\n<p>​        参数分别为，value，index，array，第二个和第三个参数是可选的。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const array1 = [1, 4, 9, 16];</span><br><span class=\"line\"></span><br><span class=\"line\">// pass a function to map</span><br><span class=\"line\">const map1 = array1.map(x =&gt; x * 2);</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(map1);</span><br><span class=\"line\">// expected output: Array [2, 8, 18, 32]</span><br></pre></td></tr></table></figure>\n\n<p>​    <strong>thisArg</strong></p>\n<p>​        在执行callabck函数时，被用作 <code>this</code></p>\n<h2 id=\"简单的源码实现\"><a href=\"#简单的源码实现\" class=\"headerlink\" title=\"简单的源码实现\"></a>简单的源码实现</h2><p>通过上面的参数描述，我们可以知道，</p>\n<p>我们需要先对数组进行循环，然后将其带入callback，返回值会push入一个res数组，</p>\n<p>然后因为第二个参数是this的指向，所以我们需要在判断是否携带了第二个参数**(  const _this = thisArg || this;)**</p>\n<p>将其this的指向进行改变，使用了call方法。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function myMap(callback, thisArg) &#123;</span><br><span class=\"line\">  const result = [];</span><br><span class=\"line\">  const arr = this;</span><br><span class=\"line\">  const _this = thisArg || this;</span><br><span class=\"line\"></span><br><span class=\"line\">  for (let i = 0; i &lt; arr.length; i++) &#123;</span><br><span class=\"line\">    result.push(callback.call(_this, arr[i], i, arr));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  return result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"一些面试时遇到的问题\"><a href=\"#一些面试时遇到的问题\" class=\"headerlink\" title=\"一些面试时遇到的问题\"></a>一些面试时遇到的问题</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const arr = [1, 2, 3, 10, 111];</span><br><span class=\"line\"></span><br><span class=\"line\">arr.map(parseInt)</span><br><span class=\"line\"></span><br><span class=\"line\">这个可能有的没有理解的话会有点懵逼</span><br><span class=\"line\">其实理解了就很简单了。</span><br><span class=\"line\">这就是把parseInt作为一个回调函数传递给了map，</span><br><span class=\"line\">map的回调函数的参数是，value， index， arr</span><br><span class=\"line\">而parseInt，可以带两个参数，这两个参数，一个是要转化的字符串（数字也可以），一个是要转化的进制。</span><br><span class=\"line\"></span><br><span class=\"line\">所以我们就能够理解了，</span><br><span class=\"line\">对于 arr 1， 2， 3， 10， 111</span><br><span class=\"line\">会分别传递</span><br><span class=\"line\">\t1， 0</span><br><span class=\"line\">\t2， 1</span><br><span class=\"line\">\t3， 2</span><br><span class=\"line\">\t10， 3</span><br><span class=\"line\">\t111， 4</span><br><span class=\"line\">其中，0代表了默认转换，对于字符串没有进制前缀的，就是默认十进制，具体的转换规则后续写 parseInt 的时候再说明。</span><br><span class=\"line\"></span><br><span class=\"line\">我们可以看出，1对应的默认进制转换，2对应的1进制，3对应的2进制，10对应的3进制，111对应的4进制，因为parseInt的第二个参数范围是2-36，所以对于其他的除0以外直接NaN。</span><br><span class=\"line\">所以对应的结果是 1, NaN, NaN, 3, 21.</span><br></pre></td></tr></table></figure>\n\n<p>对于其他的就也可以按照这个思路进行思考了。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"JavaScript之Array-map函数\"><a href=\"#JavaScript之Array-map函数\" class=\"headerlink\" title=\"JavaScript之Array.map函数\"></a>JavaScript之Array.map函数</h1><h2 id=\"使用方法\"><a href=\"#使用方法\" class=\"headerlink\" title=\"使用方法\"></a>使用方法</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/map</span><br></pre></td></tr></table></figure>\n\n<p><code>**map()**</code> 方法创建一个新数组，其结果是该数组中的每个元素是调用一次提供的函数后的返回值。</p>\n<p><strong>参数</strong></p>\n<p>​    <strong>回调函数，callback</strong></p>\n<p>​        参数分别为，value，index，array，第二个和第三个参数是可选的。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const array1 = [1, 4, 9, 16];</span><br><span class=\"line\"></span><br><span class=\"line\">// pass a function to map</span><br><span class=\"line\">const map1 = array1.map(x =&gt; x * 2);</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(map1);</span><br><span class=\"line\">// expected output: Array [2, 8, 18, 32]</span><br></pre></td></tr></table></figure>\n\n<p>​    <strong>thisArg</strong></p>\n<p>​        在执行callabck函数时，被用作 <code>this</code></p>\n<h2 id=\"简单的源码实现\"><a href=\"#简单的源码实现\" class=\"headerlink\" title=\"简单的源码实现\"></a>简单的源码实现</h2><p>通过上面的参数描述，我们可以知道，</p>\n<p>我们需要先对数组进行循环，然后将其带入callback，返回值会push入一个res数组，</p>\n<p>然后因为第二个参数是this的指向，所以我们需要在判断是否携带了第二个参数**(  const _this = thisArg || this;)**</p>\n<p>将其this的指向进行改变，使用了call方法。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function myMap(callback, thisArg) &#123;</span><br><span class=\"line\">  const result = [];</span><br><span class=\"line\">  const arr = this;</span><br><span class=\"line\">  const _this = thisArg || this;</span><br><span class=\"line\"></span><br><span class=\"line\">  for (let i = 0; i &lt; arr.length; i++) &#123;</span><br><span class=\"line\">    result.push(callback.call(_this, arr[i], i, arr));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  return result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"一些面试时遇到的问题\"><a href=\"#一些面试时遇到的问题\" class=\"headerlink\" title=\"一些面试时遇到的问题\"></a>一些面试时遇到的问题</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const arr = [1, 2, 3, 10, 111];</span><br><span class=\"line\"></span><br><span class=\"line\">arr.map(parseInt)</span><br><span class=\"line\"></span><br><span class=\"line\">这个可能有的没有理解的话会有点懵逼</span><br><span class=\"line\">其实理解了就很简单了。</span><br><span class=\"line\">这就是把parseInt作为一个回调函数传递给了map，</span><br><span class=\"line\">map的回调函数的参数是，value， index， arr</span><br><span class=\"line\">而parseInt，可以带两个参数，这两个参数，一个是要转化的字符串（数字也可以），一个是要转化的进制。</span><br><span class=\"line\"></span><br><span class=\"line\">所以我们就能够理解了，</span><br><span class=\"line\">对于 arr 1， 2， 3， 10， 111</span><br><span class=\"line\">会分别传递</span><br><span class=\"line\">\t1， 0</span><br><span class=\"line\">\t2， 1</span><br><span class=\"line\">\t3， 2</span><br><span class=\"line\">\t10， 3</span><br><span class=\"line\">\t111， 4</span><br><span class=\"line\">其中，0代表了默认转换，对于字符串没有进制前缀的，就是默认十进制，具体的转换规则后续写 parseInt 的时候再说明。</span><br><span class=\"line\"></span><br><span class=\"line\">我们可以看出，1对应的默认进制转换，2对应的1进制，3对应的2进制，10对应的3进制，111对应的4进制，因为parseInt的第二个参数范围是2-36，所以对于其他的除0以外直接NaN。</span><br><span class=\"line\">所以对应的结果是 1, NaN, NaN, 3, 21.</span><br></pre></td></tr></table></figure>\n\n<p>对于其他的就也可以按照这个思路进行思考了。</p>\n"},{"title":"块环境上下文(BFC)","date":"2021-10-21T14:49:56.000Z","_content":"\n\n\n#  块环境上下文（BFC）\n\n```\nhttps://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Block_formatting_context\nhttps://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Flow_Layout/Intro_to_formatting_contexts\n```\n\n\n\n**什么是BFC**\n\n```\n\t块格式化上下文（Block Formatting Context，BFC） 是Web页面的可视CSS渲染的一部分，是块盒子的布局过程发生的区域，也是浮动元素与其他元素交互的区域。\n```\n\n**有什么作用**\n\n```\n\t解决外边距合并：\n\t\t首先，外边距合并的原因是因为在同一个BFC下的结果，所以我们可以针对不同的\n\t\t对于不同的BFC也不会造成外边距和合并。所以可以使用BFC来解决外边距合并的问题。\n\t清除浮动：\n\t\t可以清除浮动，对于清除浮动，只能清除同一BFC的浮动。\n\t自适应两栏布局：\n\t\t可以做一个横向的两栏布局，一个宽度固定作为一个BFC，另一个做成另一个BFC。\n```\n\n\n\n## 创建方式\n\n```\n\t根元素（<html>）\n\t浮动元素（元素的 float 不是 none）\n\t绝对定位元素（元素的 position 为 absolute 或 fixed）\n\t行内块元素（元素的 display 为 inline-block）\n\t表格单元格（元素的 display 为 table-cell，HTML表格单元格默认为该值）\n\t表格标题（元素的 display 为 table-caption，HTML表格标题默认为该值）\n\t匿名表格单元格元素（元素的 display 为 table、table-row、 table-row-group、table-header-group、table-footer-group（分别是HTML table、row、tbody、thead、tfoot 的默认属性）或 inline-table）\n\toverflow 计算值(Computed)不为 visible 的块元素\n\tdisplay 值为 flow-root 的元素\n\tcontain 值为 layout、content 或 paint 的元素\n\t弹性元素（display 为 flex 或 inline-flex 元素的直接子元素）\n\t网格元素（display 为 grid 或 inline-grid 元素的直接子元素）\n\t多列容器（元素的 column-count 或 column-width (en-US) 不为 auto，包括 column-count 为 1）\n\tcolumn-span 为 all 的元素始终会创建一个新的BFC，即使该元素没有包裹在一个多列容器中（标准变更，Chrome bug）。\n```\n\n\n\n## 常用的 BFC 方式\n\nHTML根元素\n\n浮动， 不能为 `none`\n\n绝对定位， 包括 `absolute `和 `fixed`\n\n表格\t包括，表格布局和表格元素\n\noverflow\t计算值不为 `visible` ，这里说的是计算值\n\n弹性布局\t`flex`\n\n网格布局\t`grid`\n\n\n\n​\t\t`display: flow-root`，一个新的 `display` 属性的值，它可以创建无副作用的 BFC。在父级块中使用 `display: flow-root` 可以创建新的 BFC。\n\n​\t\t给 `<div>` `display: flow-root` 属性后，`<div>` 中的所有内容都会参与 BFC，浮动的内容不会从底部溢出。\n\n\n\n### 解决外边距合并\n\n这个我前面有写有，并且这个只需要不处于同一个BFC就可以有效果。所以这里不做过多说明，就简单的贴一个代码就行。\n\n```\n<!DOCTYPE html>\n<html lang=\"zh\">\n<head>\n  <meta charset=\"UTF-8\">\n  <title>Title</title>\n  <style>\n    .f {\n      display: inline-block;\n      background-color: red;\n      height: 90px;\n      width: 100px;\n      margin-bottom: 20px;\n    }\n    .c {\n      margin-top: 20px;\n      height: 100px;\n      width: 200px;\n      background-color: blue;\n    }\n  </style>\n\n</head>\n<body>\n<div class=\"f\"></div>\n<div class=\"c\"></div>\n</body>\n</html>\n```\n\n\n\n### 清除浮动\n\n​\t\t从下面的例子可以看出。\n\n​\t\t从结果可以看到，当一个元素创建了一个BFC之后，其内部的所有元素都会影响。对于根元素f（red），子元素c（blue），子子元素cc（black）。red的高度被其black所影响。而因为blue没有形成一个BFC，所以虽然black属于blue的子元素，但是blue没有将高度撑开为 black 的高度。\n\n**注意：**使用clear清除浮动，不是BFC的效果。因为我们可以直接对父元素使用clear发现并不会撑开盒子，所以并没有产生BFC。\n\n```\n<!DOCTYPE html>\n<html lang=\"zh\">\n<head>\n  <meta charset=\"UTF-8\">\n  <title>Title</title>\n  <style>\n    .f {\n      display: flow-root;\n      background-color: red;\n    }\n\n    .c {\n      /*float: left;*/\n      height: 100px;\n      width: 200px;\n      background-color: blue;\n    }\n\n    .cc {\n      float: left;\n      height: 300px;\n      width: 100px;\n      background-color: black;\n    }\n  </style>\n\n</head>\n<body>\n<div class=\"f\">\n  <div class=\"c\">\n    <div class=\"cc\"></div>\n  </div>\n</div>\n\n</body>\n</html>\n```\n\n结果\n\n<img src=\"块环境上下文/image-20211022110540794.png\" alt=\"image-20211022110540794\" style=\"zoom:33%;\" />\n\n\n\n\n\n\n\n注意点：如果设置了高度，那么父元素则不会进行扩张。\n\n以及对一个元素的 before和 after伪类进行了 BFC ，并不会将 BFC 给到该元素上。\n\n\n\n### 两栏布局\n\n就是，先指定一个的宽度，然后令其浮动，此时第二个的盒子将会位于第一个下面，然后，在将第二个盒子设置成一个BFC，所以就会出现他们并排一行，并且第二个盒子不会换行，然后因为默认占比的100%宽度，所以就会有一个自适应的效果。\n\n```\n<!DOCTYPE html>\n<html lang=\"zh\">\n<head>\n  <meta charset=\"UTF-8\">\n  <title>Title</title>\n  <style>\n    .left {\n      float: left;\n      height: 100px;\n      width: 200px;\n      background-color: red;\n    }\n    .right {\n      overflow: hidden;\n      height: 300px;\n      background-color: blue;\n    }\n  </style>\n</head>\n<body>\n<div class=\"left\"></div>\n<div class=\"right\"></div>\n</body>\n</html>\n```\n\n\n\n<img src=\"块环境上下文/image-20211022161542404.png\" alt=\"image-20211022161542404\" style=\"zoom:33%;\" />\n\n","source":"_posts/HTML/块环境上下文.md","raw":"---\ntitle: 块环境上下文(BFC)\ndate: 2021-10-21 22:49:56\ntags:\n - HTML\n - BFC\ncategories:\n - HTML\n---\n\n\n\n#  块环境上下文（BFC）\n\n```\nhttps://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Block_formatting_context\nhttps://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Flow_Layout/Intro_to_formatting_contexts\n```\n\n\n\n**什么是BFC**\n\n```\n\t块格式化上下文（Block Formatting Context，BFC） 是Web页面的可视CSS渲染的一部分，是块盒子的布局过程发生的区域，也是浮动元素与其他元素交互的区域。\n```\n\n**有什么作用**\n\n```\n\t解决外边距合并：\n\t\t首先，外边距合并的原因是因为在同一个BFC下的结果，所以我们可以针对不同的\n\t\t对于不同的BFC也不会造成外边距和合并。所以可以使用BFC来解决外边距合并的问题。\n\t清除浮动：\n\t\t可以清除浮动，对于清除浮动，只能清除同一BFC的浮动。\n\t自适应两栏布局：\n\t\t可以做一个横向的两栏布局，一个宽度固定作为一个BFC，另一个做成另一个BFC。\n```\n\n\n\n## 创建方式\n\n```\n\t根元素（<html>）\n\t浮动元素（元素的 float 不是 none）\n\t绝对定位元素（元素的 position 为 absolute 或 fixed）\n\t行内块元素（元素的 display 为 inline-block）\n\t表格单元格（元素的 display 为 table-cell，HTML表格单元格默认为该值）\n\t表格标题（元素的 display 为 table-caption，HTML表格标题默认为该值）\n\t匿名表格单元格元素（元素的 display 为 table、table-row、 table-row-group、table-header-group、table-footer-group（分别是HTML table、row、tbody、thead、tfoot 的默认属性）或 inline-table）\n\toverflow 计算值(Computed)不为 visible 的块元素\n\tdisplay 值为 flow-root 的元素\n\tcontain 值为 layout、content 或 paint 的元素\n\t弹性元素（display 为 flex 或 inline-flex 元素的直接子元素）\n\t网格元素（display 为 grid 或 inline-grid 元素的直接子元素）\n\t多列容器（元素的 column-count 或 column-width (en-US) 不为 auto，包括 column-count 为 1）\n\tcolumn-span 为 all 的元素始终会创建一个新的BFC，即使该元素没有包裹在一个多列容器中（标准变更，Chrome bug）。\n```\n\n\n\n## 常用的 BFC 方式\n\nHTML根元素\n\n浮动， 不能为 `none`\n\n绝对定位， 包括 `absolute `和 `fixed`\n\n表格\t包括，表格布局和表格元素\n\noverflow\t计算值不为 `visible` ，这里说的是计算值\n\n弹性布局\t`flex`\n\n网格布局\t`grid`\n\n\n\n​\t\t`display: flow-root`，一个新的 `display` 属性的值，它可以创建无副作用的 BFC。在父级块中使用 `display: flow-root` 可以创建新的 BFC。\n\n​\t\t给 `<div>` `display: flow-root` 属性后，`<div>` 中的所有内容都会参与 BFC，浮动的内容不会从底部溢出。\n\n\n\n### 解决外边距合并\n\n这个我前面有写有，并且这个只需要不处于同一个BFC就可以有效果。所以这里不做过多说明，就简单的贴一个代码就行。\n\n```\n<!DOCTYPE html>\n<html lang=\"zh\">\n<head>\n  <meta charset=\"UTF-8\">\n  <title>Title</title>\n  <style>\n    .f {\n      display: inline-block;\n      background-color: red;\n      height: 90px;\n      width: 100px;\n      margin-bottom: 20px;\n    }\n    .c {\n      margin-top: 20px;\n      height: 100px;\n      width: 200px;\n      background-color: blue;\n    }\n  </style>\n\n</head>\n<body>\n<div class=\"f\"></div>\n<div class=\"c\"></div>\n</body>\n</html>\n```\n\n\n\n### 清除浮动\n\n​\t\t从下面的例子可以看出。\n\n​\t\t从结果可以看到，当一个元素创建了一个BFC之后，其内部的所有元素都会影响。对于根元素f（red），子元素c（blue），子子元素cc（black）。red的高度被其black所影响。而因为blue没有形成一个BFC，所以虽然black属于blue的子元素，但是blue没有将高度撑开为 black 的高度。\n\n**注意：**使用clear清除浮动，不是BFC的效果。因为我们可以直接对父元素使用clear发现并不会撑开盒子，所以并没有产生BFC。\n\n```\n<!DOCTYPE html>\n<html lang=\"zh\">\n<head>\n  <meta charset=\"UTF-8\">\n  <title>Title</title>\n  <style>\n    .f {\n      display: flow-root;\n      background-color: red;\n    }\n\n    .c {\n      /*float: left;*/\n      height: 100px;\n      width: 200px;\n      background-color: blue;\n    }\n\n    .cc {\n      float: left;\n      height: 300px;\n      width: 100px;\n      background-color: black;\n    }\n  </style>\n\n</head>\n<body>\n<div class=\"f\">\n  <div class=\"c\">\n    <div class=\"cc\"></div>\n  </div>\n</div>\n\n</body>\n</html>\n```\n\n结果\n\n<img src=\"块环境上下文/image-20211022110540794.png\" alt=\"image-20211022110540794\" style=\"zoom:33%;\" />\n\n\n\n\n\n\n\n注意点：如果设置了高度，那么父元素则不会进行扩张。\n\n以及对一个元素的 before和 after伪类进行了 BFC ，并不会将 BFC 给到该元素上。\n\n\n\n### 两栏布局\n\n就是，先指定一个的宽度，然后令其浮动，此时第二个的盒子将会位于第一个下面，然后，在将第二个盒子设置成一个BFC，所以就会出现他们并排一行，并且第二个盒子不会换行，然后因为默认占比的100%宽度，所以就会有一个自适应的效果。\n\n```\n<!DOCTYPE html>\n<html lang=\"zh\">\n<head>\n  <meta charset=\"UTF-8\">\n  <title>Title</title>\n  <style>\n    .left {\n      float: left;\n      height: 100px;\n      width: 200px;\n      background-color: red;\n    }\n    .right {\n      overflow: hidden;\n      height: 300px;\n      background-color: blue;\n    }\n  </style>\n</head>\n<body>\n<div class=\"left\"></div>\n<div class=\"right\"></div>\n</body>\n</html>\n```\n\n\n\n<img src=\"块环境上下文/image-20211022161542404.png\" alt=\"image-20211022161542404\" style=\"zoom:33%;\" />\n\n","slug":"HTML/块环境上下文","published":1,"updated":"2021-12-09T01:56:49.404Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckznhkk7r003aikub1eak86go","content":"<h1 id=\"块环境上下文（BFC）\"><a href=\"#块环境上下文（BFC）\" class=\"headerlink\" title=\"块环境上下文（BFC）\"></a>块环境上下文（BFC）</h1><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Block_formatting_context</span><br><span class=\"line\">https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Flow_Layout/Intro_to_formatting_contexts</span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>什么是BFC</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">块格式化上下文（Block Formatting Context，BFC） 是Web页面的可视CSS渲染的一部分，是块盒子的布局过程发生的区域，也是浮动元素与其他元素交互的区域。</span><br></pre></td></tr></table></figure>\n\n<p><strong>有什么作用</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">解决外边距合并：</span><br><span class=\"line\">\t首先，外边距合并的原因是因为在同一个BFC下的结果，所以我们可以针对不同的</span><br><span class=\"line\">\t对于不同的BFC也不会造成外边距和合并。所以可以使用BFC来解决外边距合并的问题。</span><br><span class=\"line\">清除浮动：</span><br><span class=\"line\">\t可以清除浮动，对于清除浮动，只能清除同一BFC的浮动。</span><br><span class=\"line\">自适应两栏布局：</span><br><span class=\"line\">\t可以做一个横向的两栏布局，一个宽度固定作为一个BFC，另一个做成另一个BFC。</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"创建方式\"><a href=\"#创建方式\" class=\"headerlink\" title=\"创建方式\"></a>创建方式</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">根元素（&lt;html&gt;）</span><br><span class=\"line\">浮动元素（元素的 float 不是 none）</span><br><span class=\"line\">绝对定位元素（元素的 position 为 absolute 或 fixed）</span><br><span class=\"line\">行内块元素（元素的 display 为 inline-block）</span><br><span class=\"line\">表格单元格（元素的 display 为 table-cell，HTML表格单元格默认为该值）</span><br><span class=\"line\">表格标题（元素的 display 为 table-caption，HTML表格标题默认为该值）</span><br><span class=\"line\">匿名表格单元格元素（元素的 display 为 table、table-row、 table-row-group、table-header-group、table-footer-group（分别是HTML table、row、tbody、thead、tfoot 的默认属性）或 inline-table）</span><br><span class=\"line\">overflow 计算值(Computed)不为 visible 的块元素</span><br><span class=\"line\">display 值为 flow-root 的元素</span><br><span class=\"line\">contain 值为 layout、content 或 paint 的元素</span><br><span class=\"line\">弹性元素（display 为 flex 或 inline-flex 元素的直接子元素）</span><br><span class=\"line\">网格元素（display 为 grid 或 inline-grid 元素的直接子元素）</span><br><span class=\"line\">多列容器（元素的 column-count 或 column-width (en-US) 不为 auto，包括 column-count 为 1）</span><br><span class=\"line\">column-span 为 all 的元素始终会创建一个新的BFC，即使该元素没有包裹在一个多列容器中（标准变更，Chrome bug）。</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"常用的-BFC-方式\"><a href=\"#常用的-BFC-方式\" class=\"headerlink\" title=\"常用的 BFC 方式\"></a>常用的 BFC 方式</h2><p>HTML根元素</p>\n<p>浮动， 不能为 <code>none</code></p>\n<p>绝对定位， 包括 <code>absolute </code>和 <code>fixed</code></p>\n<p>表格    包括，表格布局和表格元素</p>\n<p>overflow    计算值不为 <code>visible</code> ，这里说的是计算值</p>\n<p>弹性布局    <code>flex</code></p>\n<p>网格布局    <code>grid</code></p>\n<p>​        <code>display: flow-root</code>，一个新的 <code>display</code> 属性的值，它可以创建无副作用的 BFC。在父级块中使用 <code>display: flow-root</code> 可以创建新的 BFC。</p>\n<p>​        给 <code>&lt;div&gt;</code> <code>display: flow-root</code> 属性后，<code>&lt;div&gt;</code> 中的所有内容都会参与 BFC，浮动的内容不会从底部溢出。</p>\n<h3 id=\"解决外边距合并\"><a href=\"#解决外边距合并\" class=\"headerlink\" title=\"解决外边距合并\"></a>解决外边距合并</h3><p>这个我前面有写有，并且这个只需要不处于同一个BFC就可以有效果。所以这里不做过多说明，就简单的贴一个代码就行。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html lang=&quot;zh&quot;&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">  &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class=\"line\">  &lt;title&gt;Title&lt;/title&gt;</span><br><span class=\"line\">  &lt;style&gt;</span><br><span class=\"line\">    .f &#123;</span><br><span class=\"line\">      display: inline-block;</span><br><span class=\"line\">      background-color: red;</span><br><span class=\"line\">      height: 90px;</span><br><span class=\"line\">      width: 100px;</span><br><span class=\"line\">      margin-bottom: 20px;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    .c &#123;</span><br><span class=\"line\">      margin-top: 20px;</span><br><span class=\"line\">      height: 100px;</span><br><span class=\"line\">      width: 200px;</span><br><span class=\"line\">      background-color: blue;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &lt;/style&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">&lt;div class=&quot;f&quot;&gt;&lt;/div&gt;</span><br><span class=\"line\">&lt;div class=&quot;c&quot;&gt;&lt;/div&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"清除浮动\"><a href=\"#清除浮动\" class=\"headerlink\" title=\"清除浮动\"></a>清除浮动</h3><p>​        从下面的例子可以看出。</p>\n<p>​        从结果可以看到，当一个元素创建了一个BFC之后，其内部的所有元素都会影响。对于根元素f（red），子元素c（blue），子子元素cc（black）。red的高度被其black所影响。而因为blue没有形成一个BFC，所以虽然black属于blue的子元素，但是blue没有将高度撑开为 black 的高度。</p>\n<p><strong>注意：</strong>使用clear清除浮动，不是BFC的效果。因为我们可以直接对父元素使用clear发现并不会撑开盒子，所以并没有产生BFC。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html lang=&quot;zh&quot;&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">  &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class=\"line\">  &lt;title&gt;Title&lt;/title&gt;</span><br><span class=\"line\">  &lt;style&gt;</span><br><span class=\"line\">    .f &#123;</span><br><span class=\"line\">      display: flow-root;</span><br><span class=\"line\">      background-color: red;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    .c &#123;</span><br><span class=\"line\">      /*float: left;*/</span><br><span class=\"line\">      height: 100px;</span><br><span class=\"line\">      width: 200px;</span><br><span class=\"line\">      background-color: blue;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    .cc &#123;</span><br><span class=\"line\">      float: left;</span><br><span class=\"line\">      height: 300px;</span><br><span class=\"line\">      width: 100px;</span><br><span class=\"line\">      background-color: black;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &lt;/style&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">&lt;div class=&quot;f&quot;&gt;</span><br><span class=\"line\">  &lt;div class=&quot;c&quot;&gt;</span><br><span class=\"line\">    &lt;div class=&quot;cc&quot;&gt;&lt;/div&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n\n<p>结果</p>\n<img src=\"/.io//image-20211022110540794.png\" alt=\"image-20211022110540794\" style=\"zoom:33%;\">\n\n\n\n\n\n\n\n<p>注意点：如果设置了高度，那么父元素则不会进行扩张。</p>\n<p>以及对一个元素的 before和 after伪类进行了 BFC ，并不会将 BFC 给到该元素上。</p>\n<h3 id=\"两栏布局\"><a href=\"#两栏布局\" class=\"headerlink\" title=\"两栏布局\"></a>两栏布局</h3><p>就是，先指定一个的宽度，然后令其浮动，此时第二个的盒子将会位于第一个下面，然后，在将第二个盒子设置成一个BFC，所以就会出现他们并排一行，并且第二个盒子不会换行，然后因为默认占比的100%宽度，所以就会有一个自适应的效果。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html lang=&quot;zh&quot;&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">  &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class=\"line\">  &lt;title&gt;Title&lt;/title&gt;</span><br><span class=\"line\">  &lt;style&gt;</span><br><span class=\"line\">    .left &#123;</span><br><span class=\"line\">      float: left;</span><br><span class=\"line\">      height: 100px;</span><br><span class=\"line\">      width: 200px;</span><br><span class=\"line\">      background-color: red;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    .right &#123;</span><br><span class=\"line\">      overflow: hidden;</span><br><span class=\"line\">      height: 300px;</span><br><span class=\"line\">      background-color: blue;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &lt;/style&gt;</span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">&lt;div class=&quot;left&quot;&gt;&lt;/div&gt;</span><br><span class=\"line\">&lt;div class=&quot;right&quot;&gt;&lt;/div&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n<img src=\"/.io//image-20211022161542404.png\" alt=\"image-20211022161542404\" style=\"zoom:33%;\">\n\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"块环境上下文（BFC）\"><a href=\"#块环境上下文（BFC）\" class=\"headerlink\" title=\"块环境上下文（BFC）\"></a>块环境上下文（BFC）</h1><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Block_formatting_context</span><br><span class=\"line\">https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Flow_Layout/Intro_to_formatting_contexts</span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>什么是BFC</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">块格式化上下文（Block Formatting Context，BFC） 是Web页面的可视CSS渲染的一部分，是块盒子的布局过程发生的区域，也是浮动元素与其他元素交互的区域。</span><br></pre></td></tr></table></figure>\n\n<p><strong>有什么作用</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">解决外边距合并：</span><br><span class=\"line\">\t首先，外边距合并的原因是因为在同一个BFC下的结果，所以我们可以针对不同的</span><br><span class=\"line\">\t对于不同的BFC也不会造成外边距和合并。所以可以使用BFC来解决外边距合并的问题。</span><br><span class=\"line\">清除浮动：</span><br><span class=\"line\">\t可以清除浮动，对于清除浮动，只能清除同一BFC的浮动。</span><br><span class=\"line\">自适应两栏布局：</span><br><span class=\"line\">\t可以做一个横向的两栏布局，一个宽度固定作为一个BFC，另一个做成另一个BFC。</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"创建方式\"><a href=\"#创建方式\" class=\"headerlink\" title=\"创建方式\"></a>创建方式</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">根元素（&lt;html&gt;）</span><br><span class=\"line\">浮动元素（元素的 float 不是 none）</span><br><span class=\"line\">绝对定位元素（元素的 position 为 absolute 或 fixed）</span><br><span class=\"line\">行内块元素（元素的 display 为 inline-block）</span><br><span class=\"line\">表格单元格（元素的 display 为 table-cell，HTML表格单元格默认为该值）</span><br><span class=\"line\">表格标题（元素的 display 为 table-caption，HTML表格标题默认为该值）</span><br><span class=\"line\">匿名表格单元格元素（元素的 display 为 table、table-row、 table-row-group、table-header-group、table-footer-group（分别是HTML table、row、tbody、thead、tfoot 的默认属性）或 inline-table）</span><br><span class=\"line\">overflow 计算值(Computed)不为 visible 的块元素</span><br><span class=\"line\">display 值为 flow-root 的元素</span><br><span class=\"line\">contain 值为 layout、content 或 paint 的元素</span><br><span class=\"line\">弹性元素（display 为 flex 或 inline-flex 元素的直接子元素）</span><br><span class=\"line\">网格元素（display 为 grid 或 inline-grid 元素的直接子元素）</span><br><span class=\"line\">多列容器（元素的 column-count 或 column-width (en-US) 不为 auto，包括 column-count 为 1）</span><br><span class=\"line\">column-span 为 all 的元素始终会创建一个新的BFC，即使该元素没有包裹在一个多列容器中（标准变更，Chrome bug）。</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"常用的-BFC-方式\"><a href=\"#常用的-BFC-方式\" class=\"headerlink\" title=\"常用的 BFC 方式\"></a>常用的 BFC 方式</h2><p>HTML根元素</p>\n<p>浮动， 不能为 <code>none</code></p>\n<p>绝对定位， 包括 <code>absolute </code>和 <code>fixed</code></p>\n<p>表格    包括，表格布局和表格元素</p>\n<p>overflow    计算值不为 <code>visible</code> ，这里说的是计算值</p>\n<p>弹性布局    <code>flex</code></p>\n<p>网格布局    <code>grid</code></p>\n<p>​        <code>display: flow-root</code>，一个新的 <code>display</code> 属性的值，它可以创建无副作用的 BFC。在父级块中使用 <code>display: flow-root</code> 可以创建新的 BFC。</p>\n<p>​        给 <code>&lt;div&gt;</code> <code>display: flow-root</code> 属性后，<code>&lt;div&gt;</code> 中的所有内容都会参与 BFC，浮动的内容不会从底部溢出。</p>\n<h3 id=\"解决外边距合并\"><a href=\"#解决外边距合并\" class=\"headerlink\" title=\"解决外边距合并\"></a>解决外边距合并</h3><p>这个我前面有写有，并且这个只需要不处于同一个BFC就可以有效果。所以这里不做过多说明，就简单的贴一个代码就行。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html lang=&quot;zh&quot;&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">  &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class=\"line\">  &lt;title&gt;Title&lt;/title&gt;</span><br><span class=\"line\">  &lt;style&gt;</span><br><span class=\"line\">    .f &#123;</span><br><span class=\"line\">      display: inline-block;</span><br><span class=\"line\">      background-color: red;</span><br><span class=\"line\">      height: 90px;</span><br><span class=\"line\">      width: 100px;</span><br><span class=\"line\">      margin-bottom: 20px;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    .c &#123;</span><br><span class=\"line\">      margin-top: 20px;</span><br><span class=\"line\">      height: 100px;</span><br><span class=\"line\">      width: 200px;</span><br><span class=\"line\">      background-color: blue;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &lt;/style&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">&lt;div class=&quot;f&quot;&gt;&lt;/div&gt;</span><br><span class=\"line\">&lt;div class=&quot;c&quot;&gt;&lt;/div&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"清除浮动\"><a href=\"#清除浮动\" class=\"headerlink\" title=\"清除浮动\"></a>清除浮动</h3><p>​        从下面的例子可以看出。</p>\n<p>​        从结果可以看到，当一个元素创建了一个BFC之后，其内部的所有元素都会影响。对于根元素f（red），子元素c（blue），子子元素cc（black）。red的高度被其black所影响。而因为blue没有形成一个BFC，所以虽然black属于blue的子元素，但是blue没有将高度撑开为 black 的高度。</p>\n<p><strong>注意：</strong>使用clear清除浮动，不是BFC的效果。因为我们可以直接对父元素使用clear发现并不会撑开盒子，所以并没有产生BFC。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html lang=&quot;zh&quot;&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">  &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class=\"line\">  &lt;title&gt;Title&lt;/title&gt;</span><br><span class=\"line\">  &lt;style&gt;</span><br><span class=\"line\">    .f &#123;</span><br><span class=\"line\">      display: flow-root;</span><br><span class=\"line\">      background-color: red;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    .c &#123;</span><br><span class=\"line\">      /*float: left;*/</span><br><span class=\"line\">      height: 100px;</span><br><span class=\"line\">      width: 200px;</span><br><span class=\"line\">      background-color: blue;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    .cc &#123;</span><br><span class=\"line\">      float: left;</span><br><span class=\"line\">      height: 300px;</span><br><span class=\"line\">      width: 100px;</span><br><span class=\"line\">      background-color: black;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &lt;/style&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">&lt;div class=&quot;f&quot;&gt;</span><br><span class=\"line\">  &lt;div class=&quot;c&quot;&gt;</span><br><span class=\"line\">    &lt;div class=&quot;cc&quot;&gt;&lt;/div&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n\n<p>结果</p>\n<img src=\"/.io//image-20211022110540794.png\" alt=\"image-20211022110540794\" style=\"zoom:33%;\">\n\n\n\n\n\n\n\n<p>注意点：如果设置了高度，那么父元素则不会进行扩张。</p>\n<p>以及对一个元素的 before和 after伪类进行了 BFC ，并不会将 BFC 给到该元素上。</p>\n<h3 id=\"两栏布局\"><a href=\"#两栏布局\" class=\"headerlink\" title=\"两栏布局\"></a>两栏布局</h3><p>就是，先指定一个的宽度，然后令其浮动，此时第二个的盒子将会位于第一个下面，然后，在将第二个盒子设置成一个BFC，所以就会出现他们并排一行，并且第二个盒子不会换行，然后因为默认占比的100%宽度，所以就会有一个自适应的效果。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html lang=&quot;zh&quot;&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">  &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class=\"line\">  &lt;title&gt;Title&lt;/title&gt;</span><br><span class=\"line\">  &lt;style&gt;</span><br><span class=\"line\">    .left &#123;</span><br><span class=\"line\">      float: left;</span><br><span class=\"line\">      height: 100px;</span><br><span class=\"line\">      width: 200px;</span><br><span class=\"line\">      background-color: red;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    .right &#123;</span><br><span class=\"line\">      overflow: hidden;</span><br><span class=\"line\">      height: 300px;</span><br><span class=\"line\">      background-color: blue;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &lt;/style&gt;</span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">&lt;div class=&quot;left&quot;&gt;&lt;/div&gt;</span><br><span class=\"line\">&lt;div class=&quot;right&quot;&gt;&lt;/div&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n<img src=\"/.io//image-20211022161542404.png\" alt=\"image-20211022161542404\" style=\"zoom:33%;\">\n\n"},{"title":"Vue-methods使用箭头函数","date":"2021-10-31T08:51:55.000Z","_content":"\n\n\n#  Vue \n\n本篇随笔写的是在Vue的 **methods** 方法里面使用箭头函数。\n\n\n\n在说明之前，我们先对这个进行一下分析：\n\n首先 一个 **Vue** 的实例实则也是通过里面的对象进行的操作。\n\n其次，**箭头函数的作用**，主要是 this 指向的不同，箭头函数的 this 指向是根据当前的上下文进行决定的。\n\n所以首先可以认为，在Vue里面使用箭头函数，如果要使用 data里面 数据应该是不行，因为data里面的数据是通过 this 来获取，所以我们可以认为，Vue 内部对每个方法进行了一个this指向的变化，而箭头函数是无法修改的。\n\n```\n  var app4 = new Vue({\n    el: '#app-4',\n    data: {\n      todos: [\n        { text: '学习 JavaScript', flag: true },\n        { text: '学习 Vue', flag: false },\n        { text: '整个牛项目', flag: true }\n      ]\n    },\n    methods: {\n      test() {\n        console.log(this.todos);\n      },\n      test1: () => {\n        console.log(this.todos);\n      }\n    },\n  })\n```\n\n\n\n**示例2：**\n\n```\n  var a = 3;\n\n  let obj = {\n    a: 1,\n    m: {\n      t: () => {\n        console.log(this);\n        console.log(this.a);\n      },\n      t1() {\n        console.log(this);\n        console.log(this.a);\n      }\n    }\n  }\n```\n\nt 使用的箭头函数，this 的指向为 window\n\nt1 使用的普通函数，this 的指向，指向了调用他的方法。\n\n\n\n**结论：**\n\n* 使用箭头函数的方法，确实不能获取到 data 的值\n* 使用箭头函数后，this 的指向指向了 window 对象。\n* 对于对象的对象的箭头函数，this的指向，还是指向的最外边的对象所处的上下文位置。","source":"_posts/Vue/Vue-methods使用箭头函数.md","raw":"---\ntitle: Vue-methods使用箭头函数\ndate: 2021-10-31 16:51:55\ntags:\n - Vue\n - 随笔\ncategories:\n - Vue\n - 随笔\n---\n\n\n\n#  Vue \n\n本篇随笔写的是在Vue的 **methods** 方法里面使用箭头函数。\n\n\n\n在说明之前，我们先对这个进行一下分析：\n\n首先 一个 **Vue** 的实例实则也是通过里面的对象进行的操作。\n\n其次，**箭头函数的作用**，主要是 this 指向的不同，箭头函数的 this 指向是根据当前的上下文进行决定的。\n\n所以首先可以认为，在Vue里面使用箭头函数，如果要使用 data里面 数据应该是不行，因为data里面的数据是通过 this 来获取，所以我们可以认为，Vue 内部对每个方法进行了一个this指向的变化，而箭头函数是无法修改的。\n\n```\n  var app4 = new Vue({\n    el: '#app-4',\n    data: {\n      todos: [\n        { text: '学习 JavaScript', flag: true },\n        { text: '学习 Vue', flag: false },\n        { text: '整个牛项目', flag: true }\n      ]\n    },\n    methods: {\n      test() {\n        console.log(this.todos);\n      },\n      test1: () => {\n        console.log(this.todos);\n      }\n    },\n  })\n```\n\n\n\n**示例2：**\n\n```\n  var a = 3;\n\n  let obj = {\n    a: 1,\n    m: {\n      t: () => {\n        console.log(this);\n        console.log(this.a);\n      },\n      t1() {\n        console.log(this);\n        console.log(this.a);\n      }\n    }\n  }\n```\n\nt 使用的箭头函数，this 的指向为 window\n\nt1 使用的普通函数，this 的指向，指向了调用他的方法。\n\n\n\n**结论：**\n\n* 使用箭头函数的方法，确实不能获取到 data 的值\n* 使用箭头函数后，this 的指向指向了 window 对象。\n* 对于对象的对象的箭头函数，this的指向，还是指向的最外边的对象所处的上下文位置。","slug":"Vue/Vue-methods使用箭头函数","published":1,"updated":"2021-12-09T01:56:49.404Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckznhkk7v003fikub1wxmg2eq","content":"<h1 id=\"Vue\"><a href=\"#Vue\" class=\"headerlink\" title=\"Vue\"></a>Vue</h1><p>本篇随笔写的是在Vue的 <strong>methods</strong> 方法里面使用箭头函数。</p>\n<p>在说明之前，我们先对这个进行一下分析：</p>\n<p>首先 一个 <strong>Vue</strong> 的实例实则也是通过里面的对象进行的操作。</p>\n<p>其次，<strong>箭头函数的作用</strong>，主要是 this 指向的不同，箭头函数的 this 指向是根据当前的上下文进行决定的。</p>\n<p>所以首先可以认为，在Vue里面使用箭头函数，如果要使用 data里面 数据应该是不行，因为data里面的数据是通过 this 来获取，所以我们可以认为，Vue 内部对每个方法进行了一个this指向的变化，而箭头函数是无法修改的。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var app4 = new Vue(&#123;</span><br><span class=\"line\">  el: &#x27;#app-4&#x27;,</span><br><span class=\"line\">  data: &#123;</span><br><span class=\"line\">    todos: [</span><br><span class=\"line\">      &#123; text: &#x27;学习 JavaScript&#x27;, flag: true &#125;,</span><br><span class=\"line\">      &#123; text: &#x27;学习 Vue&#x27;, flag: false &#125;,</span><br><span class=\"line\">      &#123; text: &#x27;整个牛项目&#x27;, flag: true &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  methods: &#123;</span><br><span class=\"line\">    test() &#123;</span><br><span class=\"line\">      console.log(this.todos);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    test1: () =&gt; &#123;</span><br><span class=\"line\">      console.log(this.todos);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>示例2：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a = 3;</span><br><span class=\"line\"></span><br><span class=\"line\">let obj = &#123;</span><br><span class=\"line\">  a: 1,</span><br><span class=\"line\">  m: &#123;</span><br><span class=\"line\">    t: () =&gt; &#123;</span><br><span class=\"line\">      console.log(this);</span><br><span class=\"line\">      console.log(this.a);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    t1() &#123;</span><br><span class=\"line\">      console.log(this);</span><br><span class=\"line\">      console.log(this.a);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>t 使用的箭头函数，this 的指向为 window</p>\n<p>t1 使用的普通函数，this 的指向，指向了调用他的方法。</p>\n<p><strong>结论：</strong></p>\n<ul>\n<li>使用箭头函数的方法，确实不能获取到 data 的值</li>\n<li>使用箭头函数后，this 的指向指向了 window 对象。</li>\n<li>对于对象的对象的箭头函数，this的指向，还是指向的最外边的对象所处的上下文位置。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Vue\"><a href=\"#Vue\" class=\"headerlink\" title=\"Vue\"></a>Vue</h1><p>本篇随笔写的是在Vue的 <strong>methods</strong> 方法里面使用箭头函数。</p>\n<p>在说明之前，我们先对这个进行一下分析：</p>\n<p>首先 一个 <strong>Vue</strong> 的实例实则也是通过里面的对象进行的操作。</p>\n<p>其次，<strong>箭头函数的作用</strong>，主要是 this 指向的不同，箭头函数的 this 指向是根据当前的上下文进行决定的。</p>\n<p>所以首先可以认为，在Vue里面使用箭头函数，如果要使用 data里面 数据应该是不行，因为data里面的数据是通过 this 来获取，所以我们可以认为，Vue 内部对每个方法进行了一个this指向的变化，而箭头函数是无法修改的。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var app4 = new Vue(&#123;</span><br><span class=\"line\">  el: &#x27;#app-4&#x27;,</span><br><span class=\"line\">  data: &#123;</span><br><span class=\"line\">    todos: [</span><br><span class=\"line\">      &#123; text: &#x27;学习 JavaScript&#x27;, flag: true &#125;,</span><br><span class=\"line\">      &#123; text: &#x27;学习 Vue&#x27;, flag: false &#125;,</span><br><span class=\"line\">      &#123; text: &#x27;整个牛项目&#x27;, flag: true &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  methods: &#123;</span><br><span class=\"line\">    test() &#123;</span><br><span class=\"line\">      console.log(this.todos);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    test1: () =&gt; &#123;</span><br><span class=\"line\">      console.log(this.todos);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>示例2：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a = 3;</span><br><span class=\"line\"></span><br><span class=\"line\">let obj = &#123;</span><br><span class=\"line\">  a: 1,</span><br><span class=\"line\">  m: &#123;</span><br><span class=\"line\">    t: () =&gt; &#123;</span><br><span class=\"line\">      console.log(this);</span><br><span class=\"line\">      console.log(this.a);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    t1() &#123;</span><br><span class=\"line\">      console.log(this);</span><br><span class=\"line\">      console.log(this.a);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>t 使用的箭头函数，this 的指向为 window</p>\n<p>t1 使用的普通函数，this 的指向，指向了调用他的方法。</p>\n<p><strong>结论：</strong></p>\n<ul>\n<li>使用箭头函数的方法，确实不能获取到 data 的值</li>\n<li>使用箭头函数后，this 的指向指向了 window 对象。</li>\n<li>对于对象的对象的箭头函数，this的指向，还是指向的最外边的对象所处的上下文位置。</li>\n</ul>\n"},{"title":"VueRouter两种模式","date":"2021-11-07T05:33:21.000Z","_content":"\n\n\n#  VueRouter的两种模式\n\n有history 和 hash两个模式\n\n\n\n## history模式\n\n在这里我先直接说一下history模式的问题，简单来说就是不能刷新页面，因为后端没有对其进行一个处理。\n\n这里开始我想了很久都没有理解是什么意思，并且在本地访问也没有任何问题，后面才知道，这个是需要发布的时候，正式访问才会出现的问题。\n\n首先，history模式在本地是没有问题的，只有在打包之后，运行那个dist文件夹服务才会发现\n\n其次，问题的复现很简单，\n\n* 先运行**打包**之后的项目，然后访问，注意，一定要打包之后的，如果直接运行server，你不会发现这个问题。\n* 此时一般都是 `http://localhost:3000` 这种，访问之后，url一般都会根据前端的路由进行一次变化 `http://localhost:3000/bookkeeping` 我这里就变成这样了。\n* 然后此时如果你刷新，请求的就是 `http://localhost:3000/bookkeeping` 而不是最开始那个，如果你没有对这个进行一个处理，那么就会404.\n\n解决方法，简单来说就是对没有的域名都进行一个跳转为index.html页面的情况。\n\n\n\n*  **方式1**：\n\n  这个方式的前提条件就是 前端和后端的项目是合并的。并不是一个分离式的开发。此时的话，我们也可以知道，前端的页面请求是先通过了后端，然后后端进行配置，对于一些没有的路径进行一个处理即可\n\n*  **方式2**：\n\n  前后端进行了分离，这个时候就对前端运行就好了。下面这个是Vue的一个例子，我们在dist文件里新建一个js文件作为一个启动文件。然后在这里进行了一个文件的拦截，就像是一种虽然前后端分离，但是实则还是有一个后端。\n\n  ```\n  const http = require('http')\n  const fs = require('fs')\n  const httpPort = 80\n  \n  http.createServer((req, res) => {\n    fs.readFile('index.html', 'utf-8', (err, content) => {\n      if (err) {\n        console.log('We cannot open \"index.html\" file.')\n      }\n  \n      res.writeHead(200, {\n        'Content-Type': 'text/html; charset=utf-8'\n      })\n  \n      res.end(content)\n    })\n  }).listen(httpPort, () => {\n    console.log('Server listening on: http://localhost:%s', httpPort)\n  })\n  ```\n\n*  **方式3**：\n\n  使用nginx进行代理。这里我没有成功，不知道是哪的问题，大致好像是使用 rewired进行重定向操作。具体以后再说。\n\n\n\n## hash模式\n\n​\t\thash模式，简单来说就是使用的 url的#，因为url的#是不会参与请求，所以基本没有什么问题，除了不怎么好看之外。\n\n","source":"_posts/Vue/VueRouter两种模式.md","raw":"---\ntitle: VueRouter两种模式\ndate: 2021-11-07 13:33:21\ntags:\n - Vue\n - VueRouter\ncategories: \n - Vue\n - VueRouter\n---\n\n\n\n#  VueRouter的两种模式\n\n有history 和 hash两个模式\n\n\n\n## history模式\n\n在这里我先直接说一下history模式的问题，简单来说就是不能刷新页面，因为后端没有对其进行一个处理。\n\n这里开始我想了很久都没有理解是什么意思，并且在本地访问也没有任何问题，后面才知道，这个是需要发布的时候，正式访问才会出现的问题。\n\n首先，history模式在本地是没有问题的，只有在打包之后，运行那个dist文件夹服务才会发现\n\n其次，问题的复现很简单，\n\n* 先运行**打包**之后的项目，然后访问，注意，一定要打包之后的，如果直接运行server，你不会发现这个问题。\n* 此时一般都是 `http://localhost:3000` 这种，访问之后，url一般都会根据前端的路由进行一次变化 `http://localhost:3000/bookkeeping` 我这里就变成这样了。\n* 然后此时如果你刷新，请求的就是 `http://localhost:3000/bookkeeping` 而不是最开始那个，如果你没有对这个进行一个处理，那么就会404.\n\n解决方法，简单来说就是对没有的域名都进行一个跳转为index.html页面的情况。\n\n\n\n*  **方式1**：\n\n  这个方式的前提条件就是 前端和后端的项目是合并的。并不是一个分离式的开发。此时的话，我们也可以知道，前端的页面请求是先通过了后端，然后后端进行配置，对于一些没有的路径进行一个处理即可\n\n*  **方式2**：\n\n  前后端进行了分离，这个时候就对前端运行就好了。下面这个是Vue的一个例子，我们在dist文件里新建一个js文件作为一个启动文件。然后在这里进行了一个文件的拦截，就像是一种虽然前后端分离，但是实则还是有一个后端。\n\n  ```\n  const http = require('http')\n  const fs = require('fs')\n  const httpPort = 80\n  \n  http.createServer((req, res) => {\n    fs.readFile('index.html', 'utf-8', (err, content) => {\n      if (err) {\n        console.log('We cannot open \"index.html\" file.')\n      }\n  \n      res.writeHead(200, {\n        'Content-Type': 'text/html; charset=utf-8'\n      })\n  \n      res.end(content)\n    })\n  }).listen(httpPort, () => {\n    console.log('Server listening on: http://localhost:%s', httpPort)\n  })\n  ```\n\n*  **方式3**：\n\n  使用nginx进行代理。这里我没有成功，不知道是哪的问题，大致好像是使用 rewired进行重定向操作。具体以后再说。\n\n\n\n## hash模式\n\n​\t\thash模式，简单来说就是使用的 url的#，因为url的#是不会参与请求，所以基本没有什么问题，除了不怎么好看之外。\n\n","slug":"Vue/VueRouter两种模式","published":1,"updated":"2021-12-09T01:56:49.404Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckznhkk7v003iikubf24h43ei","content":"<h1 id=\"VueRouter的两种模式\"><a href=\"#VueRouter的两种模式\" class=\"headerlink\" title=\"VueRouter的两种模式\"></a>VueRouter的两种模式</h1><p>有history 和 hash两个模式</p>\n<h2 id=\"history模式\"><a href=\"#history模式\" class=\"headerlink\" title=\"history模式\"></a>history模式</h2><p>在这里我先直接说一下history模式的问题，简单来说就是不能刷新页面，因为后端没有对其进行一个处理。</p>\n<p>这里开始我想了很久都没有理解是什么意思，并且在本地访问也没有任何问题，后面才知道，这个是需要发布的时候，正式访问才会出现的问题。</p>\n<p>首先，history模式在本地是没有问题的，只有在打包之后，运行那个dist文件夹服务才会发现</p>\n<p>其次，问题的复现很简单，</p>\n<ul>\n<li>先运行<strong>打包</strong>之后的项目，然后访问，注意，一定要打包之后的，如果直接运行server，你不会发现这个问题。</li>\n<li>此时一般都是 <code>http://localhost:3000</code> 这种，访问之后，url一般都会根据前端的路由进行一次变化 <code>http://localhost:3000/bookkeeping</code> 我这里就变成这样了。</li>\n<li>然后此时如果你刷新，请求的就是 <code>http://localhost:3000/bookkeeping</code> 而不是最开始那个，如果你没有对这个进行一个处理，那么就会404.</li>\n</ul>\n<p>解决方法，简单来说就是对没有的域名都进行一个跳转为index.html页面的情况。</p>\n<ul>\n<li> <strong>方式1</strong>：</li>\n</ul>\n<p>  这个方式的前提条件就是 前端和后端的项目是合并的。并不是一个分离式的开发。此时的话，我们也可以知道，前端的页面请求是先通过了后端，然后后端进行配置，对于一些没有的路径进行一个处理即可</p>\n<ul>\n<li> <strong>方式2</strong>：</li>\n</ul>\n<p>  前后端进行了分离，这个时候就对前端运行就好了。下面这个是Vue的一个例子，我们在dist文件里新建一个js文件作为一个启动文件。然后在这里进行了一个文件的拦截，就像是一种虽然前后端分离，但是实则还是有一个后端。</p>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const http = require(&#x27;http&#x27;)</span><br><span class=\"line\">const fs = require(&#x27;fs&#x27;)</span><br><span class=\"line\">const httpPort = 80</span><br><span class=\"line\"></span><br><span class=\"line\">http.createServer((req, res) =&gt; &#123;</span><br><span class=\"line\">  fs.readFile(&#x27;index.html&#x27;, &#x27;utf-8&#x27;, (err, content) =&gt; &#123;</span><br><span class=\"line\">    if (err) &#123;</span><br><span class=\"line\">      console.log(&#x27;We cannot open &quot;index.html&quot; file.&#x27;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    res.writeHead(200, &#123;</span><br><span class=\"line\">      &#x27;Content-Type&#x27;: &#x27;text/html; charset=utf-8&#x27;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    res.end(content)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;).listen(httpPort, () =&gt; &#123;</span><br><span class=\"line\">  console.log(&#x27;Server listening on: http://localhost:%s&#x27;, httpPort)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li> <strong>方式3</strong>：</li>\n</ul>\n<p>  使用nginx进行代理。这里我没有成功，不知道是哪的问题，大致好像是使用 rewired进行重定向操作。具体以后再说。</p>\n<h2 id=\"hash模式\"><a href=\"#hash模式\" class=\"headerlink\" title=\"hash模式\"></a>hash模式</h2><p>​        hash模式，简单来说就是使用的 url的#，因为url的#是不会参与请求，所以基本没有什么问题，除了不怎么好看之外。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"VueRouter的两种模式\"><a href=\"#VueRouter的两种模式\" class=\"headerlink\" title=\"VueRouter的两种模式\"></a>VueRouter的两种模式</h1><p>有history 和 hash两个模式</p>\n<h2 id=\"history模式\"><a href=\"#history模式\" class=\"headerlink\" title=\"history模式\"></a>history模式</h2><p>在这里我先直接说一下history模式的问题，简单来说就是不能刷新页面，因为后端没有对其进行一个处理。</p>\n<p>这里开始我想了很久都没有理解是什么意思，并且在本地访问也没有任何问题，后面才知道，这个是需要发布的时候，正式访问才会出现的问题。</p>\n<p>首先，history模式在本地是没有问题的，只有在打包之后，运行那个dist文件夹服务才会发现</p>\n<p>其次，问题的复现很简单，</p>\n<ul>\n<li>先运行<strong>打包</strong>之后的项目，然后访问，注意，一定要打包之后的，如果直接运行server，你不会发现这个问题。</li>\n<li>此时一般都是 <code>http://localhost:3000</code> 这种，访问之后，url一般都会根据前端的路由进行一次变化 <code>http://localhost:3000/bookkeeping</code> 我这里就变成这样了。</li>\n<li>然后此时如果你刷新，请求的就是 <code>http://localhost:3000/bookkeeping</code> 而不是最开始那个，如果你没有对这个进行一个处理，那么就会404.</li>\n</ul>\n<p>解决方法，简单来说就是对没有的域名都进行一个跳转为index.html页面的情况。</p>\n<ul>\n<li> <strong>方式1</strong>：</li>\n</ul>\n<p>  这个方式的前提条件就是 前端和后端的项目是合并的。并不是一个分离式的开发。此时的话，我们也可以知道，前端的页面请求是先通过了后端，然后后端进行配置，对于一些没有的路径进行一个处理即可</p>\n<ul>\n<li> <strong>方式2</strong>：</li>\n</ul>\n<p>  前后端进行了分离，这个时候就对前端运行就好了。下面这个是Vue的一个例子，我们在dist文件里新建一个js文件作为一个启动文件。然后在这里进行了一个文件的拦截，就像是一种虽然前后端分离，但是实则还是有一个后端。</p>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const http = require(&#x27;http&#x27;)</span><br><span class=\"line\">const fs = require(&#x27;fs&#x27;)</span><br><span class=\"line\">const httpPort = 80</span><br><span class=\"line\"></span><br><span class=\"line\">http.createServer((req, res) =&gt; &#123;</span><br><span class=\"line\">  fs.readFile(&#x27;index.html&#x27;, &#x27;utf-8&#x27;, (err, content) =&gt; &#123;</span><br><span class=\"line\">    if (err) &#123;</span><br><span class=\"line\">      console.log(&#x27;We cannot open &quot;index.html&quot; file.&#x27;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    res.writeHead(200, &#123;</span><br><span class=\"line\">      &#x27;Content-Type&#x27;: &#x27;text/html; charset=utf-8&#x27;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    res.end(content)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;).listen(httpPort, () =&gt; &#123;</span><br><span class=\"line\">  console.log(&#x27;Server listening on: http://localhost:%s&#x27;, httpPort)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li> <strong>方式3</strong>：</li>\n</ul>\n<p>  使用nginx进行代理。这里我没有成功，不知道是哪的问题，大致好像是使用 rewired进行重定向操作。具体以后再说。</p>\n<h2 id=\"hash模式\"><a href=\"#hash模式\" class=\"headerlink\" title=\"hash模式\"></a>hash模式</h2><p>​        hash模式，简单来说就是使用的 url的#，因为url的#是不会参与请求，所以基本没有什么问题，除了不怎么好看之外。</p>\n"},{"title":"Vue生命周期","date":"2021-11-16T14:15:21.000Z","_content":"\n\n\n# Vue生命周期\n\n先来一个直译的形式\n\n```\n  创建一个Vue实例 new Vue\n  初始化事件和生命周期\n  调用 beforeCreate钩子\n  初始化注入和反应\n  调用 created 钩子\n  编译模板阶段\n\t\tHas el option 这里是判断是否使用了 el这个属性。如果没有使用那么就是属于未挂载的状态，只有在之后 $mount 被调用时才会进行下一步的编译。\n\t\tHas template option，判断是否使用了template参数。如果没有使用template参数，那么就将用el元素时的内部标签，如果使用了template元素，那么就会将template的字符串作为标签覆盖el元素内部的，除非有插槽。\n\t\t这里的 outerHTML，我们也知道就是：除了包含innerHTML的全部内容外, 还包含对象标签本身。\n\t然后就是调用 beforeMount 钩子\n\t然后就是创建 虚拟DOM 并且替换 el，这里就是实现了将页面的显示。此时这里在显示的时候就已经创建好了虚拟DOM并且还进行了数据和视图的绑定。\n\t调用 mounted 钩子，但是记住，这里这个钩子并不会保正所有的子组件都被挂载完成，虽然大部分情况都是的。当然可以使用 nexttick 这个函数来保证了所有的组件被渲染。\n\t现在已经装载完成，处于组件在视图中的情况。此时当数据发生改变会引起 beforeupdate钩子\n\tbeforeUpdate钩子函数，在数据发生改变的时候，进行虚拟dom的渲染和patch之前。\n\tupdated钩子函数，在渲染和patch之后。但是不会保证所有的子组件都刷新。\n\t当调用了 destroy方法，触发了 beforeDestroy钩子\n\t拆卸 watchers，子组件和事件监听\n\t已经被销毁了，调用destroyed\n```\n\n<img src=\"Vue生命周期/lifecycle.png\" alt=\"lifecycle\" style=\"zoom:67%;\" />\n\n简单就是分为了三大阶段。\n\n**初始化，数据响应式，销毁。**\n\n<img src=\"Vue生命周期/lifecycle9.jpg\" alt=\"lifecycle9\" style=\"zoom:67%;\" />\n\n\n\n# 分析每一阶段\n\n## beforeCreate\n\n​\t\t实例初始化之后，进行数据监听和事件/侦听器的配置之前\n\n​\t\t此时实例已经初始化了，就是有了this的指向，但是还没有开启数据监听和事件的配置。\n\n​\t\t但是没有data属性\n\n## created\n\n​\t\t此时代表已经创建完成，已经将data对象创建好了，那么也代表了已经创建了响应的准备。\n\n​\t\t但是还没有开始编译模板。\n\n## beforeMount\n\n​\t\t此时是创建了虚拟DOM进行了存储，对于存在了el参数的将会即时编译，不存在el参数的将会等待被调用时(vm.$mount(el))，再进行编译。\n\n​\t\t在编译完成之后便会调用beforeMount，此时就是处于编译完成，但是却没有进行页面渲染。\n\n​\t\t在挂载开始之前被调用：相关的 `render` 函数首次被调用。\n\n​\t\t此时我们可以发现，虽然我们使用 this.$el 会有输出，但是里面的 括号表达式还没有被转换为data的数据。{{ message }}\n\n​\t\t就是属于创建了一个虚拟的节点但是还没有进行处理。\n\n\n\n## mounted\n\n​\t\tel 被新创建的 $el 替换了。此时模板已经渲染到了浏览器，\n\n​\t\t但是注意并不会保证所有的子组件也已经被挂载完成。\n\n\n\n## beforeUpdate\n\n​\t\t此时是数据已经发生了改变，但是还没有更新DOM时被调用。\n\n​\t\t这里我们可以了解以下Vue的一个更新形式，在被修改了DOM时，是先进行虚拟DOM的修改，然后直到一个执行的结束，然后再进行渲染。这里的一个是指的是一个任务的执行结束加上微任务的结束。而宏任务会被记录为下一个nexttick\n\n​\t\t我们也可以简单的使用代码进行测试\n\n```\nnew Promise(((resolve, reject) => {\n  this.a = 10;\n  resolve(20);\n})).then(res => {\n  this.a = res;\n})\nsetTimeout(() => {\n  this.a = 30;\n}, 0);\n\n先使用promise，promise内部是一个同步，直到一个异步的开始，便下一个。\nthen方法会被加入微任务\nsettimeout方法会被加入宏任务。\n所以最后使用\nbeforeUpdate() {\n\t// console.log(this.a);\n  this.$nextTick(() => {\n    console.log(this.a);\n  });\n}\n输出时，nexttick会等待一个任务加上微任务的结束为标识进行执行。所以先直接输出两次 20\n然后再输出一次 30\n这里为什么会输出两次20，原因是beforeUpdate执行了两次，所以就运行了两次。\n```\n\n\n\n## updated\n\n​\t\t此时，组件的DOM已经更新。可以使用一些依赖DOM的操作，但是不会保证子组件的渲染完成。\n\n\n\n## beforeDestroy\n\n​\t\t在实例被销毁之前被调用，此时所有的实例任然完全可以使用。\n\n\n\n## destroyed\n\n​\t\t实例销毁之后调用，此时所有的实例已经被解绑，监听已经被移除。所有的子实例也被销毁。","source":"_posts/Vue/Vue生命周期.md","raw":"---\ntitle: Vue生命周期\ndate: 2021-11-16 22:15:21\ntags:\n - Vue\n - 生命周期\ncategories:\n - Vue\n - 随笔\n---\n\n\n\n# Vue生命周期\n\n先来一个直译的形式\n\n```\n  创建一个Vue实例 new Vue\n  初始化事件和生命周期\n  调用 beforeCreate钩子\n  初始化注入和反应\n  调用 created 钩子\n  编译模板阶段\n\t\tHas el option 这里是判断是否使用了 el这个属性。如果没有使用那么就是属于未挂载的状态，只有在之后 $mount 被调用时才会进行下一步的编译。\n\t\tHas template option，判断是否使用了template参数。如果没有使用template参数，那么就将用el元素时的内部标签，如果使用了template元素，那么就会将template的字符串作为标签覆盖el元素内部的，除非有插槽。\n\t\t这里的 outerHTML，我们也知道就是：除了包含innerHTML的全部内容外, 还包含对象标签本身。\n\t然后就是调用 beforeMount 钩子\n\t然后就是创建 虚拟DOM 并且替换 el，这里就是实现了将页面的显示。此时这里在显示的时候就已经创建好了虚拟DOM并且还进行了数据和视图的绑定。\n\t调用 mounted 钩子，但是记住，这里这个钩子并不会保正所有的子组件都被挂载完成，虽然大部分情况都是的。当然可以使用 nexttick 这个函数来保证了所有的组件被渲染。\n\t现在已经装载完成，处于组件在视图中的情况。此时当数据发生改变会引起 beforeupdate钩子\n\tbeforeUpdate钩子函数，在数据发生改变的时候，进行虚拟dom的渲染和patch之前。\n\tupdated钩子函数，在渲染和patch之后。但是不会保证所有的子组件都刷新。\n\t当调用了 destroy方法，触发了 beforeDestroy钩子\n\t拆卸 watchers，子组件和事件监听\n\t已经被销毁了，调用destroyed\n```\n\n<img src=\"Vue生命周期/lifecycle.png\" alt=\"lifecycle\" style=\"zoom:67%;\" />\n\n简单就是分为了三大阶段。\n\n**初始化，数据响应式，销毁。**\n\n<img src=\"Vue生命周期/lifecycle9.jpg\" alt=\"lifecycle9\" style=\"zoom:67%;\" />\n\n\n\n# 分析每一阶段\n\n## beforeCreate\n\n​\t\t实例初始化之后，进行数据监听和事件/侦听器的配置之前\n\n​\t\t此时实例已经初始化了，就是有了this的指向，但是还没有开启数据监听和事件的配置。\n\n​\t\t但是没有data属性\n\n## created\n\n​\t\t此时代表已经创建完成，已经将data对象创建好了，那么也代表了已经创建了响应的准备。\n\n​\t\t但是还没有开始编译模板。\n\n## beforeMount\n\n​\t\t此时是创建了虚拟DOM进行了存储，对于存在了el参数的将会即时编译，不存在el参数的将会等待被调用时(vm.$mount(el))，再进行编译。\n\n​\t\t在编译完成之后便会调用beforeMount，此时就是处于编译完成，但是却没有进行页面渲染。\n\n​\t\t在挂载开始之前被调用：相关的 `render` 函数首次被调用。\n\n​\t\t此时我们可以发现，虽然我们使用 this.$el 会有输出，但是里面的 括号表达式还没有被转换为data的数据。{{ message }}\n\n​\t\t就是属于创建了一个虚拟的节点但是还没有进行处理。\n\n\n\n## mounted\n\n​\t\tel 被新创建的 $el 替换了。此时模板已经渲染到了浏览器，\n\n​\t\t但是注意并不会保证所有的子组件也已经被挂载完成。\n\n\n\n## beforeUpdate\n\n​\t\t此时是数据已经发生了改变，但是还没有更新DOM时被调用。\n\n​\t\t这里我们可以了解以下Vue的一个更新形式，在被修改了DOM时，是先进行虚拟DOM的修改，然后直到一个执行的结束，然后再进行渲染。这里的一个是指的是一个任务的执行结束加上微任务的结束。而宏任务会被记录为下一个nexttick\n\n​\t\t我们也可以简单的使用代码进行测试\n\n```\nnew Promise(((resolve, reject) => {\n  this.a = 10;\n  resolve(20);\n})).then(res => {\n  this.a = res;\n})\nsetTimeout(() => {\n  this.a = 30;\n}, 0);\n\n先使用promise，promise内部是一个同步，直到一个异步的开始，便下一个。\nthen方法会被加入微任务\nsettimeout方法会被加入宏任务。\n所以最后使用\nbeforeUpdate() {\n\t// console.log(this.a);\n  this.$nextTick(() => {\n    console.log(this.a);\n  });\n}\n输出时，nexttick会等待一个任务加上微任务的结束为标识进行执行。所以先直接输出两次 20\n然后再输出一次 30\n这里为什么会输出两次20，原因是beforeUpdate执行了两次，所以就运行了两次。\n```\n\n\n\n## updated\n\n​\t\t此时，组件的DOM已经更新。可以使用一些依赖DOM的操作，但是不会保证子组件的渲染完成。\n\n\n\n## beforeDestroy\n\n​\t\t在实例被销毁之前被调用，此时所有的实例任然完全可以使用。\n\n\n\n## destroyed\n\n​\t\t实例销毁之后调用，此时所有的实例已经被解绑，监听已经被移除。所有的子实例也被销毁。","slug":"Vue/Vue生命周期","published":1,"updated":"2021-12-09T01:56:49.404Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckznhkk80003mikubddff7yfn","content":"<h1 id=\"Vue生命周期\"><a href=\"#Vue生命周期\" class=\"headerlink\" title=\"Vue生命周期\"></a>Vue生命周期</h1><p>先来一个直译的形式</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> 创建一个Vue实例 new Vue</span><br><span class=\"line\"> 初始化事件和生命周期</span><br><span class=\"line\"> 调用 beforeCreate钩子</span><br><span class=\"line\"> 初始化注入和反应</span><br><span class=\"line\"> 调用 created 钩子</span><br><span class=\"line\"> 编译模板阶段</span><br><span class=\"line\">\tHas el option 这里是判断是否使用了 el这个属性。如果没有使用那么就是属于未挂载的状态，只有在之后 $mount 被调用时才会进行下一步的编译。</span><br><span class=\"line\">\tHas template option，判断是否使用了template参数。如果没有使用template参数，那么就将用el元素时的内部标签，如果使用了template元素，那么就会将template的字符串作为标签覆盖el元素内部的，除非有插槽。</span><br><span class=\"line\">\t这里的 outerHTML，我们也知道就是：除了包含innerHTML的全部内容外, 还包含对象标签本身。</span><br><span class=\"line\">然后就是调用 beforeMount 钩子</span><br><span class=\"line\">然后就是创建 虚拟DOM 并且替换 el，这里就是实现了将页面的显示。此时这里在显示的时候就已经创建好了虚拟DOM并且还进行了数据和视图的绑定。</span><br><span class=\"line\">调用 mounted 钩子，但是记住，这里这个钩子并不会保正所有的子组件都被挂载完成，虽然大部分情况都是的。当然可以使用 nexttick 这个函数来保证了所有的组件被渲染。</span><br><span class=\"line\">现在已经装载完成，处于组件在视图中的情况。此时当数据发生改变会引起 beforeupdate钩子</span><br><span class=\"line\">beforeUpdate钩子函数，在数据发生改变的时候，进行虚拟dom的渲染和patch之前。</span><br><span class=\"line\">updated钩子函数，在渲染和patch之后。但是不会保证所有的子组件都刷新。</span><br><span class=\"line\">当调用了 destroy方法，触发了 beforeDestroy钩子</span><br><span class=\"line\">拆卸 watchers，子组件和事件监听</span><br><span class=\"line\">已经被销毁了，调用destroyed</span><br></pre></td></tr></table></figure>\n\n<img src=\"/.io//lifecycle.png\" alt=\"lifecycle\" style=\"zoom:67%;\">\n\n<p>简单就是分为了三大阶段。</p>\n<p><strong>初始化，数据响应式，销毁。</strong></p>\n<img src=\"/.io//lifecycle9.jpg\" alt=\"lifecycle9\" style=\"zoom:67%;\">\n\n\n\n<h1 id=\"分析每一阶段\"><a href=\"#分析每一阶段\" class=\"headerlink\" title=\"分析每一阶段\"></a>分析每一阶段</h1><h2 id=\"beforeCreate\"><a href=\"#beforeCreate\" class=\"headerlink\" title=\"beforeCreate\"></a>beforeCreate</h2><p>​        实例初始化之后，进行数据监听和事件/侦听器的配置之前</p>\n<p>​        此时实例已经初始化了，就是有了this的指向，但是还没有开启数据监听和事件的配置。</p>\n<p>​        但是没有data属性</p>\n<h2 id=\"created\"><a href=\"#created\" class=\"headerlink\" title=\"created\"></a>created</h2><p>​        此时代表已经创建完成，已经将data对象创建好了，那么也代表了已经创建了响应的准备。</p>\n<p>​        但是还没有开始编译模板。</p>\n<h2 id=\"beforeMount\"><a href=\"#beforeMount\" class=\"headerlink\" title=\"beforeMount\"></a>beforeMount</h2><p>​        此时是创建了虚拟DOM进行了存储，对于存在了el参数的将会即时编译，不存在el参数的将会等待被调用时(vm.$mount(el))，再进行编译。</p>\n<p>​        在编译完成之后便会调用beforeMount，此时就是处于编译完成，但是却没有进行页面渲染。</p>\n<p>​        在挂载开始之前被调用：相关的 <code>render</code> 函数首次被调用。</p>\n<p>​        此时我们可以发现，虽然我们使用 this.$el 会有输出，但是里面的 括号表达式还没有被转换为data的数据。</p>\n<p>​        就是属于创建了一个虚拟的节点但是还没有进行处理。</p>\n<h2 id=\"mounted\"><a href=\"#mounted\" class=\"headerlink\" title=\"mounted\"></a>mounted</h2><p>​        el 被新创建的 $el 替换了。此时模板已经渲染到了浏览器，</p>\n<p>​        但是注意并不会保证所有的子组件也已经被挂载完成。</p>\n<h2 id=\"beforeUpdate\"><a href=\"#beforeUpdate\" class=\"headerlink\" title=\"beforeUpdate\"></a>beforeUpdate</h2><p>​        此时是数据已经发生了改变，但是还没有更新DOM时被调用。</p>\n<p>​        这里我们可以了解以下Vue的一个更新形式，在被修改了DOM时，是先进行虚拟DOM的修改，然后直到一个执行的结束，然后再进行渲染。这里的一个是指的是一个任务的执行结束加上微任务的结束。而宏任务会被记录为下一个nexttick</p>\n<p>​        我们也可以简单的使用代码进行测试</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new Promise(((resolve, reject) =&gt; &#123;</span><br><span class=\"line\">  this.a = 10;</span><br><span class=\"line\">  resolve(20);</span><br><span class=\"line\">&#125;)).then(res =&gt; &#123;</span><br><span class=\"line\">  this.a = res;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">setTimeout(() =&gt; &#123;</span><br><span class=\"line\">  this.a = 30;</span><br><span class=\"line\">&#125;, 0);</span><br><span class=\"line\"></span><br><span class=\"line\">先使用promise，promise内部是一个同步，直到一个异步的开始，便下一个。</span><br><span class=\"line\">then方法会被加入微任务</span><br><span class=\"line\">settimeout方法会被加入宏任务。</span><br><span class=\"line\">所以最后使用</span><br><span class=\"line\">beforeUpdate() &#123;</span><br><span class=\"line\">\t// console.log(this.a);</span><br><span class=\"line\">  this.$nextTick(() =&gt; &#123;</span><br><span class=\"line\">    console.log(this.a);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">输出时，nexttick会等待一个任务加上微任务的结束为标识进行执行。所以先直接输出两次 20</span><br><span class=\"line\">然后再输出一次 30</span><br><span class=\"line\">这里为什么会输出两次20，原因是beforeUpdate执行了两次，所以就运行了两次。</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"updated\"><a href=\"#updated\" class=\"headerlink\" title=\"updated\"></a>updated</h2><p>​        此时，组件的DOM已经更新。可以使用一些依赖DOM的操作，但是不会保证子组件的渲染完成。</p>\n<h2 id=\"beforeDestroy\"><a href=\"#beforeDestroy\" class=\"headerlink\" title=\"beforeDestroy\"></a>beforeDestroy</h2><p>​        在实例被销毁之前被调用，此时所有的实例任然完全可以使用。</p>\n<h2 id=\"destroyed\"><a href=\"#destroyed\" class=\"headerlink\" title=\"destroyed\"></a>destroyed</h2><p>​        实例销毁之后调用，此时所有的实例已经被解绑，监听已经被移除。所有的子实例也被销毁。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Vue生命周期\"><a href=\"#Vue生命周期\" class=\"headerlink\" title=\"Vue生命周期\"></a>Vue生命周期</h1><p>先来一个直译的形式</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> 创建一个Vue实例 new Vue</span><br><span class=\"line\"> 初始化事件和生命周期</span><br><span class=\"line\"> 调用 beforeCreate钩子</span><br><span class=\"line\"> 初始化注入和反应</span><br><span class=\"line\"> 调用 created 钩子</span><br><span class=\"line\"> 编译模板阶段</span><br><span class=\"line\">\tHas el option 这里是判断是否使用了 el这个属性。如果没有使用那么就是属于未挂载的状态，只有在之后 $mount 被调用时才会进行下一步的编译。</span><br><span class=\"line\">\tHas template option，判断是否使用了template参数。如果没有使用template参数，那么就将用el元素时的内部标签，如果使用了template元素，那么就会将template的字符串作为标签覆盖el元素内部的，除非有插槽。</span><br><span class=\"line\">\t这里的 outerHTML，我们也知道就是：除了包含innerHTML的全部内容外, 还包含对象标签本身。</span><br><span class=\"line\">然后就是调用 beforeMount 钩子</span><br><span class=\"line\">然后就是创建 虚拟DOM 并且替换 el，这里就是实现了将页面的显示。此时这里在显示的时候就已经创建好了虚拟DOM并且还进行了数据和视图的绑定。</span><br><span class=\"line\">调用 mounted 钩子，但是记住，这里这个钩子并不会保正所有的子组件都被挂载完成，虽然大部分情况都是的。当然可以使用 nexttick 这个函数来保证了所有的组件被渲染。</span><br><span class=\"line\">现在已经装载完成，处于组件在视图中的情况。此时当数据发生改变会引起 beforeupdate钩子</span><br><span class=\"line\">beforeUpdate钩子函数，在数据发生改变的时候，进行虚拟dom的渲染和patch之前。</span><br><span class=\"line\">updated钩子函数，在渲染和patch之后。但是不会保证所有的子组件都刷新。</span><br><span class=\"line\">当调用了 destroy方法，触发了 beforeDestroy钩子</span><br><span class=\"line\">拆卸 watchers，子组件和事件监听</span><br><span class=\"line\">已经被销毁了，调用destroyed</span><br></pre></td></tr></table></figure>\n\n<img src=\"/.io//lifecycle.png\" alt=\"lifecycle\" style=\"zoom:67%;\">\n\n<p>简单就是分为了三大阶段。</p>\n<p><strong>初始化，数据响应式，销毁。</strong></p>\n<img src=\"/.io//lifecycle9.jpg\" alt=\"lifecycle9\" style=\"zoom:67%;\">\n\n\n\n<h1 id=\"分析每一阶段\"><a href=\"#分析每一阶段\" class=\"headerlink\" title=\"分析每一阶段\"></a>分析每一阶段</h1><h2 id=\"beforeCreate\"><a href=\"#beforeCreate\" class=\"headerlink\" title=\"beforeCreate\"></a>beforeCreate</h2><p>​        实例初始化之后，进行数据监听和事件/侦听器的配置之前</p>\n<p>​        此时实例已经初始化了，就是有了this的指向，但是还没有开启数据监听和事件的配置。</p>\n<p>​        但是没有data属性</p>\n<h2 id=\"created\"><a href=\"#created\" class=\"headerlink\" title=\"created\"></a>created</h2><p>​        此时代表已经创建完成，已经将data对象创建好了，那么也代表了已经创建了响应的准备。</p>\n<p>​        但是还没有开始编译模板。</p>\n<h2 id=\"beforeMount\"><a href=\"#beforeMount\" class=\"headerlink\" title=\"beforeMount\"></a>beforeMount</h2><p>​        此时是创建了虚拟DOM进行了存储，对于存在了el参数的将会即时编译，不存在el参数的将会等待被调用时(vm.$mount(el))，再进行编译。</p>\n<p>​        在编译完成之后便会调用beforeMount，此时就是处于编译完成，但是却没有进行页面渲染。</p>\n<p>​        在挂载开始之前被调用：相关的 <code>render</code> 函数首次被调用。</p>\n<p>​        此时我们可以发现，虽然我们使用 this.$el 会有输出，但是里面的 括号表达式还没有被转换为data的数据。</p>\n<p>​        就是属于创建了一个虚拟的节点但是还没有进行处理。</p>\n<h2 id=\"mounted\"><a href=\"#mounted\" class=\"headerlink\" title=\"mounted\"></a>mounted</h2><p>​        el 被新创建的 $el 替换了。此时模板已经渲染到了浏览器，</p>\n<p>​        但是注意并不会保证所有的子组件也已经被挂载完成。</p>\n<h2 id=\"beforeUpdate\"><a href=\"#beforeUpdate\" class=\"headerlink\" title=\"beforeUpdate\"></a>beforeUpdate</h2><p>​        此时是数据已经发生了改变，但是还没有更新DOM时被调用。</p>\n<p>​        这里我们可以了解以下Vue的一个更新形式，在被修改了DOM时，是先进行虚拟DOM的修改，然后直到一个执行的结束，然后再进行渲染。这里的一个是指的是一个任务的执行结束加上微任务的结束。而宏任务会被记录为下一个nexttick</p>\n<p>​        我们也可以简单的使用代码进行测试</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new Promise(((resolve, reject) =&gt; &#123;</span><br><span class=\"line\">  this.a = 10;</span><br><span class=\"line\">  resolve(20);</span><br><span class=\"line\">&#125;)).then(res =&gt; &#123;</span><br><span class=\"line\">  this.a = res;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">setTimeout(() =&gt; &#123;</span><br><span class=\"line\">  this.a = 30;</span><br><span class=\"line\">&#125;, 0);</span><br><span class=\"line\"></span><br><span class=\"line\">先使用promise，promise内部是一个同步，直到一个异步的开始，便下一个。</span><br><span class=\"line\">then方法会被加入微任务</span><br><span class=\"line\">settimeout方法会被加入宏任务。</span><br><span class=\"line\">所以最后使用</span><br><span class=\"line\">beforeUpdate() &#123;</span><br><span class=\"line\">\t// console.log(this.a);</span><br><span class=\"line\">  this.$nextTick(() =&gt; &#123;</span><br><span class=\"line\">    console.log(this.a);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">输出时，nexttick会等待一个任务加上微任务的结束为标识进行执行。所以先直接输出两次 20</span><br><span class=\"line\">然后再输出一次 30</span><br><span class=\"line\">这里为什么会输出两次20，原因是beforeUpdate执行了两次，所以就运行了两次。</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"updated\"><a href=\"#updated\" class=\"headerlink\" title=\"updated\"></a>updated</h2><p>​        此时，组件的DOM已经更新。可以使用一些依赖DOM的操作，但是不会保证子组件的渲染完成。</p>\n<h2 id=\"beforeDestroy\"><a href=\"#beforeDestroy\" class=\"headerlink\" title=\"beforeDestroy\"></a>beforeDestroy</h2><p>​        在实例被销毁之前被调用，此时所有的实例任然完全可以使用。</p>\n<h2 id=\"destroyed\"><a href=\"#destroyed\" class=\"headerlink\" title=\"destroyed\"></a>destroyed</h2><p>​        实例销毁之后调用，此时所有的实例已经被解绑，监听已经被移除。所有的子实例也被销毁。</p>\n"},{"title":"Vue2和Vue3的区别","date":"2021-10-16T12:02:19.000Z","_content":"\n\n\n\n# Vue2和Vue3的区别\n\n参考别人的文章和官网\n\n```\nhttps://blog.csdn.net/weixin_46071217/article/details/108858877\nhttps://zhuanlan.zhihu.com/p/139590941\n\nhttps://v3.cn.vuejs.org/guide/migration/introduction.html\n```\n\n\n\n## 从内部上\n\n\n\n### 响应式的改变\n\nVue2是使用的 `Object.definePropert()` ，而Vue3是使用的 `Proxy` 来对数据进行的代理。\n\n**definePropert的使用**\n\n```\nhttps://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty\n```\n\n```\nhttps://www.jianshu.com/p/8fe1382ba135\n```\n\n```\nlet a = {};\n\n//这里这个bV是用来存储属性的值。\nlet bV;\nObject.defineProperty(a, 'b', {\n  set(v) {\n    console.log('set', v);\n    bV = v;\n  },\n  get() {\n    console.log('get', bV);\n    return bV;\n  },\n  enumerable : true,\n  configurable : true\n});\n```\n\n**prosy**\n\n```\nhttps://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy\n```\n\n```\nlet validator = {\n  set(obj, prop, value) {\n    console.log('set   ');\n    console.log(obj, prop, value);\n    obj[prop] = value;\n    return true;\n  },\n  get(obj, prop) {\n    console.log('get   ');\n    console.log(obj, prop);\n    return obj[prop];\n  }\n}\n\nlet person = new Proxy({}, validator);\n\nperson.a = 100;\nconsole.log(person.a);\n```\n\nproxy的优势\n\n```\n使用对象，可以是数组，函数，任何对象，而definePropert只能是一个对象的某一个值进行监听。\n\ndefineProperty只能监听某个属性，不能对全对象监听\n可以省去for in、闭包等内容来提升效率（直接绑定整个对象即可）\n可以监听数组，不用再去单独的对数组做特异性操作 vue3.x可以检测到数组内部数据的变化\n```\n\n\n\n### 默认进行懒观察（lazy observation）。\n\n```\n在 2.x 版本里，不管数据多大，都会在一开始就为其创建观察者。当数据很大时，这可能会在页面载入时造成明显的性能压力。3.x 版本，只会对「被用于渲染初始可见部分的数据」创建观察者，而且 3.x 的观察者更高效。\n```\n\n\n\n### 更精准的变更通知。\n\n```\n2.x 版本中，使用 Vue.set 来给对象新增一个属性时，这个对象的所有 watcher 都会重新运行；3.x 版本中，只有依赖那个属性的 watcher 才会重新运行。\n```\n\n\n\n## 从使用上\n\n```\nhttps://v3.cn.vuejs.org/guide/migration/introduction.html\n```\n\n\n\n### 组合式API\n\n**setup**\n\n注意\n\n```\n在 setup 中你应该避免使用 this，因为它不会找到组件实例。\nsetup 的调用发生在 data property、computed property 或 methods 被解析之前，所以它们无法在 setup 中被获取。\n```\n\n使用ref将值封装于对象之中。\n\n```\n因为在 JavaScript 中，Number 或 String 等基本类型是通过值而非引用传递的，所以封装成对象之后变有了作用。\n```\n\n在setup里面注册生命周期钩子\n\n```\nonMounted(getUserRepositories) // 在 `mounted` 时调用 `getUserRepositories`\n\n这个代码放在setup内部\n```\n\n\n\n### Teleport\n\nTeleport 提供了一种干净的方法，允许我们控制在 DOM 中哪个父节点下渲染了 HTML，而不必求助于全局状态或将其拆分为两个组件。\n\n```\n<teleport to=\"body\"></teleport>\n```\n\n特点：使用之后， `to=\"body\"`，代表了在渲染时会作为body的子元素来进行渲染，不会出现一些，因为父元素的设置定位等问题而影响到了 `teleport ` 的渲染。\n\n\n\n### 片段\n\nVue2.x 不支持多根节点，而Vue3.x支持了。\n\n在 3.x 中，组件可以包含多个根节点！但是，这要求开发者显式定义 attribute 应该分布在哪里。\n\n\n\n**为什么Vue实例只能有一个根元素**\n\n```\nhttps://zhuanlan.zhihu.com/p/111691226\n```\n\n从源码上来说。\n\n```\n在实例化Vue的时候，填写一个el选项，来指定入口\n在Vue的源码里面，他只寻找了指定选择器的第一个元素。所以后面的都会原封不动。\n```\n\n对于单文件组件。\n\ntemplate里面如果有 多个div入口，不知道如何指定 谁作为入口。\n\n\n\n### 单文件组件`<script setup>`\n\n\n\n<script setup> 是在单文件组件 (SFC) 中使用组合式 API 的编译时语法糖。相比于普通的 <script> 语法，它具有更多优势：\n\t更少的样板内容，更简洁的代码。\n    能够使用纯 Typescript 声明 props 和抛出事件。\n    更好的运行时性能 (其模板会被编译成与其同一作用域的渲染函数，没有任何的中间代理)。\n    更好的 IDE 类型推断性能 (减少语言服务器从代码中抽离类型的工作)。\n\n\n\n```\n里面的代码会被编译成组件 setup() 函数的内容。这意味着与普通的 <script> 只在组件被首次引入的时候执行一次不同，<script setup> 中的代码会在每次组件实例被创建的时候执行。\n```\n\n\n\n**限制：没有 Src 导入**\n\n```\n由于模块执行语义的差异，`<script setup>` 中的代码依赖单文件组件的上下文。当将其移动到外部的 `.js` 或者 `.ts` 文件中的时候，对于开发者和工具来说都会感到混乱。因而 **`<script setup>`** 不能和 `src` attribute 一起使用。\n```\n\n\n\n### 状态驱动的动态 CSS\n\n单文件组件的 `<style>` 标签可以通过 `v-bind` 这一 CSS 函数将 CSS 的值关联到动态的组件状态上：\n\n\n\n```\nscript \n\texport default\n\t\tdata() {\n\t\t\treturn {\n\t\t\t\tcolor: 'red'\n\t\t\t}\n\t\t}\n\n\n<style>\n.text {\n  color: v-bind(color);\n}\n</style>\n```\n\n\n\n### Suspense**新增**\n\nSuspense 是一个试验性的新特性，其 API 可能随时会发生变动。特此声明，以便社区能够为当前的实现提供反馈。\n\n生产环境请勿使用。\n\n```\n\t在正确渲染组件之前进行一些异步请求是很常见的事。组件通常会在本地处理这种逻辑，绝大多数情况下这是非常完美的做法。\n\t该 `<suspense>` 组件提供了另一个方案，允许将等待过程提升到组件树中处理，而不是在单个组件中。\n```\n\n","source":"_posts/Vue/vue2和vue3的区别.md","raw":"---\ntitle: Vue2和Vue3的区别\ndate: 2021-10-16 20:02:19\ntags:\n  - Vue\n  - Vue3的不同\ncategories:\n - Vue\n - Vue3\n---\n\n\n\n\n# Vue2和Vue3的区别\n\n参考别人的文章和官网\n\n```\nhttps://blog.csdn.net/weixin_46071217/article/details/108858877\nhttps://zhuanlan.zhihu.com/p/139590941\n\nhttps://v3.cn.vuejs.org/guide/migration/introduction.html\n```\n\n\n\n## 从内部上\n\n\n\n### 响应式的改变\n\nVue2是使用的 `Object.definePropert()` ，而Vue3是使用的 `Proxy` 来对数据进行的代理。\n\n**definePropert的使用**\n\n```\nhttps://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty\n```\n\n```\nhttps://www.jianshu.com/p/8fe1382ba135\n```\n\n```\nlet a = {};\n\n//这里这个bV是用来存储属性的值。\nlet bV;\nObject.defineProperty(a, 'b', {\n  set(v) {\n    console.log('set', v);\n    bV = v;\n  },\n  get() {\n    console.log('get', bV);\n    return bV;\n  },\n  enumerable : true,\n  configurable : true\n});\n```\n\n**prosy**\n\n```\nhttps://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy\n```\n\n```\nlet validator = {\n  set(obj, prop, value) {\n    console.log('set   ');\n    console.log(obj, prop, value);\n    obj[prop] = value;\n    return true;\n  },\n  get(obj, prop) {\n    console.log('get   ');\n    console.log(obj, prop);\n    return obj[prop];\n  }\n}\n\nlet person = new Proxy({}, validator);\n\nperson.a = 100;\nconsole.log(person.a);\n```\n\nproxy的优势\n\n```\n使用对象，可以是数组，函数，任何对象，而definePropert只能是一个对象的某一个值进行监听。\n\ndefineProperty只能监听某个属性，不能对全对象监听\n可以省去for in、闭包等内容来提升效率（直接绑定整个对象即可）\n可以监听数组，不用再去单独的对数组做特异性操作 vue3.x可以检测到数组内部数据的变化\n```\n\n\n\n### 默认进行懒观察（lazy observation）。\n\n```\n在 2.x 版本里，不管数据多大，都会在一开始就为其创建观察者。当数据很大时，这可能会在页面载入时造成明显的性能压力。3.x 版本，只会对「被用于渲染初始可见部分的数据」创建观察者，而且 3.x 的观察者更高效。\n```\n\n\n\n### 更精准的变更通知。\n\n```\n2.x 版本中，使用 Vue.set 来给对象新增一个属性时，这个对象的所有 watcher 都会重新运行；3.x 版本中，只有依赖那个属性的 watcher 才会重新运行。\n```\n\n\n\n## 从使用上\n\n```\nhttps://v3.cn.vuejs.org/guide/migration/introduction.html\n```\n\n\n\n### 组合式API\n\n**setup**\n\n注意\n\n```\n在 setup 中你应该避免使用 this，因为它不会找到组件实例。\nsetup 的调用发生在 data property、computed property 或 methods 被解析之前，所以它们无法在 setup 中被获取。\n```\n\n使用ref将值封装于对象之中。\n\n```\n因为在 JavaScript 中，Number 或 String 等基本类型是通过值而非引用传递的，所以封装成对象之后变有了作用。\n```\n\n在setup里面注册生命周期钩子\n\n```\nonMounted(getUserRepositories) // 在 `mounted` 时调用 `getUserRepositories`\n\n这个代码放在setup内部\n```\n\n\n\n### Teleport\n\nTeleport 提供了一种干净的方法，允许我们控制在 DOM 中哪个父节点下渲染了 HTML，而不必求助于全局状态或将其拆分为两个组件。\n\n```\n<teleport to=\"body\"></teleport>\n```\n\n特点：使用之后， `to=\"body\"`，代表了在渲染时会作为body的子元素来进行渲染，不会出现一些，因为父元素的设置定位等问题而影响到了 `teleport ` 的渲染。\n\n\n\n### 片段\n\nVue2.x 不支持多根节点，而Vue3.x支持了。\n\n在 3.x 中，组件可以包含多个根节点！但是，这要求开发者显式定义 attribute 应该分布在哪里。\n\n\n\n**为什么Vue实例只能有一个根元素**\n\n```\nhttps://zhuanlan.zhihu.com/p/111691226\n```\n\n从源码上来说。\n\n```\n在实例化Vue的时候，填写一个el选项，来指定入口\n在Vue的源码里面，他只寻找了指定选择器的第一个元素。所以后面的都会原封不动。\n```\n\n对于单文件组件。\n\ntemplate里面如果有 多个div入口，不知道如何指定 谁作为入口。\n\n\n\n### 单文件组件`<script setup>`\n\n\n\n<script setup> 是在单文件组件 (SFC) 中使用组合式 API 的编译时语法糖。相比于普通的 <script> 语法，它具有更多优势：\n\t更少的样板内容，更简洁的代码。\n    能够使用纯 Typescript 声明 props 和抛出事件。\n    更好的运行时性能 (其模板会被编译成与其同一作用域的渲染函数，没有任何的中间代理)。\n    更好的 IDE 类型推断性能 (减少语言服务器从代码中抽离类型的工作)。\n\n\n\n```\n里面的代码会被编译成组件 setup() 函数的内容。这意味着与普通的 <script> 只在组件被首次引入的时候执行一次不同，<script setup> 中的代码会在每次组件实例被创建的时候执行。\n```\n\n\n\n**限制：没有 Src 导入**\n\n```\n由于模块执行语义的差异，`<script setup>` 中的代码依赖单文件组件的上下文。当将其移动到外部的 `.js` 或者 `.ts` 文件中的时候，对于开发者和工具来说都会感到混乱。因而 **`<script setup>`** 不能和 `src` attribute 一起使用。\n```\n\n\n\n### 状态驱动的动态 CSS\n\n单文件组件的 `<style>` 标签可以通过 `v-bind` 这一 CSS 函数将 CSS 的值关联到动态的组件状态上：\n\n\n\n```\nscript \n\texport default\n\t\tdata() {\n\t\t\treturn {\n\t\t\t\tcolor: 'red'\n\t\t\t}\n\t\t}\n\n\n<style>\n.text {\n  color: v-bind(color);\n}\n</style>\n```\n\n\n\n### Suspense**新增**\n\nSuspense 是一个试验性的新特性，其 API 可能随时会发生变动。特此声明，以便社区能够为当前的实现提供反馈。\n\n生产环境请勿使用。\n\n```\n\t在正确渲染组件之前进行一些异步请求是很常见的事。组件通常会在本地处理这种逻辑，绝大多数情况下这是非常完美的做法。\n\t该 `<suspense>` 组件提供了另一个方案，允许将等待过程提升到组件树中处理，而不是在单个组件中。\n```\n\n","slug":"Vue/vue2和vue3的区别","published":1,"updated":"2021-12-09T01:56:49.420Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckznhkk81003pikub0bkt18yl","content":"<h1 id=\"Vue2和Vue3的区别\"><a href=\"#Vue2和Vue3的区别\" class=\"headerlink\" title=\"Vue2和Vue3的区别\"></a>Vue2和Vue3的区别</h1><p>参考别人的文章和官网</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://blog.csdn.net/weixin_46071217/article/details/108858877</span><br><span class=\"line\">https://zhuanlan.zhihu.com/p/139590941</span><br><span class=\"line\"></span><br><span class=\"line\">https://v3.cn.vuejs.org/guide/migration/introduction.html</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"从内部上\"><a href=\"#从内部上\" class=\"headerlink\" title=\"从内部上\"></a>从内部上</h2><h3 id=\"响应式的改变\"><a href=\"#响应式的改变\" class=\"headerlink\" title=\"响应式的改变\"></a>响应式的改变</h3><p>Vue2是使用的 <code>Object.definePropert()</code> ，而Vue3是使用的 <code>Proxy</code> 来对数据进行的代理。</p>\n<p><strong>definePropert的使用</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://www.jianshu.com/p/8fe1382ba135</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let a = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">//这里这个bV是用来存储属性的值。</span><br><span class=\"line\">let bV;</span><br><span class=\"line\">Object.defineProperty(a, &#x27;b&#x27;, &#123;</span><br><span class=\"line\">  set(v) &#123;</span><br><span class=\"line\">    console.log(&#x27;set&#x27;, v);</span><br><span class=\"line\">    bV = v;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  get() &#123;</span><br><span class=\"line\">    console.log(&#x27;get&#x27;, bV);</span><br><span class=\"line\">    return bV;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  enumerable : true,</span><br><span class=\"line\">  configurable : true</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p><strong>prosy</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let validator = &#123;</span><br><span class=\"line\">  set(obj, prop, value) &#123;</span><br><span class=\"line\">    console.log(&#x27;set   &#x27;);</span><br><span class=\"line\">    console.log(obj, prop, value);</span><br><span class=\"line\">    obj[prop] = value;</span><br><span class=\"line\">    return true;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  get(obj, prop) &#123;</span><br><span class=\"line\">    console.log(&#x27;get   &#x27;);</span><br><span class=\"line\">    console.log(obj, prop);</span><br><span class=\"line\">    return obj[prop];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">let person = new Proxy(&#123;&#125;, validator);</span><br><span class=\"line\"></span><br><span class=\"line\">person.a = 100;</span><br><span class=\"line\">console.log(person.a);</span><br></pre></td></tr></table></figure>\n\n<p>proxy的优势</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">使用对象，可以是数组，函数，任何对象，而definePropert只能是一个对象的某一个值进行监听。</span><br><span class=\"line\"></span><br><span class=\"line\">defineProperty只能监听某个属性，不能对全对象监听</span><br><span class=\"line\">可以省去for in、闭包等内容来提升效率（直接绑定整个对象即可）</span><br><span class=\"line\">可以监听数组，不用再去单独的对数组做特异性操作 vue3.x可以检测到数组内部数据的变化</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"默认进行懒观察（lazy-observation）。\"><a href=\"#默认进行懒观察（lazy-observation）。\" class=\"headerlink\" title=\"默认进行懒观察（lazy observation）。\"></a>默认进行懒观察（lazy observation）。</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">在 2.x 版本里，不管数据多大，都会在一开始就为其创建观察者。当数据很大时，这可能会在页面载入时造成明显的性能压力。3.x 版本，只会对「被用于渲染初始可见部分的数据」创建观察者，而且 3.x 的观察者更高效。</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"更精准的变更通知。\"><a href=\"#更精准的变更通知。\" class=\"headerlink\" title=\"更精准的变更通知。\"></a>更精准的变更通知。</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2.x 版本中，使用 Vue.set 来给对象新增一个属性时，这个对象的所有 watcher 都会重新运行；3.x 版本中，只有依赖那个属性的 watcher 才会重新运行。</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"从使用上\"><a href=\"#从使用上\" class=\"headerlink\" title=\"从使用上\"></a>从使用上</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://v3.cn.vuejs.org/guide/migration/introduction.html</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"组合式API\"><a href=\"#组合式API\" class=\"headerlink\" title=\"组合式API\"></a>组合式API</h3><p><strong>setup</strong></p>\n<p>注意</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">在 setup 中你应该避免使用 this，因为它不会找到组件实例。</span><br><span class=\"line\">setup 的调用发生在 data property、computed property 或 methods 被解析之前，所以它们无法在 setup 中被获取。</span><br></pre></td></tr></table></figure>\n\n<p>使用ref将值封装于对象之中。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">因为在 JavaScript 中，Number 或 String 等基本类型是通过值而非引用传递的，所以封装成对象之后变有了作用。</span><br></pre></td></tr></table></figure>\n\n<p>在setup里面注册生命周期钩子</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">onMounted(getUserRepositories) // 在 `mounted` 时调用 `getUserRepositories`</span><br><span class=\"line\"></span><br><span class=\"line\">这个代码放在setup内部</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"Teleport\"><a href=\"#Teleport\" class=\"headerlink\" title=\"Teleport\"></a>Teleport</h3><p>Teleport 提供了一种干净的方法，允许我们控制在 DOM 中哪个父节点下渲染了 HTML，而不必求助于全局状态或将其拆分为两个组件。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;teleport to=&quot;body&quot;&gt;&lt;/teleport&gt;</span><br></pre></td></tr></table></figure>\n\n<p>特点：使用之后， <code>to=&quot;body&quot;</code>，代表了在渲染时会作为body的子元素来进行渲染，不会出现一些，因为父元素的设置定位等问题而影响到了 <code>teleport </code> 的渲染。</p>\n<h3 id=\"片段\"><a href=\"#片段\" class=\"headerlink\" title=\"片段\"></a>片段</h3><p>Vue2.x 不支持多根节点，而Vue3.x支持了。</p>\n<p>在 3.x 中，组件可以包含多个根节点！但是，这要求开发者显式定义 attribute 应该分布在哪里。</p>\n<p><strong>为什么Vue实例只能有一个根元素</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://zhuanlan.zhihu.com/p/111691226</span><br></pre></td></tr></table></figure>\n\n<p>从源码上来说。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">在实例化Vue的时候，填写一个el选项，来指定入口</span><br><span class=\"line\">在Vue的源码里面，他只寻找了指定选择器的第一个元素。所以后面的都会原封不动。</span><br></pre></td></tr></table></figure>\n\n<p>对于单文件组件。</p>\n<p>template里面如果有 多个div入口，不知道如何指定 谁作为入口。</p>\n<h3 id=\"单文件组件-lt-script-setup-gt\"><a href=\"#单文件组件-lt-script-setup-gt\" class=\"headerlink\" title=\"单文件组件&lt;script setup&gt;\"></a>单文件组件<code>&lt;script setup&gt;</code></h3><script setup> 是在单文件组件 (SFC) 中使用组合式 API 的编译时语法糖。相比于普通的 <script> 语法，它具有更多优势：\n    更少的样板内容，更简洁的代码。\n    能够使用纯 Typescript 声明 props 和抛出事件。\n    更好的运行时性能 (其模板会被编译成与其同一作用域的渲染函数，没有任何的中间代理)。\n    更好的 IDE 类型推断性能 (减少语言服务器从代码中抽离类型的工作)。\n\n\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">里面的代码会被编译成组件 setup() 函数的内容。这意味着与普通的 &lt;script&gt; 只在组件被首次引入的时候执行一次不同，&lt;script setup&gt; 中的代码会在每次组件实例被创建的时候执行。</span><br></pre></td></tr></table></figure>\n\n\n\n**限制：没有 Src 导入**\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">由于模块执行语义的差异，`&lt;script setup&gt;` 中的代码依赖单文件组件的上下文。当将其移动到外部的 `.js` 或者 `.ts` 文件中的时候，对于开发者和工具来说都会感到混乱。因而 **`&lt;script setup&gt;`** 不能和 `src` attribute 一起使用。</span><br></pre></td></tr></table></figure>\n\n\n\n### 状态驱动的动态 CSS\n\n单文件组件的 `<style>` 标签可以通过 `v-bind` 这一 CSS 函数将 CSS 的值关联到动态的组件状态上：\n\n\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">script </span><br><span class=\"line\">\texport default</span><br><span class=\"line\">\t\tdata() &#123;</span><br><span class=\"line\">\t\t\treturn &#123;</span><br><span class=\"line\">\t\t\t\tcolor: &#x27;red&#x27;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&lt;style&gt;</span><br><span class=\"line\">.text &#123;</span><br><span class=\"line\">  color: v-bind(color);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/style&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n### Suspense**新增**\n\nSuspense 是一个试验性的新特性，其 API 可能随时会发生变动。特此声明，以便社区能够为当前的实现提供反馈。\n\n生产环境请勿使用。\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">在正确渲染组件之前进行一些异步请求是很常见的事。组件通常会在本地处理这种逻辑，绝大多数情况下这是非常完美的做法。</span><br><span class=\"line\">该 `&lt;suspense&gt;` 组件提供了另一个方案，允许将等待过程提升到组件树中处理，而不是在单个组件中。</span><br></pre></td></tr></table></figure>\n\n</script>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Vue2和Vue3的区别\"><a href=\"#Vue2和Vue3的区别\" class=\"headerlink\" title=\"Vue2和Vue3的区别\"></a>Vue2和Vue3的区别</h1><p>参考别人的文章和官网</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://blog.csdn.net/weixin_46071217/article/details/108858877</span><br><span class=\"line\">https://zhuanlan.zhihu.com/p/139590941</span><br><span class=\"line\"></span><br><span class=\"line\">https://v3.cn.vuejs.org/guide/migration/introduction.html</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"从内部上\"><a href=\"#从内部上\" class=\"headerlink\" title=\"从内部上\"></a>从内部上</h2><h3 id=\"响应式的改变\"><a href=\"#响应式的改变\" class=\"headerlink\" title=\"响应式的改变\"></a>响应式的改变</h3><p>Vue2是使用的 <code>Object.definePropert()</code> ，而Vue3是使用的 <code>Proxy</code> 来对数据进行的代理。</p>\n<p><strong>definePropert的使用</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://www.jianshu.com/p/8fe1382ba135</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let a = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">//这里这个bV是用来存储属性的值。</span><br><span class=\"line\">let bV;</span><br><span class=\"line\">Object.defineProperty(a, &#x27;b&#x27;, &#123;</span><br><span class=\"line\">  set(v) &#123;</span><br><span class=\"line\">    console.log(&#x27;set&#x27;, v);</span><br><span class=\"line\">    bV = v;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  get() &#123;</span><br><span class=\"line\">    console.log(&#x27;get&#x27;, bV);</span><br><span class=\"line\">    return bV;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  enumerable : true,</span><br><span class=\"line\">  configurable : true</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p><strong>prosy</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let validator = &#123;</span><br><span class=\"line\">  set(obj, prop, value) &#123;</span><br><span class=\"line\">    console.log(&#x27;set   &#x27;);</span><br><span class=\"line\">    console.log(obj, prop, value);</span><br><span class=\"line\">    obj[prop] = value;</span><br><span class=\"line\">    return true;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  get(obj, prop) &#123;</span><br><span class=\"line\">    console.log(&#x27;get   &#x27;);</span><br><span class=\"line\">    console.log(obj, prop);</span><br><span class=\"line\">    return obj[prop];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">let person = new Proxy(&#123;&#125;, validator);</span><br><span class=\"line\"></span><br><span class=\"line\">person.a = 100;</span><br><span class=\"line\">console.log(person.a);</span><br></pre></td></tr></table></figure>\n\n<p>proxy的优势</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">使用对象，可以是数组，函数，任何对象，而definePropert只能是一个对象的某一个值进行监听。</span><br><span class=\"line\"></span><br><span class=\"line\">defineProperty只能监听某个属性，不能对全对象监听</span><br><span class=\"line\">可以省去for in、闭包等内容来提升效率（直接绑定整个对象即可）</span><br><span class=\"line\">可以监听数组，不用再去单独的对数组做特异性操作 vue3.x可以检测到数组内部数据的变化</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"默认进行懒观察（lazy-observation）。\"><a href=\"#默认进行懒观察（lazy-observation）。\" class=\"headerlink\" title=\"默认进行懒观察（lazy observation）。\"></a>默认进行懒观察（lazy observation）。</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">在 2.x 版本里，不管数据多大，都会在一开始就为其创建观察者。当数据很大时，这可能会在页面载入时造成明显的性能压力。3.x 版本，只会对「被用于渲染初始可见部分的数据」创建观察者，而且 3.x 的观察者更高效。</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"更精准的变更通知。\"><a href=\"#更精准的变更通知。\" class=\"headerlink\" title=\"更精准的变更通知。\"></a>更精准的变更通知。</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2.x 版本中，使用 Vue.set 来给对象新增一个属性时，这个对象的所有 watcher 都会重新运行；3.x 版本中，只有依赖那个属性的 watcher 才会重新运行。</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"从使用上\"><a href=\"#从使用上\" class=\"headerlink\" title=\"从使用上\"></a>从使用上</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://v3.cn.vuejs.org/guide/migration/introduction.html</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"组合式API\"><a href=\"#组合式API\" class=\"headerlink\" title=\"组合式API\"></a>组合式API</h3><p><strong>setup</strong></p>\n<p>注意</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">在 setup 中你应该避免使用 this，因为它不会找到组件实例。</span><br><span class=\"line\">setup 的调用发生在 data property、computed property 或 methods 被解析之前，所以它们无法在 setup 中被获取。</span><br></pre></td></tr></table></figure>\n\n<p>使用ref将值封装于对象之中。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">因为在 JavaScript 中，Number 或 String 等基本类型是通过值而非引用传递的，所以封装成对象之后变有了作用。</span><br></pre></td></tr></table></figure>\n\n<p>在setup里面注册生命周期钩子</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">onMounted(getUserRepositories) // 在 `mounted` 时调用 `getUserRepositories`</span><br><span class=\"line\"></span><br><span class=\"line\">这个代码放在setup内部</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"Teleport\"><a href=\"#Teleport\" class=\"headerlink\" title=\"Teleport\"></a>Teleport</h3><p>Teleport 提供了一种干净的方法，允许我们控制在 DOM 中哪个父节点下渲染了 HTML，而不必求助于全局状态或将其拆分为两个组件。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;teleport to=&quot;body&quot;&gt;&lt;/teleport&gt;</span><br></pre></td></tr></table></figure>\n\n<p>特点：使用之后， <code>to=&quot;body&quot;</code>，代表了在渲染时会作为body的子元素来进行渲染，不会出现一些，因为父元素的设置定位等问题而影响到了 <code>teleport </code> 的渲染。</p>\n<h3 id=\"片段\"><a href=\"#片段\" class=\"headerlink\" title=\"片段\"></a>片段</h3><p>Vue2.x 不支持多根节点，而Vue3.x支持了。</p>\n<p>在 3.x 中，组件可以包含多个根节点！但是，这要求开发者显式定义 attribute 应该分布在哪里。</p>\n<p><strong>为什么Vue实例只能有一个根元素</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://zhuanlan.zhihu.com/p/111691226</span><br></pre></td></tr></table></figure>\n\n<p>从源码上来说。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">在实例化Vue的时候，填写一个el选项，来指定入口</span><br><span class=\"line\">在Vue的源码里面，他只寻找了指定选择器的第一个元素。所以后面的都会原封不动。</span><br></pre></td></tr></table></figure>\n\n<p>对于单文件组件。</p>\n<p>template里面如果有 多个div入口，不知道如何指定 谁作为入口。</p>\n<h3 id=\"单文件组件-lt-script-setup-gt\"><a href=\"#单文件组件-lt-script-setup-gt\" class=\"headerlink\" title=\"单文件组件&lt;script setup&gt;\"></a>单文件组件<code>&lt;script setup&gt;</code></h3><script setup> 是在单文件组件 (SFC) 中使用组合式 API 的编译时语法糖。相比于普通的 <script> 语法，它具有更多优势：\n    更少的样板内容，更简洁的代码。\n    能够使用纯 Typescript 声明 props 和抛出事件。\n    更好的运行时性能 (其模板会被编译成与其同一作用域的渲染函数，没有任何的中间代理)。\n    更好的 IDE 类型推断性能 (减少语言服务器从代码中抽离类型的工作)。\n\n\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">里面的代码会被编译成组件 setup() 函数的内容。这意味着与普通的 &lt;script&gt; 只在组件被首次引入的时候执行一次不同，&lt;script setup&gt; 中的代码会在每次组件实例被创建的时候执行。</span><br></pre></td></tr></table></figure>\n\n\n\n**限制：没有 Src 导入**\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">由于模块执行语义的差异，`&lt;script setup&gt;` 中的代码依赖单文件组件的上下文。当将其移动到外部的 `.js` 或者 `.ts` 文件中的时候，对于开发者和工具来说都会感到混乱。因而 **`&lt;script setup&gt;`** 不能和 `src` attribute 一起使用。</span><br></pre></td></tr></table></figure>\n\n\n\n### 状态驱动的动态 CSS\n\n单文件组件的 `<style>` 标签可以通过 `v-bind` 这一 CSS 函数将 CSS 的值关联到动态的组件状态上：\n\n\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">script </span><br><span class=\"line\">\texport default</span><br><span class=\"line\">\t\tdata() &#123;</span><br><span class=\"line\">\t\t\treturn &#123;</span><br><span class=\"line\">\t\t\t\tcolor: &#x27;red&#x27;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&lt;style&gt;</span><br><span class=\"line\">.text &#123;</span><br><span class=\"line\">  color: v-bind(color);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/style&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n### Suspense**新增**\n\nSuspense 是一个试验性的新特性，其 API 可能随时会发生变动。特此声明，以便社区能够为当前的实现提供反馈。\n\n生产环境请勿使用。\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">在正确渲染组件之前进行一些异步请求是很常见的事。组件通常会在本地处理这种逻辑，绝大多数情况下这是非常完美的做法。</span><br><span class=\"line\">该 `&lt;suspense&gt;` 组件提供了另一个方案，允许将等待过程提升到组件树中处理，而不是在单个组件中。</span><br></pre></td></tr></table></figure>\n\n</script>"},{"title":"Node JS 读取文件","date":"2021-10-13T16:00:00.000Z","_content":"\n\n\n# Node JS 读取文件\n\n\n\n在  ` Node JS ` 中文件 操作是使用的 ` fs ` 模块进行了读取操作。\n\n\n\n#### 使用` Node JS `读取文件\n\n```\nhttp://nodejs.cn/api/fs.html#fs_fs_readfile_path_options_callback\n```\n\n- `path` \\<string> | \\<Buffer> | \\<URL> | \\<integer> 文件名或文件描述符\n- options   \\<Object> | \\<string>\n    - `encoding` \\<null> | \\<string> **默认值:** `null`\n    - `flag` \\<string>  **默认值:** `'r'`。\n    - `signal` \\<AbortSignal>允许中止正在进行的读取文件\n- callback   \\<Function>\n    - `err`  \\<Error> | \\<AggregateError>\n    - `data` \\<string> | \\<Buffer>\n\n\n\n```\nconst fs = require('fs');\n\nfs.readFile('./../source/Node JS 读取文件.md', 'utf8', (err, data) => {\n  if (err) {\n    throw err;\n  } else {\n  \t//data 是一个 十六进制的buffer，所以使用toString转成字符。\n    console.log(data.toString());\n  }\n})\n```\n\n\n\n","source":"_posts/Node JS/Node JS 读取文件.md","raw":"---\ntitle: Node JS 读取文件\ndate: 2021/10/14\ntags: \n - Node JS\n - fs\ncategories:\n - Node JS\n - fs\n---\n\n\n\n# Node JS 读取文件\n\n\n\n在  ` Node JS ` 中文件 操作是使用的 ` fs ` 模块进行了读取操作。\n\n\n\n#### 使用` Node JS `读取文件\n\n```\nhttp://nodejs.cn/api/fs.html#fs_fs_readfile_path_options_callback\n```\n\n- `path` \\<string> | \\<Buffer> | \\<URL> | \\<integer> 文件名或文件描述符\n- options   \\<Object> | \\<string>\n    - `encoding` \\<null> | \\<string> **默认值:** `null`\n    - `flag` \\<string>  **默认值:** `'r'`。\n    - `signal` \\<AbortSignal>允许中止正在进行的读取文件\n- callback   \\<Function>\n    - `err`  \\<Error> | \\<AggregateError>\n    - `data` \\<string> | \\<Buffer>\n\n\n\n```\nconst fs = require('fs');\n\nfs.readFile('./../source/Node JS 读取文件.md', 'utf8', (err, data) => {\n  if (err) {\n    throw err;\n  } else {\n  \t//data 是一个 十六进制的buffer，所以使用toString转成字符。\n    console.log(data.toString());\n  }\n})\n```\n\n\n\n","slug":"Node JS/Node JS 读取文件","published":1,"updated":"2021-12-09T01:56:49.404Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckznhkk82003sikub3uedcn6s","content":"<h1 id=\"Node-JS-读取文件\"><a href=\"#Node-JS-读取文件\" class=\"headerlink\" title=\"Node JS 读取文件\"></a>Node JS 读取文件</h1><p>在  <code>Node JS</code> 中文件 操作是使用的 <code>fs</code> 模块进行了读取操作。</p>\n<h4 id=\"使用Node-JS读取文件\"><a href=\"#使用Node-JS读取文件\" class=\"headerlink\" title=\"使用Node JS读取文件\"></a>使用<code>Node JS</code>读取文件</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http://nodejs.cn/api/fs.html#fs_fs_readfile_path_options_callback</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>path</code> &lt;string&gt; | &lt;Buffer&gt; | &lt;URL&gt; | &lt;integer&gt; 文件名或文件描述符</li>\n<li>options   &lt;Object&gt; | &lt;string&gt;<ul>\n<li><code>encoding</code> &lt;null&gt; | &lt;string&gt; <strong>默认值:</strong> <code>null</code></li>\n<li><code>flag</code> &lt;string&gt;  <strong>默认值:</strong> <code>&#39;r&#39;</code>。</li>\n<li><code>signal</code> &lt;AbortSignal&gt;允许中止正在进行的读取文件</li>\n</ul>\n</li>\n<li>callback   &lt;Function&gt;<ul>\n<li><code>err</code>  &lt;Error&gt; | &lt;AggregateError&gt;</li>\n<li><code>data</code> &lt;string&gt; | &lt;Buffer&gt;</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const fs = require(&#x27;fs&#x27;);</span><br><span class=\"line\"></span><br><span class=\"line\">fs.readFile(&#x27;./../source/Node JS 读取文件.md&#x27;, &#x27;utf8&#x27;, (err, data) =&gt; &#123;</span><br><span class=\"line\">  if (err) &#123;</span><br><span class=\"line\">    throw err;</span><br><span class=\"line\">  &#125; else &#123;</span><br><span class=\"line\">  \t//data 是一个 十六进制的buffer，所以使用toString转成字符。</span><br><span class=\"line\">    console.log(data.toString());</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n\n\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Node-JS-读取文件\"><a href=\"#Node-JS-读取文件\" class=\"headerlink\" title=\"Node JS 读取文件\"></a>Node JS 读取文件</h1><p>在  <code>Node JS</code> 中文件 操作是使用的 <code>fs</code> 模块进行了读取操作。</p>\n<h4 id=\"使用Node-JS读取文件\"><a href=\"#使用Node-JS读取文件\" class=\"headerlink\" title=\"使用Node JS读取文件\"></a>使用<code>Node JS</code>读取文件</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http://nodejs.cn/api/fs.html#fs_fs_readfile_path_options_callback</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>path</code> &lt;string&gt; | &lt;Buffer&gt; | &lt;URL&gt; | &lt;integer&gt; 文件名或文件描述符</li>\n<li>options   &lt;Object&gt; | &lt;string&gt;<ul>\n<li><code>encoding</code> &lt;null&gt; | &lt;string&gt; <strong>默认值:</strong> <code>null</code></li>\n<li><code>flag</code> &lt;string&gt;  <strong>默认值:</strong> <code>&#39;r&#39;</code>。</li>\n<li><code>signal</code> &lt;AbortSignal&gt;允许中止正在进行的读取文件</li>\n</ul>\n</li>\n<li>callback   &lt;Function&gt;<ul>\n<li><code>err</code>  &lt;Error&gt; | &lt;AggregateError&gt;</li>\n<li><code>data</code> &lt;string&gt; | &lt;Buffer&gt;</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const fs = require(&#x27;fs&#x27;);</span><br><span class=\"line\"></span><br><span class=\"line\">fs.readFile(&#x27;./../source/Node JS 读取文件.md&#x27;, &#x27;utf8&#x27;, (err, data) =&gt; &#123;</span><br><span class=\"line\">  if (err) &#123;</span><br><span class=\"line\">    throw err;</span><br><span class=\"line\">  &#125; else &#123;</span><br><span class=\"line\">  \t//data 是一个 十六进制的buffer，所以使用toString转成字符。</span><br><span class=\"line\">    console.log(data.toString());</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n\n\n"},{"title":"JavaScript事件循环","date":"2021-11-07T12:23:56.000Z","_content":"\n\n\n#  JavaScript的事件循环机制\n\n这里分为 NodeJS 和 浏览器环境\n\n​\t因为 Node JS虽然是使用了 浏览器的V8处理器 作为一个JavaScript的解释器，但是其中的IO处理实则还是使用的 libuv 引擎。\n\n\n\n## 浏览器的事件循环\n\n​\t\t这里先引入一个概念，叫做**任务队列(Task Queue)**，简单来说就是维护了一个需要执行的函数的一个队列。\n\n​\t\t在这里，任务队列又分为了**宏任务队列(macro task)**和**微任务队列(micro task)**。\n\n\n\n​\t\t简单来说就是JavaScript，在执行的过程中，如果遇到了异步处理，就会将其推入任务队列。然后继续执行后面的函数。直到执行结束，然后才会调用任务队列的任务进行执行。\n\n​\t\t这里是先调用的 微任务队列的方法，先执行，直至微任务队列为空，这里如果产生了微任务，也会即刻放入这个微任务队列中，因为这是一个的队列。微任务队列执行结束，然后就会从宏任务队列中取出一个来进行执行，方式就如同上面那样，这样即产生了事件的循环。\n\n\n\n​\t\t**常见宏任务**：\n\n```\nscript (可以理解为外层同步代码)、setTimeout/setInterval、setImmediate(Node.js)、I/O、UI事件、postMessage。\n```\n\n​\t\t因为在这里，我们如果将最外层的同步代码视为第一个宏任务队列的话，我们就可以这样理解，先取出一个宏任务，然后再执行，然后再执行微任务，然后又取出宏任务这样循环。\n\n​\t\t**常见微任务**：\n\n```\nPromise.then、process.nextTick(Node.js) 这里nextTick会先于微任务执行、Object.observe、MutaionObserver。\n```\n\n​\t\t这里 Promise里面算是一个同步的代码，只是then方法是一个异步的。所以then方法算是一个微任务。\n\n\n\n## Node JS的事件循环\n\n **官方文档**：\n\n```\nhttps://nodejs.org/zh-cn/docs/guides/event-loop-timers-and-nexttick/\n```\n\n事件循环操作顺序的简化图\n\n<img src=\"JavaScript事件循环/image-20211107211640084.png\" alt=\"image-20211107211640084\" style=\"zoom:80%;\" />\n\n一个框，便为事件循环的一个阶段\n\n\n\n​\t\t每个阶段都有一个FIFO(first input first output，就是队列) 队列，通常情况下，当进入给定的阶段，将执行该阶段的行为。然后执行回调，直到队列用尽或者最大回调数的执行。然后事件循环将移动到下一阶段。\n\n​\t\t由于这些操作中的任何一个都可能调度 *更多的* 操作和由内核排列在**轮询**阶段被处理的新事件， 且在处理轮询中的事件时，轮询事件可以排队。因此，长时间运行的回调可以允许轮询阶段运行长于计时器的阈值时间。有关详细信息，请参阅 [**计时器**](https://nodejs.org/zh-cn/docs/guides/event-loop-timers-and-nexttick/#timers) 和 [**轮询**](https://nodejs.org/zh-cn/docs/guides/event-loop-timers-and-nexttick/#poll) 部分。**（没看懂，直接复制的原文，后续再解读）**\n\n\n\n### **阶段概述**：\n\n* 定时器（timers）： 本阶段执行已经被 `setTimeout()` 和 `setInterval()` 的调度回调函数。\n* 待定回调（pending callbacks）：执行延迟到下一个循环迭代的I/O回调\n* idle，prepare：仅系统内部使用\n* 轮询（poll）：检索新的I/O事件；执行与I/O相关的回调（几乎所有情况下，除了关闭的回调函数，那些由计时器和`setImmediate`调度的之外），其余情况node将在适当的时候在此阻塞\n* 检测（check）：`setImmediate()` 回调函数在这里执行。\n* 关闭的回调函数（close callbacks）：一些关闭的回调函数，如：`socket.on('close', ...)`。\n\n在每次运行的事件循环之间，Node JS检查它是否在等待任何异步I/O或者计时器，如果没有，则完全关闭。\n\n\n\n### 阶段的详细概述\n\n#### 定时器\n\n​\t\t可以执行所提供回调的阈值，而不是执行的确切事件，是指在时间间隔后，回调将尽快的执行。但是，操作系统或其他正在运行的回调可能会延迟它们的执行。\n\n\n\n#### 待定回调\n\n​\t\t对某些系统操作（如 TCP 错误类型）执行回调。例如，如果 TCP 套接字在尝试连接时接收到 `ECONNREFUSED`，则某些 *nix 的系统希望等待报告错误。\n\n\n\n#### 轮询\n\n两个重要的功能：\n\n* 计算应该 阻塞和轮询I/O的时间。\n* 处理轮询队列里的事件。\n\n当事件循环进入轮询阶段，且没有被调度的计时器时，将发生以下两种情况：\n\n* 如果轮询队列不是空的，事件循环将循环访问回调队列并同步执行它们，直到队列已用尽，或者达到了与系统相关的硬性限制。\n  * 为了防止轮询阶段饿死事件循环，[libuv](https://libuv.org/)（实现 Node.js 事件循环和平台的所有异步行为的 C 函数库），在停止轮询以获得更多事件之前，还有一个硬性最大值（依赖于系统）。\n* *如果 **轮询** 队列 **是空的*** ，还有两件事发生：\n  * 如果脚本被 `setImmediate()` 调度，则事件循环将结束 **轮询** 阶段，并继续 **检查** 阶段以执行那些被调度的脚本。\n  * 如果脚本 **未被** `setImmediate()`调度，则事件循环将等待回调被添加到队列中，然后立即执行。\n\n一旦 **轮询** 队列为空，事件循环将检查 _已达到时间阈值的计时器_。如果一个或多个计时器已准备就绪，则事件循环将绕回计时器阶段以执行这些计时器的回调。\n\n\n\n#### 检查阶段\n\n​\t\t此阶段允许人员在轮询阶段完成后立即执行回调。如果轮询阶段变为空闲状态，并且脚本使用 `setImmediate()` 后被排列在队列中，则事件循环可能继续到 **检查** 阶段而不是等待。\n\n​\t\t`setImmediate()` 实际上是一个在事件循环的单独阶段运行的特殊计时器。它使用一个 libuv API 来安排回调在 **轮询** 阶段完成后执行。\n\n\n\n#### 关闭的回调函数\n\n​\t\t如果套接字或处理函数突然关闭（例如 `socket.destroy()`），则`'close'` 事件将在这个阶段发出。否则它将通过 `process.nextTick()` 发出。\n\n\n\n​\t\t任何时候在给定的阶段中调用 `process.nextTick()`，所有传递到 `process.nextTick()` 的回调将在事件循环继续之前解析。\n\n","source":"_posts/Node JS/JavaScript事件循环.md","raw":"---\ntitle: JavaScript事件循环\ndate: 2021-11-07 20:23:56\ntags:\n - JavaScript\n - 事件循环\n - 随笔\ncategories:\n - JavaScript\n - 随笔\n---\n\n\n\n#  JavaScript的事件循环机制\n\n这里分为 NodeJS 和 浏览器环境\n\n​\t因为 Node JS虽然是使用了 浏览器的V8处理器 作为一个JavaScript的解释器，但是其中的IO处理实则还是使用的 libuv 引擎。\n\n\n\n## 浏览器的事件循环\n\n​\t\t这里先引入一个概念，叫做**任务队列(Task Queue)**，简单来说就是维护了一个需要执行的函数的一个队列。\n\n​\t\t在这里，任务队列又分为了**宏任务队列(macro task)**和**微任务队列(micro task)**。\n\n\n\n​\t\t简单来说就是JavaScript，在执行的过程中，如果遇到了异步处理，就会将其推入任务队列。然后继续执行后面的函数。直到执行结束，然后才会调用任务队列的任务进行执行。\n\n​\t\t这里是先调用的 微任务队列的方法，先执行，直至微任务队列为空，这里如果产生了微任务，也会即刻放入这个微任务队列中，因为这是一个的队列。微任务队列执行结束，然后就会从宏任务队列中取出一个来进行执行，方式就如同上面那样，这样即产生了事件的循环。\n\n\n\n​\t\t**常见宏任务**：\n\n```\nscript (可以理解为外层同步代码)、setTimeout/setInterval、setImmediate(Node.js)、I/O、UI事件、postMessage。\n```\n\n​\t\t因为在这里，我们如果将最外层的同步代码视为第一个宏任务队列的话，我们就可以这样理解，先取出一个宏任务，然后再执行，然后再执行微任务，然后又取出宏任务这样循环。\n\n​\t\t**常见微任务**：\n\n```\nPromise.then、process.nextTick(Node.js) 这里nextTick会先于微任务执行、Object.observe、MutaionObserver。\n```\n\n​\t\t这里 Promise里面算是一个同步的代码，只是then方法是一个异步的。所以then方法算是一个微任务。\n\n\n\n## Node JS的事件循环\n\n **官方文档**：\n\n```\nhttps://nodejs.org/zh-cn/docs/guides/event-loop-timers-and-nexttick/\n```\n\n事件循环操作顺序的简化图\n\n<img src=\"JavaScript事件循环/image-20211107211640084.png\" alt=\"image-20211107211640084\" style=\"zoom:80%;\" />\n\n一个框，便为事件循环的一个阶段\n\n\n\n​\t\t每个阶段都有一个FIFO(first input first output，就是队列) 队列，通常情况下，当进入给定的阶段，将执行该阶段的行为。然后执行回调，直到队列用尽或者最大回调数的执行。然后事件循环将移动到下一阶段。\n\n​\t\t由于这些操作中的任何一个都可能调度 *更多的* 操作和由内核排列在**轮询**阶段被处理的新事件， 且在处理轮询中的事件时，轮询事件可以排队。因此，长时间运行的回调可以允许轮询阶段运行长于计时器的阈值时间。有关详细信息，请参阅 [**计时器**](https://nodejs.org/zh-cn/docs/guides/event-loop-timers-and-nexttick/#timers) 和 [**轮询**](https://nodejs.org/zh-cn/docs/guides/event-loop-timers-and-nexttick/#poll) 部分。**（没看懂，直接复制的原文，后续再解读）**\n\n\n\n### **阶段概述**：\n\n* 定时器（timers）： 本阶段执行已经被 `setTimeout()` 和 `setInterval()` 的调度回调函数。\n* 待定回调（pending callbacks）：执行延迟到下一个循环迭代的I/O回调\n* idle，prepare：仅系统内部使用\n* 轮询（poll）：检索新的I/O事件；执行与I/O相关的回调（几乎所有情况下，除了关闭的回调函数，那些由计时器和`setImmediate`调度的之外），其余情况node将在适当的时候在此阻塞\n* 检测（check）：`setImmediate()` 回调函数在这里执行。\n* 关闭的回调函数（close callbacks）：一些关闭的回调函数，如：`socket.on('close', ...)`。\n\n在每次运行的事件循环之间，Node JS检查它是否在等待任何异步I/O或者计时器，如果没有，则完全关闭。\n\n\n\n### 阶段的详细概述\n\n#### 定时器\n\n​\t\t可以执行所提供回调的阈值，而不是执行的确切事件，是指在时间间隔后，回调将尽快的执行。但是，操作系统或其他正在运行的回调可能会延迟它们的执行。\n\n\n\n#### 待定回调\n\n​\t\t对某些系统操作（如 TCP 错误类型）执行回调。例如，如果 TCP 套接字在尝试连接时接收到 `ECONNREFUSED`，则某些 *nix 的系统希望等待报告错误。\n\n\n\n#### 轮询\n\n两个重要的功能：\n\n* 计算应该 阻塞和轮询I/O的时间。\n* 处理轮询队列里的事件。\n\n当事件循环进入轮询阶段，且没有被调度的计时器时，将发生以下两种情况：\n\n* 如果轮询队列不是空的，事件循环将循环访问回调队列并同步执行它们，直到队列已用尽，或者达到了与系统相关的硬性限制。\n  * 为了防止轮询阶段饿死事件循环，[libuv](https://libuv.org/)（实现 Node.js 事件循环和平台的所有异步行为的 C 函数库），在停止轮询以获得更多事件之前，还有一个硬性最大值（依赖于系统）。\n* *如果 **轮询** 队列 **是空的*** ，还有两件事发生：\n  * 如果脚本被 `setImmediate()` 调度，则事件循环将结束 **轮询** 阶段，并继续 **检查** 阶段以执行那些被调度的脚本。\n  * 如果脚本 **未被** `setImmediate()`调度，则事件循环将等待回调被添加到队列中，然后立即执行。\n\n一旦 **轮询** 队列为空，事件循环将检查 _已达到时间阈值的计时器_。如果一个或多个计时器已准备就绪，则事件循环将绕回计时器阶段以执行这些计时器的回调。\n\n\n\n#### 检查阶段\n\n​\t\t此阶段允许人员在轮询阶段完成后立即执行回调。如果轮询阶段变为空闲状态，并且脚本使用 `setImmediate()` 后被排列在队列中，则事件循环可能继续到 **检查** 阶段而不是等待。\n\n​\t\t`setImmediate()` 实际上是一个在事件循环的单独阶段运行的特殊计时器。它使用一个 libuv API 来安排回调在 **轮询** 阶段完成后执行。\n\n\n\n#### 关闭的回调函数\n\n​\t\t如果套接字或处理函数突然关闭（例如 `socket.destroy()`），则`'close'` 事件将在这个阶段发出。否则它将通过 `process.nextTick()` 发出。\n\n\n\n​\t\t任何时候在给定的阶段中调用 `process.nextTick()`，所有传递到 `process.nextTick()` 的回调将在事件循环继续之前解析。\n\n","slug":"Node JS/JavaScript事件循环","published":1,"updated":"2021-12-09T01:56:49.404Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckznhkk83003vikubeg8f12gq","content":"<h1 id=\"JavaScript的事件循环机制\"><a href=\"#JavaScript的事件循环机制\" class=\"headerlink\" title=\"JavaScript的事件循环机制\"></a>JavaScript的事件循环机制</h1><p>这里分为 NodeJS 和 浏览器环境</p>\n<p>​    因为 Node JS虽然是使用了 浏览器的V8处理器 作为一个JavaScript的解释器，但是其中的IO处理实则还是使用的 libuv 引擎。</p>\n<h2 id=\"浏览器的事件循环\"><a href=\"#浏览器的事件循环\" class=\"headerlink\" title=\"浏览器的事件循环\"></a>浏览器的事件循环</h2><p>​        这里先引入一个概念，叫做**任务队列(Task Queue)**，简单来说就是维护了一个需要执行的函数的一个队列。</p>\n<p>​        在这里，任务队列又分为了**宏任务队列(macro task)<strong>和</strong>微任务队列(micro task)**。</p>\n<p>​        简单来说就是JavaScript，在执行的过程中，如果遇到了异步处理，就会将其推入任务队列。然后继续执行后面的函数。直到执行结束，然后才会调用任务队列的任务进行执行。</p>\n<p>​        这里是先调用的 微任务队列的方法，先执行，直至微任务队列为空，这里如果产生了微任务，也会即刻放入这个微任务队列中，因为这是一个的队列。微任务队列执行结束，然后就会从宏任务队列中取出一个来进行执行，方式就如同上面那样，这样即产生了事件的循环。</p>\n<p>​        <strong>常见宏任务</strong>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">script (可以理解为外层同步代码)、setTimeout/setInterval、setImmediate(Node.js)、I/O、UI事件、postMessage。</span><br></pre></td></tr></table></figure>\n\n<p>​        因为在这里，我们如果将最外层的同步代码视为第一个宏任务队列的话，我们就可以这样理解，先取出一个宏任务，然后再执行，然后再执行微任务，然后又取出宏任务这样循环。</p>\n<p>​        <strong>常见微任务</strong>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Promise.then、process.nextTick(Node.js) 这里nextTick会先于微任务执行、Object.observe、MutaionObserver。</span><br></pre></td></tr></table></figure>\n\n<p>​        这里 Promise里面算是一个同步的代码，只是then方法是一个异步的。所以then方法算是一个微任务。</p>\n<h2 id=\"Node-JS的事件循环\"><a href=\"#Node-JS的事件循环\" class=\"headerlink\" title=\"Node JS的事件循环\"></a>Node JS的事件循环</h2><p> <strong>官方文档</strong>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://nodejs.org/zh-cn/docs/guides/event-loop-timers-and-nexttick/</span><br></pre></td></tr></table></figure>\n\n<p>事件循环操作顺序的简化图</p>\n<img src=\"/.io//image-20211107211640084.png\" alt=\"image-20211107211640084\" style=\"zoom:80%;\">\n\n<p>一个框，便为事件循环的一个阶段</p>\n<p>​        每个阶段都有一个FIFO(first input first output，就是队列) 队列，通常情况下，当进入给定的阶段，将执行该阶段的行为。然后执行回调，直到队列用尽或者最大回调数的执行。然后事件循环将移动到下一阶段。</p>\n<p>​        由于这些操作中的任何一个都可能调度 <em>更多的</em> 操作和由内核排列在<strong>轮询</strong>阶段被处理的新事件， 且在处理轮询中的事件时，轮询事件可以排队。因此，长时间运行的回调可以允许轮询阶段运行长于计时器的阈值时间。有关详细信息，请参阅 <a href=\"https://nodejs.org/zh-cn/docs/guides/event-loop-timers-and-nexttick/#timers\"><strong>计时器</strong></a> 和 <a href=\"https://nodejs.org/zh-cn/docs/guides/event-loop-timers-and-nexttick/#poll\"><strong>轮询</strong></a> 部分。<strong>（没看懂，直接复制的原文，后续再解读）</strong></p>\n<h3 id=\"阶段概述：\"><a href=\"#阶段概述：\" class=\"headerlink\" title=\"阶段概述：\"></a><strong>阶段概述</strong>：</h3><ul>\n<li>定时器（timers）： 本阶段执行已经被 <code>setTimeout()</code> 和 <code>setInterval()</code> 的调度回调函数。</li>\n<li>待定回调（pending callbacks）：执行延迟到下一个循环迭代的I/O回调</li>\n<li>idle，prepare：仅系统内部使用</li>\n<li>轮询（poll）：检索新的I/O事件；执行与I/O相关的回调（几乎所有情况下，除了关闭的回调函数，那些由计时器和<code>setImmediate</code>调度的之外），其余情况node将在适当的时候在此阻塞</li>\n<li>检测（check）：<code>setImmediate()</code> 回调函数在这里执行。</li>\n<li>关闭的回调函数（close callbacks）：一些关闭的回调函数，如：<code>socket.on(&#39;close&#39;, ...)</code>。</li>\n</ul>\n<p>在每次运行的事件循环之间，Node JS检查它是否在等待任何异步I/O或者计时器，如果没有，则完全关闭。</p>\n<h3 id=\"阶段的详细概述\"><a href=\"#阶段的详细概述\" class=\"headerlink\" title=\"阶段的详细概述\"></a>阶段的详细概述</h3><h4 id=\"定时器\"><a href=\"#定时器\" class=\"headerlink\" title=\"定时器\"></a>定时器</h4><p>​        可以执行所提供回调的阈值，而不是执行的确切事件，是指在时间间隔后，回调将尽快的执行。但是，操作系统或其他正在运行的回调可能会延迟它们的执行。</p>\n<h4 id=\"待定回调\"><a href=\"#待定回调\" class=\"headerlink\" title=\"待定回调\"></a>待定回调</h4><p>​        对某些系统操作（如 TCP 错误类型）执行回调。例如，如果 TCP 套接字在尝试连接时接收到 <code>ECONNREFUSED</code>，则某些 *nix 的系统希望等待报告错误。</p>\n<h4 id=\"轮询\"><a href=\"#轮询\" class=\"headerlink\" title=\"轮询\"></a>轮询</h4><p>两个重要的功能：</p>\n<ul>\n<li>计算应该 阻塞和轮询I/O的时间。</li>\n<li>处理轮询队列里的事件。</li>\n</ul>\n<p>当事件循环进入轮询阶段，且没有被调度的计时器时，将发生以下两种情况：</p>\n<ul>\n<li>如果轮询队列不是空的，事件循环将循环访问回调队列并同步执行它们，直到队列已用尽，或者达到了与系统相关的硬性限制。<ul>\n<li>为了防止轮询阶段饿死事件循环，<a href=\"https://libuv.org/\">libuv</a>（实现 Node.js 事件循环和平台的所有异步行为的 C 函数库），在停止轮询以获得更多事件之前，还有一个硬性最大值（依赖于系统）。</li>\n</ul>\n</li>\n<li><em>如果 <strong>轮询</strong> 队列 <strong>是空的</strong></em> ，还有两件事发生：<ul>\n<li>如果脚本被 <code>setImmediate()</code> 调度，则事件循环将结束 <strong>轮询</strong> 阶段，并继续 <strong>检查</strong> 阶段以执行那些被调度的脚本。</li>\n<li>如果脚本 <strong>未被</strong> <code>setImmediate()</code>调度，则事件循环将等待回调被添加到队列中，然后立即执行。</li>\n</ul>\n</li>\n</ul>\n<p>一旦 <strong>轮询</strong> 队列为空，事件循环将检查 _已达到时间阈值的计时器_。如果一个或多个计时器已准备就绪，则事件循环将绕回计时器阶段以执行这些计时器的回调。</p>\n<h4 id=\"检查阶段\"><a href=\"#检查阶段\" class=\"headerlink\" title=\"检查阶段\"></a>检查阶段</h4><p>​        此阶段允许人员在轮询阶段完成后立即执行回调。如果轮询阶段变为空闲状态，并且脚本使用 <code>setImmediate()</code> 后被排列在队列中，则事件循环可能继续到 <strong>检查</strong> 阶段而不是等待。</p>\n<p>​        <code>setImmediate()</code> 实际上是一个在事件循环的单独阶段运行的特殊计时器。它使用一个 libuv API 来安排回调在 <strong>轮询</strong> 阶段完成后执行。</p>\n<h4 id=\"关闭的回调函数\"><a href=\"#关闭的回调函数\" class=\"headerlink\" title=\"关闭的回调函数\"></a>关闭的回调函数</h4><p>​        如果套接字或处理函数突然关闭（例如 <code>socket.destroy()</code>），则<code>&#39;close&#39;</code> 事件将在这个阶段发出。否则它将通过 <code>process.nextTick()</code> 发出。</p>\n<p>​        任何时候在给定的阶段中调用 <code>process.nextTick()</code>，所有传递到 <code>process.nextTick()</code> 的回调将在事件循环继续之前解析。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"JavaScript的事件循环机制\"><a href=\"#JavaScript的事件循环机制\" class=\"headerlink\" title=\"JavaScript的事件循环机制\"></a>JavaScript的事件循环机制</h1><p>这里分为 NodeJS 和 浏览器环境</p>\n<p>​    因为 Node JS虽然是使用了 浏览器的V8处理器 作为一个JavaScript的解释器，但是其中的IO处理实则还是使用的 libuv 引擎。</p>\n<h2 id=\"浏览器的事件循环\"><a href=\"#浏览器的事件循环\" class=\"headerlink\" title=\"浏览器的事件循环\"></a>浏览器的事件循环</h2><p>​        这里先引入一个概念，叫做**任务队列(Task Queue)**，简单来说就是维护了一个需要执行的函数的一个队列。</p>\n<p>​        在这里，任务队列又分为了**宏任务队列(macro task)<strong>和</strong>微任务队列(micro task)**。</p>\n<p>​        简单来说就是JavaScript，在执行的过程中，如果遇到了异步处理，就会将其推入任务队列。然后继续执行后面的函数。直到执行结束，然后才会调用任务队列的任务进行执行。</p>\n<p>​        这里是先调用的 微任务队列的方法，先执行，直至微任务队列为空，这里如果产生了微任务，也会即刻放入这个微任务队列中，因为这是一个的队列。微任务队列执行结束，然后就会从宏任务队列中取出一个来进行执行，方式就如同上面那样，这样即产生了事件的循环。</p>\n<p>​        <strong>常见宏任务</strong>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">script (可以理解为外层同步代码)、setTimeout/setInterval、setImmediate(Node.js)、I/O、UI事件、postMessage。</span><br></pre></td></tr></table></figure>\n\n<p>​        因为在这里，我们如果将最外层的同步代码视为第一个宏任务队列的话，我们就可以这样理解，先取出一个宏任务，然后再执行，然后再执行微任务，然后又取出宏任务这样循环。</p>\n<p>​        <strong>常见微任务</strong>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Promise.then、process.nextTick(Node.js) 这里nextTick会先于微任务执行、Object.observe、MutaionObserver。</span><br></pre></td></tr></table></figure>\n\n<p>​        这里 Promise里面算是一个同步的代码，只是then方法是一个异步的。所以then方法算是一个微任务。</p>\n<h2 id=\"Node-JS的事件循环\"><a href=\"#Node-JS的事件循环\" class=\"headerlink\" title=\"Node JS的事件循环\"></a>Node JS的事件循环</h2><p> <strong>官方文档</strong>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://nodejs.org/zh-cn/docs/guides/event-loop-timers-and-nexttick/</span><br></pre></td></tr></table></figure>\n\n<p>事件循环操作顺序的简化图</p>\n<img src=\"/.io//image-20211107211640084.png\" alt=\"image-20211107211640084\" style=\"zoom:80%;\">\n\n<p>一个框，便为事件循环的一个阶段</p>\n<p>​        每个阶段都有一个FIFO(first input first output，就是队列) 队列，通常情况下，当进入给定的阶段，将执行该阶段的行为。然后执行回调，直到队列用尽或者最大回调数的执行。然后事件循环将移动到下一阶段。</p>\n<p>​        由于这些操作中的任何一个都可能调度 <em>更多的</em> 操作和由内核排列在<strong>轮询</strong>阶段被处理的新事件， 且在处理轮询中的事件时，轮询事件可以排队。因此，长时间运行的回调可以允许轮询阶段运行长于计时器的阈值时间。有关详细信息，请参阅 <a href=\"https://nodejs.org/zh-cn/docs/guides/event-loop-timers-and-nexttick/#timers\"><strong>计时器</strong></a> 和 <a href=\"https://nodejs.org/zh-cn/docs/guides/event-loop-timers-and-nexttick/#poll\"><strong>轮询</strong></a> 部分。<strong>（没看懂，直接复制的原文，后续再解读）</strong></p>\n<h3 id=\"阶段概述：\"><a href=\"#阶段概述：\" class=\"headerlink\" title=\"阶段概述：\"></a><strong>阶段概述</strong>：</h3><ul>\n<li>定时器（timers）： 本阶段执行已经被 <code>setTimeout()</code> 和 <code>setInterval()</code> 的调度回调函数。</li>\n<li>待定回调（pending callbacks）：执行延迟到下一个循环迭代的I/O回调</li>\n<li>idle，prepare：仅系统内部使用</li>\n<li>轮询（poll）：检索新的I/O事件；执行与I/O相关的回调（几乎所有情况下，除了关闭的回调函数，那些由计时器和<code>setImmediate</code>调度的之外），其余情况node将在适当的时候在此阻塞</li>\n<li>检测（check）：<code>setImmediate()</code> 回调函数在这里执行。</li>\n<li>关闭的回调函数（close callbacks）：一些关闭的回调函数，如：<code>socket.on(&#39;close&#39;, ...)</code>。</li>\n</ul>\n<p>在每次运行的事件循环之间，Node JS检查它是否在等待任何异步I/O或者计时器，如果没有，则完全关闭。</p>\n<h3 id=\"阶段的详细概述\"><a href=\"#阶段的详细概述\" class=\"headerlink\" title=\"阶段的详细概述\"></a>阶段的详细概述</h3><h4 id=\"定时器\"><a href=\"#定时器\" class=\"headerlink\" title=\"定时器\"></a>定时器</h4><p>​        可以执行所提供回调的阈值，而不是执行的确切事件，是指在时间间隔后，回调将尽快的执行。但是，操作系统或其他正在运行的回调可能会延迟它们的执行。</p>\n<h4 id=\"待定回调\"><a href=\"#待定回调\" class=\"headerlink\" title=\"待定回调\"></a>待定回调</h4><p>​        对某些系统操作（如 TCP 错误类型）执行回调。例如，如果 TCP 套接字在尝试连接时接收到 <code>ECONNREFUSED</code>，则某些 *nix 的系统希望等待报告错误。</p>\n<h4 id=\"轮询\"><a href=\"#轮询\" class=\"headerlink\" title=\"轮询\"></a>轮询</h4><p>两个重要的功能：</p>\n<ul>\n<li>计算应该 阻塞和轮询I/O的时间。</li>\n<li>处理轮询队列里的事件。</li>\n</ul>\n<p>当事件循环进入轮询阶段，且没有被调度的计时器时，将发生以下两种情况：</p>\n<ul>\n<li>如果轮询队列不是空的，事件循环将循环访问回调队列并同步执行它们，直到队列已用尽，或者达到了与系统相关的硬性限制。<ul>\n<li>为了防止轮询阶段饿死事件循环，<a href=\"https://libuv.org/\">libuv</a>（实现 Node.js 事件循环和平台的所有异步行为的 C 函数库），在停止轮询以获得更多事件之前，还有一个硬性最大值（依赖于系统）。</li>\n</ul>\n</li>\n<li><em>如果 <strong>轮询</strong> 队列 <strong>是空的</strong></em> ，还有两件事发生：<ul>\n<li>如果脚本被 <code>setImmediate()</code> 调度，则事件循环将结束 <strong>轮询</strong> 阶段，并继续 <strong>检查</strong> 阶段以执行那些被调度的脚本。</li>\n<li>如果脚本 <strong>未被</strong> <code>setImmediate()</code>调度，则事件循环将等待回调被添加到队列中，然后立即执行。</li>\n</ul>\n</li>\n</ul>\n<p>一旦 <strong>轮询</strong> 队列为空，事件循环将检查 _已达到时间阈值的计时器_。如果一个或多个计时器已准备就绪，则事件循环将绕回计时器阶段以执行这些计时器的回调。</p>\n<h4 id=\"检查阶段\"><a href=\"#检查阶段\" class=\"headerlink\" title=\"检查阶段\"></a>检查阶段</h4><p>​        此阶段允许人员在轮询阶段完成后立即执行回调。如果轮询阶段变为空闲状态，并且脚本使用 <code>setImmediate()</code> 后被排列在队列中，则事件循环可能继续到 <strong>检查</strong> 阶段而不是等待。</p>\n<p>​        <code>setImmediate()</code> 实际上是一个在事件循环的单独阶段运行的特殊计时器。它使用一个 libuv API 来安排回调在 <strong>轮询</strong> 阶段完成后执行。</p>\n<h4 id=\"关闭的回调函数\"><a href=\"#关闭的回调函数\" class=\"headerlink\" title=\"关闭的回调函数\"></a>关闭的回调函数</h4><p>​        如果套接字或处理函数突然关闭（例如 <code>socket.destroy()</code>），则<code>&#39;close&#39;</code> 事件将在这个阶段发出。否则它将通过 <code>process.nextTick()</code> 发出。</p>\n<p>​        任何时候在给定的阶段中调用 <code>process.nextTick()</code>，所有传递到 <code>process.nextTick()</code> 的回调将在事件循环继续之前解析。</p>\n"},{"layout":"draft","title":"NodeJS下载和npm安装和配置","date":"2021-12-28T03:36:56.000Z","_content":"\n\n\n#  NodeJS下载和npm安装\n\n\n\n下载 NodeJS，没啥，直接官网进入，下载包\n\n```\nhttps://nodejs.org/zh-cn/download/\n```\n\n\n\n一路安装，node 安装会自动安装 npm\n\n安装完成之后\n\n通过在 cmd 使用 来判断是否安装完成\n\n```\nnpm -v\nnode -v\n```\n\n\n\n## 修改安装路径\n\n### 查看路径\n\n```\nnpm prefix -g\n```\n\n\n\n### 修改路径\n\n```\n这个是全局安装时的路径，使用全局安装会将其安装在这里，当然你也可以直接安装在nodejs这个目录就行，不需要更深层的目录。但是这样不方便查看和删除。\nnpm config set prefix “D:\\Software\\nodejs\\node_global”\n这个是缓存的路径，npm会生成缓存。用于更快的进行启动和操作。\nnpm config set cache “D:\\Software\\nodejs\\node_cache”\n```\n\n\n\n配置环境变量\n\n![image-20211228140948410](NodeJS下载和npm安装\\image-20211228140948410-16406717947501.png)\n\n\n\n然后点击确定保存即可。\n\n\n\n### 配置镜像\n\n我们先配置一个镜像然后再安装一个源管理工具nrm\n\n这个是一个淘宝的镜像源\n\n```\nnpm config set registry=https://registry.npm.taobao.org\n```\n\n\n\n### 安装nrm\n\n如果出现操作错误，试试使用管理员的cmd进行操作\n\n```\nnpm i -g nrm\n```\n\n\n\n### 使用nrm\n\n```\nnrm ls\n输出nrm的一个镜像仓库\n\nnrm use xxx\n使用这个xxx镜像\n\nnrm add name url\n添加一个镜像仓库，名字是name，地址是url\n\nnrm del xx\n删除xx仓库\n```\n\n\n\n","source":"_posts/Node JS/NodeJS下载和npm安装.md","raw":"---\nlayout: draft\ntitle: NodeJS下载和npm安装和配置\ndate: 2021-12-28 11:36:56\ntags:\n - 安装教程\n - NodeJS\n - npm\n - 随笔\n---\n\n\n\n#  NodeJS下载和npm安装\n\n\n\n下载 NodeJS，没啥，直接官网进入，下载包\n\n```\nhttps://nodejs.org/zh-cn/download/\n```\n\n\n\n一路安装，node 安装会自动安装 npm\n\n安装完成之后\n\n通过在 cmd 使用 来判断是否安装完成\n\n```\nnpm -v\nnode -v\n```\n\n\n\n## 修改安装路径\n\n### 查看路径\n\n```\nnpm prefix -g\n```\n\n\n\n### 修改路径\n\n```\n这个是全局安装时的路径，使用全局安装会将其安装在这里，当然你也可以直接安装在nodejs这个目录就行，不需要更深层的目录。但是这样不方便查看和删除。\nnpm config set prefix “D:\\Software\\nodejs\\node_global”\n这个是缓存的路径，npm会生成缓存。用于更快的进行启动和操作。\nnpm config set cache “D:\\Software\\nodejs\\node_cache”\n```\n\n\n\n配置环境变量\n\n![image-20211228140948410](NodeJS下载和npm安装\\image-20211228140948410-16406717947501.png)\n\n\n\n然后点击确定保存即可。\n\n\n\n### 配置镜像\n\n我们先配置一个镜像然后再安装一个源管理工具nrm\n\n这个是一个淘宝的镜像源\n\n```\nnpm config set registry=https://registry.npm.taobao.org\n```\n\n\n\n### 安装nrm\n\n如果出现操作错误，试试使用管理员的cmd进行操作\n\n```\nnpm i -g nrm\n```\n\n\n\n### 使用nrm\n\n```\nnrm ls\n输出nrm的一个镜像仓库\n\nnrm use xxx\n使用这个xxx镜像\n\nnrm add name url\n添加一个镜像仓库，名字是name，地址是url\n\nnrm del xx\n删除xx仓库\n```\n\n\n\n","slug":"Node JS/NodeJS下载和npm安装","published":1,"updated":"2022-01-20T08:54:18.464Z","comments":1,"photos":[],"link":"","_id":"ckznhkk83003zikubab78bq7s","content":"<h1 id=\"NodeJS下载和npm安装\"><a href=\"#NodeJS下载和npm安装\" class=\"headerlink\" title=\"NodeJS下载和npm安装\"></a>NodeJS下载和npm安装</h1><p>下载 NodeJS，没啥，直接官网进入，下载包</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://nodejs.org/zh-cn/download/</span><br></pre></td></tr></table></figure>\n\n\n\n<p>一路安装，node 安装会自动安装 npm</p>\n<p>安装完成之后</p>\n<p>通过在 cmd 使用 来判断是否安装完成</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm -v</span><br><span class=\"line\">node -v</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"修改安装路径\"><a href=\"#修改安装路径\" class=\"headerlink\" title=\"修改安装路径\"></a>修改安装路径</h2><h3 id=\"查看路径\"><a href=\"#查看路径\" class=\"headerlink\" title=\"查看路径\"></a>查看路径</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm prefix -g</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"修改路径\"><a href=\"#修改路径\" class=\"headerlink\" title=\"修改路径\"></a>修改路径</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">这个是全局安装时的路径，使用全局安装会将其安装在这里，当然你也可以直接安装在nodejs这个目录就行，不需要更深层的目录。但是这样不方便查看和删除。</span><br><span class=\"line\">npm config set prefix “D:\\Software\\nodejs\\node_global”</span><br><span class=\"line\">这个是缓存的路径，npm会生成缓存。用于更快的进行启动和操作。</span><br><span class=\"line\">npm config set cache “D:\\Software\\nodejs\\node_cache”</span><br></pre></td></tr></table></figure>\n\n\n\n<p>配置环境变量</p>\n<p><img src=\"/.io//NodeJS%E4%B8%8B%E8%BD%BD%E5%92%8Cnpm%E5%AE%89%E8%A3%85%5Cimage-20211228140948410-16406717947501.png\" alt=\"image-20211228140948410\"></p>\n<p>然后点击确定保存即可。</p>\n<h3 id=\"配置镜像\"><a href=\"#配置镜像\" class=\"headerlink\" title=\"配置镜像\"></a>配置镜像</h3><p>我们先配置一个镜像然后再安装一个源管理工具nrm</p>\n<p>这个是一个淘宝的镜像源</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm config set registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"安装nrm\"><a href=\"#安装nrm\" class=\"headerlink\" title=\"安装nrm\"></a>安装nrm</h3><p>如果出现操作错误，试试使用管理员的cmd进行操作</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm i -g nrm</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"使用nrm\"><a href=\"#使用nrm\" class=\"headerlink\" title=\"使用nrm\"></a>使用nrm</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nrm ls</span><br><span class=\"line\">输出nrm的一个镜像仓库</span><br><span class=\"line\"></span><br><span class=\"line\">nrm use xxx</span><br><span class=\"line\">使用这个xxx镜像</span><br><span class=\"line\"></span><br><span class=\"line\">nrm add name url</span><br><span class=\"line\">添加一个镜像仓库，名字是name，地址是url</span><br><span class=\"line\"></span><br><span class=\"line\">nrm del xx</span><br><span class=\"line\">删除xx仓库</span><br></pre></td></tr></table></figure>\n\n\n\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"NodeJS下载和npm安装\"><a href=\"#NodeJS下载和npm安装\" class=\"headerlink\" title=\"NodeJS下载和npm安装\"></a>NodeJS下载和npm安装</h1><p>下载 NodeJS，没啥，直接官网进入，下载包</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://nodejs.org/zh-cn/download/</span><br></pre></td></tr></table></figure>\n\n\n\n<p>一路安装，node 安装会自动安装 npm</p>\n<p>安装完成之后</p>\n<p>通过在 cmd 使用 来判断是否安装完成</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm -v</span><br><span class=\"line\">node -v</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"修改安装路径\"><a href=\"#修改安装路径\" class=\"headerlink\" title=\"修改安装路径\"></a>修改安装路径</h2><h3 id=\"查看路径\"><a href=\"#查看路径\" class=\"headerlink\" title=\"查看路径\"></a>查看路径</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm prefix -g</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"修改路径\"><a href=\"#修改路径\" class=\"headerlink\" title=\"修改路径\"></a>修改路径</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">这个是全局安装时的路径，使用全局安装会将其安装在这里，当然你也可以直接安装在nodejs这个目录就行，不需要更深层的目录。但是这样不方便查看和删除。</span><br><span class=\"line\">npm config set prefix “D:\\Software\\nodejs\\node_global”</span><br><span class=\"line\">这个是缓存的路径，npm会生成缓存。用于更快的进行启动和操作。</span><br><span class=\"line\">npm config set cache “D:\\Software\\nodejs\\node_cache”</span><br></pre></td></tr></table></figure>\n\n\n\n<p>配置环境变量</p>\n<p><img src=\"/.io//NodeJS%E4%B8%8B%E8%BD%BD%E5%92%8Cnpm%E5%AE%89%E8%A3%85%5Cimage-20211228140948410-16406717947501.png\" alt=\"image-20211228140948410\"></p>\n<p>然后点击确定保存即可。</p>\n<h3 id=\"配置镜像\"><a href=\"#配置镜像\" class=\"headerlink\" title=\"配置镜像\"></a>配置镜像</h3><p>我们先配置一个镜像然后再安装一个源管理工具nrm</p>\n<p>这个是一个淘宝的镜像源</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm config set registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"安装nrm\"><a href=\"#安装nrm\" class=\"headerlink\" title=\"安装nrm\"></a>安装nrm</h3><p>如果出现操作错误，试试使用管理员的cmd进行操作</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm i -g nrm</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"使用nrm\"><a href=\"#使用nrm\" class=\"headerlink\" title=\"使用nrm\"></a>使用nrm</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nrm ls</span><br><span class=\"line\">输出nrm的一个镜像仓库</span><br><span class=\"line\"></span><br><span class=\"line\">nrm use xxx</span><br><span class=\"line\">使用这个xxx镜像</span><br><span class=\"line\"></span><br><span class=\"line\">nrm add name url</span><br><span class=\"line\">添加一个镜像仓库，名字是name，地址是url</span><br><span class=\"line\"></span><br><span class=\"line\">nrm del xx</span><br><span class=\"line\">删除xx仓库</span><br></pre></td></tr></table></figure>\n\n\n\n"},{"title":"Cookie、SessionStorage、LocalStorage的区别","date":"2021-11-06T05:35:43.000Z","_content":"\n\n\n#  Cookie、SessionStorage、LocalStorage的区别\n\n**共同点：**\n\n* 保存于浏览器端\n* 属于同源\n\n\n\n## Cookie\n\n* 数据始终在同源的HTTP请求中携带，即使不需要。\n* 存在路径的概念，可以限制cookie只属于某个路径。\n* 存储的大小只有4k左右。\n* 一般由服务器生成，设置过期时间，如果不设置过期时间，则表示这个cookie生命周期为浏览器会话期间，只要关闭浏览器窗口，cookie就消失了。\n\n使用：\n\n```\nJavaScript\n\tdocument.cookie = 'key=value';\n\t\nHTTP响应头的 set-cookie\n```\n\n\n\n### 安全机制\n\n* 响应头中setCookie设置HttpOnly 使JavaScript无法进行获取。\n* 响应头设置 secure，告诉浏览器仅在HTTPS请求发送cookie\n* 人为的设置时间，以及对key和value进行一些随机的生成。\n\n\n\n## SessionStorage\n\n* 存储时间：浏览器窗口关闭前有效，就是一个标签页。在标签页中，进行刷新也不会消失，但是关闭就会消失。\n* 即使是同域名下的页面，只要不在同一浏览器窗口打开，那么他们的SessionStorage无法共享。\n* 大小限制 5M\n* 不和服务器进行通信，仅客户端使用\n\n**使用**：\n\n```\nsessionStorage.setItem(key, value);\nsessionStorage.getItem(key);\n```\n\n\n\n## LocalStorage\n\n* 存储时间：永久有效。用作持久数据\n* 同源的页面可以访问，不同于SessionStorage。\n* 其他基本和SessionStorage相同。\n* 基于上面的特点，LocalStorage可以作为浏览器的本地缓存方案，用来提升网页首屏渲染速度（根据第一请求返回时，将一些不变的信息直接存储在本地）\n\n**使用**：\n\n```\nlocalStorage.setItem(key, value);\nlocalStorage.getItem(key);\n```\n\n","source":"_posts/其他/Cookie、SessionStorage、LocalStorage的区别.md","raw":"---\ntitle: Cookie、SessionStorage、LocalStorage的区别\ndate: 2021-11-06 13:35:43\ntags:\n - 随笔\n - Cookie\n - LocalStorage\n - SessionStorage\ncategories:\n - 随笔\n---\n\n\n\n#  Cookie、SessionStorage、LocalStorage的区别\n\n**共同点：**\n\n* 保存于浏览器端\n* 属于同源\n\n\n\n## Cookie\n\n* 数据始终在同源的HTTP请求中携带，即使不需要。\n* 存在路径的概念，可以限制cookie只属于某个路径。\n* 存储的大小只有4k左右。\n* 一般由服务器生成，设置过期时间，如果不设置过期时间，则表示这个cookie生命周期为浏览器会话期间，只要关闭浏览器窗口，cookie就消失了。\n\n使用：\n\n```\nJavaScript\n\tdocument.cookie = 'key=value';\n\t\nHTTP响应头的 set-cookie\n```\n\n\n\n### 安全机制\n\n* 响应头中setCookie设置HttpOnly 使JavaScript无法进行获取。\n* 响应头设置 secure，告诉浏览器仅在HTTPS请求发送cookie\n* 人为的设置时间，以及对key和value进行一些随机的生成。\n\n\n\n## SessionStorage\n\n* 存储时间：浏览器窗口关闭前有效，就是一个标签页。在标签页中，进行刷新也不会消失，但是关闭就会消失。\n* 即使是同域名下的页面，只要不在同一浏览器窗口打开，那么他们的SessionStorage无法共享。\n* 大小限制 5M\n* 不和服务器进行通信，仅客户端使用\n\n**使用**：\n\n```\nsessionStorage.setItem(key, value);\nsessionStorage.getItem(key);\n```\n\n\n\n## LocalStorage\n\n* 存储时间：永久有效。用作持久数据\n* 同源的页面可以访问，不同于SessionStorage。\n* 其他基本和SessionStorage相同。\n* 基于上面的特点，LocalStorage可以作为浏览器的本地缓存方案，用来提升网页首屏渲染速度（根据第一请求返回时，将一些不变的信息直接存储在本地）\n\n**使用**：\n\n```\nlocalStorage.setItem(key, value);\nlocalStorage.getItem(key);\n```\n\n","slug":"其他/Cookie、SessionStorage、LocalStorage的区别","published":1,"updated":"2021-12-09T01:56:49.420Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckznhkk840042ikub8p79g9i4","content":"<h1 id=\"Cookie、SessionStorage、LocalStorage的区别\"><a href=\"#Cookie、SessionStorage、LocalStorage的区别\" class=\"headerlink\" title=\"Cookie、SessionStorage、LocalStorage的区别\"></a>Cookie、SessionStorage、LocalStorage的区别</h1><p><strong>共同点：</strong></p>\n<ul>\n<li>保存于浏览器端</li>\n<li>属于同源</li>\n</ul>\n<h2 id=\"Cookie\"><a href=\"#Cookie\" class=\"headerlink\" title=\"Cookie\"></a>Cookie</h2><ul>\n<li>数据始终在同源的HTTP请求中携带，即使不需要。</li>\n<li>存在路径的概念，可以限制cookie只属于某个路径。</li>\n<li>存储的大小只有4k左右。</li>\n<li>一般由服务器生成，设置过期时间，如果不设置过期时间，则表示这个cookie生命周期为浏览器会话期间，只要关闭浏览器窗口，cookie就消失了。</li>\n</ul>\n<p>使用：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JavaScript</span><br><span class=\"line\">\tdocument.cookie = &#x27;key=value&#x27;;</span><br><span class=\"line\">\t</span><br><span class=\"line\">HTTP响应头的 set-cookie</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"安全机制\"><a href=\"#安全机制\" class=\"headerlink\" title=\"安全机制\"></a>安全机制</h3><ul>\n<li>响应头中setCookie设置HttpOnly 使JavaScript无法进行获取。</li>\n<li>响应头设置 secure，告诉浏览器仅在HTTPS请求发送cookie</li>\n<li>人为的设置时间，以及对key和value进行一些随机的生成。</li>\n</ul>\n<h2 id=\"SessionStorage\"><a href=\"#SessionStorage\" class=\"headerlink\" title=\"SessionStorage\"></a>SessionStorage</h2><ul>\n<li>存储时间：浏览器窗口关闭前有效，就是一个标签页。在标签页中，进行刷新也不会消失，但是关闭就会消失。</li>\n<li>即使是同域名下的页面，只要不在同一浏览器窗口打开，那么他们的SessionStorage无法共享。</li>\n<li>大小限制 5M</li>\n<li>不和服务器进行通信，仅客户端使用</li>\n</ul>\n<p><strong>使用</strong>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sessionStorage.setItem(key, value);</span><br><span class=\"line\">sessionStorage.getItem(key);</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"LocalStorage\"><a href=\"#LocalStorage\" class=\"headerlink\" title=\"LocalStorage\"></a>LocalStorage</h2><ul>\n<li>存储时间：永久有效。用作持久数据</li>\n<li>同源的页面可以访问，不同于SessionStorage。</li>\n<li>其他基本和SessionStorage相同。</li>\n<li>基于上面的特点，LocalStorage可以作为浏览器的本地缓存方案，用来提升网页首屏渲染速度（根据第一请求返回时，将一些不变的信息直接存储在本地）</li>\n</ul>\n<p><strong>使用</strong>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">localStorage.setItem(key, value);</span><br><span class=\"line\">localStorage.getItem(key);</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Cookie、SessionStorage、LocalStorage的区别\"><a href=\"#Cookie、SessionStorage、LocalStorage的区别\" class=\"headerlink\" title=\"Cookie、SessionStorage、LocalStorage的区别\"></a>Cookie、SessionStorage、LocalStorage的区别</h1><p><strong>共同点：</strong></p>\n<ul>\n<li>保存于浏览器端</li>\n<li>属于同源</li>\n</ul>\n<h2 id=\"Cookie\"><a href=\"#Cookie\" class=\"headerlink\" title=\"Cookie\"></a>Cookie</h2><ul>\n<li>数据始终在同源的HTTP请求中携带，即使不需要。</li>\n<li>存在路径的概念，可以限制cookie只属于某个路径。</li>\n<li>存储的大小只有4k左右。</li>\n<li>一般由服务器生成，设置过期时间，如果不设置过期时间，则表示这个cookie生命周期为浏览器会话期间，只要关闭浏览器窗口，cookie就消失了。</li>\n</ul>\n<p>使用：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JavaScript</span><br><span class=\"line\">\tdocument.cookie = &#x27;key=value&#x27;;</span><br><span class=\"line\">\t</span><br><span class=\"line\">HTTP响应头的 set-cookie</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"安全机制\"><a href=\"#安全机制\" class=\"headerlink\" title=\"安全机制\"></a>安全机制</h3><ul>\n<li>响应头中setCookie设置HttpOnly 使JavaScript无法进行获取。</li>\n<li>响应头设置 secure，告诉浏览器仅在HTTPS请求发送cookie</li>\n<li>人为的设置时间，以及对key和value进行一些随机的生成。</li>\n</ul>\n<h2 id=\"SessionStorage\"><a href=\"#SessionStorage\" class=\"headerlink\" title=\"SessionStorage\"></a>SessionStorage</h2><ul>\n<li>存储时间：浏览器窗口关闭前有效，就是一个标签页。在标签页中，进行刷新也不会消失，但是关闭就会消失。</li>\n<li>即使是同域名下的页面，只要不在同一浏览器窗口打开，那么他们的SessionStorage无法共享。</li>\n<li>大小限制 5M</li>\n<li>不和服务器进行通信，仅客户端使用</li>\n</ul>\n<p><strong>使用</strong>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sessionStorage.setItem(key, value);</span><br><span class=\"line\">sessionStorage.getItem(key);</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"LocalStorage\"><a href=\"#LocalStorage\" class=\"headerlink\" title=\"LocalStorage\"></a>LocalStorage</h2><ul>\n<li>存储时间：永久有效。用作持久数据</li>\n<li>同源的页面可以访问，不同于SessionStorage。</li>\n<li>其他基本和SessionStorage相同。</li>\n<li>基于上面的特点，LocalStorage可以作为浏览器的本地缓存方案，用来提升网页首屏渲染速度（根据第一请求返回时，将一些不变的信息直接存储在本地）</li>\n</ul>\n<p><strong>使用</strong>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">localStorage.setItem(key, value);</span><br><span class=\"line\">localStorage.getItem(key);</span><br></pre></td></tr></table></figure>\n\n"},{"title":"HTTP和HTTPS","date":"2021-11-05T13:52:44.000Z","_content":"\n\n\n#  HTTP和HTTPS的区别\n\n参考链接\n\n```\nhttps://www.nowcoder.com/tutorial/96/4700c6f1f3334c9191a38406002efa65\n```\n\n\n\n## 体系结构\n\n首先我们要知道 OSI网络参考模型 和 TCP/IP模型 以及最后的五层协议的体系\n\n<img src=\"http和https/image-20210831164301870.png\" alt=\"image-20210831164301870\" style=\"zoom:67%;\" />\n\n**对比**\n\n* TCP/IP 将OSI 应用层，表示层，会话层 合并为了 应用层，但是同时也将 数据链路层 和物理层合并为了网络接口层。\n* 而五层协议在TCP/IP和OSI的综合下，合并了应用层，但是也保留了数据链路层和物理层\n\n\n\n在这里，应用层就是HTTP的部分了。\n\n\n\n## HTTP协议\n\n​\t\tHTTP：超文本传输协议。是一个客户端和服务器端应答的标准(TCP)，\n\n\n\n### HTTP报文格式\n\n​\t\t请求行，请求头，空行，请求体\n\n\n\n## HTTPS\n\n​\t\tHTTPS，在HTTP的基础上，添加了安全，因为HTTP都是进行的明文传输。\n\n​\t\tHTTPS的SSL加密是在传输层实现的。\n\n​\t\tHTTPS的主要作用是：建立一个信息安全通道，来确保数组的传输，确保网站的真实性。\n\n\n\n### SSL/TLS\n\nSSL，安全套接层，Secure Sockets Layer\n\nTLS，安全传输层，Transport Layer Security\n\n\n\n### 摘要算法\n\n* 它可以把任意长度的数据压缩成固定长度，并且独一无二的摘要字符串。\n* 通过把明文信息和摘要一起加密传输，接收后解密再对明文信息进行摘要，判断是否被修改。\n\n\n\n### 对称加密和非对称加密\n\n* 对称加密，加密和解密使用相同的密钥进行实现\n* 非对称加密，有两个密钥，一个是**私钥**，一个是**公钥**，**私钥是必须严格保密的，用于解密的。公钥是公开的，进行加密的。** \n\n\n\n### 混合加密\n\n* 因为非对称加密的传输速度较慢，所以使用混合加密的方式。\n\n* 简而言之，通过非对称加密进行传输对称加密的密钥，然后通过对称加密进行数据传输。\n\n\n\n### 数字证书\n\n* 对于一个服务是否可信，我们通过使用了数字证书来进行验证。\n* 里面包括了 CA信息，公钥用户的信息，公钥，权威机构的签名，有效期\n* 数字证书的作用： 1.向浏览器证明身份。 2.里面含有公钥。\n\n\n\n### HTTPS的传输步骤\n\n* 客户端使用HTTPS进行访问时，则要求web服务器建立SSL连接。\n\n* web服务端收到请求后，会将网站的数字证书返回给客户端。\n* 客户端验证过后，开始和web服务器协商SSL连接的安全等级，就是加密等级。\n* 客户端通过双方协商后的安全等级，建立会话密钥，然后通过网站的公钥来加密会话密钥，并传送给网站。\n* 服务端进行解密，也获取了密钥\n* 使用密钥进行传输\n\n\n\n### HTTPS的优点\n\n* 安全，防止数据在过程中不被窃取，改变，确保了数据的完整性。\n\n\n\n### HTTPS的缺点\n\n* 费时\n* 缓存没有HTTP高效\n\n\n\n## HTTP和HTTPS的区别\n\n* HTTPS协议需要ca证书，费用较高。\n* HTTP是超文本传输协议，信息是明文传输，HTTPS则是具有安全性的ssl加密传输协议。\n* 使用不同的链接方式，端口也不同，一般而言，HTTP协议的端口为80，HTTPS的端口为443\n* HTTP的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比HTTP协议安全。\n\n\n\n\n\n","source":"_posts/其他/HTTP和HTTPS.md","raw":"---\ntitle: HTTP和HTTPS\ndate: 2021-11-05 21:52:44\ntags:\n - HTTP\ncategories:\n - 随笔\n---\n\n\n\n#  HTTP和HTTPS的区别\n\n参考链接\n\n```\nhttps://www.nowcoder.com/tutorial/96/4700c6f1f3334c9191a38406002efa65\n```\n\n\n\n## 体系结构\n\n首先我们要知道 OSI网络参考模型 和 TCP/IP模型 以及最后的五层协议的体系\n\n<img src=\"http和https/image-20210831164301870.png\" alt=\"image-20210831164301870\" style=\"zoom:67%;\" />\n\n**对比**\n\n* TCP/IP 将OSI 应用层，表示层，会话层 合并为了 应用层，但是同时也将 数据链路层 和物理层合并为了网络接口层。\n* 而五层协议在TCP/IP和OSI的综合下，合并了应用层，但是也保留了数据链路层和物理层\n\n\n\n在这里，应用层就是HTTP的部分了。\n\n\n\n## HTTP协议\n\n​\t\tHTTP：超文本传输协议。是一个客户端和服务器端应答的标准(TCP)，\n\n\n\n### HTTP报文格式\n\n​\t\t请求行，请求头，空行，请求体\n\n\n\n## HTTPS\n\n​\t\tHTTPS，在HTTP的基础上，添加了安全，因为HTTP都是进行的明文传输。\n\n​\t\tHTTPS的SSL加密是在传输层实现的。\n\n​\t\tHTTPS的主要作用是：建立一个信息安全通道，来确保数组的传输，确保网站的真实性。\n\n\n\n### SSL/TLS\n\nSSL，安全套接层，Secure Sockets Layer\n\nTLS，安全传输层，Transport Layer Security\n\n\n\n### 摘要算法\n\n* 它可以把任意长度的数据压缩成固定长度，并且独一无二的摘要字符串。\n* 通过把明文信息和摘要一起加密传输，接收后解密再对明文信息进行摘要，判断是否被修改。\n\n\n\n### 对称加密和非对称加密\n\n* 对称加密，加密和解密使用相同的密钥进行实现\n* 非对称加密，有两个密钥，一个是**私钥**，一个是**公钥**，**私钥是必须严格保密的，用于解密的。公钥是公开的，进行加密的。** \n\n\n\n### 混合加密\n\n* 因为非对称加密的传输速度较慢，所以使用混合加密的方式。\n\n* 简而言之，通过非对称加密进行传输对称加密的密钥，然后通过对称加密进行数据传输。\n\n\n\n### 数字证书\n\n* 对于一个服务是否可信，我们通过使用了数字证书来进行验证。\n* 里面包括了 CA信息，公钥用户的信息，公钥，权威机构的签名，有效期\n* 数字证书的作用： 1.向浏览器证明身份。 2.里面含有公钥。\n\n\n\n### HTTPS的传输步骤\n\n* 客户端使用HTTPS进行访问时，则要求web服务器建立SSL连接。\n\n* web服务端收到请求后，会将网站的数字证书返回给客户端。\n* 客户端验证过后，开始和web服务器协商SSL连接的安全等级，就是加密等级。\n* 客户端通过双方协商后的安全等级，建立会话密钥，然后通过网站的公钥来加密会话密钥，并传送给网站。\n* 服务端进行解密，也获取了密钥\n* 使用密钥进行传输\n\n\n\n### HTTPS的优点\n\n* 安全，防止数据在过程中不被窃取，改变，确保了数据的完整性。\n\n\n\n### HTTPS的缺点\n\n* 费时\n* 缓存没有HTTP高效\n\n\n\n## HTTP和HTTPS的区别\n\n* HTTPS协议需要ca证书，费用较高。\n* HTTP是超文本传输协议，信息是明文传输，HTTPS则是具有安全性的ssl加密传输协议。\n* 使用不同的链接方式，端口也不同，一般而言，HTTP协议的端口为80，HTTPS的端口为443\n* HTTP的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比HTTP协议安全。\n\n\n\n\n\n","slug":"其他/HTTP和HTTPS","published":1,"updated":"2021-12-09T01:56:49.420Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckznhkk850046ikub3bol02e3","content":"<h1 id=\"HTTP和HTTPS的区别\"><a href=\"#HTTP和HTTPS的区别\" class=\"headerlink\" title=\"HTTP和HTTPS的区别\"></a>HTTP和HTTPS的区别</h1><p>参考链接</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://www.nowcoder.com/tutorial/96/4700c6f1f3334c9191a38406002efa65</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"体系结构\"><a href=\"#体系结构\" class=\"headerlink\" title=\"体系结构\"></a>体系结构</h2><p>首先我们要知道 OSI网络参考模型 和 TCP/IP模型 以及最后的五层协议的体系</p>\n<img src=\"http和https/image-20210831164301870.png\" alt=\"image-20210831164301870\" style=\"zoom:67%;\">\n\n<p><strong>对比</strong></p>\n<ul>\n<li>TCP/IP 将OSI 应用层，表示层，会话层 合并为了 应用层，但是同时也将 数据链路层 和物理层合并为了网络接口层。</li>\n<li>而五层协议在TCP/IP和OSI的综合下，合并了应用层，但是也保留了数据链路层和物理层</li>\n</ul>\n<p>在这里，应用层就是HTTP的部分了。</p>\n<h2 id=\"HTTP协议\"><a href=\"#HTTP协议\" class=\"headerlink\" title=\"HTTP协议\"></a>HTTP协议</h2><p>​        HTTP：超文本传输协议。是一个客户端和服务器端应答的标准(TCP)，</p>\n<h3 id=\"HTTP报文格式\"><a href=\"#HTTP报文格式\" class=\"headerlink\" title=\"HTTP报文格式\"></a>HTTP报文格式</h3><p>​        请求行，请求头，空行，请求体</p>\n<h2 id=\"HTTPS\"><a href=\"#HTTPS\" class=\"headerlink\" title=\"HTTPS\"></a>HTTPS</h2><p>​        HTTPS，在HTTP的基础上，添加了安全，因为HTTP都是进行的明文传输。</p>\n<p>​        HTTPS的SSL加密是在传输层实现的。</p>\n<p>​        HTTPS的主要作用是：建立一个信息安全通道，来确保数组的传输，确保网站的真实性。</p>\n<h3 id=\"SSL-TLS\"><a href=\"#SSL-TLS\" class=\"headerlink\" title=\"SSL/TLS\"></a>SSL/TLS</h3><p>SSL，安全套接层，Secure Sockets Layer</p>\n<p>TLS，安全传输层，Transport Layer Security</p>\n<h3 id=\"摘要算法\"><a href=\"#摘要算法\" class=\"headerlink\" title=\"摘要算法\"></a>摘要算法</h3><ul>\n<li>它可以把任意长度的数据压缩成固定长度，并且独一无二的摘要字符串。</li>\n<li>通过把明文信息和摘要一起加密传输，接收后解密再对明文信息进行摘要，判断是否被修改。</li>\n</ul>\n<h3 id=\"对称加密和非对称加密\"><a href=\"#对称加密和非对称加密\" class=\"headerlink\" title=\"对称加密和非对称加密\"></a>对称加密和非对称加密</h3><ul>\n<li>对称加密，加密和解密使用相同的密钥进行实现</li>\n<li>非对称加密，有两个密钥，一个是<strong>私钥</strong>，一个是<strong>公钥</strong>，<strong>私钥是必须严格保密的，用于解密的。公钥是公开的，进行加密的。</strong> </li>\n</ul>\n<h3 id=\"混合加密\"><a href=\"#混合加密\" class=\"headerlink\" title=\"混合加密\"></a>混合加密</h3><ul>\n<li><p>因为非对称加密的传输速度较慢，所以使用混合加密的方式。</p>\n</li>\n<li><p>简而言之，通过非对称加密进行传输对称加密的密钥，然后通过对称加密进行数据传输。</p>\n</li>\n</ul>\n<h3 id=\"数字证书\"><a href=\"#数字证书\" class=\"headerlink\" title=\"数字证书\"></a>数字证书</h3><ul>\n<li>对于一个服务是否可信，我们通过使用了数字证书来进行验证。</li>\n<li>里面包括了 CA信息，公钥用户的信息，公钥，权威机构的签名，有效期</li>\n<li>数字证书的作用： 1.向浏览器证明身份。 2.里面含有公钥。</li>\n</ul>\n<h3 id=\"HTTPS的传输步骤\"><a href=\"#HTTPS的传输步骤\" class=\"headerlink\" title=\"HTTPS的传输步骤\"></a>HTTPS的传输步骤</h3><ul>\n<li><p>客户端使用HTTPS进行访问时，则要求web服务器建立SSL连接。</p>\n</li>\n<li><p>web服务端收到请求后，会将网站的数字证书返回给客户端。</p>\n</li>\n<li><p>客户端验证过后，开始和web服务器协商SSL连接的安全等级，就是加密等级。</p>\n</li>\n<li><p>客户端通过双方协商后的安全等级，建立会话密钥，然后通过网站的公钥来加密会话密钥，并传送给网站。</p>\n</li>\n<li><p>服务端进行解密，也获取了密钥</p>\n</li>\n<li><p>使用密钥进行传输</p>\n</li>\n</ul>\n<h3 id=\"HTTPS的优点\"><a href=\"#HTTPS的优点\" class=\"headerlink\" title=\"HTTPS的优点\"></a>HTTPS的优点</h3><ul>\n<li>安全，防止数据在过程中不被窃取，改变，确保了数据的完整性。</li>\n</ul>\n<h3 id=\"HTTPS的缺点\"><a href=\"#HTTPS的缺点\" class=\"headerlink\" title=\"HTTPS的缺点\"></a>HTTPS的缺点</h3><ul>\n<li>费时</li>\n<li>缓存没有HTTP高效</li>\n</ul>\n<h2 id=\"HTTP和HTTPS的区别-1\"><a href=\"#HTTP和HTTPS的区别-1\" class=\"headerlink\" title=\"HTTP和HTTPS的区别\"></a>HTTP和HTTPS的区别</h2><ul>\n<li>HTTPS协议需要ca证书，费用较高。</li>\n<li>HTTP是超文本传输协议，信息是明文传输，HTTPS则是具有安全性的ssl加密传输协议。</li>\n<li>使用不同的链接方式，端口也不同，一般而言，HTTP协议的端口为80，HTTPS的端口为443</li>\n<li>HTTP的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比HTTP协议安全。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"HTTP和HTTPS的区别\"><a href=\"#HTTP和HTTPS的区别\" class=\"headerlink\" title=\"HTTP和HTTPS的区别\"></a>HTTP和HTTPS的区别</h1><p>参考链接</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://www.nowcoder.com/tutorial/96/4700c6f1f3334c9191a38406002efa65</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"体系结构\"><a href=\"#体系结构\" class=\"headerlink\" title=\"体系结构\"></a>体系结构</h2><p>首先我们要知道 OSI网络参考模型 和 TCP/IP模型 以及最后的五层协议的体系</p>\n<img src=\"http和https/image-20210831164301870.png\" alt=\"image-20210831164301870\" style=\"zoom:67%;\">\n\n<p><strong>对比</strong></p>\n<ul>\n<li>TCP/IP 将OSI 应用层，表示层，会话层 合并为了 应用层，但是同时也将 数据链路层 和物理层合并为了网络接口层。</li>\n<li>而五层协议在TCP/IP和OSI的综合下，合并了应用层，但是也保留了数据链路层和物理层</li>\n</ul>\n<p>在这里，应用层就是HTTP的部分了。</p>\n<h2 id=\"HTTP协议\"><a href=\"#HTTP协议\" class=\"headerlink\" title=\"HTTP协议\"></a>HTTP协议</h2><p>​        HTTP：超文本传输协议。是一个客户端和服务器端应答的标准(TCP)，</p>\n<h3 id=\"HTTP报文格式\"><a href=\"#HTTP报文格式\" class=\"headerlink\" title=\"HTTP报文格式\"></a>HTTP报文格式</h3><p>​        请求行，请求头，空行，请求体</p>\n<h2 id=\"HTTPS\"><a href=\"#HTTPS\" class=\"headerlink\" title=\"HTTPS\"></a>HTTPS</h2><p>​        HTTPS，在HTTP的基础上，添加了安全，因为HTTP都是进行的明文传输。</p>\n<p>​        HTTPS的SSL加密是在传输层实现的。</p>\n<p>​        HTTPS的主要作用是：建立一个信息安全通道，来确保数组的传输，确保网站的真实性。</p>\n<h3 id=\"SSL-TLS\"><a href=\"#SSL-TLS\" class=\"headerlink\" title=\"SSL/TLS\"></a>SSL/TLS</h3><p>SSL，安全套接层，Secure Sockets Layer</p>\n<p>TLS，安全传输层，Transport Layer Security</p>\n<h3 id=\"摘要算法\"><a href=\"#摘要算法\" class=\"headerlink\" title=\"摘要算法\"></a>摘要算法</h3><ul>\n<li>它可以把任意长度的数据压缩成固定长度，并且独一无二的摘要字符串。</li>\n<li>通过把明文信息和摘要一起加密传输，接收后解密再对明文信息进行摘要，判断是否被修改。</li>\n</ul>\n<h3 id=\"对称加密和非对称加密\"><a href=\"#对称加密和非对称加密\" class=\"headerlink\" title=\"对称加密和非对称加密\"></a>对称加密和非对称加密</h3><ul>\n<li>对称加密，加密和解密使用相同的密钥进行实现</li>\n<li>非对称加密，有两个密钥，一个是<strong>私钥</strong>，一个是<strong>公钥</strong>，<strong>私钥是必须严格保密的，用于解密的。公钥是公开的，进行加密的。</strong> </li>\n</ul>\n<h3 id=\"混合加密\"><a href=\"#混合加密\" class=\"headerlink\" title=\"混合加密\"></a>混合加密</h3><ul>\n<li><p>因为非对称加密的传输速度较慢，所以使用混合加密的方式。</p>\n</li>\n<li><p>简而言之，通过非对称加密进行传输对称加密的密钥，然后通过对称加密进行数据传输。</p>\n</li>\n</ul>\n<h3 id=\"数字证书\"><a href=\"#数字证书\" class=\"headerlink\" title=\"数字证书\"></a>数字证书</h3><ul>\n<li>对于一个服务是否可信，我们通过使用了数字证书来进行验证。</li>\n<li>里面包括了 CA信息，公钥用户的信息，公钥，权威机构的签名，有效期</li>\n<li>数字证书的作用： 1.向浏览器证明身份。 2.里面含有公钥。</li>\n</ul>\n<h3 id=\"HTTPS的传输步骤\"><a href=\"#HTTPS的传输步骤\" class=\"headerlink\" title=\"HTTPS的传输步骤\"></a>HTTPS的传输步骤</h3><ul>\n<li><p>客户端使用HTTPS进行访问时，则要求web服务器建立SSL连接。</p>\n</li>\n<li><p>web服务端收到请求后，会将网站的数字证书返回给客户端。</p>\n</li>\n<li><p>客户端验证过后，开始和web服务器协商SSL连接的安全等级，就是加密等级。</p>\n</li>\n<li><p>客户端通过双方协商后的安全等级，建立会话密钥，然后通过网站的公钥来加密会话密钥，并传送给网站。</p>\n</li>\n<li><p>服务端进行解密，也获取了密钥</p>\n</li>\n<li><p>使用密钥进行传输</p>\n</li>\n</ul>\n<h3 id=\"HTTPS的优点\"><a href=\"#HTTPS的优点\" class=\"headerlink\" title=\"HTTPS的优点\"></a>HTTPS的优点</h3><ul>\n<li>安全，防止数据在过程中不被窃取，改变，确保了数据的完整性。</li>\n</ul>\n<h3 id=\"HTTPS的缺点\"><a href=\"#HTTPS的缺点\" class=\"headerlink\" title=\"HTTPS的缺点\"></a>HTTPS的缺点</h3><ul>\n<li>费时</li>\n<li>缓存没有HTTP高效</li>\n</ul>\n<h2 id=\"HTTP和HTTPS的区别-1\"><a href=\"#HTTP和HTTPS的区别-1\" class=\"headerlink\" title=\"HTTP和HTTPS的区别\"></a>HTTP和HTTPS的区别</h2><ul>\n<li>HTTPS协议需要ca证书，费用较高。</li>\n<li>HTTP是超文本传输协议，信息是明文传输，HTTPS则是具有安全性的ssl加密传输协议。</li>\n<li>使用不同的链接方式，端口也不同，一般而言，HTTP协议的端口为80，HTTPS的端口为443</li>\n<li>HTTP的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比HTTP协议安全。</li>\n</ul>\n"},{"title":"HTTP概述","date":"2021-10-23T15:13:22.000Z","_content":"\n\n\n#  HTTP概述\n\n## 概述\n\n找不到说啥，直接放个MDN文档\n\n```\nhttps://developer.mozilla.org/zh-CN/docs/Web/HTTP/Overview\n```\n\n<img src=\"HTTP概述/image-20211024100324347.png\" alt=\"image-20211024100324347\" style=\"zoom:67%;\" />\n\n\n\n## 版本迭代\n\n```\nhttps://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/Evolution_of_HTTP\n```\n\n### HTTP/0.9\n\n也被称为 **单行协议** \n\n请求由单行指令构成，以唯一可用方法[`GET`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/GET)开头，其后跟目标资源的路径\n\n```\nGET /mypage.html\n```\n\n响应就只包含了响应文档本身，就是HTML文件\n\n并且因为不包含响应头，所以只有HTML文件可以进行传输。\n\n\n\n### HTTP/1.0\n\n```\n最大的变化是支持了传输其他文件，默认是短连接，支持GET、POST、 HEAD请求\n```\n\n- 协议版本信息现在会随着每个请求发送（`HTTP/1.0`被追加到了`GET`行）。\n- **状态码会在响应开始时发送**，使浏览器能了解请求执行成功或失败，并相应调整行为（如更新或使用本地缓存）。\n- 引入了HTTP头的概念，无论是对于请求还是响应，允许传输元数据，使协议变得非常灵活，更具扩展性。\n- 在新HTTP头的帮助下，具备了传输除纯文本HTML文件以外其他类型文档的能力（感谢[`Content-Type`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Type)头）。\n\n**默认是短连接，一次请求会建立一次TCP连接，请求结束就断开。**可以通过一个 `Connection: keep-alive`字段使服务器不关闭连接。服务器同时也会响应这个字段。\n\n```\nGET /mypage.html HTTP/1.0\nUser-Agent: NCSA_Mosaic/2.0 (Windows 3.1)\n\n```\n\n\n\n### HTTP/1.1\n\n```\n最大的变化就是支持了持久连接，默认长连接。不同自己声明 `Connection: keep-alive` ，增加了 `HOST` ，增加了请求方式，支持断点续传功能。\n```\n\n- 连接可以复用，节省了多次打开TCP连接加载网页文档资源的时间。\n- 增加管线化技术，允许在第一个应答被完全发送之前就发送第二个请求，以降低通信延迟。\n- 支持响应分块。\n- 引入额外的缓存控制机制。\n- 引入内容协商机制，包括语言，编码，类型等，并允许客户端和服务器之间约定以最合适的内容进行交换。\n- 感谢[`Host`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Host)头，能够使不同域名配置在同一个IP地址的服务器上。\n\n**Host** 请求头指明了请求将要发送到的服务器主机名和端口号。\n\n如果没有包含端口号，会自动使用被请求服务的默认端口（比如HTTPS URL使用443端口，HTTP URL使用80端口）。\n\n所有HTTP/1.1 请求报文中必须包含一个`Host`头字段。对于缺少`Host`头或者含有超过一个`Host`头的HTTP/1.1 请求，可能会收到[`400`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/400)（Bad Request）状态码。\n\n\n\n所有请求都是通过一个连接实现的。就是持久连接。服务器发现对方一段时间没有活动，就可以主动关闭连接。不过，规范的做法是，客户端在最后一个请求时，发送`Connection: close`，明确要求服务器关闭TCP连接。\n\n```\nGET /en-US/docs/Glossary/Simple_header HTTP/1.1\nHost: developer.mozilla.org\nUser-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.9; rv:50.0) Gecko/20100101 Firefox/50.0\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\nAccept-Language: en-US,en;q=0.5\nAccept-Encoding: gzip, deflate, br\nReferer: https://developer.mozilla.org/en-US/docs/Glossary/Simple_header\n\n```\n\n\n\n### HTTP/2.0\n\n```\n最大的区别，协议为二进制协议，服务器主动推送，以及 headers 压缩\n```\n\n- HTTP/2是二进制协议而不是文本协议。不再可读，也不可无障碍的手动创建，改善的优化技术现在可被实施。\n- 这是一个复用协议。并行的请求能在同一个链接中处理，移除了HTTP/1.x中顺序和阻塞的约束。\n- 压缩了headers。因为headers在一系列请求中常常是相似的，其移除了重复和传输重复数据的成本。\n- 其允许服务器在客户端缓存中填充数据，通过一个叫服务器推送的机制来提前请求。\n\n\n\n### 服务器推送方式\n\n```\nhttp://www.ruanyifeng.com/blog/2017/05/server-sent_events.html\n```\n\n**WebSockets**\n\n```\nhttps://developer.mozilla.org/zh-CN/docs/Web/API/WebSockets_API\n```\n\n**Server-sent events**\n\n```\nhttps://developer.mozilla.org/zh-CN/docs/Web/API/Server-sent_events\n```\n\n\n\n## 连接管理\n\nHTTP/1.x有三个，HTTP/2新增了其他的连接管理模型\n\n```\nhttps://developer.mozilla.org/zh-CN/docs/Web/HTTP/Connection_management_in_HTTP_1.x\n```\n\n\n\nHTTP/1.x的三个连接\n\n短连接，长连接，流水线\n\n<img src=\"HTTP概述/image-20211024104204389.png\" alt=\"image-20211024104204389\" style=\"zoom:67%;\" />\n\n\n\n### 短连接\n\n​\t\t每一个 HTTP 请求都由它自己独立的连接完成；这意味着发起每一个 HTTP 请求之前都会有一次 TCP 握手，而且是连续不断的。\n\n​\t\t简单来说就是每次请求都要建立连接，请求结束关闭连接，造成了大量的连接时间的浪费。\n\n​\t\t这是 HTTP/1.0 的默认模型(如果没有指定 [`Connection`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Connection) 协议头，或者是值被设置为 `close`)。而在 HTTP/1.1 中，只有当 [`Connection`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Connection) 被设置为 `close` 时才会用到这个模型。\n\n\n\n### 长连接\n\n​\t\t在HTTP/1.1被设计出来之前：`Connection: keep-alive`被作为一个请求头，做成了长连接的效果。\n\n​\t\t为了缓解这些问题，*长连接* 的概念便被设计出来了，甚至在 HTTP/1.1 之前。或者这被称之为一个 *keep-alive* 连接。\n\n\n\n### 流水线\n\n```\nHTTP 流水线在现代浏览器中并不是默认被启用的：\n\tWeb 开发者并不能轻易的遇见和判断那些搞怪的代理服务器的各种莫名其妙的行为。\n\t正确的实现流水线是复杂的：传输中的资源大小，多少有效的 RTT 会被用到，还有有效带宽，流水线带来的改善有多大的影响范围。不知道这些的话，重要的消息可能被延迟到不重要的消息后面。这个重要性的概念甚至会演变为影响到页面布局！因此 HTTP 流水线在大多数情况下带来的改善并不明显。\n\t流水线受制于 HOL 问题。\n由于这些原因，流水线已经被更好的算法给代替，如 multiplexing，已经用在 HTTP/2。\n```\n\n简单理解就是说，直接发送连续的请求，不需要等待每次的响应。\n\n\n\n### 域名分片\n\n简单的理解就是为域名多建立几个连接。以实现并发请求。但是HTTP/2支持客户端的并发请求","source":"_posts/其他/HTTP概述.md","raw":"---\ntitle: HTTP概述\ndate: 2021-10-23 23:13:22\ntags:\n - HTTP\ncategories:\n - 随笔\n---\n\n\n\n#  HTTP概述\n\n## 概述\n\n找不到说啥，直接放个MDN文档\n\n```\nhttps://developer.mozilla.org/zh-CN/docs/Web/HTTP/Overview\n```\n\n<img src=\"HTTP概述/image-20211024100324347.png\" alt=\"image-20211024100324347\" style=\"zoom:67%;\" />\n\n\n\n## 版本迭代\n\n```\nhttps://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/Evolution_of_HTTP\n```\n\n### HTTP/0.9\n\n也被称为 **单行协议** \n\n请求由单行指令构成，以唯一可用方法[`GET`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/GET)开头，其后跟目标资源的路径\n\n```\nGET /mypage.html\n```\n\n响应就只包含了响应文档本身，就是HTML文件\n\n并且因为不包含响应头，所以只有HTML文件可以进行传输。\n\n\n\n### HTTP/1.0\n\n```\n最大的变化是支持了传输其他文件，默认是短连接，支持GET、POST、 HEAD请求\n```\n\n- 协议版本信息现在会随着每个请求发送（`HTTP/1.0`被追加到了`GET`行）。\n- **状态码会在响应开始时发送**，使浏览器能了解请求执行成功或失败，并相应调整行为（如更新或使用本地缓存）。\n- 引入了HTTP头的概念，无论是对于请求还是响应，允许传输元数据，使协议变得非常灵活，更具扩展性。\n- 在新HTTP头的帮助下，具备了传输除纯文本HTML文件以外其他类型文档的能力（感谢[`Content-Type`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Type)头）。\n\n**默认是短连接，一次请求会建立一次TCP连接，请求结束就断开。**可以通过一个 `Connection: keep-alive`字段使服务器不关闭连接。服务器同时也会响应这个字段。\n\n```\nGET /mypage.html HTTP/1.0\nUser-Agent: NCSA_Mosaic/2.0 (Windows 3.1)\n\n```\n\n\n\n### HTTP/1.1\n\n```\n最大的变化就是支持了持久连接，默认长连接。不同自己声明 `Connection: keep-alive` ，增加了 `HOST` ，增加了请求方式，支持断点续传功能。\n```\n\n- 连接可以复用，节省了多次打开TCP连接加载网页文档资源的时间。\n- 增加管线化技术，允许在第一个应答被完全发送之前就发送第二个请求，以降低通信延迟。\n- 支持响应分块。\n- 引入额外的缓存控制机制。\n- 引入内容协商机制，包括语言，编码，类型等，并允许客户端和服务器之间约定以最合适的内容进行交换。\n- 感谢[`Host`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Host)头，能够使不同域名配置在同一个IP地址的服务器上。\n\n**Host** 请求头指明了请求将要发送到的服务器主机名和端口号。\n\n如果没有包含端口号，会自动使用被请求服务的默认端口（比如HTTPS URL使用443端口，HTTP URL使用80端口）。\n\n所有HTTP/1.1 请求报文中必须包含一个`Host`头字段。对于缺少`Host`头或者含有超过一个`Host`头的HTTP/1.1 请求，可能会收到[`400`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/400)（Bad Request）状态码。\n\n\n\n所有请求都是通过一个连接实现的。就是持久连接。服务器发现对方一段时间没有活动，就可以主动关闭连接。不过，规范的做法是，客户端在最后一个请求时，发送`Connection: close`，明确要求服务器关闭TCP连接。\n\n```\nGET /en-US/docs/Glossary/Simple_header HTTP/1.1\nHost: developer.mozilla.org\nUser-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.9; rv:50.0) Gecko/20100101 Firefox/50.0\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\nAccept-Language: en-US,en;q=0.5\nAccept-Encoding: gzip, deflate, br\nReferer: https://developer.mozilla.org/en-US/docs/Glossary/Simple_header\n\n```\n\n\n\n### HTTP/2.0\n\n```\n最大的区别，协议为二进制协议，服务器主动推送，以及 headers 压缩\n```\n\n- HTTP/2是二进制协议而不是文本协议。不再可读，也不可无障碍的手动创建，改善的优化技术现在可被实施。\n- 这是一个复用协议。并行的请求能在同一个链接中处理，移除了HTTP/1.x中顺序和阻塞的约束。\n- 压缩了headers。因为headers在一系列请求中常常是相似的，其移除了重复和传输重复数据的成本。\n- 其允许服务器在客户端缓存中填充数据，通过一个叫服务器推送的机制来提前请求。\n\n\n\n### 服务器推送方式\n\n```\nhttp://www.ruanyifeng.com/blog/2017/05/server-sent_events.html\n```\n\n**WebSockets**\n\n```\nhttps://developer.mozilla.org/zh-CN/docs/Web/API/WebSockets_API\n```\n\n**Server-sent events**\n\n```\nhttps://developer.mozilla.org/zh-CN/docs/Web/API/Server-sent_events\n```\n\n\n\n## 连接管理\n\nHTTP/1.x有三个，HTTP/2新增了其他的连接管理模型\n\n```\nhttps://developer.mozilla.org/zh-CN/docs/Web/HTTP/Connection_management_in_HTTP_1.x\n```\n\n\n\nHTTP/1.x的三个连接\n\n短连接，长连接，流水线\n\n<img src=\"HTTP概述/image-20211024104204389.png\" alt=\"image-20211024104204389\" style=\"zoom:67%;\" />\n\n\n\n### 短连接\n\n​\t\t每一个 HTTP 请求都由它自己独立的连接完成；这意味着发起每一个 HTTP 请求之前都会有一次 TCP 握手，而且是连续不断的。\n\n​\t\t简单来说就是每次请求都要建立连接，请求结束关闭连接，造成了大量的连接时间的浪费。\n\n​\t\t这是 HTTP/1.0 的默认模型(如果没有指定 [`Connection`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Connection) 协议头，或者是值被设置为 `close`)。而在 HTTP/1.1 中，只有当 [`Connection`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Connection) 被设置为 `close` 时才会用到这个模型。\n\n\n\n### 长连接\n\n​\t\t在HTTP/1.1被设计出来之前：`Connection: keep-alive`被作为一个请求头，做成了长连接的效果。\n\n​\t\t为了缓解这些问题，*长连接* 的概念便被设计出来了，甚至在 HTTP/1.1 之前。或者这被称之为一个 *keep-alive* 连接。\n\n\n\n### 流水线\n\n```\nHTTP 流水线在现代浏览器中并不是默认被启用的：\n\tWeb 开发者并不能轻易的遇见和判断那些搞怪的代理服务器的各种莫名其妙的行为。\n\t正确的实现流水线是复杂的：传输中的资源大小，多少有效的 RTT 会被用到，还有有效带宽，流水线带来的改善有多大的影响范围。不知道这些的话，重要的消息可能被延迟到不重要的消息后面。这个重要性的概念甚至会演变为影响到页面布局！因此 HTTP 流水线在大多数情况下带来的改善并不明显。\n\t流水线受制于 HOL 问题。\n由于这些原因，流水线已经被更好的算法给代替，如 multiplexing，已经用在 HTTP/2。\n```\n\n简单理解就是说，直接发送连续的请求，不需要等待每次的响应。\n\n\n\n### 域名分片\n\n简单的理解就是为域名多建立几个连接。以实现并发请求。但是HTTP/2支持客户端的并发请求","slug":"其他/HTTP概述","published":1,"updated":"2021-12-09T01:56:49.420Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckznhkk850049ikubbnkkd4rc","content":"<h1 id=\"HTTP概述\"><a href=\"#HTTP概述\" class=\"headerlink\" title=\"HTTP概述\"></a>HTTP概述</h1><h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>找不到说啥，直接放个MDN文档</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Overview</span><br></pre></td></tr></table></figure>\n\n<img src=\"/.io//image-20211024100324347.png\" alt=\"image-20211024100324347\" style=\"zoom:67%;\">\n\n\n\n<h2 id=\"版本迭代\"><a href=\"#版本迭代\" class=\"headerlink\" title=\"版本迭代\"></a>版本迭代</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/Evolution_of_HTTP</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"HTTP-0-9\"><a href=\"#HTTP-0-9\" class=\"headerlink\" title=\"HTTP/0.9\"></a>HTTP/0.9</h3><p>也被称为 <strong>单行协议</strong> </p>\n<p>请求由单行指令构成，以唯一可用方法<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/GET\"><code>GET</code></a>开头，其后跟目标资源的路径</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET /mypage.html</span><br></pre></td></tr></table></figure>\n\n<p>响应就只包含了响应文档本身，就是HTML文件</p>\n<p>并且因为不包含响应头，所以只有HTML文件可以进行传输。</p>\n<h3 id=\"HTTP-1-0\"><a href=\"#HTTP-1-0\" class=\"headerlink\" title=\"HTTP/1.0\"></a>HTTP/1.0</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">最大的变化是支持了传输其他文件，默认是短连接，支持GET、POST、 HEAD请求</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>协议版本信息现在会随着每个请求发送（<code>HTTP/1.0</code>被追加到了<code>GET</code>行）。</li>\n<li><strong>状态码会在响应开始时发送</strong>，使浏览器能了解请求执行成功或失败，并相应调整行为（如更新或使用本地缓存）。</li>\n<li>引入了HTTP头的概念，无论是对于请求还是响应，允许传输元数据，使协议变得非常灵活，更具扩展性。</li>\n<li>在新HTTP头的帮助下，具备了传输除纯文本HTML文件以外其他类型文档的能力（感谢<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Type\"><code>Content-Type</code></a>头）。</li>\n</ul>\n<p><strong>默认是短连接，一次请求会建立一次TCP连接，请求结束就断开。</strong>可以通过一个 <code>Connection: keep-alive</code>字段使服务器不关闭连接。服务器同时也会响应这个字段。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET /mypage.html HTTP/1.0</span><br><span class=\"line\">User-Agent: NCSA_Mosaic/2.0 (Windows 3.1)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"HTTP-1-1\"><a href=\"#HTTP-1-1\" class=\"headerlink\" title=\"HTTP/1.1\"></a>HTTP/1.1</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">最大的变化就是支持了持久连接，默认长连接。不同自己声明 `Connection: keep-alive` ，增加了 `HOST` ，增加了请求方式，支持断点续传功能。</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>连接可以复用，节省了多次打开TCP连接加载网页文档资源的时间。</li>\n<li>增加管线化技术，允许在第一个应答被完全发送之前就发送第二个请求，以降低通信延迟。</li>\n<li>支持响应分块。</li>\n<li>引入额外的缓存控制机制。</li>\n<li>引入内容协商机制，包括语言，编码，类型等，并允许客户端和服务器之间约定以最合适的内容进行交换。</li>\n<li>感谢<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Host\"><code>Host</code></a>头，能够使不同域名配置在同一个IP地址的服务器上。</li>\n</ul>\n<p><strong>Host</strong> 请求头指明了请求将要发送到的服务器主机名和端口号。</p>\n<p>如果没有包含端口号，会自动使用被请求服务的默认端口（比如HTTPS URL使用443端口，HTTP URL使用80端口）。</p>\n<p>所有HTTP/1.1 请求报文中必须包含一个<code>Host</code>头字段。对于缺少<code>Host</code>头或者含有超过一个<code>Host</code>头的HTTP/1.1 请求，可能会收到<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/400\"><code>400</code></a>（Bad Request）状态码。</p>\n<p>所有请求都是通过一个连接实现的。就是持久连接。服务器发现对方一段时间没有活动，就可以主动关闭连接。不过，规范的做法是，客户端在最后一个请求时，发送<code>Connection: close</code>，明确要求服务器关闭TCP连接。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET /en-US/docs/Glossary/Simple_header HTTP/1.1</span><br><span class=\"line\">Host: developer.mozilla.org</span><br><span class=\"line\">User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.9; rv:50.0) Gecko/20100101 Firefox/50.0</span><br><span class=\"line\">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class=\"line\">Accept-Language: en-US,en;q=0.5</span><br><span class=\"line\">Accept-Encoding: gzip, deflate, br</span><br><span class=\"line\">Referer: https://developer.mozilla.org/en-US/docs/Glossary/Simple_header</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"HTTP-2-0\"><a href=\"#HTTP-2-0\" class=\"headerlink\" title=\"HTTP/2.0\"></a>HTTP/2.0</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">最大的区别，协议为二进制协议，服务器主动推送，以及 headers 压缩</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>HTTP/2是二进制协议而不是文本协议。不再可读，也不可无障碍的手动创建，改善的优化技术现在可被实施。</li>\n<li>这是一个复用协议。并行的请求能在同一个链接中处理，移除了HTTP/1.x中顺序和阻塞的约束。</li>\n<li>压缩了headers。因为headers在一系列请求中常常是相似的，其移除了重复和传输重复数据的成本。</li>\n<li>其允许服务器在客户端缓存中填充数据，通过一个叫服务器推送的机制来提前请求。</li>\n</ul>\n<h3 id=\"服务器推送方式\"><a href=\"#服务器推送方式\" class=\"headerlink\" title=\"服务器推送方式\"></a>服务器推送方式</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http://www.ruanyifeng.com/blog/2017/05/server-sent_events.html</span><br></pre></td></tr></table></figure>\n\n<p><strong>WebSockets</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://developer.mozilla.org/zh-CN/docs/Web/API/WebSockets_API</span><br></pre></td></tr></table></figure>\n\n<p><strong>Server-sent events</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://developer.mozilla.org/zh-CN/docs/Web/API/Server-sent_events</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"连接管理\"><a href=\"#连接管理\" class=\"headerlink\" title=\"连接管理\"></a>连接管理</h2><p>HTTP/1.x有三个，HTTP/2新增了其他的连接管理模型</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Connection_management_in_HTTP_1.x</span><br></pre></td></tr></table></figure>\n\n\n\n<p>HTTP/1.x的三个连接</p>\n<p>短连接，长连接，流水线</p>\n<img src=\"/.io//image-20211024104204389.png\" alt=\"image-20211024104204389\" style=\"zoom:67%;\">\n\n\n\n<h3 id=\"短连接\"><a href=\"#短连接\" class=\"headerlink\" title=\"短连接\"></a>短连接</h3><p>​        每一个 HTTP 请求都由它自己独立的连接完成；这意味着发起每一个 HTTP 请求之前都会有一次 TCP 握手，而且是连续不断的。</p>\n<p>​        简单来说就是每次请求都要建立连接，请求结束关闭连接，造成了大量的连接时间的浪费。</p>\n<p>​        这是 HTTP/1.0 的默认模型(如果没有指定 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Connection\"><code>Connection</code></a> 协议头，或者是值被设置为 <code>close</code>)。而在 HTTP/1.1 中，只有当 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Connection\"><code>Connection</code></a> 被设置为 <code>close</code> 时才会用到这个模型。</p>\n<h3 id=\"长连接\"><a href=\"#长连接\" class=\"headerlink\" title=\"长连接\"></a>长连接</h3><p>​        在HTTP/1.1被设计出来之前：<code>Connection: keep-alive</code>被作为一个请求头，做成了长连接的效果。</p>\n<p>​        为了缓解这些问题，<em>长连接</em> 的概念便被设计出来了，甚至在 HTTP/1.1 之前。或者这被称之为一个 <em>keep-alive</em> 连接。</p>\n<h3 id=\"流水线\"><a href=\"#流水线\" class=\"headerlink\" title=\"流水线\"></a>流水线</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HTTP 流水线在现代浏览器中并不是默认被启用的：</span><br><span class=\"line\">\tWeb 开发者并不能轻易的遇见和判断那些搞怪的代理服务器的各种莫名其妙的行为。</span><br><span class=\"line\">\t正确的实现流水线是复杂的：传输中的资源大小，多少有效的 RTT 会被用到，还有有效带宽，流水线带来的改善有多大的影响范围。不知道这些的话，重要的消息可能被延迟到不重要的消息后面。这个重要性的概念甚至会演变为影响到页面布局！因此 HTTP 流水线在大多数情况下带来的改善并不明显。</span><br><span class=\"line\">\t流水线受制于 HOL 问题。</span><br><span class=\"line\">由于这些原因，流水线已经被更好的算法给代替，如 multiplexing，已经用在 HTTP/2。</span><br></pre></td></tr></table></figure>\n\n<p>简单理解就是说，直接发送连续的请求，不需要等待每次的响应。</p>\n<h3 id=\"域名分片\"><a href=\"#域名分片\" class=\"headerlink\" title=\"域名分片\"></a>域名分片</h3><p>简单的理解就是为域名多建立几个连接。以实现并发请求。但是HTTP/2支持客户端的并发请求</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"HTTP概述\"><a href=\"#HTTP概述\" class=\"headerlink\" title=\"HTTP概述\"></a>HTTP概述</h1><h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>找不到说啥，直接放个MDN文档</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Overview</span><br></pre></td></tr></table></figure>\n\n<img src=\"/.io//image-20211024100324347.png\" alt=\"image-20211024100324347\" style=\"zoom:67%;\">\n\n\n\n<h2 id=\"版本迭代\"><a href=\"#版本迭代\" class=\"headerlink\" title=\"版本迭代\"></a>版本迭代</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/Evolution_of_HTTP</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"HTTP-0-9\"><a href=\"#HTTP-0-9\" class=\"headerlink\" title=\"HTTP/0.9\"></a>HTTP/0.9</h3><p>也被称为 <strong>单行协议</strong> </p>\n<p>请求由单行指令构成，以唯一可用方法<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/GET\"><code>GET</code></a>开头，其后跟目标资源的路径</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET /mypage.html</span><br></pre></td></tr></table></figure>\n\n<p>响应就只包含了响应文档本身，就是HTML文件</p>\n<p>并且因为不包含响应头，所以只有HTML文件可以进行传输。</p>\n<h3 id=\"HTTP-1-0\"><a href=\"#HTTP-1-0\" class=\"headerlink\" title=\"HTTP/1.0\"></a>HTTP/1.0</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">最大的变化是支持了传输其他文件，默认是短连接，支持GET、POST、 HEAD请求</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>协议版本信息现在会随着每个请求发送（<code>HTTP/1.0</code>被追加到了<code>GET</code>行）。</li>\n<li><strong>状态码会在响应开始时发送</strong>，使浏览器能了解请求执行成功或失败，并相应调整行为（如更新或使用本地缓存）。</li>\n<li>引入了HTTP头的概念，无论是对于请求还是响应，允许传输元数据，使协议变得非常灵活，更具扩展性。</li>\n<li>在新HTTP头的帮助下，具备了传输除纯文本HTML文件以外其他类型文档的能力（感谢<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Type\"><code>Content-Type</code></a>头）。</li>\n</ul>\n<p><strong>默认是短连接，一次请求会建立一次TCP连接，请求结束就断开。</strong>可以通过一个 <code>Connection: keep-alive</code>字段使服务器不关闭连接。服务器同时也会响应这个字段。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET /mypage.html HTTP/1.0</span><br><span class=\"line\">User-Agent: NCSA_Mosaic/2.0 (Windows 3.1)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"HTTP-1-1\"><a href=\"#HTTP-1-1\" class=\"headerlink\" title=\"HTTP/1.1\"></a>HTTP/1.1</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">最大的变化就是支持了持久连接，默认长连接。不同自己声明 `Connection: keep-alive` ，增加了 `HOST` ，增加了请求方式，支持断点续传功能。</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>连接可以复用，节省了多次打开TCP连接加载网页文档资源的时间。</li>\n<li>增加管线化技术，允许在第一个应答被完全发送之前就发送第二个请求，以降低通信延迟。</li>\n<li>支持响应分块。</li>\n<li>引入额外的缓存控制机制。</li>\n<li>引入内容协商机制，包括语言，编码，类型等，并允许客户端和服务器之间约定以最合适的内容进行交换。</li>\n<li>感谢<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Host\"><code>Host</code></a>头，能够使不同域名配置在同一个IP地址的服务器上。</li>\n</ul>\n<p><strong>Host</strong> 请求头指明了请求将要发送到的服务器主机名和端口号。</p>\n<p>如果没有包含端口号，会自动使用被请求服务的默认端口（比如HTTPS URL使用443端口，HTTP URL使用80端口）。</p>\n<p>所有HTTP/1.1 请求报文中必须包含一个<code>Host</code>头字段。对于缺少<code>Host</code>头或者含有超过一个<code>Host</code>头的HTTP/1.1 请求，可能会收到<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/400\"><code>400</code></a>（Bad Request）状态码。</p>\n<p>所有请求都是通过一个连接实现的。就是持久连接。服务器发现对方一段时间没有活动，就可以主动关闭连接。不过，规范的做法是，客户端在最后一个请求时，发送<code>Connection: close</code>，明确要求服务器关闭TCP连接。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET /en-US/docs/Glossary/Simple_header HTTP/1.1</span><br><span class=\"line\">Host: developer.mozilla.org</span><br><span class=\"line\">User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.9; rv:50.0) Gecko/20100101 Firefox/50.0</span><br><span class=\"line\">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class=\"line\">Accept-Language: en-US,en;q=0.5</span><br><span class=\"line\">Accept-Encoding: gzip, deflate, br</span><br><span class=\"line\">Referer: https://developer.mozilla.org/en-US/docs/Glossary/Simple_header</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"HTTP-2-0\"><a href=\"#HTTP-2-0\" class=\"headerlink\" title=\"HTTP/2.0\"></a>HTTP/2.0</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">最大的区别，协议为二进制协议，服务器主动推送，以及 headers 压缩</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>HTTP/2是二进制协议而不是文本协议。不再可读，也不可无障碍的手动创建，改善的优化技术现在可被实施。</li>\n<li>这是一个复用协议。并行的请求能在同一个链接中处理，移除了HTTP/1.x中顺序和阻塞的约束。</li>\n<li>压缩了headers。因为headers在一系列请求中常常是相似的，其移除了重复和传输重复数据的成本。</li>\n<li>其允许服务器在客户端缓存中填充数据，通过一个叫服务器推送的机制来提前请求。</li>\n</ul>\n<h3 id=\"服务器推送方式\"><a href=\"#服务器推送方式\" class=\"headerlink\" title=\"服务器推送方式\"></a>服务器推送方式</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http://www.ruanyifeng.com/blog/2017/05/server-sent_events.html</span><br></pre></td></tr></table></figure>\n\n<p><strong>WebSockets</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://developer.mozilla.org/zh-CN/docs/Web/API/WebSockets_API</span><br></pre></td></tr></table></figure>\n\n<p><strong>Server-sent events</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://developer.mozilla.org/zh-CN/docs/Web/API/Server-sent_events</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"连接管理\"><a href=\"#连接管理\" class=\"headerlink\" title=\"连接管理\"></a>连接管理</h2><p>HTTP/1.x有三个，HTTP/2新增了其他的连接管理模型</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Connection_management_in_HTTP_1.x</span><br></pre></td></tr></table></figure>\n\n\n\n<p>HTTP/1.x的三个连接</p>\n<p>短连接，长连接，流水线</p>\n<img src=\"/.io//image-20211024104204389.png\" alt=\"image-20211024104204389\" style=\"zoom:67%;\">\n\n\n\n<h3 id=\"短连接\"><a href=\"#短连接\" class=\"headerlink\" title=\"短连接\"></a>短连接</h3><p>​        每一个 HTTP 请求都由它自己独立的连接完成；这意味着发起每一个 HTTP 请求之前都会有一次 TCP 握手，而且是连续不断的。</p>\n<p>​        简单来说就是每次请求都要建立连接，请求结束关闭连接，造成了大量的连接时间的浪费。</p>\n<p>​        这是 HTTP/1.0 的默认模型(如果没有指定 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Connection\"><code>Connection</code></a> 协议头，或者是值被设置为 <code>close</code>)。而在 HTTP/1.1 中，只有当 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Connection\"><code>Connection</code></a> 被设置为 <code>close</code> 时才会用到这个模型。</p>\n<h3 id=\"长连接\"><a href=\"#长连接\" class=\"headerlink\" title=\"长连接\"></a>长连接</h3><p>​        在HTTP/1.1被设计出来之前：<code>Connection: keep-alive</code>被作为一个请求头，做成了长连接的效果。</p>\n<p>​        为了缓解这些问题，<em>长连接</em> 的概念便被设计出来了，甚至在 HTTP/1.1 之前。或者这被称之为一个 <em>keep-alive</em> 连接。</p>\n<h3 id=\"流水线\"><a href=\"#流水线\" class=\"headerlink\" title=\"流水线\"></a>流水线</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HTTP 流水线在现代浏览器中并不是默认被启用的：</span><br><span class=\"line\">\tWeb 开发者并不能轻易的遇见和判断那些搞怪的代理服务器的各种莫名其妙的行为。</span><br><span class=\"line\">\t正确的实现流水线是复杂的：传输中的资源大小，多少有效的 RTT 会被用到，还有有效带宽，流水线带来的改善有多大的影响范围。不知道这些的话，重要的消息可能被延迟到不重要的消息后面。这个重要性的概念甚至会演变为影响到页面布局！因此 HTTP 流水线在大多数情况下带来的改善并不明显。</span><br><span class=\"line\">\t流水线受制于 HOL 问题。</span><br><span class=\"line\">由于这些原因，流水线已经被更好的算法给代替，如 multiplexing，已经用在 HTTP/2。</span><br></pre></td></tr></table></figure>\n\n<p>简单理解就是说，直接发送连续的请求，不需要等待每次的响应。</p>\n<h3 id=\"域名分片\"><a href=\"#域名分片\" class=\"headerlink\" title=\"域名分片\"></a>域名分片</h3><p>简单的理解就是为域名多建立几个连接。以实现并发请求。但是HTTP/2支持客户端的并发请求</p>\n"},{"title":"TCP","date":"2021-11-06T01:45:52.000Z","_content":"\n\n\n#  TCP\n\n* 首先TCP属于传输层\n* 面向连接的传输层协议\n* 一对一的连接\n* 提供可靠交付服务\n* 全双工通信\n* 面向字节流：指的是流入到进程或从进程流出的字节序列\n\n\n\n​\t\tTCP并不关心应用一次把多长的报文发送到TCP缓存中，而是根据对方给出的窗口和当前网络拥塞的程度来决定一个报文应该包含多少个字节。\n\n\n\n## TCP和UDP的区别\n\n\n\n| TCP                                            | UDP                                                |\n| ---------------------------------------------- | -------------------------------------------------- |\n| 面向连接                                       | 无连接，即发送前不需要先建立连接                   |\n| 提供可靠交互，无差错，不丢失，不重复，按序到达 | 尽最大努力交付，不保证可靠交付                     |\n| 面向字节流                                     | 面向报文                                           |\n| 一对一的连接                                   | 支持一对一，一对多的通信                           |\n| 拥塞控制                                       | 没有拥塞控制，所以不会使发送率降低，因此会出现丢包 |\n| 首部较大20字节                                 | 只有8字节                                          |\n\n\n\n## 可靠传输的工作原理\n\n* 停止等待协议\n  * <img src=\"TCP/image-20211106102234899.png\" alt=\"image-20211106102234899\" style=\"zoom: 67%;\" />\n* 连续arq协议\n  * <img src=\"TCP/image-20211106102310315.png\" alt=\"image-20211106102310315\" style=\"zoom:67%;\" />\n\n\n\n## TCP可靠传输的实现\n\n* 滑动窗口\n  * <img src=\"TCP/image-20211106102333564.png\" alt=\"image-20211106102333564\" style=\"zoom:67%;\" />\n\n\n\n## 拥塞控制方法\n\n​\t\t慢开始和拥塞避免\n\n<img src=\"TCP/image-20211106102433477.png\" alt=\"image-20211106102433477\" style=\"zoom:67%;\" />\n\n​\t\t计算方式\n\n<img src=\"TCP/image-20211106102459740.png\" alt=\"image-20211106102459740\" style=\"zoom:67%;\" />\n\n\n\n## TCP三次握手\n\n<img src=\"TCP/image-20211106102538627.png\" alt=\"image-20211106102538627\" style=\"zoom:67%;\" />\n\n步骤：\n\n* 客户端主动打开，进行连接，SYN=1，seq=x，状态为SYN-SENT\n* 服务器处于LISTEN状态，等待客户端开始连接，接收到客户端的连接之后，返回 SYN=1，ACK=1，seq=y，ack=x+1，状态修改为SYN-RCVD\n* 客户端收到连接之后，发送 ACK=1，seq=x+1，ack=y+1，此时就代表了客户端已经成功收到，处于了ESTAB-LISHED状态。\n* 服务器收到之后，也处于了ESTAB-LISHED状态\n* 开始进行数据传送。\n\n**一句话简述**：\n\n```\n客户端发起连接请求，\n服务器收到连接请求，发送了确认报文。\n客户端收到确认报文，发送自己的确认报文，并准备传输数据。\n服务器收到了客户端的确认报文，准备接收数据。\n```\n\n\n\n## TCP四次挥手\n\n<img src=\"TCP/image-20211106103554196.png\" alt=\"image-20211106103554196\" style=\"zoom:67%;\" />\n\n**步骤：**\n\n客户端A，服务器B\n\n* A主动关闭，发送 FIN=1，seq=u，状态置为 FIN-WAIT-1\n* B收到关闭信息，先返回确认报文，ACK=1，seq=v，ack=u+1，状态：CLOSE-WAIT\n* 此时因为B可能还有数据传输或者数据处理，所以不会马上关闭\n* A收到确认信息，状态：FIN-WAIT-2\n* B数据传输结束，准备关闭，返回关闭确认，FIN=1，ACK=1，seq=w，ack=u+1，状态：LAST-ACK\n* A收到了确认关闭的信息，发送确认收到报文，ACK=1，seq=u+1，ack=w+1，同时状态：TIME-WAIT。\n* 这里为什么A没有马上关闭是因为，如果B没有收到最后的确认报文，就不会关闭会重复发送，所以这里A等待了2MSL，（MSL叫做最长报文段寿命(Maximum Segment Lifetime)），所以在2MSL之后，关闭了连接，状态：closed\n* B收到确认，关闭连接，状态：closed\n\n**一句话简述**：\n\n```\n客户端发送关闭，\n服务器确认收到并返回确认，但是此时服务器可能有数据进行传输，所以没有马上关闭\n服务器传输结束，返回关闭确认\n客户端收到关闭确认，返回确认\n服务器收到确认，关闭\n客户端等待了2MSL，来回最长报文段寿命后，关闭。\n```\n\n","source":"_posts/其他/TCP.md","raw":"---\ntitle: TCP\ndate: 2021-11-06 09:45:52\ntags:\n - TCP\ncategories:\n - 随笔\n---\n\n\n\n#  TCP\n\n* 首先TCP属于传输层\n* 面向连接的传输层协议\n* 一对一的连接\n* 提供可靠交付服务\n* 全双工通信\n* 面向字节流：指的是流入到进程或从进程流出的字节序列\n\n\n\n​\t\tTCP并不关心应用一次把多长的报文发送到TCP缓存中，而是根据对方给出的窗口和当前网络拥塞的程度来决定一个报文应该包含多少个字节。\n\n\n\n## TCP和UDP的区别\n\n\n\n| TCP                                            | UDP                                                |\n| ---------------------------------------------- | -------------------------------------------------- |\n| 面向连接                                       | 无连接，即发送前不需要先建立连接                   |\n| 提供可靠交互，无差错，不丢失，不重复，按序到达 | 尽最大努力交付，不保证可靠交付                     |\n| 面向字节流                                     | 面向报文                                           |\n| 一对一的连接                                   | 支持一对一，一对多的通信                           |\n| 拥塞控制                                       | 没有拥塞控制，所以不会使发送率降低，因此会出现丢包 |\n| 首部较大20字节                                 | 只有8字节                                          |\n\n\n\n## 可靠传输的工作原理\n\n* 停止等待协议\n  * <img src=\"TCP/image-20211106102234899.png\" alt=\"image-20211106102234899\" style=\"zoom: 67%;\" />\n* 连续arq协议\n  * <img src=\"TCP/image-20211106102310315.png\" alt=\"image-20211106102310315\" style=\"zoom:67%;\" />\n\n\n\n## TCP可靠传输的实现\n\n* 滑动窗口\n  * <img src=\"TCP/image-20211106102333564.png\" alt=\"image-20211106102333564\" style=\"zoom:67%;\" />\n\n\n\n## 拥塞控制方法\n\n​\t\t慢开始和拥塞避免\n\n<img src=\"TCP/image-20211106102433477.png\" alt=\"image-20211106102433477\" style=\"zoom:67%;\" />\n\n​\t\t计算方式\n\n<img src=\"TCP/image-20211106102459740.png\" alt=\"image-20211106102459740\" style=\"zoom:67%;\" />\n\n\n\n## TCP三次握手\n\n<img src=\"TCP/image-20211106102538627.png\" alt=\"image-20211106102538627\" style=\"zoom:67%;\" />\n\n步骤：\n\n* 客户端主动打开，进行连接，SYN=1，seq=x，状态为SYN-SENT\n* 服务器处于LISTEN状态，等待客户端开始连接，接收到客户端的连接之后，返回 SYN=1，ACK=1，seq=y，ack=x+1，状态修改为SYN-RCVD\n* 客户端收到连接之后，发送 ACK=1，seq=x+1，ack=y+1，此时就代表了客户端已经成功收到，处于了ESTAB-LISHED状态。\n* 服务器收到之后，也处于了ESTAB-LISHED状态\n* 开始进行数据传送。\n\n**一句话简述**：\n\n```\n客户端发起连接请求，\n服务器收到连接请求，发送了确认报文。\n客户端收到确认报文，发送自己的确认报文，并准备传输数据。\n服务器收到了客户端的确认报文，准备接收数据。\n```\n\n\n\n## TCP四次挥手\n\n<img src=\"TCP/image-20211106103554196.png\" alt=\"image-20211106103554196\" style=\"zoom:67%;\" />\n\n**步骤：**\n\n客户端A，服务器B\n\n* A主动关闭，发送 FIN=1，seq=u，状态置为 FIN-WAIT-1\n* B收到关闭信息，先返回确认报文，ACK=1，seq=v，ack=u+1，状态：CLOSE-WAIT\n* 此时因为B可能还有数据传输或者数据处理，所以不会马上关闭\n* A收到确认信息，状态：FIN-WAIT-2\n* B数据传输结束，准备关闭，返回关闭确认，FIN=1，ACK=1，seq=w，ack=u+1，状态：LAST-ACK\n* A收到了确认关闭的信息，发送确认收到报文，ACK=1，seq=u+1，ack=w+1，同时状态：TIME-WAIT。\n* 这里为什么A没有马上关闭是因为，如果B没有收到最后的确认报文，就不会关闭会重复发送，所以这里A等待了2MSL，（MSL叫做最长报文段寿命(Maximum Segment Lifetime)），所以在2MSL之后，关闭了连接，状态：closed\n* B收到确认，关闭连接，状态：closed\n\n**一句话简述**：\n\n```\n客户端发送关闭，\n服务器确认收到并返回确认，但是此时服务器可能有数据进行传输，所以没有马上关闭\n服务器传输结束，返回关闭确认\n客户端收到关闭确认，返回确认\n服务器收到确认，关闭\n客户端等待了2MSL，来回最长报文段寿命后，关闭。\n```\n\n","slug":"其他/TCP","published":1,"updated":"2021-12-09T01:56:49.420Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckznhkk86004dikubgrxt6h3f","content":"<h1 id=\"TCP\"><a href=\"#TCP\" class=\"headerlink\" title=\"TCP\"></a>TCP</h1><ul>\n<li>首先TCP属于传输层</li>\n<li>面向连接的传输层协议</li>\n<li>一对一的连接</li>\n<li>提供可靠交付服务</li>\n<li>全双工通信</li>\n<li>面向字节流：指的是流入到进程或从进程流出的字节序列</li>\n</ul>\n<p>​        TCP并不关心应用一次把多长的报文发送到TCP缓存中，而是根据对方给出的窗口和当前网络拥塞的程度来决定一个报文应该包含多少个字节。</p>\n<h2 id=\"TCP和UDP的区别\"><a href=\"#TCP和UDP的区别\" class=\"headerlink\" title=\"TCP和UDP的区别\"></a>TCP和UDP的区别</h2><table>\n<thead>\n<tr>\n<th>TCP</th>\n<th>UDP</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>面向连接</td>\n<td>无连接，即发送前不需要先建立连接</td>\n</tr>\n<tr>\n<td>提供可靠交互，无差错，不丢失，不重复，按序到达</td>\n<td>尽最大努力交付，不保证可靠交付</td>\n</tr>\n<tr>\n<td>面向字节流</td>\n<td>面向报文</td>\n</tr>\n<tr>\n<td>一对一的连接</td>\n<td>支持一对一，一对多的通信</td>\n</tr>\n<tr>\n<td>拥塞控制</td>\n<td>没有拥塞控制，所以不会使发送率降低，因此会出现丢包</td>\n</tr>\n<tr>\n<td>首部较大20字节</td>\n<td>只有8字节</td>\n</tr>\n</tbody></table>\n<h2 id=\"可靠传输的工作原理\"><a href=\"#可靠传输的工作原理\" class=\"headerlink\" title=\"可靠传输的工作原理\"></a>可靠传输的工作原理</h2><ul>\n<li>停止等待协议<ul>\n<li><img src=\"/.io//image-20211106102234899.png\" alt=\"image-20211106102234899\" style=\"zoom: 67%;\"></li>\n</ul>\n</li>\n<li>连续arq协议<ul>\n<li><img src=\"/.io//image-20211106102310315.png\" alt=\"image-20211106102310315\" style=\"zoom:67%;\"></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"TCP可靠传输的实现\"><a href=\"#TCP可靠传输的实现\" class=\"headerlink\" title=\"TCP可靠传输的实现\"></a>TCP可靠传输的实现</h2><ul>\n<li>滑动窗口<ul>\n<li><img src=\"/.io//image-20211106102333564.png\" alt=\"image-20211106102333564\" style=\"zoom:67%;\"></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"拥塞控制方法\"><a href=\"#拥塞控制方法\" class=\"headerlink\" title=\"拥塞控制方法\"></a>拥塞控制方法</h2><p>​        慢开始和拥塞避免</p>\n<img src=\"/.io//image-20211106102433477.png\" alt=\"image-20211106102433477\" style=\"zoom:67%;\">\n\n<p>​        计算方式</p>\n<img src=\"/.io//image-20211106102459740.png\" alt=\"image-20211106102459740\" style=\"zoom:67%;\">\n\n\n\n<h2 id=\"TCP三次握手\"><a href=\"#TCP三次握手\" class=\"headerlink\" title=\"TCP三次握手\"></a>TCP三次握手</h2><img src=\"/.io//image-20211106102538627.png\" alt=\"image-20211106102538627\" style=\"zoom:67%;\">\n\n<p>步骤：</p>\n<ul>\n<li>客户端主动打开，进行连接，SYN=1，seq=x，状态为SYN-SENT</li>\n<li>服务器处于LISTEN状态，等待客户端开始连接，接收到客户端的连接之后，返回 SYN=1，ACK=1，seq=y，ack=x+1，状态修改为SYN-RCVD</li>\n<li>客户端收到连接之后，发送 ACK=1，seq=x+1，ack=y+1，此时就代表了客户端已经成功收到，处于了ESTAB-LISHED状态。</li>\n<li>服务器收到之后，也处于了ESTAB-LISHED状态</li>\n<li>开始进行数据传送。</li>\n</ul>\n<p><strong>一句话简述</strong>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">客户端发起连接请求，</span><br><span class=\"line\">服务器收到连接请求，发送了确认报文。</span><br><span class=\"line\">客户端收到确认报文，发送自己的确认报文，并准备传输数据。</span><br><span class=\"line\">服务器收到了客户端的确认报文，准备接收数据。</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"TCP四次挥手\"><a href=\"#TCP四次挥手\" class=\"headerlink\" title=\"TCP四次挥手\"></a>TCP四次挥手</h2><img src=\"/.io//image-20211106103554196.png\" alt=\"image-20211106103554196\" style=\"zoom:67%;\">\n\n<p><strong>步骤：</strong></p>\n<p>客户端A，服务器B</p>\n<ul>\n<li>A主动关闭，发送 FIN=1，seq=u，状态置为 FIN-WAIT-1</li>\n<li>B收到关闭信息，先返回确认报文，ACK=1，seq=v，ack=u+1，状态：CLOSE-WAIT</li>\n<li>此时因为B可能还有数据传输或者数据处理，所以不会马上关闭</li>\n<li>A收到确认信息，状态：FIN-WAIT-2</li>\n<li>B数据传输结束，准备关闭，返回关闭确认，FIN=1，ACK=1，seq=w，ack=u+1，状态：LAST-ACK</li>\n<li>A收到了确认关闭的信息，发送确认收到报文，ACK=1，seq=u+1，ack=w+1，同时状态：TIME-WAIT。</li>\n<li>这里为什么A没有马上关闭是因为，如果B没有收到最后的确认报文，就不会关闭会重复发送，所以这里A等待了2MSL，（MSL叫做最长报文段寿命(Maximum Segment Lifetime)），所以在2MSL之后，关闭了连接，状态：closed</li>\n<li>B收到确认，关闭连接，状态：closed</li>\n</ul>\n<p><strong>一句话简述</strong>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">客户端发送关闭，</span><br><span class=\"line\">服务器确认收到并返回确认，但是此时服务器可能有数据进行传输，所以没有马上关闭</span><br><span class=\"line\">服务器传输结束，返回关闭确认</span><br><span class=\"line\">客户端收到关闭确认，返回确认</span><br><span class=\"line\">服务器收到确认，关闭</span><br><span class=\"line\">客户端等待了2MSL，来回最长报文段寿命后，关闭。</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"TCP\"><a href=\"#TCP\" class=\"headerlink\" title=\"TCP\"></a>TCP</h1><ul>\n<li>首先TCP属于传输层</li>\n<li>面向连接的传输层协议</li>\n<li>一对一的连接</li>\n<li>提供可靠交付服务</li>\n<li>全双工通信</li>\n<li>面向字节流：指的是流入到进程或从进程流出的字节序列</li>\n</ul>\n<p>​        TCP并不关心应用一次把多长的报文发送到TCP缓存中，而是根据对方给出的窗口和当前网络拥塞的程度来决定一个报文应该包含多少个字节。</p>\n<h2 id=\"TCP和UDP的区别\"><a href=\"#TCP和UDP的区别\" class=\"headerlink\" title=\"TCP和UDP的区别\"></a>TCP和UDP的区别</h2><table>\n<thead>\n<tr>\n<th>TCP</th>\n<th>UDP</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>面向连接</td>\n<td>无连接，即发送前不需要先建立连接</td>\n</tr>\n<tr>\n<td>提供可靠交互，无差错，不丢失，不重复，按序到达</td>\n<td>尽最大努力交付，不保证可靠交付</td>\n</tr>\n<tr>\n<td>面向字节流</td>\n<td>面向报文</td>\n</tr>\n<tr>\n<td>一对一的连接</td>\n<td>支持一对一，一对多的通信</td>\n</tr>\n<tr>\n<td>拥塞控制</td>\n<td>没有拥塞控制，所以不会使发送率降低，因此会出现丢包</td>\n</tr>\n<tr>\n<td>首部较大20字节</td>\n<td>只有8字节</td>\n</tr>\n</tbody></table>\n<h2 id=\"可靠传输的工作原理\"><a href=\"#可靠传输的工作原理\" class=\"headerlink\" title=\"可靠传输的工作原理\"></a>可靠传输的工作原理</h2><ul>\n<li>停止等待协议<ul>\n<li><img src=\"/.io//image-20211106102234899.png\" alt=\"image-20211106102234899\" style=\"zoom: 67%;\"></li>\n</ul>\n</li>\n<li>连续arq协议<ul>\n<li><img src=\"/.io//image-20211106102310315.png\" alt=\"image-20211106102310315\" style=\"zoom:67%;\"></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"TCP可靠传输的实现\"><a href=\"#TCP可靠传输的实现\" class=\"headerlink\" title=\"TCP可靠传输的实现\"></a>TCP可靠传输的实现</h2><ul>\n<li>滑动窗口<ul>\n<li><img src=\"/.io//image-20211106102333564.png\" alt=\"image-20211106102333564\" style=\"zoom:67%;\"></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"拥塞控制方法\"><a href=\"#拥塞控制方法\" class=\"headerlink\" title=\"拥塞控制方法\"></a>拥塞控制方法</h2><p>​        慢开始和拥塞避免</p>\n<img src=\"/.io//image-20211106102433477.png\" alt=\"image-20211106102433477\" style=\"zoom:67%;\">\n\n<p>​        计算方式</p>\n<img src=\"/.io//image-20211106102459740.png\" alt=\"image-20211106102459740\" style=\"zoom:67%;\">\n\n\n\n<h2 id=\"TCP三次握手\"><a href=\"#TCP三次握手\" class=\"headerlink\" title=\"TCP三次握手\"></a>TCP三次握手</h2><img src=\"/.io//image-20211106102538627.png\" alt=\"image-20211106102538627\" style=\"zoom:67%;\">\n\n<p>步骤：</p>\n<ul>\n<li>客户端主动打开，进行连接，SYN=1，seq=x，状态为SYN-SENT</li>\n<li>服务器处于LISTEN状态，等待客户端开始连接，接收到客户端的连接之后，返回 SYN=1，ACK=1，seq=y，ack=x+1，状态修改为SYN-RCVD</li>\n<li>客户端收到连接之后，发送 ACK=1，seq=x+1，ack=y+1，此时就代表了客户端已经成功收到，处于了ESTAB-LISHED状态。</li>\n<li>服务器收到之后，也处于了ESTAB-LISHED状态</li>\n<li>开始进行数据传送。</li>\n</ul>\n<p><strong>一句话简述</strong>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">客户端发起连接请求，</span><br><span class=\"line\">服务器收到连接请求，发送了确认报文。</span><br><span class=\"line\">客户端收到确认报文，发送自己的确认报文，并准备传输数据。</span><br><span class=\"line\">服务器收到了客户端的确认报文，准备接收数据。</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"TCP四次挥手\"><a href=\"#TCP四次挥手\" class=\"headerlink\" title=\"TCP四次挥手\"></a>TCP四次挥手</h2><img src=\"/.io//image-20211106103554196.png\" alt=\"image-20211106103554196\" style=\"zoom:67%;\">\n\n<p><strong>步骤：</strong></p>\n<p>客户端A，服务器B</p>\n<ul>\n<li>A主动关闭，发送 FIN=1，seq=u，状态置为 FIN-WAIT-1</li>\n<li>B收到关闭信息，先返回确认报文，ACK=1，seq=v，ack=u+1，状态：CLOSE-WAIT</li>\n<li>此时因为B可能还有数据传输或者数据处理，所以不会马上关闭</li>\n<li>A收到确认信息，状态：FIN-WAIT-2</li>\n<li>B数据传输结束，准备关闭，返回关闭确认，FIN=1，ACK=1，seq=w，ack=u+1，状态：LAST-ACK</li>\n<li>A收到了确认关闭的信息，发送确认收到报文，ACK=1，seq=u+1，ack=w+1，同时状态：TIME-WAIT。</li>\n<li>这里为什么A没有马上关闭是因为，如果B没有收到最后的确认报文，就不会关闭会重复发送，所以这里A等待了2MSL，（MSL叫做最长报文段寿命(Maximum Segment Lifetime)），所以在2MSL之后，关闭了连接，状态：closed</li>\n<li>B收到确认，关闭连接，状态：closed</li>\n</ul>\n<p><strong>一句话简述</strong>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">客户端发送关闭，</span><br><span class=\"line\">服务器确认收到并返回确认，但是此时服务器可能有数据进行传输，所以没有马上关闭</span><br><span class=\"line\">服务器传输结束，返回关闭确认</span><br><span class=\"line\">客户端收到关闭确认，返回确认</span><br><span class=\"line\">服务器收到确认，关闭</span><br><span class=\"line\">客户端等待了2MSL，来回最长报文段寿命后，关闭。</span><br></pre></td></tr></table></figure>\n\n"},{"title":"状态码","date":"2021-11-06T02:51:49.000Z","_content":"\n\n\n#  状态码\n\n## 1xx\n\n* **100**\n  * 告诉客户端应该继续发送请求。\n\n\n\n## 2xx\n\n* **200**\n  * 表示服务器已经成功接收请求，并返回请求结果\n* **202**\n  * 表示服务器接受了请求，但是还没有处理\n* **204**\n  * 表示服务器处理了请求，但是没有返回任何实体内容\n* **206**\n  * 是对资源的部分请求，断点续传，下载时的\n\n\n\n## 3xx\n\n* **301**\n  * 永久重定向，客户端会保存新的链接。\n* **302**\n  * 临时重定向，一般如果不是资源的临时移动，都建议使用301，有很多好处\n* **303**\n  * 和302相同，但是明确表示客户端应当采用GET方法获取资源\n* **304**\n  * 命中协商缓存\n\n\n\n## 4xx\n\n* **400**\n  * 客户端发送的请求无法理解\n* **401**\n  * 请求需要通过HTTP认证\n* **403**\n  * 不允许访问资源，权限，未授权等\n* **404**\n  * 服务器没有的请求资源，路径错误等\n\n\n\n## 5xx\n\n* **500**\n  * 服务器错误\n* **503**\n  * 服务器负载","source":"_posts/其他/状态码.md","raw":"---\ntitle: 状态码\ndate: 2021-11-06 10:51:49\ntags:\n - 状态码\n - 随笔\ncategories:\n - 随笔\n---\n\n\n\n#  状态码\n\n## 1xx\n\n* **100**\n  * 告诉客户端应该继续发送请求。\n\n\n\n## 2xx\n\n* **200**\n  * 表示服务器已经成功接收请求，并返回请求结果\n* **202**\n  * 表示服务器接受了请求，但是还没有处理\n* **204**\n  * 表示服务器处理了请求，但是没有返回任何实体内容\n* **206**\n  * 是对资源的部分请求，断点续传，下载时的\n\n\n\n## 3xx\n\n* **301**\n  * 永久重定向，客户端会保存新的链接。\n* **302**\n  * 临时重定向，一般如果不是资源的临时移动，都建议使用301，有很多好处\n* **303**\n  * 和302相同，但是明确表示客户端应当采用GET方法获取资源\n* **304**\n  * 命中协商缓存\n\n\n\n## 4xx\n\n* **400**\n  * 客户端发送的请求无法理解\n* **401**\n  * 请求需要通过HTTP认证\n* **403**\n  * 不允许访问资源，权限，未授权等\n* **404**\n  * 服务器没有的请求资源，路径错误等\n\n\n\n## 5xx\n\n* **500**\n  * 服务器错误\n* **503**\n  * 服务器负载","slug":"其他/状态码","published":1,"updated":"2021-12-09T01:56:49.432Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckznhkk86004gikubffi7fd6x","content":"<h1 id=\"状态码\"><a href=\"#状态码\" class=\"headerlink\" title=\"状态码\"></a>状态码</h1><h2 id=\"1xx\"><a href=\"#1xx\" class=\"headerlink\" title=\"1xx\"></a>1xx</h2><ul>\n<li><strong>100</strong><ul>\n<li>告诉客户端应该继续发送请求。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"2xx\"><a href=\"#2xx\" class=\"headerlink\" title=\"2xx\"></a>2xx</h2><ul>\n<li><strong>200</strong><ul>\n<li>表示服务器已经成功接收请求，并返回请求结果</li>\n</ul>\n</li>\n<li><strong>202</strong><ul>\n<li>表示服务器接受了请求，但是还没有处理</li>\n</ul>\n</li>\n<li><strong>204</strong><ul>\n<li>表示服务器处理了请求，但是没有返回任何实体内容</li>\n</ul>\n</li>\n<li><strong>206</strong><ul>\n<li>是对资源的部分请求，断点续传，下载时的</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"3xx\"><a href=\"#3xx\" class=\"headerlink\" title=\"3xx\"></a>3xx</h2><ul>\n<li><strong>301</strong><ul>\n<li>永久重定向，客户端会保存新的链接。</li>\n</ul>\n</li>\n<li><strong>302</strong><ul>\n<li>临时重定向，一般如果不是资源的临时移动，都建议使用301，有很多好处</li>\n</ul>\n</li>\n<li><strong>303</strong><ul>\n<li>和302相同，但是明确表示客户端应当采用GET方法获取资源</li>\n</ul>\n</li>\n<li><strong>304</strong><ul>\n<li>命中协商缓存</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"4xx\"><a href=\"#4xx\" class=\"headerlink\" title=\"4xx\"></a>4xx</h2><ul>\n<li><strong>400</strong><ul>\n<li>客户端发送的请求无法理解</li>\n</ul>\n</li>\n<li><strong>401</strong><ul>\n<li>请求需要通过HTTP认证</li>\n</ul>\n</li>\n<li><strong>403</strong><ul>\n<li>不允许访问资源，权限，未授权等</li>\n</ul>\n</li>\n<li><strong>404</strong><ul>\n<li>服务器没有的请求资源，路径错误等</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"5xx\"><a href=\"#5xx\" class=\"headerlink\" title=\"5xx\"></a>5xx</h2><ul>\n<li><strong>500</strong><ul>\n<li>服务器错误</li>\n</ul>\n</li>\n<li><strong>503</strong><ul>\n<li>服务器负载</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"状态码\"><a href=\"#状态码\" class=\"headerlink\" title=\"状态码\"></a>状态码</h1><h2 id=\"1xx\"><a href=\"#1xx\" class=\"headerlink\" title=\"1xx\"></a>1xx</h2><ul>\n<li><strong>100</strong><ul>\n<li>告诉客户端应该继续发送请求。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"2xx\"><a href=\"#2xx\" class=\"headerlink\" title=\"2xx\"></a>2xx</h2><ul>\n<li><strong>200</strong><ul>\n<li>表示服务器已经成功接收请求，并返回请求结果</li>\n</ul>\n</li>\n<li><strong>202</strong><ul>\n<li>表示服务器接受了请求，但是还没有处理</li>\n</ul>\n</li>\n<li><strong>204</strong><ul>\n<li>表示服务器处理了请求，但是没有返回任何实体内容</li>\n</ul>\n</li>\n<li><strong>206</strong><ul>\n<li>是对资源的部分请求，断点续传，下载时的</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"3xx\"><a href=\"#3xx\" class=\"headerlink\" title=\"3xx\"></a>3xx</h2><ul>\n<li><strong>301</strong><ul>\n<li>永久重定向，客户端会保存新的链接。</li>\n</ul>\n</li>\n<li><strong>302</strong><ul>\n<li>临时重定向，一般如果不是资源的临时移动，都建议使用301，有很多好处</li>\n</ul>\n</li>\n<li><strong>303</strong><ul>\n<li>和302相同，但是明确表示客户端应当采用GET方法获取资源</li>\n</ul>\n</li>\n<li><strong>304</strong><ul>\n<li>命中协商缓存</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"4xx\"><a href=\"#4xx\" class=\"headerlink\" title=\"4xx\"></a>4xx</h2><ul>\n<li><strong>400</strong><ul>\n<li>客户端发送的请求无法理解</li>\n</ul>\n</li>\n<li><strong>401</strong><ul>\n<li>请求需要通过HTTP认证</li>\n</ul>\n</li>\n<li><strong>403</strong><ul>\n<li>不允许访问资源，权限，未授权等</li>\n</ul>\n</li>\n<li><strong>404</strong><ul>\n<li>服务器没有的请求资源，路径错误等</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"5xx\"><a href=\"#5xx\" class=\"headerlink\" title=\"5xx\"></a>5xx</h2><ul>\n<li><strong>500</strong><ul>\n<li>服务器错误</li>\n</ul>\n</li>\n<li><strong>503</strong><ul>\n<li>服务器负载</li>\n</ul>\n</li>\n</ul>\n"},{"title":"浏览器缓存策略","date":"2021-10-22T13:43:10.000Z","_content":"\n\n\n#  浏览器缓存策略\n\n**参考文章**\n\n```\nhttps://juejin.cn/post/6844903757872889870\nMDN\nhttps://juejin.cn/post/6844903737538920462\n```\n\n\n\n**先说一下什么是缓存**\n\n```\n\t缓存就是会将一些不会经常更改的图片文件等资源存储下来，下次访问的时候会优先读取本地的资源进行显示，这样既能减轻服务器的负载，也能加快页面的显示。\n\t这时可能就可能会问，那如果资源有了改变怎么办，所以这时候就有了强缓存和协商缓存两种。\n```\n\n\n\n**浏览器缓存策略分为**\n\n​\t**强缓存**\n\n​\t\t强缓存就是直接从本地进行读取，不需要向服务器端进行获取资源。因此很快。\n\n​\t\t在命中强缓存的情况下，状态码为 200，但是size显示from disk cache或from memory cache\n\n​\t**协商缓存**\n\n​\t\t协商缓存就是会请求，但是会将一个文件的信息加入到请求头，然后服务器端进行判断，来决定是否要更新浏览器的资源。\n\n​\t\t会将 `Last-Modified` 和 `Etag` 放入请求头，然后服务器就会进行比对，如果命中协商缓存，状态码为304。否则会将资源传输过来。\n\n\n\n## 强缓存\n\n在进行请求的时候，不会向服务器发送请求，直接从缓存中读取资源，但是状态码是200\n\n\n\n如何进行强缓存，简单来说就是我们请求资源之后，服务器会返回一个请求头。浏览器后续就会根据这个请求头进行判断是否命中强缓存。\n\n\n\n### 请求头\n\n​\t\t对于强缓存的请求头，有 **Expires** 和 **Cache-Control**，但是因为**Cache-Control** 是HTTP/1.1的产物，所以，优先级高于 Expires。\n\n\n\n#### Expires\n\n```\nhttps://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Expires\n```\n\nHTTP/1.0\n\n​\t缓存过期时间，用来指定资源到期的时间。\n\n​\t\t缺点，是通过本地时间进行的判断。\n\n```\nExpires: Wed, 21 Oct 2015 07:28:00 GMT\n```\n\n**注：**\n\n​\t如果在`Cache-Contro`响应头设置了`max-age`或者`s-max-age`指令，那么`Expires`头会被忽悠。\n\n\n\n#### Cache-Control\n\nHTTP/1.1\n\n```\nhttps://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cache-Control\n```\n\n**语法**：\n\n- 不区分大小写，但建议使用小写。\n- 多个指令以逗号分隔。\n- 具有可选参数，可以用令牌或者带引号的字符串语法。\n\n**默认值：private**\n\n**指令**：\n\n**可缓存性指令：**\n\n**public：**\n\n​\t\t表明响应可以被任何对象（包括：发送请求的客户端，代理服务器，等等）缓存，即使是通常不可缓存的内容。\n\n​\t\t（例如：1.该响应没有`max-age`指令或`Expires`消息头；\n\n​\t\t\t\t\t\t2. 该响应对应的请求方法是 [POST](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/POST) 。）\n\n**private：**\n\n​\t\t表明响应只能被单个用户缓存，不能作为共享缓存（即代理服务器不能缓存它）。私有缓存可以缓存响应内容。\n\n​\t\t比如：对应用户的本地浏览器。\n\n**no-cache**:\n\n​\t\t在发布缓存副本之前，强制要求缓存把请求提交给原始服务器进行验证(协商缓存验证)。\n\n**no-store**：\n\n​\t\t缓存不应存储有关客户端请求或服务器响应的任何内容，即不使用任何缓存。\n\n\n\n**到期：**\n\n**max-age**：\n\n​\t\t设置缓存存储的最大周期，超过这个时间缓存被认为过期(单位秒)。与`Expires`相反，时间是相对于请求的时间。\n\n**s-maxage**：\n\n​\t\t覆盖`max-age`或者`Expires`头，但是仅适用于共享缓存(比如各个代理)，私有缓存会忽略它。\n\n**max-stale**：\n\n​\t\t表明客户端愿意接收一个已经过期的资源。可以设置一个可选的秒数，表示响应不能已经过时超过该给定的时间。\n\n**min-fresh**：\n\n​\t\t表示客户端希望获取一个能在指定的秒数内保持其最新状态的响应。\n\n\n\n**重新验证与加载：**\n\n**must-revalidate**：\n\n​\t\t一旦资源过期（比如已经超过`max-age`），在成功向原始服务器验证之前，缓存不能用该资源响应后续请求。\n\n\n\n<img src=\"浏览器缓存策略/image-20211023161739229.png\" alt=\"image-20211023161739229\" style=\"zoom:67%;\" />\n\n图片来源\n\n```\nhttps://juejin.cn/post/6844903757872889870\n```\n\n\n\n**需要进行重新验证，这个就是会进行协商缓存：**\n\n​\t\t指定 `no-cache` 或 `max-age=0, must-revalidate` 表示客户端可以缓存资源，每次使用缓存资源前都必须重新验证其有效性。这意味着每次都会发起 HTTP 请求，但当缓存内容仍有效时可以跳过 HTTP 响应体的下载。\n\n**注意：**\n\n​\t如果服务器关闭或失去连接，下面的指令可能会造成使用缓存。\n\n```\nCache-Control: max-age=0\n```\n\n\n\n### 在强缓存时间内如何更新资源\n\n```\nhttps://juejin.cn/post/6844903737538920462#heading-5\n```\n\n虽然强缓存很好，但是有一个问题，如果在强缓存时间内，我的文件资源发生了更新，那该怎么解决呢？`（这个是我面试的时候问到的，一下把我人问傻了。）`\n\n这里我后面去了解了：\n\n​\t简单来说就是对于资源文件需要在发生了改变之后，可以让客户端再请求一次，方法就是将文件的名字在每次修改之后会发生改变，所以每次修改了之后，客户端要请求的文件名发生了改变，就会重新再进行一次请求了。这里对于文件名的方式使用`hash`。\n\n​\tHTML：使用协商缓存，因为里面会存储资源文件的路径，在每次更新之后里面的路径需要修改，所以使用协商缓存更合理。\n\n​\t对于　CSS／JS／图片：使用强缓存，对于一个文件名带上一个 hash 值。在每次文件进行了修改之后，名字后面的hash就会发生改变。所以客户端就会重新请求。\n\n\n\n## 协商缓存\n\n​\t\t会在请求头加上：`If-None-Match`和`If-Modified-Since`\n\n​\t\t分别对应了服务器响应头的：`ETag` 和  `Last-Modified`\n\nETag 优先级高于 Last-Modified\n\n\n\n###  **If-Modified-Since** 与  **Last-Modified**：\n\n**Last-Modified**：\n\n​\t这个是服务器端的返回的响应头。\n\n**If-Modified-Since**：\n\n​\t这个是客户端的请求的请求头。\n\n\n\n#### **Last-Modified**：\n\n```\nhttps://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Last-Modified\n```\n\n​\t\t这个是根据上一次请求资源时，服务器所返回的**Last-Modified**，这个作为一个响应的头部。其中包含源头服务器认定的资源做出修改的日期及时间\n\n​\t\t包含有  [`If-Modified-Since`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/If-Modified-Since) 或 [`If-Unmodified-Since`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/If-Unmodified-Since) 首部的条件请求会使用这个字段。 \n\n\n\n#### **If-Modified-Since**：\n\n```\nhttps://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/If-Modified-Since\n```\n\n​\t\t服务器只在所请求的资源在给定的日期时间之后对内容进行过修改的情况下才会将资源返回，状态码为 [`200`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/200) 。\n\n​\t\t如果请求的资源从那时起未经修改，那么返回一个不带有消息主体的 [`304`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/304) 响应，而在 [`Last-Modified`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Last-Modified) 首部中会带有上次修改时间。**（注：虽然返回了304，但是会有last-modified的头部返回，因此浏览器下次请求时，会使用的是此时服务器端返回过来的last-modified，而不是以前的。）**\n\n​\t\t`If-Modified-Since` 只可以用在 [`GET`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/GET) 或 [`HEAD`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/HEAD) 请求中。\n\n​\t\t当与 [`If-None-Match`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/If-None-Match) 一同出现时，它（**`If-Modified-Since`**）会被忽略掉，除非服务器不支持 `If-None-Match`。\n\n\n\n**If-Unmodified-Since：**\n\n​\t\t这个我没有了解。\n\n\n\n**使用上面这个的弊端：**\n\n​\t\t对于没有进行修改，但是有过保存导致 Last-Modified 被修改，无法命中。\n\n​\t\t这个只能以秒计时，所以对于秒以内的修改文件，不能返回。\n\n\n\n### If-None-Match 和 ETag\n\n**ETag**：\n\n​\t这个是服务器端的返回的响应头。\n\n**If-None-Match**：\n\n​\t这个是客户端的请求的请求头。\n\n\n\n#### **ETag**：\n\n```\nhttps://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/ETag\n```\n\n简单来说就是一个唯一标识资源的一个特殊符号，\n\n通常计算方式是：\n\n​\t**使用内容的散列，最后修改时间戳的哈希值，或简单地使用版本号**\n\n```\nhttps://juejin.cn/post/6844903737538920462\n这里有将比较详细的计算方式，我这里就不做过多的说明。\n```\n\n\n\n```\nETag: \"33a64df551425fcc55e4d42a148795d9f25f89d4\"\n```\n\n```\n作用：\n\t避免空中碰撞\n\t缓存未更改的资源，就是304.\n```\n\n\n\n##### 避免空中碰撞\n\nMDN上有说有这句话：\n\n​\t**而如果内容发生了变化，使用ETag有助于防止资源的同时更新相互覆盖（“空中碰撞”）**\n\n```\nhttps://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/ETag#避免“空中碰撞”\n```\n\n大概的意思就是说，\n\n​\t\t我在客户端进行编辑共享文档时`（共享文档就是说可以被多人查看和编辑的）`，最开始拿到的文档是最新的。\n\n​\t\t但是在编辑的过程中，可能别人也有编辑，但是比我上传的早，所以，在我准备上传一个共享文档时，服务器端的文档已经被别人修改过了，但是此时我的客户端的文档因为没有重新进行请求，所以还是没有被修改过的，\n\n​\t\t此时如果没有先进行一次判断 ETag 值的话，就会发生相互覆盖，这个就是空中碰撞。\n\n​\t\t避免就是会先进行 ETag 匹配检查是否为最新版，否则报 412 前提条件失败错误。\n\n`（此时这个 ETag 会放在 If-Match 的请求头中。）`\n\n\n\n**注：**\n\n​\t\t如果给定URL中的资源更改，则一定要生成新的 Etag 值。 因此 Etags 类似于指纹，也可能被某些服务器用于跟踪。 比较 etags 能快速确定此资源是否变化，但也可能被跟踪服务器永久存留。**（我能理解到 ETag 可能用于快速比较一个文件是否发生过修改，因为他是一个文根据文件的相关信息进行的一个算法生成的一个值，但是我不清楚什么是会被跟踪服务器存留）**\n\n\n\n##### 缓存未更改的资源\n\n​\t\t对于用户访问一个URL时，显示了资源过期且不可用，客户端就发送 ETag 的值 作为 If-None-Match 的请求头，如果资源没有更改，那么服务器将会返回不带响应体的 304 状态。\n\n\n\n#### **If-None-Match**：\n\n```\nhttps://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/If-None-Match\n```\n\n`If-None-Match` 和 `If-Match` 的区别\n\n```\nhttps://datatracker.ietf.org/doc/html/rfc7232#section-3.1\n```\n\nIf-None-Match\n\n​\t使用的是 弱比较算法。\n\n​\t常用于 GET 请求的，请求最新资源的方式\n\nIf-Match\n\n​\t使用的是 强比较算法。\n\n​\t常用于 POST  PUT，DELETE 状态改变方法，防止多个用户同时操作的意外覆盖。\n\n\n\n## 后端设置方式\n\n```\n参考文章\nhttps://juejin.cn/post/6844903737538920462#heading-11\n```\n\n```\nres.setHeader('Cache-Control', 'public, max-age=xxx');\n\n\nres.setHeader('Cache-Control', 'public, max-age=0');\nres.setHeader('Last-Modified', xxx);\nres.setHeader('ETag', xxx);\n```\n\n\n\n\n\n## 最后，重新来一遍浏览器缓存过程\n\n\n\n**第一次请求**\n\n浏览器进行请求，发现缓存没有这个文件\n\n向服务器进行请求，获得文件，并带上响应头：\n\n​\t属于强缓存的：Cache-Control，Expires\n\n​\t属于协商缓存的：ETag，Last-Modified\n\n浏览器接收到了文件，并将文件和这些响应头缓存下来，下次使用。\n\n\n\n**强缓存**\n\n浏览器进行请求，发现缓存存在这个文件\n\n浏览器缓存查看该次请求是否命中强缓存（就是没有超过文件缓存过期时间）\n\n命中强缓存，直接从本地读取，状态码：200\n\n\n\n**协商缓存**\n\n浏览器进行请求，发现缓存存在这个文件\n\n浏览器缓存查看该次请求是否命中强缓存，\n\n没有命中强缓存，将 ETag 和 Last-Modified 的值放入请求头，\n\n​\t为 If-None-Match 和 If-Modified-Since，发送给服务器\n\n服务器接收到请求后，查看是否命中协商缓存，\n\n发现命中协商缓存，服务器会返回状态码 304，没有响应体\n\n​\t并将响应头的 Last-Modified 和 ETag 的值设置为文件的值，返回\n\n客户端接收到服务器的 304 响应，并将 ETag 和 Last-Modified 存储下来。\n\n\n\n**简单来说：**\n\n​\t就是第一次的文件请求会正常的返回，第二次会先看看能不能命中强缓存，如果能直接读取本地的，如果不能则看看能不能命中协商缓存，如果命中，则还是读取本地的文件，如果都没有命中，那么就会使用新的文件。\n\n\n\n这里**对于一个文件如何在强缓存期间进行更新**也有说明：就是会对文件名进行hash计算，修改过的文件的hash值不一样，所以对于浏览器来说，这个文件名不一样，不是一个文件，需要重新请求。\n\n","source":"_posts/其他/浏览器缓存策略.md","raw":"---\ntitle: 浏览器缓存策略\ndate: 2021-10-22 21:43:10\ntags:\n - 缓存策略\n - 随笔\ncategories:\n - 随笔\n---\n\n\n\n#  浏览器缓存策略\n\n**参考文章**\n\n```\nhttps://juejin.cn/post/6844903757872889870\nMDN\nhttps://juejin.cn/post/6844903737538920462\n```\n\n\n\n**先说一下什么是缓存**\n\n```\n\t缓存就是会将一些不会经常更改的图片文件等资源存储下来，下次访问的时候会优先读取本地的资源进行显示，这样既能减轻服务器的负载，也能加快页面的显示。\n\t这时可能就可能会问，那如果资源有了改变怎么办，所以这时候就有了强缓存和协商缓存两种。\n```\n\n\n\n**浏览器缓存策略分为**\n\n​\t**强缓存**\n\n​\t\t强缓存就是直接从本地进行读取，不需要向服务器端进行获取资源。因此很快。\n\n​\t\t在命中强缓存的情况下，状态码为 200，但是size显示from disk cache或from memory cache\n\n​\t**协商缓存**\n\n​\t\t协商缓存就是会请求，但是会将一个文件的信息加入到请求头，然后服务器端进行判断，来决定是否要更新浏览器的资源。\n\n​\t\t会将 `Last-Modified` 和 `Etag` 放入请求头，然后服务器就会进行比对，如果命中协商缓存，状态码为304。否则会将资源传输过来。\n\n\n\n## 强缓存\n\n在进行请求的时候，不会向服务器发送请求，直接从缓存中读取资源，但是状态码是200\n\n\n\n如何进行强缓存，简单来说就是我们请求资源之后，服务器会返回一个请求头。浏览器后续就会根据这个请求头进行判断是否命中强缓存。\n\n\n\n### 请求头\n\n​\t\t对于强缓存的请求头，有 **Expires** 和 **Cache-Control**，但是因为**Cache-Control** 是HTTP/1.1的产物，所以，优先级高于 Expires。\n\n\n\n#### Expires\n\n```\nhttps://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Expires\n```\n\nHTTP/1.0\n\n​\t缓存过期时间，用来指定资源到期的时间。\n\n​\t\t缺点，是通过本地时间进行的判断。\n\n```\nExpires: Wed, 21 Oct 2015 07:28:00 GMT\n```\n\n**注：**\n\n​\t如果在`Cache-Contro`响应头设置了`max-age`或者`s-max-age`指令，那么`Expires`头会被忽悠。\n\n\n\n#### Cache-Control\n\nHTTP/1.1\n\n```\nhttps://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cache-Control\n```\n\n**语法**：\n\n- 不区分大小写，但建议使用小写。\n- 多个指令以逗号分隔。\n- 具有可选参数，可以用令牌或者带引号的字符串语法。\n\n**默认值：private**\n\n**指令**：\n\n**可缓存性指令：**\n\n**public：**\n\n​\t\t表明响应可以被任何对象（包括：发送请求的客户端，代理服务器，等等）缓存，即使是通常不可缓存的内容。\n\n​\t\t（例如：1.该响应没有`max-age`指令或`Expires`消息头；\n\n​\t\t\t\t\t\t2. 该响应对应的请求方法是 [POST](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/POST) 。）\n\n**private：**\n\n​\t\t表明响应只能被单个用户缓存，不能作为共享缓存（即代理服务器不能缓存它）。私有缓存可以缓存响应内容。\n\n​\t\t比如：对应用户的本地浏览器。\n\n**no-cache**:\n\n​\t\t在发布缓存副本之前，强制要求缓存把请求提交给原始服务器进行验证(协商缓存验证)。\n\n**no-store**：\n\n​\t\t缓存不应存储有关客户端请求或服务器响应的任何内容，即不使用任何缓存。\n\n\n\n**到期：**\n\n**max-age**：\n\n​\t\t设置缓存存储的最大周期，超过这个时间缓存被认为过期(单位秒)。与`Expires`相反，时间是相对于请求的时间。\n\n**s-maxage**：\n\n​\t\t覆盖`max-age`或者`Expires`头，但是仅适用于共享缓存(比如各个代理)，私有缓存会忽略它。\n\n**max-stale**：\n\n​\t\t表明客户端愿意接收一个已经过期的资源。可以设置一个可选的秒数，表示响应不能已经过时超过该给定的时间。\n\n**min-fresh**：\n\n​\t\t表示客户端希望获取一个能在指定的秒数内保持其最新状态的响应。\n\n\n\n**重新验证与加载：**\n\n**must-revalidate**：\n\n​\t\t一旦资源过期（比如已经超过`max-age`），在成功向原始服务器验证之前，缓存不能用该资源响应后续请求。\n\n\n\n<img src=\"浏览器缓存策略/image-20211023161739229.png\" alt=\"image-20211023161739229\" style=\"zoom:67%;\" />\n\n图片来源\n\n```\nhttps://juejin.cn/post/6844903757872889870\n```\n\n\n\n**需要进行重新验证，这个就是会进行协商缓存：**\n\n​\t\t指定 `no-cache` 或 `max-age=0, must-revalidate` 表示客户端可以缓存资源，每次使用缓存资源前都必须重新验证其有效性。这意味着每次都会发起 HTTP 请求，但当缓存内容仍有效时可以跳过 HTTP 响应体的下载。\n\n**注意：**\n\n​\t如果服务器关闭或失去连接，下面的指令可能会造成使用缓存。\n\n```\nCache-Control: max-age=0\n```\n\n\n\n### 在强缓存时间内如何更新资源\n\n```\nhttps://juejin.cn/post/6844903737538920462#heading-5\n```\n\n虽然强缓存很好，但是有一个问题，如果在强缓存时间内，我的文件资源发生了更新，那该怎么解决呢？`（这个是我面试的时候问到的，一下把我人问傻了。）`\n\n这里我后面去了解了：\n\n​\t简单来说就是对于资源文件需要在发生了改变之后，可以让客户端再请求一次，方法就是将文件的名字在每次修改之后会发生改变，所以每次修改了之后，客户端要请求的文件名发生了改变，就会重新再进行一次请求了。这里对于文件名的方式使用`hash`。\n\n​\tHTML：使用协商缓存，因为里面会存储资源文件的路径，在每次更新之后里面的路径需要修改，所以使用协商缓存更合理。\n\n​\t对于　CSS／JS／图片：使用强缓存，对于一个文件名带上一个 hash 值。在每次文件进行了修改之后，名字后面的hash就会发生改变。所以客户端就会重新请求。\n\n\n\n## 协商缓存\n\n​\t\t会在请求头加上：`If-None-Match`和`If-Modified-Since`\n\n​\t\t分别对应了服务器响应头的：`ETag` 和  `Last-Modified`\n\nETag 优先级高于 Last-Modified\n\n\n\n###  **If-Modified-Since** 与  **Last-Modified**：\n\n**Last-Modified**：\n\n​\t这个是服务器端的返回的响应头。\n\n**If-Modified-Since**：\n\n​\t这个是客户端的请求的请求头。\n\n\n\n#### **Last-Modified**：\n\n```\nhttps://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Last-Modified\n```\n\n​\t\t这个是根据上一次请求资源时，服务器所返回的**Last-Modified**，这个作为一个响应的头部。其中包含源头服务器认定的资源做出修改的日期及时间\n\n​\t\t包含有  [`If-Modified-Since`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/If-Modified-Since) 或 [`If-Unmodified-Since`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/If-Unmodified-Since) 首部的条件请求会使用这个字段。 \n\n\n\n#### **If-Modified-Since**：\n\n```\nhttps://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/If-Modified-Since\n```\n\n​\t\t服务器只在所请求的资源在给定的日期时间之后对内容进行过修改的情况下才会将资源返回，状态码为 [`200`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/200) 。\n\n​\t\t如果请求的资源从那时起未经修改，那么返回一个不带有消息主体的 [`304`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/304) 响应，而在 [`Last-Modified`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Last-Modified) 首部中会带有上次修改时间。**（注：虽然返回了304，但是会有last-modified的头部返回，因此浏览器下次请求时，会使用的是此时服务器端返回过来的last-modified，而不是以前的。）**\n\n​\t\t`If-Modified-Since` 只可以用在 [`GET`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/GET) 或 [`HEAD`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/HEAD) 请求中。\n\n​\t\t当与 [`If-None-Match`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/If-None-Match) 一同出现时，它（**`If-Modified-Since`**）会被忽略掉，除非服务器不支持 `If-None-Match`。\n\n\n\n**If-Unmodified-Since：**\n\n​\t\t这个我没有了解。\n\n\n\n**使用上面这个的弊端：**\n\n​\t\t对于没有进行修改，但是有过保存导致 Last-Modified 被修改，无法命中。\n\n​\t\t这个只能以秒计时，所以对于秒以内的修改文件，不能返回。\n\n\n\n### If-None-Match 和 ETag\n\n**ETag**：\n\n​\t这个是服务器端的返回的响应头。\n\n**If-None-Match**：\n\n​\t这个是客户端的请求的请求头。\n\n\n\n#### **ETag**：\n\n```\nhttps://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/ETag\n```\n\n简单来说就是一个唯一标识资源的一个特殊符号，\n\n通常计算方式是：\n\n​\t**使用内容的散列，最后修改时间戳的哈希值，或简单地使用版本号**\n\n```\nhttps://juejin.cn/post/6844903737538920462\n这里有将比较详细的计算方式，我这里就不做过多的说明。\n```\n\n\n\n```\nETag: \"33a64df551425fcc55e4d42a148795d9f25f89d4\"\n```\n\n```\n作用：\n\t避免空中碰撞\n\t缓存未更改的资源，就是304.\n```\n\n\n\n##### 避免空中碰撞\n\nMDN上有说有这句话：\n\n​\t**而如果内容发生了变化，使用ETag有助于防止资源的同时更新相互覆盖（“空中碰撞”）**\n\n```\nhttps://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/ETag#避免“空中碰撞”\n```\n\n大概的意思就是说，\n\n​\t\t我在客户端进行编辑共享文档时`（共享文档就是说可以被多人查看和编辑的）`，最开始拿到的文档是最新的。\n\n​\t\t但是在编辑的过程中，可能别人也有编辑，但是比我上传的早，所以，在我准备上传一个共享文档时，服务器端的文档已经被别人修改过了，但是此时我的客户端的文档因为没有重新进行请求，所以还是没有被修改过的，\n\n​\t\t此时如果没有先进行一次判断 ETag 值的话，就会发生相互覆盖，这个就是空中碰撞。\n\n​\t\t避免就是会先进行 ETag 匹配检查是否为最新版，否则报 412 前提条件失败错误。\n\n`（此时这个 ETag 会放在 If-Match 的请求头中。）`\n\n\n\n**注：**\n\n​\t\t如果给定URL中的资源更改，则一定要生成新的 Etag 值。 因此 Etags 类似于指纹，也可能被某些服务器用于跟踪。 比较 etags 能快速确定此资源是否变化，但也可能被跟踪服务器永久存留。**（我能理解到 ETag 可能用于快速比较一个文件是否发生过修改，因为他是一个文根据文件的相关信息进行的一个算法生成的一个值，但是我不清楚什么是会被跟踪服务器存留）**\n\n\n\n##### 缓存未更改的资源\n\n​\t\t对于用户访问一个URL时，显示了资源过期且不可用，客户端就发送 ETag 的值 作为 If-None-Match 的请求头，如果资源没有更改，那么服务器将会返回不带响应体的 304 状态。\n\n\n\n#### **If-None-Match**：\n\n```\nhttps://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/If-None-Match\n```\n\n`If-None-Match` 和 `If-Match` 的区别\n\n```\nhttps://datatracker.ietf.org/doc/html/rfc7232#section-3.1\n```\n\nIf-None-Match\n\n​\t使用的是 弱比较算法。\n\n​\t常用于 GET 请求的，请求最新资源的方式\n\nIf-Match\n\n​\t使用的是 强比较算法。\n\n​\t常用于 POST  PUT，DELETE 状态改变方法，防止多个用户同时操作的意外覆盖。\n\n\n\n## 后端设置方式\n\n```\n参考文章\nhttps://juejin.cn/post/6844903737538920462#heading-11\n```\n\n```\nres.setHeader('Cache-Control', 'public, max-age=xxx');\n\n\nres.setHeader('Cache-Control', 'public, max-age=0');\nres.setHeader('Last-Modified', xxx);\nres.setHeader('ETag', xxx);\n```\n\n\n\n\n\n## 最后，重新来一遍浏览器缓存过程\n\n\n\n**第一次请求**\n\n浏览器进行请求，发现缓存没有这个文件\n\n向服务器进行请求，获得文件，并带上响应头：\n\n​\t属于强缓存的：Cache-Control，Expires\n\n​\t属于协商缓存的：ETag，Last-Modified\n\n浏览器接收到了文件，并将文件和这些响应头缓存下来，下次使用。\n\n\n\n**强缓存**\n\n浏览器进行请求，发现缓存存在这个文件\n\n浏览器缓存查看该次请求是否命中强缓存（就是没有超过文件缓存过期时间）\n\n命中强缓存，直接从本地读取，状态码：200\n\n\n\n**协商缓存**\n\n浏览器进行请求，发现缓存存在这个文件\n\n浏览器缓存查看该次请求是否命中强缓存，\n\n没有命中强缓存，将 ETag 和 Last-Modified 的值放入请求头，\n\n​\t为 If-None-Match 和 If-Modified-Since，发送给服务器\n\n服务器接收到请求后，查看是否命中协商缓存，\n\n发现命中协商缓存，服务器会返回状态码 304，没有响应体\n\n​\t并将响应头的 Last-Modified 和 ETag 的值设置为文件的值，返回\n\n客户端接收到服务器的 304 响应，并将 ETag 和 Last-Modified 存储下来。\n\n\n\n**简单来说：**\n\n​\t就是第一次的文件请求会正常的返回，第二次会先看看能不能命中强缓存，如果能直接读取本地的，如果不能则看看能不能命中协商缓存，如果命中，则还是读取本地的文件，如果都没有命中，那么就会使用新的文件。\n\n\n\n这里**对于一个文件如何在强缓存期间进行更新**也有说明：就是会对文件名进行hash计算，修改过的文件的hash值不一样，所以对于浏览器来说，这个文件名不一样，不是一个文件，需要重新请求。\n\n","slug":"其他/浏览器缓存策略","published":1,"updated":"2021-12-09T01:56:49.432Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckznhkk87004kikubgjv38i60","content":"<h1 id=\"浏览器缓存策略\"><a href=\"#浏览器缓存策略\" class=\"headerlink\" title=\"浏览器缓存策略\"></a>浏览器缓存策略</h1><p><strong>参考文章</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://juejin.cn/post/6844903757872889870</span><br><span class=\"line\">MDN</span><br><span class=\"line\">https://juejin.cn/post/6844903737538920462</span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>先说一下什么是缓存</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">缓存就是会将一些不会经常更改的图片文件等资源存储下来，下次访问的时候会优先读取本地的资源进行显示，这样既能减轻服务器的负载，也能加快页面的显示。</span><br><span class=\"line\">这时可能就可能会问，那如果资源有了改变怎么办，所以这时候就有了强缓存和协商缓存两种。</span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>浏览器缓存策略分为</strong></p>\n<p>​    <strong>强缓存</strong></p>\n<p>​        强缓存就是直接从本地进行读取，不需要向服务器端进行获取资源。因此很快。</p>\n<p>​        在命中强缓存的情况下，状态码为 200，但是size显示from disk cache或from memory cache</p>\n<p>​    <strong>协商缓存</strong></p>\n<p>​        协商缓存就是会请求，但是会将一个文件的信息加入到请求头，然后服务器端进行判断，来决定是否要更新浏览器的资源。</p>\n<p>​        会将 <code>Last-Modified</code> 和 <code>Etag</code> 放入请求头，然后服务器就会进行比对，如果命中协商缓存，状态码为304。否则会将资源传输过来。</p>\n<h2 id=\"强缓存\"><a href=\"#强缓存\" class=\"headerlink\" title=\"强缓存\"></a>强缓存</h2><p>在进行请求的时候，不会向服务器发送请求，直接从缓存中读取资源，但是状态码是200</p>\n<p>如何进行强缓存，简单来说就是我们请求资源之后，服务器会返回一个请求头。浏览器后续就会根据这个请求头进行判断是否命中强缓存。</p>\n<h3 id=\"请求头\"><a href=\"#请求头\" class=\"headerlink\" title=\"请求头\"></a>请求头</h3><p>​        对于强缓存的请求头，有 <strong>Expires</strong> 和 <strong>Cache-Control</strong>，但是因为<strong>Cache-Control</strong> 是HTTP/1.1的产物，所以，优先级高于 Expires。</p>\n<h4 id=\"Expires\"><a href=\"#Expires\" class=\"headerlink\" title=\"Expires\"></a>Expires</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Expires</span><br></pre></td></tr></table></figure>\n\n<p>HTTP/1.0</p>\n<p>​    缓存过期时间，用来指定资源到期的时间。</p>\n<p>​        缺点，是通过本地时间进行的判断。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Expires: Wed, 21 Oct 2015 07:28:00 GMT</span><br></pre></td></tr></table></figure>\n\n<p><strong>注：</strong></p>\n<p>​    如果在<code>Cache-Contro</code>响应头设置了<code>max-age</code>或者<code>s-max-age</code>指令，那么<code>Expires</code>头会被忽悠。</p>\n<h4 id=\"Cache-Control\"><a href=\"#Cache-Control\" class=\"headerlink\" title=\"Cache-Control\"></a>Cache-Control</h4><p>HTTP/1.1</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cache-Control</span><br></pre></td></tr></table></figure>\n\n<p><strong>语法</strong>：</p>\n<ul>\n<li>不区分大小写，但建议使用小写。</li>\n<li>多个指令以逗号分隔。</li>\n<li>具有可选参数，可以用令牌或者带引号的字符串语法。</li>\n</ul>\n<p><strong>默认值：private</strong></p>\n<p><strong>指令</strong>：</p>\n<p><strong>可缓存性指令：</strong></p>\n<p><strong>public：</strong></p>\n<p>​        表明响应可以被任何对象（包括：发送请求的客户端，代理服务器，等等）缓存，即使是通常不可缓存的内容。</p>\n<p>​        （例如：1.该响应没有<code>max-age</code>指令或<code>Expires</code>消息头；</p>\n<p>​                        2. 该响应对应的请求方法是 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/POST\">POST</a> 。）</p>\n<p><strong>private：</strong></p>\n<p>​        表明响应只能被单个用户缓存，不能作为共享缓存（即代理服务器不能缓存它）。私有缓存可以缓存响应内容。</p>\n<p>​        比如：对应用户的本地浏览器。</p>\n<p><strong>no-cache</strong>:</p>\n<p>​        在发布缓存副本之前，强制要求缓存把请求提交给原始服务器进行验证(协商缓存验证)。</p>\n<p><strong>no-store</strong>：</p>\n<p>​        缓存不应存储有关客户端请求或服务器响应的任何内容，即不使用任何缓存。</p>\n<p><strong>到期：</strong></p>\n<p><strong>max-age</strong>：</p>\n<p>​        设置缓存存储的最大周期，超过这个时间缓存被认为过期(单位秒)。与<code>Expires</code>相反，时间是相对于请求的时间。</p>\n<p><strong>s-maxage</strong>：</p>\n<p>​        覆盖<code>max-age</code>或者<code>Expires</code>头，但是仅适用于共享缓存(比如各个代理)，私有缓存会忽略它。</p>\n<p><strong>max-stale</strong>：</p>\n<p>​        表明客户端愿意接收一个已经过期的资源。可以设置一个可选的秒数，表示响应不能已经过时超过该给定的时间。</p>\n<p><strong>min-fresh</strong>：</p>\n<p>​        表示客户端希望获取一个能在指定的秒数内保持其最新状态的响应。</p>\n<p><strong>重新验证与加载：</strong></p>\n<p><strong>must-revalidate</strong>：</p>\n<p>​        一旦资源过期（比如已经超过<code>max-age</code>），在成功向原始服务器验证之前，缓存不能用该资源响应后续请求。</p>\n<img src=\"/.io//image-20211023161739229.png\" alt=\"image-20211023161739229\" style=\"zoom:67%;\">\n\n<p>图片来源</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://juejin.cn/post/6844903757872889870</span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>需要进行重新验证，这个就是会进行协商缓存：</strong></p>\n<p>​        指定 <code>no-cache</code> 或 <code>max-age=0, must-revalidate</code> 表示客户端可以缓存资源，每次使用缓存资源前都必须重新验证其有效性。这意味着每次都会发起 HTTP 请求，但当缓存内容仍有效时可以跳过 HTTP 响应体的下载。</p>\n<p><strong>注意：</strong></p>\n<p>​    如果服务器关闭或失去连接，下面的指令可能会造成使用缓存。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Cache-Control: max-age=0</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"在强缓存时间内如何更新资源\"><a href=\"#在强缓存时间内如何更新资源\" class=\"headerlink\" title=\"在强缓存时间内如何更新资源\"></a>在强缓存时间内如何更新资源</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://juejin.cn/post/6844903737538920462#heading-5</span><br></pre></td></tr></table></figure>\n\n<p>虽然强缓存很好，但是有一个问题，如果在强缓存时间内，我的文件资源发生了更新，那该怎么解决呢？<code>（这个是我面试的时候问到的，一下把我人问傻了。）</code></p>\n<p>这里我后面去了解了：</p>\n<p>​    简单来说就是对于资源文件需要在发生了改变之后，可以让客户端再请求一次，方法就是将文件的名字在每次修改之后会发生改变，所以每次修改了之后，客户端要请求的文件名发生了改变，就会重新再进行一次请求了。这里对于文件名的方式使用<code>hash</code>。</p>\n<p>​    HTML：使用协商缓存，因为里面会存储资源文件的路径，在每次更新之后里面的路径需要修改，所以使用协商缓存更合理。</p>\n<p>​    对于　CSS／JS／图片：使用强缓存，对于一个文件名带上一个 hash 值。在每次文件进行了修改之后，名字后面的hash就会发生改变。所以客户端就会重新请求。</p>\n<h2 id=\"协商缓存\"><a href=\"#协商缓存\" class=\"headerlink\" title=\"协商缓存\"></a>协商缓存</h2><p>​        会在请求头加上：<code>If-None-Match</code>和<code>If-Modified-Since</code></p>\n<p>​        分别对应了服务器响应头的：<code>ETag</code> 和  <code>Last-Modified</code></p>\n<p>ETag 优先级高于 Last-Modified</p>\n<h3 id=\"If-Modified-Since-与-Last-Modified：\"><a href=\"#If-Modified-Since-与-Last-Modified：\" class=\"headerlink\" title=\"If-Modified-Since 与  Last-Modified：\"></a><strong>If-Modified-Since</strong> 与  <strong>Last-Modified</strong>：</h3><p><strong>Last-Modified</strong>：</p>\n<p>​    这个是服务器端的返回的响应头。</p>\n<p><strong>If-Modified-Since</strong>：</p>\n<p>​    这个是客户端的请求的请求头。</p>\n<h4 id=\"Last-Modified：\"><a href=\"#Last-Modified：\" class=\"headerlink\" title=\"Last-Modified：\"></a><strong>Last-Modified</strong>：</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Last-Modified</span><br></pre></td></tr></table></figure>\n\n<p>​        这个是根据上一次请求资源时，服务器所返回的<strong>Last-Modified</strong>，这个作为一个响应的头部。其中包含源头服务器认定的资源做出修改的日期及时间</p>\n<p>​        包含有  <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/If-Modified-Since\"><code>If-Modified-Since</code></a> 或 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/If-Unmodified-Since\"><code>If-Unmodified-Since</code></a> 首部的条件请求会使用这个字段。 </p>\n<h4 id=\"If-Modified-Since：\"><a href=\"#If-Modified-Since：\" class=\"headerlink\" title=\"If-Modified-Since：\"></a><strong>If-Modified-Since</strong>：</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/If-Modified-Since</span><br></pre></td></tr></table></figure>\n\n<p>​        服务器只在所请求的资源在给定的日期时间之后对内容进行过修改的情况下才会将资源返回，状态码为 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/200\"><code>200</code></a> 。</p>\n<p>​        如果请求的资源从那时起未经修改，那么返回一个不带有消息主体的 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/304\"><code>304</code></a> 响应，而在 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Last-Modified\"><code>Last-Modified</code></a> 首部中会带有上次修改时间。<strong>（注：虽然返回了304，但是会有last-modified的头部返回，因此浏览器下次请求时，会使用的是此时服务器端返回过来的last-modified，而不是以前的。）</strong></p>\n<p>​        <code>If-Modified-Since</code> 只可以用在 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/GET\"><code>GET</code></a> 或 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/HEAD\"><code>HEAD</code></a> 请求中。</p>\n<p>​        当与 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/If-None-Match\"><code>If-None-Match</code></a> 一同出现时，它（**<code>If-Modified-Since</code>**）会被忽略掉，除非服务器不支持 <code>If-None-Match</code>。</p>\n<p><strong>If-Unmodified-Since：</strong></p>\n<p>​        这个我没有了解。</p>\n<p><strong>使用上面这个的弊端：</strong></p>\n<p>​        对于没有进行修改，但是有过保存导致 Last-Modified 被修改，无法命中。</p>\n<p>​        这个只能以秒计时，所以对于秒以内的修改文件，不能返回。</p>\n<h3 id=\"If-None-Match-和-ETag\"><a href=\"#If-None-Match-和-ETag\" class=\"headerlink\" title=\"If-None-Match 和 ETag\"></a>If-None-Match 和 ETag</h3><p><strong>ETag</strong>：</p>\n<p>​    这个是服务器端的返回的响应头。</p>\n<p><strong>If-None-Match</strong>：</p>\n<p>​    这个是客户端的请求的请求头。</p>\n<h4 id=\"ETag：\"><a href=\"#ETag：\" class=\"headerlink\" title=\"ETag：\"></a><strong>ETag</strong>：</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/ETag</span><br></pre></td></tr></table></figure>\n\n<p>简单来说就是一个唯一标识资源的一个特殊符号，</p>\n<p>通常计算方式是：</p>\n<p>​    <strong>使用内容的散列，最后修改时间戳的哈希值，或简单地使用版本号</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://juejin.cn/post/6844903737538920462</span><br><span class=\"line\">这里有将比较详细的计算方式，我这里就不做过多的说明。</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ETag: &quot;33a64df551425fcc55e4d42a148795d9f25f89d4&quot;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">作用：</span><br><span class=\"line\">\t避免空中碰撞</span><br><span class=\"line\">\t缓存未更改的资源，就是304.</span><br></pre></td></tr></table></figure>\n\n\n\n<h5 id=\"避免空中碰撞\"><a href=\"#避免空中碰撞\" class=\"headerlink\" title=\"避免空中碰撞\"></a>避免空中碰撞</h5><p>MDN上有说有这句话：</p>\n<p>​    <strong>而如果内容发生了变化，使用ETag有助于防止资源的同时更新相互覆盖（“空中碰撞”）</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/ETag#避免“空中碰撞”</span><br></pre></td></tr></table></figure>\n\n<p>大概的意思就是说，</p>\n<p>​        我在客户端进行编辑共享文档时<code>（共享文档就是说可以被多人查看和编辑的）</code>，最开始拿到的文档是最新的。</p>\n<p>​        但是在编辑的过程中，可能别人也有编辑，但是比我上传的早，所以，在我准备上传一个共享文档时，服务器端的文档已经被别人修改过了，但是此时我的客户端的文档因为没有重新进行请求，所以还是没有被修改过的，</p>\n<p>​        此时如果没有先进行一次判断 ETag 值的话，就会发生相互覆盖，这个就是空中碰撞。</p>\n<p>​        避免就是会先进行 ETag 匹配检查是否为最新版，否则报 412 前提条件失败错误。</p>\n<p><code>（此时这个 ETag 会放在 If-Match 的请求头中。）</code></p>\n<p><strong>注：</strong></p>\n<p>​        如果给定URL中的资源更改，则一定要生成新的 Etag 值。 因此 Etags 类似于指纹，也可能被某些服务器用于跟踪。 比较 etags 能快速确定此资源是否变化，但也可能被跟踪服务器永久存留。<strong>（我能理解到 ETag 可能用于快速比较一个文件是否发生过修改，因为他是一个文根据文件的相关信息进行的一个算法生成的一个值，但是我不清楚什么是会被跟踪服务器存留）</strong></p>\n<h5 id=\"缓存未更改的资源\"><a href=\"#缓存未更改的资源\" class=\"headerlink\" title=\"缓存未更改的资源\"></a>缓存未更改的资源</h5><p>​        对于用户访问一个URL时，显示了资源过期且不可用，客户端就发送 ETag 的值 作为 If-None-Match 的请求头，如果资源没有更改，那么服务器将会返回不带响应体的 304 状态。</p>\n<h4 id=\"If-None-Match：\"><a href=\"#If-None-Match：\" class=\"headerlink\" title=\"If-None-Match：\"></a><strong>If-None-Match</strong>：</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/If-None-Match</span><br></pre></td></tr></table></figure>\n\n<p><code>If-None-Match</code> 和 <code>If-Match</code> 的区别</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://datatracker.ietf.org/doc/html/rfc7232#section-3.1</span><br></pre></td></tr></table></figure>\n\n<p>If-None-Match</p>\n<p>​    使用的是 弱比较算法。</p>\n<p>​    常用于 GET 请求的，请求最新资源的方式</p>\n<p>If-Match</p>\n<p>​    使用的是 强比较算法。</p>\n<p>​    常用于 POST  PUT，DELETE 状态改变方法，防止多个用户同时操作的意外覆盖。</p>\n<h2 id=\"后端设置方式\"><a href=\"#后端设置方式\" class=\"headerlink\" title=\"后端设置方式\"></a>后端设置方式</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">参考文章</span><br><span class=\"line\">https://juejin.cn/post/6844903737538920462#heading-11</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">res.setHeader(&#x27;Cache-Control&#x27;, &#x27;public, max-age=xxx&#x27;);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">res.setHeader(&#x27;Cache-Control&#x27;, &#x27;public, max-age=0&#x27;);</span><br><span class=\"line\">res.setHeader(&#x27;Last-Modified&#x27;, xxx);</span><br><span class=\"line\">res.setHeader(&#x27;ETag&#x27;, xxx);</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h2 id=\"最后，重新来一遍浏览器缓存过程\"><a href=\"#最后，重新来一遍浏览器缓存过程\" class=\"headerlink\" title=\"最后，重新来一遍浏览器缓存过程\"></a>最后，重新来一遍浏览器缓存过程</h2><p><strong>第一次请求</strong></p>\n<p>浏览器进行请求，发现缓存没有这个文件</p>\n<p>向服务器进行请求，获得文件，并带上响应头：</p>\n<p>​    属于强缓存的：Cache-Control，Expires</p>\n<p>​    属于协商缓存的：ETag，Last-Modified</p>\n<p>浏览器接收到了文件，并将文件和这些响应头缓存下来，下次使用。</p>\n<p><strong>强缓存</strong></p>\n<p>浏览器进行请求，发现缓存存在这个文件</p>\n<p>浏览器缓存查看该次请求是否命中强缓存（就是没有超过文件缓存过期时间）</p>\n<p>命中强缓存，直接从本地读取，状态码：200</p>\n<p><strong>协商缓存</strong></p>\n<p>浏览器进行请求，发现缓存存在这个文件</p>\n<p>浏览器缓存查看该次请求是否命中强缓存，</p>\n<p>没有命中强缓存，将 ETag 和 Last-Modified 的值放入请求头，</p>\n<p>​    为 If-None-Match 和 If-Modified-Since，发送给服务器</p>\n<p>服务器接收到请求后，查看是否命中协商缓存，</p>\n<p>发现命中协商缓存，服务器会返回状态码 304，没有响应体</p>\n<p>​    并将响应头的 Last-Modified 和 ETag 的值设置为文件的值，返回</p>\n<p>客户端接收到服务器的 304 响应，并将 ETag 和 Last-Modified 存储下来。</p>\n<p><strong>简单来说：</strong></p>\n<p>​    就是第一次的文件请求会正常的返回，第二次会先看看能不能命中强缓存，如果能直接读取本地的，如果不能则看看能不能命中协商缓存，如果命中，则还是读取本地的文件，如果都没有命中，那么就会使用新的文件。</p>\n<p>这里<strong>对于一个文件如何在强缓存期间进行更新</strong>也有说明：就是会对文件名进行hash计算，修改过的文件的hash值不一样，所以对于浏览器来说，这个文件名不一样，不是一个文件，需要重新请求。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"浏览器缓存策略\"><a href=\"#浏览器缓存策略\" class=\"headerlink\" title=\"浏览器缓存策略\"></a>浏览器缓存策略</h1><p><strong>参考文章</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://juejin.cn/post/6844903757872889870</span><br><span class=\"line\">MDN</span><br><span class=\"line\">https://juejin.cn/post/6844903737538920462</span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>先说一下什么是缓存</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">缓存就是会将一些不会经常更改的图片文件等资源存储下来，下次访问的时候会优先读取本地的资源进行显示，这样既能减轻服务器的负载，也能加快页面的显示。</span><br><span class=\"line\">这时可能就可能会问，那如果资源有了改变怎么办，所以这时候就有了强缓存和协商缓存两种。</span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>浏览器缓存策略分为</strong></p>\n<p>​    <strong>强缓存</strong></p>\n<p>​        强缓存就是直接从本地进行读取，不需要向服务器端进行获取资源。因此很快。</p>\n<p>​        在命中强缓存的情况下，状态码为 200，但是size显示from disk cache或from memory cache</p>\n<p>​    <strong>协商缓存</strong></p>\n<p>​        协商缓存就是会请求，但是会将一个文件的信息加入到请求头，然后服务器端进行判断，来决定是否要更新浏览器的资源。</p>\n<p>​        会将 <code>Last-Modified</code> 和 <code>Etag</code> 放入请求头，然后服务器就会进行比对，如果命中协商缓存，状态码为304。否则会将资源传输过来。</p>\n<h2 id=\"强缓存\"><a href=\"#强缓存\" class=\"headerlink\" title=\"强缓存\"></a>强缓存</h2><p>在进行请求的时候，不会向服务器发送请求，直接从缓存中读取资源，但是状态码是200</p>\n<p>如何进行强缓存，简单来说就是我们请求资源之后，服务器会返回一个请求头。浏览器后续就会根据这个请求头进行判断是否命中强缓存。</p>\n<h3 id=\"请求头\"><a href=\"#请求头\" class=\"headerlink\" title=\"请求头\"></a>请求头</h3><p>​        对于强缓存的请求头，有 <strong>Expires</strong> 和 <strong>Cache-Control</strong>，但是因为<strong>Cache-Control</strong> 是HTTP/1.1的产物，所以，优先级高于 Expires。</p>\n<h4 id=\"Expires\"><a href=\"#Expires\" class=\"headerlink\" title=\"Expires\"></a>Expires</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Expires</span><br></pre></td></tr></table></figure>\n\n<p>HTTP/1.0</p>\n<p>​    缓存过期时间，用来指定资源到期的时间。</p>\n<p>​        缺点，是通过本地时间进行的判断。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Expires: Wed, 21 Oct 2015 07:28:00 GMT</span><br></pre></td></tr></table></figure>\n\n<p><strong>注：</strong></p>\n<p>​    如果在<code>Cache-Contro</code>响应头设置了<code>max-age</code>或者<code>s-max-age</code>指令，那么<code>Expires</code>头会被忽悠。</p>\n<h4 id=\"Cache-Control\"><a href=\"#Cache-Control\" class=\"headerlink\" title=\"Cache-Control\"></a>Cache-Control</h4><p>HTTP/1.1</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cache-Control</span><br></pre></td></tr></table></figure>\n\n<p><strong>语法</strong>：</p>\n<ul>\n<li>不区分大小写，但建议使用小写。</li>\n<li>多个指令以逗号分隔。</li>\n<li>具有可选参数，可以用令牌或者带引号的字符串语法。</li>\n</ul>\n<p><strong>默认值：private</strong></p>\n<p><strong>指令</strong>：</p>\n<p><strong>可缓存性指令：</strong></p>\n<p><strong>public：</strong></p>\n<p>​        表明响应可以被任何对象（包括：发送请求的客户端，代理服务器，等等）缓存，即使是通常不可缓存的内容。</p>\n<p>​        （例如：1.该响应没有<code>max-age</code>指令或<code>Expires</code>消息头；</p>\n<p>​                        2. 该响应对应的请求方法是 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/POST\">POST</a> 。）</p>\n<p><strong>private：</strong></p>\n<p>​        表明响应只能被单个用户缓存，不能作为共享缓存（即代理服务器不能缓存它）。私有缓存可以缓存响应内容。</p>\n<p>​        比如：对应用户的本地浏览器。</p>\n<p><strong>no-cache</strong>:</p>\n<p>​        在发布缓存副本之前，强制要求缓存把请求提交给原始服务器进行验证(协商缓存验证)。</p>\n<p><strong>no-store</strong>：</p>\n<p>​        缓存不应存储有关客户端请求或服务器响应的任何内容，即不使用任何缓存。</p>\n<p><strong>到期：</strong></p>\n<p><strong>max-age</strong>：</p>\n<p>​        设置缓存存储的最大周期，超过这个时间缓存被认为过期(单位秒)。与<code>Expires</code>相反，时间是相对于请求的时间。</p>\n<p><strong>s-maxage</strong>：</p>\n<p>​        覆盖<code>max-age</code>或者<code>Expires</code>头，但是仅适用于共享缓存(比如各个代理)，私有缓存会忽略它。</p>\n<p><strong>max-stale</strong>：</p>\n<p>​        表明客户端愿意接收一个已经过期的资源。可以设置一个可选的秒数，表示响应不能已经过时超过该给定的时间。</p>\n<p><strong>min-fresh</strong>：</p>\n<p>​        表示客户端希望获取一个能在指定的秒数内保持其最新状态的响应。</p>\n<p><strong>重新验证与加载：</strong></p>\n<p><strong>must-revalidate</strong>：</p>\n<p>​        一旦资源过期（比如已经超过<code>max-age</code>），在成功向原始服务器验证之前，缓存不能用该资源响应后续请求。</p>\n<img src=\"/.io//image-20211023161739229.png\" alt=\"image-20211023161739229\" style=\"zoom:67%;\">\n\n<p>图片来源</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://juejin.cn/post/6844903757872889870</span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>需要进行重新验证，这个就是会进行协商缓存：</strong></p>\n<p>​        指定 <code>no-cache</code> 或 <code>max-age=0, must-revalidate</code> 表示客户端可以缓存资源，每次使用缓存资源前都必须重新验证其有效性。这意味着每次都会发起 HTTP 请求，但当缓存内容仍有效时可以跳过 HTTP 响应体的下载。</p>\n<p><strong>注意：</strong></p>\n<p>​    如果服务器关闭或失去连接，下面的指令可能会造成使用缓存。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Cache-Control: max-age=0</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"在强缓存时间内如何更新资源\"><a href=\"#在强缓存时间内如何更新资源\" class=\"headerlink\" title=\"在强缓存时间内如何更新资源\"></a>在强缓存时间内如何更新资源</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://juejin.cn/post/6844903737538920462#heading-5</span><br></pre></td></tr></table></figure>\n\n<p>虽然强缓存很好，但是有一个问题，如果在强缓存时间内，我的文件资源发生了更新，那该怎么解决呢？<code>（这个是我面试的时候问到的，一下把我人问傻了。）</code></p>\n<p>这里我后面去了解了：</p>\n<p>​    简单来说就是对于资源文件需要在发生了改变之后，可以让客户端再请求一次，方法就是将文件的名字在每次修改之后会发生改变，所以每次修改了之后，客户端要请求的文件名发生了改变，就会重新再进行一次请求了。这里对于文件名的方式使用<code>hash</code>。</p>\n<p>​    HTML：使用协商缓存，因为里面会存储资源文件的路径，在每次更新之后里面的路径需要修改，所以使用协商缓存更合理。</p>\n<p>​    对于　CSS／JS／图片：使用强缓存，对于一个文件名带上一个 hash 值。在每次文件进行了修改之后，名字后面的hash就会发生改变。所以客户端就会重新请求。</p>\n<h2 id=\"协商缓存\"><a href=\"#协商缓存\" class=\"headerlink\" title=\"协商缓存\"></a>协商缓存</h2><p>​        会在请求头加上：<code>If-None-Match</code>和<code>If-Modified-Since</code></p>\n<p>​        分别对应了服务器响应头的：<code>ETag</code> 和  <code>Last-Modified</code></p>\n<p>ETag 优先级高于 Last-Modified</p>\n<h3 id=\"If-Modified-Since-与-Last-Modified：\"><a href=\"#If-Modified-Since-与-Last-Modified：\" class=\"headerlink\" title=\"If-Modified-Since 与  Last-Modified：\"></a><strong>If-Modified-Since</strong> 与  <strong>Last-Modified</strong>：</h3><p><strong>Last-Modified</strong>：</p>\n<p>​    这个是服务器端的返回的响应头。</p>\n<p><strong>If-Modified-Since</strong>：</p>\n<p>​    这个是客户端的请求的请求头。</p>\n<h4 id=\"Last-Modified：\"><a href=\"#Last-Modified：\" class=\"headerlink\" title=\"Last-Modified：\"></a><strong>Last-Modified</strong>：</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Last-Modified</span><br></pre></td></tr></table></figure>\n\n<p>​        这个是根据上一次请求资源时，服务器所返回的<strong>Last-Modified</strong>，这个作为一个响应的头部。其中包含源头服务器认定的资源做出修改的日期及时间</p>\n<p>​        包含有  <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/If-Modified-Since\"><code>If-Modified-Since</code></a> 或 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/If-Unmodified-Since\"><code>If-Unmodified-Since</code></a> 首部的条件请求会使用这个字段。 </p>\n<h4 id=\"If-Modified-Since：\"><a href=\"#If-Modified-Since：\" class=\"headerlink\" title=\"If-Modified-Since：\"></a><strong>If-Modified-Since</strong>：</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/If-Modified-Since</span><br></pre></td></tr></table></figure>\n\n<p>​        服务器只在所请求的资源在给定的日期时间之后对内容进行过修改的情况下才会将资源返回，状态码为 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/200\"><code>200</code></a> 。</p>\n<p>​        如果请求的资源从那时起未经修改，那么返回一个不带有消息主体的 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/304\"><code>304</code></a> 响应，而在 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Last-Modified\"><code>Last-Modified</code></a> 首部中会带有上次修改时间。<strong>（注：虽然返回了304，但是会有last-modified的头部返回，因此浏览器下次请求时，会使用的是此时服务器端返回过来的last-modified，而不是以前的。）</strong></p>\n<p>​        <code>If-Modified-Since</code> 只可以用在 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/GET\"><code>GET</code></a> 或 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/HEAD\"><code>HEAD</code></a> 请求中。</p>\n<p>​        当与 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/If-None-Match\"><code>If-None-Match</code></a> 一同出现时，它（**<code>If-Modified-Since</code>**）会被忽略掉，除非服务器不支持 <code>If-None-Match</code>。</p>\n<p><strong>If-Unmodified-Since：</strong></p>\n<p>​        这个我没有了解。</p>\n<p><strong>使用上面这个的弊端：</strong></p>\n<p>​        对于没有进行修改，但是有过保存导致 Last-Modified 被修改，无法命中。</p>\n<p>​        这个只能以秒计时，所以对于秒以内的修改文件，不能返回。</p>\n<h3 id=\"If-None-Match-和-ETag\"><a href=\"#If-None-Match-和-ETag\" class=\"headerlink\" title=\"If-None-Match 和 ETag\"></a>If-None-Match 和 ETag</h3><p><strong>ETag</strong>：</p>\n<p>​    这个是服务器端的返回的响应头。</p>\n<p><strong>If-None-Match</strong>：</p>\n<p>​    这个是客户端的请求的请求头。</p>\n<h4 id=\"ETag：\"><a href=\"#ETag：\" class=\"headerlink\" title=\"ETag：\"></a><strong>ETag</strong>：</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/ETag</span><br></pre></td></tr></table></figure>\n\n<p>简单来说就是一个唯一标识资源的一个特殊符号，</p>\n<p>通常计算方式是：</p>\n<p>​    <strong>使用内容的散列，最后修改时间戳的哈希值，或简单地使用版本号</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://juejin.cn/post/6844903737538920462</span><br><span class=\"line\">这里有将比较详细的计算方式，我这里就不做过多的说明。</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ETag: &quot;33a64df551425fcc55e4d42a148795d9f25f89d4&quot;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">作用：</span><br><span class=\"line\">\t避免空中碰撞</span><br><span class=\"line\">\t缓存未更改的资源，就是304.</span><br></pre></td></tr></table></figure>\n\n\n\n<h5 id=\"避免空中碰撞\"><a href=\"#避免空中碰撞\" class=\"headerlink\" title=\"避免空中碰撞\"></a>避免空中碰撞</h5><p>MDN上有说有这句话：</p>\n<p>​    <strong>而如果内容发生了变化，使用ETag有助于防止资源的同时更新相互覆盖（“空中碰撞”）</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/ETag#避免“空中碰撞”</span><br></pre></td></tr></table></figure>\n\n<p>大概的意思就是说，</p>\n<p>​        我在客户端进行编辑共享文档时<code>（共享文档就是说可以被多人查看和编辑的）</code>，最开始拿到的文档是最新的。</p>\n<p>​        但是在编辑的过程中，可能别人也有编辑，但是比我上传的早，所以，在我准备上传一个共享文档时，服务器端的文档已经被别人修改过了，但是此时我的客户端的文档因为没有重新进行请求，所以还是没有被修改过的，</p>\n<p>​        此时如果没有先进行一次判断 ETag 值的话，就会发生相互覆盖，这个就是空中碰撞。</p>\n<p>​        避免就是会先进行 ETag 匹配检查是否为最新版，否则报 412 前提条件失败错误。</p>\n<p><code>（此时这个 ETag 会放在 If-Match 的请求头中。）</code></p>\n<p><strong>注：</strong></p>\n<p>​        如果给定URL中的资源更改，则一定要生成新的 Etag 值。 因此 Etags 类似于指纹，也可能被某些服务器用于跟踪。 比较 etags 能快速确定此资源是否变化，但也可能被跟踪服务器永久存留。<strong>（我能理解到 ETag 可能用于快速比较一个文件是否发生过修改，因为他是一个文根据文件的相关信息进行的一个算法生成的一个值，但是我不清楚什么是会被跟踪服务器存留）</strong></p>\n<h5 id=\"缓存未更改的资源\"><a href=\"#缓存未更改的资源\" class=\"headerlink\" title=\"缓存未更改的资源\"></a>缓存未更改的资源</h5><p>​        对于用户访问一个URL时，显示了资源过期且不可用，客户端就发送 ETag 的值 作为 If-None-Match 的请求头，如果资源没有更改，那么服务器将会返回不带响应体的 304 状态。</p>\n<h4 id=\"If-None-Match：\"><a href=\"#If-None-Match：\" class=\"headerlink\" title=\"If-None-Match：\"></a><strong>If-None-Match</strong>：</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/If-None-Match</span><br></pre></td></tr></table></figure>\n\n<p><code>If-None-Match</code> 和 <code>If-Match</code> 的区别</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://datatracker.ietf.org/doc/html/rfc7232#section-3.1</span><br></pre></td></tr></table></figure>\n\n<p>If-None-Match</p>\n<p>​    使用的是 弱比较算法。</p>\n<p>​    常用于 GET 请求的，请求最新资源的方式</p>\n<p>If-Match</p>\n<p>​    使用的是 强比较算法。</p>\n<p>​    常用于 POST  PUT，DELETE 状态改变方法，防止多个用户同时操作的意外覆盖。</p>\n<h2 id=\"后端设置方式\"><a href=\"#后端设置方式\" class=\"headerlink\" title=\"后端设置方式\"></a>后端设置方式</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">参考文章</span><br><span class=\"line\">https://juejin.cn/post/6844903737538920462#heading-11</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">res.setHeader(&#x27;Cache-Control&#x27;, &#x27;public, max-age=xxx&#x27;);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">res.setHeader(&#x27;Cache-Control&#x27;, &#x27;public, max-age=0&#x27;);</span><br><span class=\"line\">res.setHeader(&#x27;Last-Modified&#x27;, xxx);</span><br><span class=\"line\">res.setHeader(&#x27;ETag&#x27;, xxx);</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h2 id=\"最后，重新来一遍浏览器缓存过程\"><a href=\"#最后，重新来一遍浏览器缓存过程\" class=\"headerlink\" title=\"最后，重新来一遍浏览器缓存过程\"></a>最后，重新来一遍浏览器缓存过程</h2><p><strong>第一次请求</strong></p>\n<p>浏览器进行请求，发现缓存没有这个文件</p>\n<p>向服务器进行请求，获得文件，并带上响应头：</p>\n<p>​    属于强缓存的：Cache-Control，Expires</p>\n<p>​    属于协商缓存的：ETag，Last-Modified</p>\n<p>浏览器接收到了文件，并将文件和这些响应头缓存下来，下次使用。</p>\n<p><strong>强缓存</strong></p>\n<p>浏览器进行请求，发现缓存存在这个文件</p>\n<p>浏览器缓存查看该次请求是否命中强缓存（就是没有超过文件缓存过期时间）</p>\n<p>命中强缓存，直接从本地读取，状态码：200</p>\n<p><strong>协商缓存</strong></p>\n<p>浏览器进行请求，发现缓存存在这个文件</p>\n<p>浏览器缓存查看该次请求是否命中强缓存，</p>\n<p>没有命中强缓存，将 ETag 和 Last-Modified 的值放入请求头，</p>\n<p>​    为 If-None-Match 和 If-Modified-Since，发送给服务器</p>\n<p>服务器接收到请求后，查看是否命中协商缓存，</p>\n<p>发现命中协商缓存，服务器会返回状态码 304，没有响应体</p>\n<p>​    并将响应头的 Last-Modified 和 ETag 的值设置为文件的值，返回</p>\n<p>客户端接收到服务器的 304 响应，并将 ETag 和 Last-Modified 存储下来。</p>\n<p><strong>简单来说：</strong></p>\n<p>​    就是第一次的文件请求会正常的返回，第二次会先看看能不能命中强缓存，如果能直接读取本地的，如果不能则看看能不能命中协商缓存，如果命中，则还是读取本地的文件，如果都没有命中，那么就会使用新的文件。</p>\n<p>这里<strong>对于一个文件如何在强缓存期间进行更新</strong>也有说明：就是会对文件名进行hash计算，修改过的文件的hash值不一样，所以对于浏览器来说，这个文件名不一样，不是一个文件，需要重新请求。</p>\n"},{"title":"RESTful","date":"2021-11-06T07:24:20.000Z","_content":"\n\n\n#  RESTful架构\n\nREST：**Representational State Transfer** 的简写\n\n就是表现层状态转化\n\n\n\n简单理解：\n\n* url 表示的是一个资源，就是一个实体，一个具体的信息\n* 而操作作为一个HTTP请求路径和方法来进行一个体现。\n* 常用的方法操作：\n  * GET：获取资源\n  * POST：新建或更新资源\n  * PUT：更新资源\n  * DELETE：删除资源\n* 客户端通过HTTP的方法和路径，实现对服务器端资源进行操作。","source":"_posts/随笔/RESTful.md","raw":"---\ntitle: RESTful\ndate: 2021-11-06 15:24:20\ntags:\n - RESTful架构\n - 随笔\ncategories:\n - 随笔\n---\n\n\n\n#  RESTful架构\n\nREST：**Representational State Transfer** 的简写\n\n就是表现层状态转化\n\n\n\n简单理解：\n\n* url 表示的是一个资源，就是一个实体，一个具体的信息\n* 而操作作为一个HTTP请求路径和方法来进行一个体现。\n* 常用的方法操作：\n  * GET：获取资源\n  * POST：新建或更新资源\n  * PUT：更新资源\n  * DELETE：删除资源\n* 客户端通过HTTP的方法和路径，实现对服务器端资源进行操作。","slug":"随笔/RESTful","published":1,"updated":"2021-12-09T01:56:49.432Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckznhkk87004oikubc2yw8bub","content":"<h1 id=\"RESTful架构\"><a href=\"#RESTful架构\" class=\"headerlink\" title=\"RESTful架构\"></a>RESTful架构</h1><p>REST：<strong>Representational State Transfer</strong> 的简写</p>\n<p>就是表现层状态转化</p>\n<p>简单理解：</p>\n<ul>\n<li>url 表示的是一个资源，就是一个实体，一个具体的信息</li>\n<li>而操作作为一个HTTP请求路径和方法来进行一个体现。</li>\n<li>常用的方法操作：<ul>\n<li>GET：获取资源</li>\n<li>POST：新建或更新资源</li>\n<li>PUT：更新资源</li>\n<li>DELETE：删除资源</li>\n</ul>\n</li>\n<li>客户端通过HTTP的方法和路径，实现对服务器端资源进行操作。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"RESTful架构\"><a href=\"#RESTful架构\" class=\"headerlink\" title=\"RESTful架构\"></a>RESTful架构</h1><p>REST：<strong>Representational State Transfer</strong> 的简写</p>\n<p>就是表现层状态转化</p>\n<p>简单理解：</p>\n<ul>\n<li>url 表示的是一个资源，就是一个实体，一个具体的信息</li>\n<li>而操作作为一个HTTP请求路径和方法来进行一个体现。</li>\n<li>常用的方法操作：<ul>\n<li>GET：获取资源</li>\n<li>POST：新建或更新资源</li>\n<li>PUT：更新资源</li>\n<li>DELETE：删除资源</li>\n</ul>\n</li>\n<li>客户端通过HTTP的方法和路径，实现对服务器端资源进行操作。</li>\n</ul>\n"},{"title":"Git常用命令","date":"2021-10-19T06:10:15.000Z","_content":"\n\n\n#  Git常用命令\n\n\n\n新建一个git仓库\n\n```\ngit init\n```\n\n\n\n将内容进行本地提交\n\n```\ngit add .\n```\n\n\n\n设置提交到GitHub的url\n\n```\ngit remote add origin https://xxx\n```\n\n\n\n提交\n\n```\ngit push -u origin master\n```\n\n\n\n拉取\n\n```\ngit pull origin master\n```\n\n\n\n同时将一个项目提交到两个仓库\n\n```\n需要再添加一个新的仓库\ngit remote set-url --add origin https://xx\n```\n\n也可以在配置文件里面进行修改\n\n.git/config\n\n```\n在文件里面的[remote \"origin\"]\n下面添加一个url：设置为自己的另一个仓库的url地址就可以在提交的时候将仓库提交到远程了\n```\n\n","source":"_posts/随笔/Git常用命令.md","raw":"---\ntitle: Git常用命令\ndate: 2021-10-19 14:10:15\ntags:\n - Git\n - 随笔\ncategories:\n - 随笔\n---\n\n\n\n#  Git常用命令\n\n\n\n新建一个git仓库\n\n```\ngit init\n```\n\n\n\n将内容进行本地提交\n\n```\ngit add .\n```\n\n\n\n设置提交到GitHub的url\n\n```\ngit remote add origin https://xxx\n```\n\n\n\n提交\n\n```\ngit push -u origin master\n```\n\n\n\n拉取\n\n```\ngit pull origin master\n```\n\n\n\n同时将一个项目提交到两个仓库\n\n```\n需要再添加一个新的仓库\ngit remote set-url --add origin https://xx\n```\n\n也可以在配置文件里面进行修改\n\n.git/config\n\n```\n在文件里面的[remote \"origin\"]\n下面添加一个url：设置为自己的另一个仓库的url地址就可以在提交的时候将仓库提交到远程了\n```\n\n","slug":"随笔/Git常用命令","published":1,"updated":"2021-12-09T01:56:49.432Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckznhkk88004sikubgd7tbekk","content":"<h1 id=\"Git常用命令\"><a href=\"#Git常用命令\" class=\"headerlink\" title=\"Git常用命令\"></a>Git常用命令</h1><p>新建一个git仓库</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git init</span><br></pre></td></tr></table></figure>\n\n\n\n<p>将内容进行本地提交</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git add .</span><br></pre></td></tr></table></figure>\n\n\n\n<p>设置提交到GitHub的url</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git remote add origin https://xxx</span><br></pre></td></tr></table></figure>\n\n\n\n<p>提交</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git push -u origin master</span><br></pre></td></tr></table></figure>\n\n\n\n<p>拉取</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git pull origin master</span><br></pre></td></tr></table></figure>\n\n\n\n<p>同时将一个项目提交到两个仓库</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">需要再添加一个新的仓库</span><br><span class=\"line\">git remote set-url --add origin https://xx</span><br></pre></td></tr></table></figure>\n\n<p>也可以在配置文件里面进行修改</p>\n<p>.git/config</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">在文件里面的[remote &quot;origin&quot;]</span><br><span class=\"line\">下面添加一个url：设置为自己的另一个仓库的url地址就可以在提交的时候将仓库提交到远程了</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Git常用命令\"><a href=\"#Git常用命令\" class=\"headerlink\" title=\"Git常用命令\"></a>Git常用命令</h1><p>新建一个git仓库</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git init</span><br></pre></td></tr></table></figure>\n\n\n\n<p>将内容进行本地提交</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git add .</span><br></pre></td></tr></table></figure>\n\n\n\n<p>设置提交到GitHub的url</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git remote add origin https://xxx</span><br></pre></td></tr></table></figure>\n\n\n\n<p>提交</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git push -u origin master</span><br></pre></td></tr></table></figure>\n\n\n\n<p>拉取</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git pull origin master</span><br></pre></td></tr></table></figure>\n\n\n\n<p>同时将一个项目提交到两个仓库</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">需要再添加一个新的仓库</span><br><span class=\"line\">git remote set-url --add origin https://xx</span><br></pre></td></tr></table></figure>\n\n<p>也可以在配置文件里面进行修改</p>\n<p>.git/config</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">在文件里面的[remote &quot;origin&quot;]</span><br><span class=\"line\">下面添加一个url：设置为自己的另一个仓库的url地址就可以在提交的时候将仓库提交到远程了</span><br></pre></td></tr></table></figure>\n\n"},{"title":"next 基本使用","date":"2021-10-13T07:25:56.000Z","_content":"\n\n\n# next 基本使用\n\n基本可以看这个文档，我只是在使用的时候对于我出现的问题进行一个补充。\n\n```\nhttp://theme-next.iissnan.com/getting-started.html#install-next-theme\n```\n\n下面这个是比较新的情况，有一个组织进行了维护。使用也有说明\n\n```\nhttps://theme-next.js.org/docs/getting-started/\n```\n\n\n\n```\n如果\nhexo d 的命令不行，\n可以尝试在前面加上 npx\nnpx hexo d\n```\n\nnpx 主要作用就是让项目内部模块用起来更加方便，具体可以看\n\n```\nhttp://www.ruanyifeng.com/blog/2019/02/npx.html\n```\n\n\n\n## 启用主题\n\n这里可能会因为新的版本的原因网页不能显示，这里我去百度了。\n\n\n\n![image-20211018105920422](next/image-20211018110937363.png)\n\n原因是hexo在5.0之后把swig给删除了需要自己手动安装，所以只需要安装一下 这个就行了。\n\n```java\n npm i hexo-renderer-swig\n```\n\n\n\n对于v7.8，其他版本的我没有尝试，不知道这个问题，这里有个bug，如果在md文档里面设置了\n\n```\n<Object>\n就这样一个单标签，就会让你的头像那一块位置不正确或者找不到。我这个是v7.8的版本，开始用的v8.8的版本没有问题，这个原因应该是因为没有对md文档里面的内容的处理。\n```\n\n![image-20211018105920422](next/image-20211018105920422.png)\n\n![image-20211018110658046](next/image-20211018110658046.png)\n\n\n\n## 设置 菜单\n\n这里设置 的 菜单出现错误，这个应该是v5这个版本之前的bug，后面的应该都解决了\n\n因为 在那个 /about/||user，这个 `||`之前不能有空格，空格会被当作url，你也可以看到点击之后的url地址后面有个%20,这个就是空格。\n\n不过较新的版本解决了这个问题。具体是从哪个版本开始解决的不清楚。\n\n```\nmenu:\n  home: /|| home\n  about: /about/|| user\n  tags: /tags/|| tags\n  categories: /categories/|| th\n  archives: /archives/|| archive\n  schedule: /schedule/|| calendar\n  sitemap: /sitemap.xml|| sitemap\n  #commonweal: /404/|| heartbeat\n```\n\n\n\n## 设置头像\n\n相对地址和url都放在url后面\n\n```\navatar:\n  # Replace the default image and set the url here.\n  url: /uploads/avatar.jpg #/images/avatar.gif\n```\n\n\n\n## 黑暗模式\n\n我这里不对，没有效果。\n\n```\ndarkmode: true\n```\n\n\n\n# 后续主题配置\n\n```\nhttp://theme-next.iissnan.com/theme-settings.html#tags-page\n```\n\n\n\n## 字体设置，代码高亮\n\n```\nhttps://theme-next.js.org/highlight/\n```\n\n\n\n## 图标\n\n```\nsocial:\n  GitHub: https://github.com/tallgy || fab fa-github\n  Gitee: https://gitee.com/tallgy || fab fa-github-alt\n  #E-Mail: mailto:yourname@gmail.com || fa fa-envelope\n  #Weibo: https://weibo.com/yourname || fab fa-weibo\n```\n\n图标网址\n\n```\nhttps://fontawesome.dashgame.com/\n```\n\n```\n选中自己想要的图标，然后他后面有一个复制的按钮，直接复制，替换掉就行了。\n```\n\n\n\n# 三方服务集成\n\n```\nhttp://theme-next.iissnan.com/third-party-services.html\n```\n\n\n\n## 评论系统\n\n**DISQUS**，大部分都是需要翻墙的，所以我就没有搞。。。\n\n```\n\n```\n\n","source":"_posts/随笔/next.md","raw":"---\ntitle: next 基本使用\ndate: 2021-10-13 15:25:56\ntags: \n - 随笔\ncategories:\n - 随笔\n---\n\n\n\n# next 基本使用\n\n基本可以看这个文档，我只是在使用的时候对于我出现的问题进行一个补充。\n\n```\nhttp://theme-next.iissnan.com/getting-started.html#install-next-theme\n```\n\n下面这个是比较新的情况，有一个组织进行了维护。使用也有说明\n\n```\nhttps://theme-next.js.org/docs/getting-started/\n```\n\n\n\n```\n如果\nhexo d 的命令不行，\n可以尝试在前面加上 npx\nnpx hexo d\n```\n\nnpx 主要作用就是让项目内部模块用起来更加方便，具体可以看\n\n```\nhttp://www.ruanyifeng.com/blog/2019/02/npx.html\n```\n\n\n\n## 启用主题\n\n这里可能会因为新的版本的原因网页不能显示，这里我去百度了。\n\n\n\n![image-20211018105920422](next/image-20211018110937363.png)\n\n原因是hexo在5.0之后把swig给删除了需要自己手动安装，所以只需要安装一下 这个就行了。\n\n```java\n npm i hexo-renderer-swig\n```\n\n\n\n对于v7.8，其他版本的我没有尝试，不知道这个问题，这里有个bug，如果在md文档里面设置了\n\n```\n<Object>\n就这样一个单标签，就会让你的头像那一块位置不正确或者找不到。我这个是v7.8的版本，开始用的v8.8的版本没有问题，这个原因应该是因为没有对md文档里面的内容的处理。\n```\n\n![image-20211018105920422](next/image-20211018105920422.png)\n\n![image-20211018110658046](next/image-20211018110658046.png)\n\n\n\n## 设置 菜单\n\n这里设置 的 菜单出现错误，这个应该是v5这个版本之前的bug，后面的应该都解决了\n\n因为 在那个 /about/||user，这个 `||`之前不能有空格，空格会被当作url，你也可以看到点击之后的url地址后面有个%20,这个就是空格。\n\n不过较新的版本解决了这个问题。具体是从哪个版本开始解决的不清楚。\n\n```\nmenu:\n  home: /|| home\n  about: /about/|| user\n  tags: /tags/|| tags\n  categories: /categories/|| th\n  archives: /archives/|| archive\n  schedule: /schedule/|| calendar\n  sitemap: /sitemap.xml|| sitemap\n  #commonweal: /404/|| heartbeat\n```\n\n\n\n## 设置头像\n\n相对地址和url都放在url后面\n\n```\navatar:\n  # Replace the default image and set the url here.\n  url: /uploads/avatar.jpg #/images/avatar.gif\n```\n\n\n\n## 黑暗模式\n\n我这里不对，没有效果。\n\n```\ndarkmode: true\n```\n\n\n\n# 后续主题配置\n\n```\nhttp://theme-next.iissnan.com/theme-settings.html#tags-page\n```\n\n\n\n## 字体设置，代码高亮\n\n```\nhttps://theme-next.js.org/highlight/\n```\n\n\n\n## 图标\n\n```\nsocial:\n  GitHub: https://github.com/tallgy || fab fa-github\n  Gitee: https://gitee.com/tallgy || fab fa-github-alt\n  #E-Mail: mailto:yourname@gmail.com || fa fa-envelope\n  #Weibo: https://weibo.com/yourname || fab fa-weibo\n```\n\n图标网址\n\n```\nhttps://fontawesome.dashgame.com/\n```\n\n```\n选中自己想要的图标，然后他后面有一个复制的按钮，直接复制，替换掉就行了。\n```\n\n\n\n# 三方服务集成\n\n```\nhttp://theme-next.iissnan.com/third-party-services.html\n```\n\n\n\n## 评论系统\n\n**DISQUS**，大部分都是需要翻墙的，所以我就没有搞。。。\n\n```\n\n```\n\n","slug":"随笔/next","published":1,"updated":"2021-12-09T01:56:49.432Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckznhkk89004vikub6z299npe","content":"<h1 id=\"next-基本使用\"><a href=\"#next-基本使用\" class=\"headerlink\" title=\"next 基本使用\"></a>next 基本使用</h1><p>基本可以看这个文档，我只是在使用的时候对于我出现的问题进行一个补充。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http://theme-next.iissnan.com/getting-started.html#install-next-theme</span><br></pre></td></tr></table></figure>\n\n<p>下面这个是比较新的情况，有一个组织进行了维护。使用也有说明</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://theme-next.js.org/docs/getting-started/</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">如果</span><br><span class=\"line\">hexo d 的命令不行，</span><br><span class=\"line\">可以尝试在前面加上 npx</span><br><span class=\"line\">npx hexo d</span><br></pre></td></tr></table></figure>\n\n<p>npx 主要作用就是让项目内部模块用起来更加方便，具体可以看</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http://www.ruanyifeng.com/blog/2019/02/npx.html</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"启用主题\"><a href=\"#启用主题\" class=\"headerlink\" title=\"启用主题\"></a>启用主题</h2><p>这里可能会因为新的版本的原因网页不能显示，这里我去百度了。</p>\n<p><img src=\"/.io//image-20211018110937363.png\" alt=\"image-20211018105920422\"></p>\n<p>原因是hexo在5.0之后把swig给删除了需要自己手动安装，所以只需要安装一下 这个就行了。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm i hexo-renderer-swig</span><br></pre></td></tr></table></figure>\n\n\n\n<p>对于v7.8，其他版本的我没有尝试，不知道这个问题，这里有个bug，如果在md文档里面设置了</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;Object&gt;</span><br><span class=\"line\">就这样一个单标签，就会让你的头像那一块位置不正确或者找不到。我这个是v7.8的版本，开始用的v8.8的版本没有问题，这个原因应该是因为没有对md文档里面的内容的处理。</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/.io//image-20211018105920422.png\" alt=\"image-20211018105920422\"></p>\n<p><img src=\"/.io//image-20211018110658046.png\" alt=\"image-20211018110658046\"></p>\n<h2 id=\"设置-菜单\"><a href=\"#设置-菜单\" class=\"headerlink\" title=\"设置 菜单\"></a>设置 菜单</h2><p>这里设置 的 菜单出现错误，这个应该是v5这个版本之前的bug，后面的应该都解决了</p>\n<p>因为 在那个 /about/||user，这个 <code>||</code>之前不能有空格，空格会被当作url，你也可以看到点击之后的url地址后面有个%20,这个就是空格。</p>\n<p>不过较新的版本解决了这个问题。具体是从哪个版本开始解决的不清楚。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">menu:</span><br><span class=\"line\">  home: /|| home</span><br><span class=\"line\">  about: /about/|| user</span><br><span class=\"line\">  tags: /tags/|| tags</span><br><span class=\"line\">  categories: /categories/|| th</span><br><span class=\"line\">  archives: /archives/|| archive</span><br><span class=\"line\">  schedule: /schedule/|| calendar</span><br><span class=\"line\">  sitemap: /sitemap.xml|| sitemap</span><br><span class=\"line\">  #commonweal: /404/|| heartbeat</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"设置头像\"><a href=\"#设置头像\" class=\"headerlink\" title=\"设置头像\"></a>设置头像</h2><p>相对地址和url都放在url后面</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">avatar:</span><br><span class=\"line\">  # Replace the default image and set the url here.</span><br><span class=\"line\">  url: /uploads/avatar.jpg #/images/avatar.gif</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"黑暗模式\"><a href=\"#黑暗模式\" class=\"headerlink\" title=\"黑暗模式\"></a>黑暗模式</h2><p>我这里不对，没有效果。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">darkmode: true</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"后续主题配置\"><a href=\"#后续主题配置\" class=\"headerlink\" title=\"后续主题配置\"></a>后续主题配置</h1><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http://theme-next.iissnan.com/theme-settings.html#tags-page</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"字体设置，代码高亮\"><a href=\"#字体设置，代码高亮\" class=\"headerlink\" title=\"字体设置，代码高亮\"></a>字体设置，代码高亮</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://theme-next.js.org/highlight/</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"图标\"><a href=\"#图标\" class=\"headerlink\" title=\"图标\"></a>图标</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">social:</span><br><span class=\"line\">  GitHub: https://github.com/tallgy || fab fa-github</span><br><span class=\"line\">  Gitee: https://gitee.com/tallgy || fab fa-github-alt</span><br><span class=\"line\">  #E-Mail: mailto:yourname@gmail.com || fa fa-envelope</span><br><span class=\"line\">  #Weibo: https://weibo.com/yourname || fab fa-weibo</span><br></pre></td></tr></table></figure>\n\n<p>图标网址</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://fontawesome.dashgame.com/</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">选中自己想要的图标，然后他后面有一个复制的按钮，直接复制，替换掉就行了。</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"三方服务集成\"><a href=\"#三方服务集成\" class=\"headerlink\" title=\"三方服务集成\"></a>三方服务集成</h1><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http://theme-next.iissnan.com/third-party-services.html</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"评论系统\"><a href=\"#评论系统\" class=\"headerlink\" title=\"评论系统\"></a>评论系统</h2><p><strong>DISQUS</strong>，大部分都是需要翻墙的，所以我就没有搞。。。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"next-基本使用\"><a href=\"#next-基本使用\" class=\"headerlink\" title=\"next 基本使用\"></a>next 基本使用</h1><p>基本可以看这个文档，我只是在使用的时候对于我出现的问题进行一个补充。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http://theme-next.iissnan.com/getting-started.html#install-next-theme</span><br></pre></td></tr></table></figure>\n\n<p>下面这个是比较新的情况，有一个组织进行了维护。使用也有说明</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://theme-next.js.org/docs/getting-started/</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">如果</span><br><span class=\"line\">hexo d 的命令不行，</span><br><span class=\"line\">可以尝试在前面加上 npx</span><br><span class=\"line\">npx hexo d</span><br></pre></td></tr></table></figure>\n\n<p>npx 主要作用就是让项目内部模块用起来更加方便，具体可以看</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http://www.ruanyifeng.com/blog/2019/02/npx.html</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"启用主题\"><a href=\"#启用主题\" class=\"headerlink\" title=\"启用主题\"></a>启用主题</h2><p>这里可能会因为新的版本的原因网页不能显示，这里我去百度了。</p>\n<p><img src=\"/.io//image-20211018110937363.png\" alt=\"image-20211018105920422\"></p>\n<p>原因是hexo在5.0之后把swig给删除了需要自己手动安装，所以只需要安装一下 这个就行了。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm i hexo-renderer-swig</span><br></pre></td></tr></table></figure>\n\n\n\n<p>对于v7.8，其他版本的我没有尝试，不知道这个问题，这里有个bug，如果在md文档里面设置了</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;Object&gt;</span><br><span class=\"line\">就这样一个单标签，就会让你的头像那一块位置不正确或者找不到。我这个是v7.8的版本，开始用的v8.8的版本没有问题，这个原因应该是因为没有对md文档里面的内容的处理。</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/.io//image-20211018105920422.png\" alt=\"image-20211018105920422\"></p>\n<p><img src=\"/.io//image-20211018110658046.png\" alt=\"image-20211018110658046\"></p>\n<h2 id=\"设置-菜单\"><a href=\"#设置-菜单\" class=\"headerlink\" title=\"设置 菜单\"></a>设置 菜单</h2><p>这里设置 的 菜单出现错误，这个应该是v5这个版本之前的bug，后面的应该都解决了</p>\n<p>因为 在那个 /about/||user，这个 <code>||</code>之前不能有空格，空格会被当作url，你也可以看到点击之后的url地址后面有个%20,这个就是空格。</p>\n<p>不过较新的版本解决了这个问题。具体是从哪个版本开始解决的不清楚。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">menu:</span><br><span class=\"line\">  home: /|| home</span><br><span class=\"line\">  about: /about/|| user</span><br><span class=\"line\">  tags: /tags/|| tags</span><br><span class=\"line\">  categories: /categories/|| th</span><br><span class=\"line\">  archives: /archives/|| archive</span><br><span class=\"line\">  schedule: /schedule/|| calendar</span><br><span class=\"line\">  sitemap: /sitemap.xml|| sitemap</span><br><span class=\"line\">  #commonweal: /404/|| heartbeat</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"设置头像\"><a href=\"#设置头像\" class=\"headerlink\" title=\"设置头像\"></a>设置头像</h2><p>相对地址和url都放在url后面</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">avatar:</span><br><span class=\"line\">  # Replace the default image and set the url here.</span><br><span class=\"line\">  url: /uploads/avatar.jpg #/images/avatar.gif</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"黑暗模式\"><a href=\"#黑暗模式\" class=\"headerlink\" title=\"黑暗模式\"></a>黑暗模式</h2><p>我这里不对，没有效果。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">darkmode: true</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"后续主题配置\"><a href=\"#后续主题配置\" class=\"headerlink\" title=\"后续主题配置\"></a>后续主题配置</h1><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http://theme-next.iissnan.com/theme-settings.html#tags-page</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"字体设置，代码高亮\"><a href=\"#字体设置，代码高亮\" class=\"headerlink\" title=\"字体设置，代码高亮\"></a>字体设置，代码高亮</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://theme-next.js.org/highlight/</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"图标\"><a href=\"#图标\" class=\"headerlink\" title=\"图标\"></a>图标</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">social:</span><br><span class=\"line\">  GitHub: https://github.com/tallgy || fab fa-github</span><br><span class=\"line\">  Gitee: https://gitee.com/tallgy || fab fa-github-alt</span><br><span class=\"line\">  #E-Mail: mailto:yourname@gmail.com || fa fa-envelope</span><br><span class=\"line\">  #Weibo: https://weibo.com/yourname || fab fa-weibo</span><br></pre></td></tr></table></figure>\n\n<p>图标网址</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://fontawesome.dashgame.com/</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">选中自己想要的图标，然后他后面有一个复制的按钮，直接复制，替换掉就行了。</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"三方服务集成\"><a href=\"#三方服务集成\" class=\"headerlink\" title=\"三方服务集成\"></a>三方服务集成</h1><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http://theme-next.iissnan.com/third-party-services.html</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"评论系统\"><a href=\"#评论系统\" class=\"headerlink\" title=\"评论系统\"></a>评论系统</h2><p><strong>DISQUS</strong>，大部分都是需要翻墙的，所以我就没有搞。。。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n"},{"title":"fetch发送2次请求的原因","date":"2021-11-06T05:20:43.000Z","_content":"\n\n\n#  fetch发送2次请求的原因\n\nfetch发送post请求的时候，总是发送2次，第一次状态码是204，第二次才成功？\n\n原因很简单，因为你用fetch的post请求的时候，导致fetch 第一次发送了一个Options请求，询问服务器是否支持修改的请求头，如果服务器支持，则在第二次中发送真正的请求。\n\n\n\n## 先说产生的前提条件\n\n* 请求不同源\n* 不属于简单请求\n\n\n\n## 请求不同源\n\n同源的概念：\n\n​\t\t如果两个 URL 的 [protocol](https://developer.mozilla.org/zh-CN/docs/Glossary/Protocol)、[port (en-US)](https://developer.mozilla.org/en-US/docs/Glossary/Port) (如果有指定的话)和 [host](https://developer.mozilla.org/zh-CN/docs/Glossary/Host) 都相同的话，则这两个 URL 是*同源*。这个方案也被称为“协议/主机/端口元组”，或者直接是 “元组”。\n\n所以简单来说，因为浏览器的安全策略，所以对于不同源的请求是不会成功的。\n\n\n\n## 不属于简单请求\n\n简单请求：\n\n* 请求方法是以下三个方法：\n  * HEAD, GET, POST\n* HTTP的头信息不超出以下几种字段\n  * Accept， Accept-Language， Content-Language， Last-Event-ID， Content-Type(只限于三个值`application/x-www-form-urlencoded`、`multipart/form-data`、`text/plain`)\n\n不满足以上两个条件就属于非简单请求\n\n\n\n## 对于非简单请求，需要先进行预检请求(preflight)\n\n​\t\t浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的`XMLHttpRequest`请求，否则就报错。\n\n​\t\t204的状态表示了处理了请求，没有返回实体内容。\n\n","source":"_posts/随笔/fetch发送2次请求的原因.md","raw":"---\ntitle: fetch发送2次请求的原因\ndate: 2021-11-06 13:20:43\ntags:\n - 随笔\ncategories:\n - 随笔\n---\n\n\n\n#  fetch发送2次请求的原因\n\nfetch发送post请求的时候，总是发送2次，第一次状态码是204，第二次才成功？\n\n原因很简单，因为你用fetch的post请求的时候，导致fetch 第一次发送了一个Options请求，询问服务器是否支持修改的请求头，如果服务器支持，则在第二次中发送真正的请求。\n\n\n\n## 先说产生的前提条件\n\n* 请求不同源\n* 不属于简单请求\n\n\n\n## 请求不同源\n\n同源的概念：\n\n​\t\t如果两个 URL 的 [protocol](https://developer.mozilla.org/zh-CN/docs/Glossary/Protocol)、[port (en-US)](https://developer.mozilla.org/en-US/docs/Glossary/Port) (如果有指定的话)和 [host](https://developer.mozilla.org/zh-CN/docs/Glossary/Host) 都相同的话，则这两个 URL 是*同源*。这个方案也被称为“协议/主机/端口元组”，或者直接是 “元组”。\n\n所以简单来说，因为浏览器的安全策略，所以对于不同源的请求是不会成功的。\n\n\n\n## 不属于简单请求\n\n简单请求：\n\n* 请求方法是以下三个方法：\n  * HEAD, GET, POST\n* HTTP的头信息不超出以下几种字段\n  * Accept， Accept-Language， Content-Language， Last-Event-ID， Content-Type(只限于三个值`application/x-www-form-urlencoded`、`multipart/form-data`、`text/plain`)\n\n不满足以上两个条件就属于非简单请求\n\n\n\n## 对于非简单请求，需要先进行预检请求(preflight)\n\n​\t\t浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的`XMLHttpRequest`请求，否则就报错。\n\n​\t\t204的状态表示了处理了请求，没有返回实体内容。\n\n","slug":"随笔/fetch发送2次请求的原因","published":1,"updated":"2021-12-09T01:56:49.432Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckznhkk8a0050ikub4pvk4fgk","content":"<h1 id=\"fetch发送2次请求的原因\"><a href=\"#fetch发送2次请求的原因\" class=\"headerlink\" title=\"fetch发送2次请求的原因\"></a>fetch发送2次请求的原因</h1><p>fetch发送post请求的时候，总是发送2次，第一次状态码是204，第二次才成功？</p>\n<p>原因很简单，因为你用fetch的post请求的时候，导致fetch 第一次发送了一个Options请求，询问服务器是否支持修改的请求头，如果服务器支持，则在第二次中发送真正的请求。</p>\n<h2 id=\"先说产生的前提条件\"><a href=\"#先说产生的前提条件\" class=\"headerlink\" title=\"先说产生的前提条件\"></a>先说产生的前提条件</h2><ul>\n<li>请求不同源</li>\n<li>不属于简单请求</li>\n</ul>\n<h2 id=\"请求不同源\"><a href=\"#请求不同源\" class=\"headerlink\" title=\"请求不同源\"></a>请求不同源</h2><p>同源的概念：</p>\n<p>​        如果两个 URL 的 <a href=\"https://developer.mozilla.org/zh-CN/docs/Glossary/Protocol\">protocol</a>、<a href=\"https://developer.mozilla.org/en-US/docs/Glossary/Port\">port (en-US)</a> (如果有指定的话)和 <a href=\"https://developer.mozilla.org/zh-CN/docs/Glossary/Host\">host</a> 都相同的话，则这两个 URL 是<em>同源</em>。这个方案也被称为“协议/主机/端口元组”，或者直接是 “元组”。</p>\n<p>所以简单来说，因为浏览器的安全策略，所以对于不同源的请求是不会成功的。</p>\n<h2 id=\"不属于简单请求\"><a href=\"#不属于简单请求\" class=\"headerlink\" title=\"不属于简单请求\"></a>不属于简单请求</h2><p>简单请求：</p>\n<ul>\n<li>请求方法是以下三个方法：<ul>\n<li>HEAD, GET, POST</li>\n</ul>\n</li>\n<li>HTTP的头信息不超出以下几种字段<ul>\n<li>Accept， Accept-Language， Content-Language， Last-Event-ID， Content-Type(只限于三个值<code>application/x-www-form-urlencoded</code>、<code>multipart/form-data</code>、<code>text/plain</code>)</li>\n</ul>\n</li>\n</ul>\n<p>不满足以上两个条件就属于非简单请求</p>\n<h2 id=\"对于非简单请求，需要先进行预检请求-preflight\"><a href=\"#对于非简单请求，需要先进行预检请求-preflight\" class=\"headerlink\" title=\"对于非简单请求，需要先进行预检请求(preflight)\"></a>对于非简单请求，需要先进行预检请求(preflight)</h2><p>​        浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的<code>XMLHttpRequest</code>请求，否则就报错。</p>\n<p>​        204的状态表示了处理了请求，没有返回实体内容。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"fetch发送2次请求的原因\"><a href=\"#fetch发送2次请求的原因\" class=\"headerlink\" title=\"fetch发送2次请求的原因\"></a>fetch发送2次请求的原因</h1><p>fetch发送post请求的时候，总是发送2次，第一次状态码是204，第二次才成功？</p>\n<p>原因很简单，因为你用fetch的post请求的时候，导致fetch 第一次发送了一个Options请求，询问服务器是否支持修改的请求头，如果服务器支持，则在第二次中发送真正的请求。</p>\n<h2 id=\"先说产生的前提条件\"><a href=\"#先说产生的前提条件\" class=\"headerlink\" title=\"先说产生的前提条件\"></a>先说产生的前提条件</h2><ul>\n<li>请求不同源</li>\n<li>不属于简单请求</li>\n</ul>\n<h2 id=\"请求不同源\"><a href=\"#请求不同源\" class=\"headerlink\" title=\"请求不同源\"></a>请求不同源</h2><p>同源的概念：</p>\n<p>​        如果两个 URL 的 <a href=\"https://developer.mozilla.org/zh-CN/docs/Glossary/Protocol\">protocol</a>、<a href=\"https://developer.mozilla.org/en-US/docs/Glossary/Port\">port (en-US)</a> (如果有指定的话)和 <a href=\"https://developer.mozilla.org/zh-CN/docs/Glossary/Host\">host</a> 都相同的话，则这两个 URL 是<em>同源</em>。这个方案也被称为“协议/主机/端口元组”，或者直接是 “元组”。</p>\n<p>所以简单来说，因为浏览器的安全策略，所以对于不同源的请求是不会成功的。</p>\n<h2 id=\"不属于简单请求\"><a href=\"#不属于简单请求\" class=\"headerlink\" title=\"不属于简单请求\"></a>不属于简单请求</h2><p>简单请求：</p>\n<ul>\n<li>请求方法是以下三个方法：<ul>\n<li>HEAD, GET, POST</li>\n</ul>\n</li>\n<li>HTTP的头信息不超出以下几种字段<ul>\n<li>Accept， Accept-Language， Content-Language， Last-Event-ID， Content-Type(只限于三个值<code>application/x-www-form-urlencoded</code>、<code>multipart/form-data</code>、<code>text/plain</code>)</li>\n</ul>\n</li>\n</ul>\n<p>不满足以上两个条件就属于非简单请求</p>\n<h2 id=\"对于非简单请求，需要先进行预检请求-preflight\"><a href=\"#对于非简单请求，需要先进行预检请求-preflight\" class=\"headerlink\" title=\"对于非简单请求，需要先进行预检请求(preflight)\"></a>对于非简单请求，需要先进行预检请求(preflight)</h2><p>​        浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的<code>XMLHttpRequest</code>请求，否则就报错。</p>\n<p>​        204的状态表示了处理了请求，没有返回实体内容。</p>\n"},{"title":"hexo基础","date":"2021-10-13T08:12:42.000Z","_content":"\n\n\n# hexo\n\nmd文件和html的文件对应关系在那个 ` db.json `， 它使用了hash，id以及其他。\n\n```\nhttps://hexo.io/zh-cn/docs/\n```\n\n\n\n# 使用主题\n\n我这里使用的是next主题。这里有两个，一个应该是以前个人制作的。第二个是有一个组织进行了维护吧，具体没有了解过。\n\n```\nhttp://theme-next.iissnan.com/\n```\n\n```\nhttps://theme-next.js.org/\n```\n\n这里可能会因为新的版本的原因网页不能显示，这里我去百度了。\n\n原因是hexo在5.0之后把swig给删除了需要自己手动安装，所以只需要安装一下 这个就行了。\n\n```java\n npm i hexo-renderer-swig\n```\n\n\n\n# 基本操作\n\n## 写作\n\n```\nhttps://hexo.io/zh-cn/docs/writing\n```\n\n```\nlayout， \npost， 会发表的\ndraft， 草稿，不会发表的。私密的\npage， 就是页面，会在source文件里面生成你写的文件名字，然后在里面生成一个index.md，然后，你可以在你的页面上输入 url/文件夹的名字就可以访问了，用于写页面，首页，关于，标签等都是使用的这个方法。\n```\n\n\n\n## 标签插件（Tag Plugins）\n\n直接在md文档上写就完了。会自动转译的。\n\n\n\n## 图片上传\n\n```\nhttps://blog.csdn.net/xjm850552586/article/details/84101345\n```\n\n使用插件  `hexo-asset-image`\n\n\n\n## 上传\n\n```\nnpx hexo clean\n\t清除缓存文件 ( db.json) 和生成的文件 ( public)。\nnpx hexo g\n\t生成静态文件\nnex hexo d\n\t将静态文件上传\n```\n\n```\n这里因为需要使用三个命令，很麻烦，所以就想着简单化一点。\n```\n\n```\n开始是想着使用npm或者npx命令，自己写一个的，但是因为技术不够，所以还不会，后面了解了更多了之后再进行解决。\n```\n\n```\n所以，我是用的方式是，通过一个bat文件直接将这三个命令写下来，我只需要运行这个文件就行了。\n所以我在blog里面创建了一个 \npublish.bat\n然后直接在里面，写入\n\ncall npx hexo clean\ncall npx hexo g\ncall npx hexo d\n\n这里需要在前面加上call方法。在批处理脚本中，call命令用来从一个批处理脚本中调用另一个批处理脚本。\n就这样就完成了。。\n```\n\n\n\n## gitee自动更新\n\n```\n使用puppeteer模块\n\n但是因为我谷歌浏览器修改过位置，所以需要重新下载，所以我没有进行后续的操作了。\n\nhttps://www.jianshu.com/p/6460df84a099\n```\n\n","source":"_posts/随笔/hexo.md","raw":"---\ntitle: hexo基础\ndate: 2021-10-13 16:12:42\ntags: \n - 随笔\ncategories:\n - 随笔\n---\n\n\n\n# hexo\n\nmd文件和html的文件对应关系在那个 ` db.json `， 它使用了hash，id以及其他。\n\n```\nhttps://hexo.io/zh-cn/docs/\n```\n\n\n\n# 使用主题\n\n我这里使用的是next主题。这里有两个，一个应该是以前个人制作的。第二个是有一个组织进行了维护吧，具体没有了解过。\n\n```\nhttp://theme-next.iissnan.com/\n```\n\n```\nhttps://theme-next.js.org/\n```\n\n这里可能会因为新的版本的原因网页不能显示，这里我去百度了。\n\n原因是hexo在5.0之后把swig给删除了需要自己手动安装，所以只需要安装一下 这个就行了。\n\n```java\n npm i hexo-renderer-swig\n```\n\n\n\n# 基本操作\n\n## 写作\n\n```\nhttps://hexo.io/zh-cn/docs/writing\n```\n\n```\nlayout， \npost， 会发表的\ndraft， 草稿，不会发表的。私密的\npage， 就是页面，会在source文件里面生成你写的文件名字，然后在里面生成一个index.md，然后，你可以在你的页面上输入 url/文件夹的名字就可以访问了，用于写页面，首页，关于，标签等都是使用的这个方法。\n```\n\n\n\n## 标签插件（Tag Plugins）\n\n直接在md文档上写就完了。会自动转译的。\n\n\n\n## 图片上传\n\n```\nhttps://blog.csdn.net/xjm850552586/article/details/84101345\n```\n\n使用插件  `hexo-asset-image`\n\n\n\n## 上传\n\n```\nnpx hexo clean\n\t清除缓存文件 ( db.json) 和生成的文件 ( public)。\nnpx hexo g\n\t生成静态文件\nnex hexo d\n\t将静态文件上传\n```\n\n```\n这里因为需要使用三个命令，很麻烦，所以就想着简单化一点。\n```\n\n```\n开始是想着使用npm或者npx命令，自己写一个的，但是因为技术不够，所以还不会，后面了解了更多了之后再进行解决。\n```\n\n```\n所以，我是用的方式是，通过一个bat文件直接将这三个命令写下来，我只需要运行这个文件就行了。\n所以我在blog里面创建了一个 \npublish.bat\n然后直接在里面，写入\n\ncall npx hexo clean\ncall npx hexo g\ncall npx hexo d\n\n这里需要在前面加上call方法。在批处理脚本中，call命令用来从一个批处理脚本中调用另一个批处理脚本。\n就这样就完成了。。\n```\n\n\n\n## gitee自动更新\n\n```\n使用puppeteer模块\n\n但是因为我谷歌浏览器修改过位置，所以需要重新下载，所以我没有进行后续的操作了。\n\nhttps://www.jianshu.com/p/6460df84a099\n```\n\n","slug":"随笔/hexo","published":1,"updated":"2021-12-09T01:56:49.432Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckznhkk8b0053ikubfq9h0dqo","content":"<h1 id=\"hexo\"><a href=\"#hexo\" class=\"headerlink\" title=\"hexo\"></a>hexo</h1><p>md文件和html的文件对应关系在那个 <code>db.json</code>， 它使用了hash，id以及其他。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://hexo.io/zh-cn/docs/</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"使用主题\"><a href=\"#使用主题\" class=\"headerlink\" title=\"使用主题\"></a>使用主题</h1><p>我这里使用的是next主题。这里有两个，一个应该是以前个人制作的。第二个是有一个组织进行了维护吧，具体没有了解过。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http://theme-next.iissnan.com/</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://theme-next.js.org/</span><br></pre></td></tr></table></figure>\n\n<p>这里可能会因为新的版本的原因网页不能显示，这里我去百度了。</p>\n<p>原因是hexo在5.0之后把swig给删除了需要自己手动安装，所以只需要安装一下 这个就行了。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm i hexo-renderer-swig</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"基本操作\"><a href=\"#基本操作\" class=\"headerlink\" title=\"基本操作\"></a>基本操作</h1><h2 id=\"写作\"><a href=\"#写作\" class=\"headerlink\" title=\"写作\"></a>写作</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://hexo.io/zh-cn/docs/writing</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">layout， </span><br><span class=\"line\">post， 会发表的</span><br><span class=\"line\">draft， 草稿，不会发表的。私密的</span><br><span class=\"line\">page， 就是页面，会在source文件里面生成你写的文件名字，然后在里面生成一个index.md，然后，你可以在你的页面上输入 url/文件夹的名字就可以访问了，用于写页面，首页，关于，标签等都是使用的这个方法。</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"标签插件（Tag-Plugins）\"><a href=\"#标签插件（Tag-Plugins）\" class=\"headerlink\" title=\"标签插件（Tag Plugins）\"></a>标签插件（Tag Plugins）</h2><p>直接在md文档上写就完了。会自动转译的。</p>\n<h2 id=\"图片上传\"><a href=\"#图片上传\" class=\"headerlink\" title=\"图片上传\"></a>图片上传</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://blog.csdn.net/xjm850552586/article/details/84101345</span><br></pre></td></tr></table></figure>\n\n<p>使用插件  <code>hexo-asset-image</code></p>\n<h2 id=\"上传\"><a href=\"#上传\" class=\"headerlink\" title=\"上传\"></a>上传</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npx hexo clean</span><br><span class=\"line\">\t清除缓存文件 ( db.json) 和生成的文件 ( public)。</span><br><span class=\"line\">npx hexo g</span><br><span class=\"line\">\t生成静态文件</span><br><span class=\"line\">nex hexo d</span><br><span class=\"line\">\t将静态文件上传</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">这里因为需要使用三个命令，很麻烦，所以就想着简单化一点。</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">开始是想着使用npm或者npx命令，自己写一个的，但是因为技术不够，所以还不会，后面了解了更多了之后再进行解决。</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">所以，我是用的方式是，通过一个bat文件直接将这三个命令写下来，我只需要运行这个文件就行了。</span><br><span class=\"line\">所以我在blog里面创建了一个 </span><br><span class=\"line\">publish.bat</span><br><span class=\"line\">然后直接在里面，写入</span><br><span class=\"line\"></span><br><span class=\"line\">call npx hexo clean</span><br><span class=\"line\">call npx hexo g</span><br><span class=\"line\">call npx hexo d</span><br><span class=\"line\"></span><br><span class=\"line\">这里需要在前面加上call方法。在批处理脚本中，call命令用来从一个批处理脚本中调用另一个批处理脚本。</span><br><span class=\"line\">就这样就完成了。。</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"gitee自动更新\"><a href=\"#gitee自动更新\" class=\"headerlink\" title=\"gitee自动更新\"></a>gitee自动更新</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">使用puppeteer模块</span><br><span class=\"line\"></span><br><span class=\"line\">但是因为我谷歌浏览器修改过位置，所以需要重新下载，所以我没有进行后续的操作了。</span><br><span class=\"line\"></span><br><span class=\"line\">https://www.jianshu.com/p/6460df84a099</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"hexo\"><a href=\"#hexo\" class=\"headerlink\" title=\"hexo\"></a>hexo</h1><p>md文件和html的文件对应关系在那个 <code>db.json</code>， 它使用了hash，id以及其他。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://hexo.io/zh-cn/docs/</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"使用主题\"><a href=\"#使用主题\" class=\"headerlink\" title=\"使用主题\"></a>使用主题</h1><p>我这里使用的是next主题。这里有两个，一个应该是以前个人制作的。第二个是有一个组织进行了维护吧，具体没有了解过。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http://theme-next.iissnan.com/</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://theme-next.js.org/</span><br></pre></td></tr></table></figure>\n\n<p>这里可能会因为新的版本的原因网页不能显示，这里我去百度了。</p>\n<p>原因是hexo在5.0之后把swig给删除了需要自己手动安装，所以只需要安装一下 这个就行了。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm i hexo-renderer-swig</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"基本操作\"><a href=\"#基本操作\" class=\"headerlink\" title=\"基本操作\"></a>基本操作</h1><h2 id=\"写作\"><a href=\"#写作\" class=\"headerlink\" title=\"写作\"></a>写作</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://hexo.io/zh-cn/docs/writing</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">layout， </span><br><span class=\"line\">post， 会发表的</span><br><span class=\"line\">draft， 草稿，不会发表的。私密的</span><br><span class=\"line\">page， 就是页面，会在source文件里面生成你写的文件名字，然后在里面生成一个index.md，然后，你可以在你的页面上输入 url/文件夹的名字就可以访问了，用于写页面，首页，关于，标签等都是使用的这个方法。</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"标签插件（Tag-Plugins）\"><a href=\"#标签插件（Tag-Plugins）\" class=\"headerlink\" title=\"标签插件（Tag Plugins）\"></a>标签插件（Tag Plugins）</h2><p>直接在md文档上写就完了。会自动转译的。</p>\n<h2 id=\"图片上传\"><a href=\"#图片上传\" class=\"headerlink\" title=\"图片上传\"></a>图片上传</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://blog.csdn.net/xjm850552586/article/details/84101345</span><br></pre></td></tr></table></figure>\n\n<p>使用插件  <code>hexo-asset-image</code></p>\n<h2 id=\"上传\"><a href=\"#上传\" class=\"headerlink\" title=\"上传\"></a>上传</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npx hexo clean</span><br><span class=\"line\">\t清除缓存文件 ( db.json) 和生成的文件 ( public)。</span><br><span class=\"line\">npx hexo g</span><br><span class=\"line\">\t生成静态文件</span><br><span class=\"line\">nex hexo d</span><br><span class=\"line\">\t将静态文件上传</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">这里因为需要使用三个命令，很麻烦，所以就想着简单化一点。</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">开始是想着使用npm或者npx命令，自己写一个的，但是因为技术不够，所以还不会，后面了解了更多了之后再进行解决。</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">所以，我是用的方式是，通过一个bat文件直接将这三个命令写下来，我只需要运行这个文件就行了。</span><br><span class=\"line\">所以我在blog里面创建了一个 </span><br><span class=\"line\">publish.bat</span><br><span class=\"line\">然后直接在里面，写入</span><br><span class=\"line\"></span><br><span class=\"line\">call npx hexo clean</span><br><span class=\"line\">call npx hexo g</span><br><span class=\"line\">call npx hexo d</span><br><span class=\"line\"></span><br><span class=\"line\">这里需要在前面加上call方法。在批处理脚本中，call命令用来从一个批处理脚本中调用另一个批处理脚本。</span><br><span class=\"line\">就这样就完成了。。</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"gitee自动更新\"><a href=\"#gitee自动更新\" class=\"headerlink\" title=\"gitee自动更新\"></a>gitee自动更新</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">使用puppeteer模块</span><br><span class=\"line\"></span><br><span class=\"line\">但是因为我谷歌浏览器修改过位置，所以需要重新下载，所以我没有进行后续的操作了。</span><br><span class=\"line\"></span><br><span class=\"line\">https://www.jianshu.com/p/6460df84a099</span><br></pre></td></tr></table></figure>\n\n"},{"title":"浏览器的回流和重绘","date":"2021-11-17T02:11:43.000Z","_content":"\n\n\n#  浏览器的回流和重绘\n\n```\nhttps://juejin.cn/post/6844903753783443463\n```\n\n先放一张图\n\n![painted and re-render](浏览器的回流和重绘/painted and re-render.jpg)\n\n\n\n## 浏览器解析DOM树的过程\n\n* 当浏览器获取到html文件时，开始解析和构造DOM树，我们也知道html文件里面有 JavaScript、 CSS 和 其他文件\n\n  * 遇到了 JavaScript，代码或者文件，在默认情况下，会停止DOM树的执行。因为JavaScript可以操作DOM。当然也有 defer 和 async 两个模式 \n\n    * ```\n      <script defer async></script>\n      \n      当然这里 defer 和 async 的区别我们后续在讲解。\n      ```\n\n    * 但是如果JavaScript操作了CSS，那么就会转而构造CSSOM树。\n\n  * 遇到了CSS 和 其他文件，会先进行下载，CSS 会在DOM树的构造完成之后再进行构造。\n\n* 此时，html已经解析完成，DOM树 和 CSSOM 树也已经构造完成，我们就需要将DOM树和CSSOM树进行渲染为 render tree 或者叫做 layout tree，设置了display:none 的不会出现在渲染树上，但是对于before伪元素，就会出现在渲染树上。\n\n* 生成了渲染树之后，便是进行绘制painting了。\n\n* painting之后便可以进行显示\n\n\n\n## 重绘\n\n我们可以知道页面的显示是要先进行渲染树的生成和painting，\n\n而painting就是绘制，重绘就是指渲染树不会重新生成，但是需要重新绘制的情况。\n\n常见的重绘就是颜色的变化，因为他不会引起布局的改变。\n\n\n\n## 重排 / 回流\n\n重排就是渲染树重新进行了改变，一般来说就是导致了布局的变化就会导致重排。\n\n重排会引起重绘。但是重绘不一定会引起重排\n\n现在的浏览器也对频繁的重排重绘进行过优化，比如会有维护重排和重绘的队列，只有在达到阈值或者一定时间之后才会进行统一的调用，这样可以减少变化。\n\n当然如果你使用了 clientWidth 这种属性，这一系列属性可以获取到标签的位置信息等的，浏览器会为了拿到一个最精准的属性会强制清空队列。\n\n\n\n## 如何减少重排\n\n减少的形式有很多：\n\n* 减少对渲染树的操作，比如可以将多次的操作合并为一个：\n  * 使用CSS的类进行操作。\n  * 使用display:none 进行操作，因为这样在不显示的情况下是不会引起重排的，然后再操作完之后再显示，那么就只会造成两次重排。\n  * 使用 documentFragment，将操作放入这里，然后最后再添加到文档中\n* 减少使用属性，利用缓存，减少对属性的请求\n* 尽量从末端修改元素\n* 可以使用 绝对定位和固定定位，使其脱离文档流\n* 使用transform属性代替其他操作。\n\n\n\n## transform属性为什么不会引起重排\n\n这里简单来说，就是说浏览器在进行渲染的时候，是将其分成了多个图层，使用的复合图层的形式进行的操作。\n\n当我们调用 transform的时候，会生成一个渲染层，对于这个渲染层会有独立的合成层。因此对其进行修改并不会影响到页面整体的渲染树的重新生成。\n\n就是说，浏览器是将页面分成了不同的图层，然后根据不同的图层进行了划分。然后在显示的时候再根据z-index这种类型的进行一个高低的合成。\n\n**独立的合成层如何产生**：\n\n* 使用了 3D 或者 perspective transform\n* video\n* canvas\n* flash\n* opacity\n* CSS滤镜 filters\n* 存在合成层后代的\n* 和合成层重叠且在该层上面渲染的。\n\n\n\n","source":"_posts/随笔/浏览器的回流和重绘.md","raw":"---\ntitle: 浏览器的回流和重绘\ndate: 2021-11-17 10:11:43\ntags:\n - 回流和重绘\n - 性能\n - 随笔\ncategories:\n - 随笔\n---\n\n\n\n#  浏览器的回流和重绘\n\n```\nhttps://juejin.cn/post/6844903753783443463\n```\n\n先放一张图\n\n![painted and re-render](浏览器的回流和重绘/painted and re-render.jpg)\n\n\n\n## 浏览器解析DOM树的过程\n\n* 当浏览器获取到html文件时，开始解析和构造DOM树，我们也知道html文件里面有 JavaScript、 CSS 和 其他文件\n\n  * 遇到了 JavaScript，代码或者文件，在默认情况下，会停止DOM树的执行。因为JavaScript可以操作DOM。当然也有 defer 和 async 两个模式 \n\n    * ```\n      <script defer async></script>\n      \n      当然这里 defer 和 async 的区别我们后续在讲解。\n      ```\n\n    * 但是如果JavaScript操作了CSS，那么就会转而构造CSSOM树。\n\n  * 遇到了CSS 和 其他文件，会先进行下载，CSS 会在DOM树的构造完成之后再进行构造。\n\n* 此时，html已经解析完成，DOM树 和 CSSOM 树也已经构造完成，我们就需要将DOM树和CSSOM树进行渲染为 render tree 或者叫做 layout tree，设置了display:none 的不会出现在渲染树上，但是对于before伪元素，就会出现在渲染树上。\n\n* 生成了渲染树之后，便是进行绘制painting了。\n\n* painting之后便可以进行显示\n\n\n\n## 重绘\n\n我们可以知道页面的显示是要先进行渲染树的生成和painting，\n\n而painting就是绘制，重绘就是指渲染树不会重新生成，但是需要重新绘制的情况。\n\n常见的重绘就是颜色的变化，因为他不会引起布局的改变。\n\n\n\n## 重排 / 回流\n\n重排就是渲染树重新进行了改变，一般来说就是导致了布局的变化就会导致重排。\n\n重排会引起重绘。但是重绘不一定会引起重排\n\n现在的浏览器也对频繁的重排重绘进行过优化，比如会有维护重排和重绘的队列，只有在达到阈值或者一定时间之后才会进行统一的调用，这样可以减少变化。\n\n当然如果你使用了 clientWidth 这种属性，这一系列属性可以获取到标签的位置信息等的，浏览器会为了拿到一个最精准的属性会强制清空队列。\n\n\n\n## 如何减少重排\n\n减少的形式有很多：\n\n* 减少对渲染树的操作，比如可以将多次的操作合并为一个：\n  * 使用CSS的类进行操作。\n  * 使用display:none 进行操作，因为这样在不显示的情况下是不会引起重排的，然后再操作完之后再显示，那么就只会造成两次重排。\n  * 使用 documentFragment，将操作放入这里，然后最后再添加到文档中\n* 减少使用属性，利用缓存，减少对属性的请求\n* 尽量从末端修改元素\n* 可以使用 绝对定位和固定定位，使其脱离文档流\n* 使用transform属性代替其他操作。\n\n\n\n## transform属性为什么不会引起重排\n\n这里简单来说，就是说浏览器在进行渲染的时候，是将其分成了多个图层，使用的复合图层的形式进行的操作。\n\n当我们调用 transform的时候，会生成一个渲染层，对于这个渲染层会有独立的合成层。因此对其进行修改并不会影响到页面整体的渲染树的重新生成。\n\n就是说，浏览器是将页面分成了不同的图层，然后根据不同的图层进行了划分。然后在显示的时候再根据z-index这种类型的进行一个高低的合成。\n\n**独立的合成层如何产生**：\n\n* 使用了 3D 或者 perspective transform\n* video\n* canvas\n* flash\n* opacity\n* CSS滤镜 filters\n* 存在合成层后代的\n* 和合成层重叠且在该层上面渲染的。\n\n\n\n","slug":"随笔/浏览器的回流和重绘","published":1,"updated":"2021-12-09T01:56:49.432Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckznhkk8c0058ikub8syc34cx","content":"<h1 id=\"浏览器的回流和重绘\"><a href=\"#浏览器的回流和重绘\" class=\"headerlink\" title=\"浏览器的回流和重绘\"></a>浏览器的回流和重绘</h1><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://juejin.cn/post/6844903753783443463</span><br></pre></td></tr></table></figure>\n\n<p>先放一张图</p>\n<p>![painted and re-render](浏览器的回流和重绘/painted and re-render.jpg)</p>\n<h2 id=\"浏览器解析DOM树的过程\"><a href=\"#浏览器解析DOM树的过程\" class=\"headerlink\" title=\"浏览器解析DOM树的过程\"></a>浏览器解析DOM树的过程</h2><ul>\n<li><p>当浏览器获取到html文件时，开始解析和构造DOM树，我们也知道html文件里面有 JavaScript、 CSS 和 其他文件</p>\n<ul>\n<li><p>遇到了 JavaScript，代码或者文件，在默认情况下，会停止DOM树的执行。因为JavaScript可以操作DOM。当然也有 defer 和 async 两个模式 </p>\n<ul>\n<li><pre><code>&lt;script defer async&gt;&lt;/script&gt;\n\n当然这里 defer 和 async 的区别我们后续在讲解。\n</code></pre>\n</li>\n<li><p>但是如果JavaScript操作了CSS，那么就会转而构造CSSOM树。</p>\n</li>\n</ul>\n</li>\n<li><p>遇到了CSS 和 其他文件，会先进行下载，CSS 会在DOM树的构造完成之后再进行构造。</p>\n</li>\n</ul>\n</li>\n<li><p>此时，html已经解析完成，DOM树 和 CSSOM 树也已经构造完成，我们就需要将DOM树和CSSOM树进行渲染为 render tree 或者叫做 layout tree，设置了display:none 的不会出现在渲染树上，但是对于before伪元素，就会出现在渲染树上。</p>\n</li>\n<li><p>生成了渲染树之后，便是进行绘制painting了。</p>\n</li>\n<li><p>painting之后便可以进行显示</p>\n</li>\n</ul>\n<h2 id=\"重绘\"><a href=\"#重绘\" class=\"headerlink\" title=\"重绘\"></a>重绘</h2><p>我们可以知道页面的显示是要先进行渲染树的生成和painting，</p>\n<p>而painting就是绘制，重绘就是指渲染树不会重新生成，但是需要重新绘制的情况。</p>\n<p>常见的重绘就是颜色的变化，因为他不会引起布局的改变。</p>\n<h2 id=\"重排-回流\"><a href=\"#重排-回流\" class=\"headerlink\" title=\"重排 / 回流\"></a>重排 / 回流</h2><p>重排就是渲染树重新进行了改变，一般来说就是导致了布局的变化就会导致重排。</p>\n<p>重排会引起重绘。但是重绘不一定会引起重排</p>\n<p>现在的浏览器也对频繁的重排重绘进行过优化，比如会有维护重排和重绘的队列，只有在达到阈值或者一定时间之后才会进行统一的调用，这样可以减少变化。</p>\n<p>当然如果你使用了 clientWidth 这种属性，这一系列属性可以获取到标签的位置信息等的，浏览器会为了拿到一个最精准的属性会强制清空队列。</p>\n<h2 id=\"如何减少重排\"><a href=\"#如何减少重排\" class=\"headerlink\" title=\"如何减少重排\"></a>如何减少重排</h2><p>减少的形式有很多：</p>\n<ul>\n<li>减少对渲染树的操作，比如可以将多次的操作合并为一个：<ul>\n<li>使用CSS的类进行操作。</li>\n<li>使用display:none 进行操作，因为这样在不显示的情况下是不会引起重排的，然后再操作完之后再显示，那么就只会造成两次重排。</li>\n<li>使用 documentFragment，将操作放入这里，然后最后再添加到文档中</li>\n</ul>\n</li>\n<li>减少使用属性，利用缓存，减少对属性的请求</li>\n<li>尽量从末端修改元素</li>\n<li>可以使用 绝对定位和固定定位，使其脱离文档流</li>\n<li>使用transform属性代替其他操作。</li>\n</ul>\n<h2 id=\"transform属性为什么不会引起重排\"><a href=\"#transform属性为什么不会引起重排\" class=\"headerlink\" title=\"transform属性为什么不会引起重排\"></a>transform属性为什么不会引起重排</h2><p>这里简单来说，就是说浏览器在进行渲染的时候，是将其分成了多个图层，使用的复合图层的形式进行的操作。</p>\n<p>当我们调用 transform的时候，会生成一个渲染层，对于这个渲染层会有独立的合成层。因此对其进行修改并不会影响到页面整体的渲染树的重新生成。</p>\n<p>就是说，浏览器是将页面分成了不同的图层，然后根据不同的图层进行了划分。然后在显示的时候再根据z-index这种类型的进行一个高低的合成。</p>\n<p><strong>独立的合成层如何产生</strong>：</p>\n<ul>\n<li>使用了 3D 或者 perspective transform</li>\n<li>video</li>\n<li>canvas</li>\n<li>flash</li>\n<li>opacity</li>\n<li>CSS滤镜 filters</li>\n<li>存在合成层后代的</li>\n<li>和合成层重叠且在该层上面渲染的。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"浏览器的回流和重绘\"><a href=\"#浏览器的回流和重绘\" class=\"headerlink\" title=\"浏览器的回流和重绘\"></a>浏览器的回流和重绘</h1><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://juejin.cn/post/6844903753783443463</span><br></pre></td></tr></table></figure>\n\n<p>先放一张图</p>\n<p>![painted and re-render](浏览器的回流和重绘/painted and re-render.jpg)</p>\n<h2 id=\"浏览器解析DOM树的过程\"><a href=\"#浏览器解析DOM树的过程\" class=\"headerlink\" title=\"浏览器解析DOM树的过程\"></a>浏览器解析DOM树的过程</h2><ul>\n<li><p>当浏览器获取到html文件时，开始解析和构造DOM树，我们也知道html文件里面有 JavaScript、 CSS 和 其他文件</p>\n<ul>\n<li><p>遇到了 JavaScript，代码或者文件，在默认情况下，会停止DOM树的执行。因为JavaScript可以操作DOM。当然也有 defer 和 async 两个模式 </p>\n<ul>\n<li><pre><code>&lt;script defer async&gt;&lt;/script&gt;\n\n当然这里 defer 和 async 的区别我们后续在讲解。\n</code></pre>\n</li>\n<li><p>但是如果JavaScript操作了CSS，那么就会转而构造CSSOM树。</p>\n</li>\n</ul>\n</li>\n<li><p>遇到了CSS 和 其他文件，会先进行下载，CSS 会在DOM树的构造完成之后再进行构造。</p>\n</li>\n</ul>\n</li>\n<li><p>此时，html已经解析完成，DOM树 和 CSSOM 树也已经构造完成，我们就需要将DOM树和CSSOM树进行渲染为 render tree 或者叫做 layout tree，设置了display:none 的不会出现在渲染树上，但是对于before伪元素，就会出现在渲染树上。</p>\n</li>\n<li><p>生成了渲染树之后，便是进行绘制painting了。</p>\n</li>\n<li><p>painting之后便可以进行显示</p>\n</li>\n</ul>\n<h2 id=\"重绘\"><a href=\"#重绘\" class=\"headerlink\" title=\"重绘\"></a>重绘</h2><p>我们可以知道页面的显示是要先进行渲染树的生成和painting，</p>\n<p>而painting就是绘制，重绘就是指渲染树不会重新生成，但是需要重新绘制的情况。</p>\n<p>常见的重绘就是颜色的变化，因为他不会引起布局的改变。</p>\n<h2 id=\"重排-回流\"><a href=\"#重排-回流\" class=\"headerlink\" title=\"重排 / 回流\"></a>重排 / 回流</h2><p>重排就是渲染树重新进行了改变，一般来说就是导致了布局的变化就会导致重排。</p>\n<p>重排会引起重绘。但是重绘不一定会引起重排</p>\n<p>现在的浏览器也对频繁的重排重绘进行过优化，比如会有维护重排和重绘的队列，只有在达到阈值或者一定时间之后才会进行统一的调用，这样可以减少变化。</p>\n<p>当然如果你使用了 clientWidth 这种属性，这一系列属性可以获取到标签的位置信息等的，浏览器会为了拿到一个最精准的属性会强制清空队列。</p>\n<h2 id=\"如何减少重排\"><a href=\"#如何减少重排\" class=\"headerlink\" title=\"如何减少重排\"></a>如何减少重排</h2><p>减少的形式有很多：</p>\n<ul>\n<li>减少对渲染树的操作，比如可以将多次的操作合并为一个：<ul>\n<li>使用CSS的类进行操作。</li>\n<li>使用display:none 进行操作，因为这样在不显示的情况下是不会引起重排的，然后再操作完之后再显示，那么就只会造成两次重排。</li>\n<li>使用 documentFragment，将操作放入这里，然后最后再添加到文档中</li>\n</ul>\n</li>\n<li>减少使用属性，利用缓存，减少对属性的请求</li>\n<li>尽量从末端修改元素</li>\n<li>可以使用 绝对定位和固定定位，使其脱离文档流</li>\n<li>使用transform属性代替其他操作。</li>\n</ul>\n<h2 id=\"transform属性为什么不会引起重排\"><a href=\"#transform属性为什么不会引起重排\" class=\"headerlink\" title=\"transform属性为什么不会引起重排\"></a>transform属性为什么不会引起重排</h2><p>这里简单来说，就是说浏览器在进行渲染的时候，是将其分成了多个图层，使用的复合图层的形式进行的操作。</p>\n<p>当我们调用 transform的时候，会生成一个渲染层，对于这个渲染层会有独立的合成层。因此对其进行修改并不会影响到页面整体的渲染树的重新生成。</p>\n<p>就是说，浏览器是将页面分成了不同的图层，然后根据不同的图层进行了划分。然后在显示的时候再根据z-index这种类型的进行一个高低的合成。</p>\n<p><strong>独立的合成层如何产生</strong>：</p>\n<ul>\n<li>使用了 3D 或者 perspective transform</li>\n<li>video</li>\n<li>canvas</li>\n<li>flash</li>\n<li>opacity</li>\n<li>CSS滤镜 filters</li>\n<li>存在合成层后代的</li>\n<li>和合成层重叠且在该层上面渲染的。</li>\n</ul>\n"},{"layout":"draft","title":"vue3-nextTick","date":"2021-12-09T05:30:09.000Z","_content":"\n\n\n#  this.$nextTick\n\n## 情况\n\n​\t\t图形在渲染时，没有渲染出正确的位置\n\n\n\n## 原因\n\n​\t\t因为图形的渲染是使用的获取窗口的宽度，对于原生的来说，获取窗口的宽度的操作一般是浏览器会先进行渲染操作，但是这里是使用的vue，vue是先将数据放入了虚拟dom，所以此时获取窗口的宽度时并没有先进行一个渲染的操作。所以需要使用 this.$nextTick()\n\n\n\n## 总结\n\n​\t\t对于需要通过真实dom的操作的，建议先使用 this.$nextTick() 里面进行获取。\n","source":"_drafts/debug/zyyx/vue3-nextTick.md","raw":"---\nlayout: draft\ntitle: vue3-nextTick\ndate: 2021-12-09 13:30:09\ntags:\n - bug\ncategories:\n - bug\n---\n\n\n\n#  this.$nextTick\n\n## 情况\n\n​\t\t图形在渲染时，没有渲染出正确的位置\n\n\n\n## 原因\n\n​\t\t因为图形的渲染是使用的获取窗口的宽度，对于原生的来说，获取窗口的宽度的操作一般是浏览器会先进行渲染操作，但是这里是使用的vue，vue是先将数据放入了虚拟dom，所以此时获取窗口的宽度时并没有先进行一个渲染的操作。所以需要使用 this.$nextTick()\n\n\n\n## 总结\n\n​\t\t对于需要通过真实dom的操作的，建议先使用 this.$nextTick() 里面进行获取。\n","slug":"debug/zyyx/vue3-nextTick","published":0,"updated":"2021-12-09T05:34:31.487Z","comments":1,"photos":[],"link":"","_id":"ckznhkk8d005bikub60fjebyi","content":"<h1 id=\"this-nextTick\"><a href=\"#this-nextTick\" class=\"headerlink\" title=\"this.$nextTick\"></a>this.$nextTick</h1><h2 id=\"情况\"><a href=\"#情况\" class=\"headerlink\" title=\"情况\"></a>情况</h2><p>​        图形在渲染时，没有渲染出正确的位置</p>\n<h2 id=\"原因\"><a href=\"#原因\" class=\"headerlink\" title=\"原因\"></a>原因</h2><p>​        因为图形的渲染是使用的获取窗口的宽度，对于原生的来说，获取窗口的宽度的操作一般是浏览器会先进行渲染操作，但是这里是使用的vue，vue是先将数据放入了虚拟dom，所以此时获取窗口的宽度时并没有先进行一个渲染的操作。所以需要使用 this.$nextTick()</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>​        对于需要通过真实dom的操作的，建议先使用 this.$nextTick() 里面进行获取。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"this-nextTick\"><a href=\"#this-nextTick\" class=\"headerlink\" title=\"this.$nextTick\"></a>this.$nextTick</h1><h2 id=\"情况\"><a href=\"#情况\" class=\"headerlink\" title=\"情况\"></a>情况</h2><p>​        图形在渲染时，没有渲染出正确的位置</p>\n<h2 id=\"原因\"><a href=\"#原因\" class=\"headerlink\" title=\"原因\"></a>原因</h2><p>​        因为图形的渲染是使用的获取窗口的宽度，对于原生的来说，获取窗口的宽度的操作一般是浏览器会先进行渲染操作，但是这里是使用的vue，vue是先将数据放入了虚拟dom，所以此时获取窗口的宽度时并没有先进行一个渲染的操作。所以需要使用 this.$nextTick()</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>​        对于需要通过真实dom的操作的，建议先使用 this.$nextTick() 里面进行获取。</p>\n"},{"layout":"draft","title":"vue3-getElement伪数组","date":"2021-12-09T05:45:27.000Z","_content":"\n\n\n#  getElementsByClassName 获取的是一个伪数组\n\n## 问题\n\n​\t\t使用的是 document.getElementsByClassName ，但是返回的是一个伪数组，并没有数组的一些方法。最终使用 forof 迭代循环进行的操作。\n","source":"_drafts/debug/zyyx/vue3-getElement伪数组.md","raw":"---\nlayout: draft\ntitle: vue3-getElement伪数组\ndate: 2021-12-09 13:45:27\ntags:\n - bug\ncategories:\n - bug\n---\n\n\n\n#  getElementsByClassName 获取的是一个伪数组\n\n## 问题\n\n​\t\t使用的是 document.getElementsByClassName ，但是返回的是一个伪数组，并没有数组的一些方法。最终使用 forof 迭代循环进行的操作。\n","slug":"debug/zyyx/vue3-getElement伪数组","published":0,"updated":"2021-12-09T05:46:55.368Z","comments":1,"photos":[],"link":"","_id":"ckznhkk8e005gikubhlpj9y4s","content":"<h1 id=\"getElementsByClassName-获取的是一个伪数组\"><a href=\"#getElementsByClassName-获取的是一个伪数组\" class=\"headerlink\" title=\"getElementsByClassName 获取的是一个伪数组\"></a>getElementsByClassName 获取的是一个伪数组</h1><h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><p>​        使用的是 document.getElementsByClassName ，但是返回的是一个伪数组，并没有数组的一些方法。最终使用 forof 迭代循环进行的操作。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"getElementsByClassName-获取的是一个伪数组\"><a href=\"#getElementsByClassName-获取的是一个伪数组\" class=\"headerlink\" title=\"getElementsByClassName 获取的是一个伪数组\"></a>getElementsByClassName 获取的是一个伪数组</h1><h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><p>​        使用的是 document.getElementsByClassName ，但是返回的是一个伪数组，并没有数组的一些方法。最终使用 forof 迭代循环进行的操作。</p>\n"},{"layout":"draft","title":"vue3-$slots和$refs","date":"2021-12-09T03:55:54.000Z","_content":"\n\n\n#  $slots 和 $refs\n\n## 情况\n\n​\t\t对于插槽上的元素，可以使用 $slots 来获取，但是这个获取时，没有获取到真实的dom节点。\n\n​\t\t插槽使用 $slots 没有获取到真实的dom。\n\n\n\n## 总结\n\n​\t\t最后选择使用 $refs 来进行替代  $slots 的获取。\n","source":"_drafts/debug/zyyx/vue3-slots和-refs.md","raw":"---\nlayout: draft\ntitle: vue3-$slots和$refs\ndate: 2021-12-09 11:55:54\ntags:\n - bug\ncategories:\n - bug\n---\n\n\n\n#  $slots 和 $refs\n\n## 情况\n\n​\t\t对于插槽上的元素，可以使用 $slots 来获取，但是这个获取时，没有获取到真实的dom节点。\n\n​\t\t插槽使用 $slots 没有获取到真实的dom。\n\n\n\n## 总结\n\n​\t\t最后选择使用 $refs 来进行替代  $slots 的获取。\n","slug":"debug/zyyx/vue3-slots和-refs","published":0,"updated":"2021-12-09T05:28:50.079Z","comments":1,"photos":[],"link":"","_id":"ckznhkk8e005jikubb1hj3z8w","content":"<h1 id=\"slots-和-refs\"><a href=\"#slots-和-refs\" class=\"headerlink\" title=\"$slots 和 $refs\"></a>$slots 和 $refs</h1><h2 id=\"情况\"><a href=\"#情况\" class=\"headerlink\" title=\"情况\"></a>情况</h2><p>​        对于插槽上的元素，可以使用 $slots 来获取，但是这个获取时，没有获取到真实的dom节点。</p>\n<p>​        插槽使用 $slots 没有获取到真实的dom。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>​        最后选择使用 $refs 来进行替代  $slots 的获取。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"slots-和-refs\"><a href=\"#slots-和-refs\" class=\"headerlink\" title=\"$slots 和 $refs\"></a>$slots 和 $refs</h1><h2 id=\"情况\"><a href=\"#情况\" class=\"headerlink\" title=\"情况\"></a>情况</h2><p>​        对于插槽上的元素，可以使用 $slots 来获取，但是这个获取时，没有获取到真实的dom节点。</p>\n<p>​        插槽使用 $slots 没有获取到真实的dom。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>​        最后选择使用 $refs 来进行替代  $slots 的获取。</p>\n"},{"layout":"draft","title":"vue3-ref数组","date":"2021-12-09T05:35:22.000Z","_content":"\n\n\n#  Vue3 的 ref数组\n\n## 问题\n\n​\t\t在vue2中，对于循环使用的ref，此时ref的值相同就会形成一个数组\n\n```\n<tags-select-group v-for=\"(item,index) in eventMaps\" ref=\"tagsSelectGroup\" />\n```\n\n​\t\t但是对于Vue3来说，循环的ref并不能生成数组，如果需要使用ref数组，需要使用方法，将ref存入一个数组里面。\n\n```\n<tags-select-group v-for=\"(item,index) in eventMaps\" :ref=\"setTagsSelectGroup\"/>\n\ndata: {\n\ttagsSelectGroup: [],\n},\nbeforeUpdate() {\n\t//在每次更新之前，需要将数组进行清零，避免重复进行push。\n\tthis.tagsSelectGroup.length = 0\n},\nmethods: {\n\t//这个默认不传递参数时使用的参数是 event，所以可以直接使用。当然，也有可能是vue3内部进行了额外的操作？\n\tsetTagsSelectGroup(el) {\n            el && this.tagsSelectGroup.push(el)\n    },\n}\n```\n\n","source":"_drafts/debug/zyyx/vue3-ref数组.md","raw":"---\nlayout: draft\ntitle: vue3-ref数组\ndate: 2021-12-09 13:35:22\ntags:\n - bug\ncategories:\n - bug\n---\n\n\n\n#  Vue3 的 ref数组\n\n## 问题\n\n​\t\t在vue2中，对于循环使用的ref，此时ref的值相同就会形成一个数组\n\n```\n<tags-select-group v-for=\"(item,index) in eventMaps\" ref=\"tagsSelectGroup\" />\n```\n\n​\t\t但是对于Vue3来说，循环的ref并不能生成数组，如果需要使用ref数组，需要使用方法，将ref存入一个数组里面。\n\n```\n<tags-select-group v-for=\"(item,index) in eventMaps\" :ref=\"setTagsSelectGroup\"/>\n\ndata: {\n\ttagsSelectGroup: [],\n},\nbeforeUpdate() {\n\t//在每次更新之前，需要将数组进行清零，避免重复进行push。\n\tthis.tagsSelectGroup.length = 0\n},\nmethods: {\n\t//这个默认不传递参数时使用的参数是 event，所以可以直接使用。当然，也有可能是vue3内部进行了额外的操作？\n\tsetTagsSelectGroup(el) {\n            el && this.tagsSelectGroup.push(el)\n    },\n}\n```\n\n","slug":"debug/zyyx/vue3-ref数组","published":0,"updated":"2021-12-09T05:43:24.501Z","comments":1,"photos":[],"link":"","_id":"ckznhkk8g005oikub37gad84w","content":"<h1 id=\"Vue3-的-ref数组\"><a href=\"#Vue3-的-ref数组\" class=\"headerlink\" title=\"Vue3 的 ref数组\"></a>Vue3 的 ref数组</h1><h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><p>​        在vue2中，对于循环使用的ref，此时ref的值相同就会形成一个数组</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;tags-select-group v-for=&quot;(item,index) in eventMaps&quot; ref=&quot;tagsSelectGroup&quot; /&gt;</span><br></pre></td></tr></table></figure>\n\n<p>​        但是对于Vue3来说，循环的ref并不能生成数组，如果需要使用ref数组，需要使用方法，将ref存入一个数组里面。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;tags-select-group v-for=&quot;(item,index) in eventMaps&quot; :ref=&quot;setTagsSelectGroup&quot;/&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">data: &#123;</span><br><span class=\"line\">\ttagsSelectGroup: [],</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">beforeUpdate() &#123;</span><br><span class=\"line\">\t//在每次更新之前，需要将数组进行清零，避免重复进行push。</span><br><span class=\"line\">\tthis.tagsSelectGroup.length = 0</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">methods: &#123;</span><br><span class=\"line\">\t//这个默认不传递参数时使用的参数是 event，所以可以直接使用。当然，也有可能是vue3内部进行了额外的操作？</span><br><span class=\"line\">\tsetTagsSelectGroup(el) &#123;</span><br><span class=\"line\">            el &amp;&amp; this.tagsSelectGroup.push(el)</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Vue3-的-ref数组\"><a href=\"#Vue3-的-ref数组\" class=\"headerlink\" title=\"Vue3 的 ref数组\"></a>Vue3 的 ref数组</h1><h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><p>​        在vue2中，对于循环使用的ref，此时ref的值相同就会形成一个数组</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;tags-select-group v-for=&quot;(item,index) in eventMaps&quot; ref=&quot;tagsSelectGroup&quot; /&gt;</span><br></pre></td></tr></table></figure>\n\n<p>​        但是对于Vue3来说，循环的ref并不能生成数组，如果需要使用ref数组，需要使用方法，将ref存入一个数组里面。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;tags-select-group v-for=&quot;(item,index) in eventMaps&quot; :ref=&quot;setTagsSelectGroup&quot;/&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">data: &#123;</span><br><span class=\"line\">\ttagsSelectGroup: [],</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">beforeUpdate() &#123;</span><br><span class=\"line\">\t//在每次更新之前，需要将数组进行清零，避免重复进行push。</span><br><span class=\"line\">\tthis.tagsSelectGroup.length = 0</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">methods: &#123;</span><br><span class=\"line\">\t//这个默认不传递参数时使用的参数是 event，所以可以直接使用。当然，也有可能是vue3内部进行了额外的操作？</span><br><span class=\"line\">\tsetTagsSelectGroup(el) &#123;</span><br><span class=\"line\">            el &amp;&amp; this.tagsSelectGroup.push(el)</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n"},{"layout":"draft","title":"vue-v-if和v-show","date":"2021-12-09T02:08:41.000Z","_content":"\n\n\n# v-if 和 v-show\n\n\n\n## bug情况\n\n​\t\t弹窗显示的图不正确，图是使用的canvas进行的绘制。\n\n## 原因\n\n​\t\tv-show 的显示隐藏不会刷新 canvas，所以导致了最开始的时候没有获取正确的图，后面也没有进行改变。\n\n## 总结\n\n​\t\t在自己写UI组件时，最好对于带有插槽部分的隐藏使用 v-if，而不是v-show。虽然v-show可以有一个更快的体验，但是v-show仅仅只是 display:none 的操作。\n\n​\t\t很容易出现没有更新的情况，特别是使用了canvas绘制的。\n\n","source":"_drafts/debug/zyyx/vue3-v-if和v-show.md","raw":"---\nlayout: draft\ntitle: vue-v-if和v-show\ndate: 2021-12-09 10:08:41\ntags:\n - bug\ncategories:\n - bug\n---\n\n\n\n# v-if 和 v-show\n\n\n\n## bug情况\n\n​\t\t弹窗显示的图不正确，图是使用的canvas进行的绘制。\n\n## 原因\n\n​\t\tv-show 的显示隐藏不会刷新 canvas，所以导致了最开始的时候没有获取正确的图，后面也没有进行改变。\n\n## 总结\n\n​\t\t在自己写UI组件时，最好对于带有插槽部分的隐藏使用 v-if，而不是v-show。虽然v-show可以有一个更快的体验，但是v-show仅仅只是 display:none 的操作。\n\n​\t\t很容易出现没有更新的情况，特别是使用了canvas绘制的。\n\n","slug":"debug/zyyx/vue3-v-if和v-show","published":0,"updated":"2021-12-09T02:10:27.034Z","comments":1,"photos":[],"link":"","_id":"ckznhkk8h005rikub841q5bo9","content":"<h1 id=\"v-if-和-v-show\"><a href=\"#v-if-和-v-show\" class=\"headerlink\" title=\"v-if 和 v-show\"></a>v-if 和 v-show</h1><h2 id=\"bug情况\"><a href=\"#bug情况\" class=\"headerlink\" title=\"bug情况\"></a>bug情况</h2><p>​        弹窗显示的图不正确，图是使用的canvas进行的绘制。</p>\n<h2 id=\"原因\"><a href=\"#原因\" class=\"headerlink\" title=\"原因\"></a>原因</h2><p>​        v-show 的显示隐藏不会刷新 canvas，所以导致了最开始的时候没有获取正确的图，后面也没有进行改变。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>​        在自己写UI组件时，最好对于带有插槽部分的隐藏使用 v-if，而不是v-show。虽然v-show可以有一个更快的体验，但是v-show仅仅只是 display:none 的操作。</p>\n<p>​        很容易出现没有更新的情况，特别是使用了canvas绘制的。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"v-if-和-v-show\"><a href=\"#v-if-和-v-show\" class=\"headerlink\" title=\"v-if 和 v-show\"></a>v-if 和 v-show</h1><h2 id=\"bug情况\"><a href=\"#bug情况\" class=\"headerlink\" title=\"bug情况\"></a>bug情况</h2><p>​        弹窗显示的图不正确，图是使用的canvas进行的绘制。</p>\n<h2 id=\"原因\"><a href=\"#原因\" class=\"headerlink\" title=\"原因\"></a>原因</h2><p>​        v-show 的显示隐藏不会刷新 canvas，所以导致了最开始的时候没有获取正确的图，后面也没有进行改变。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>​        在自己写UI组件时，最好对于带有插槽部分的隐藏使用 v-if，而不是v-show。虽然v-show可以有一个更快的体验，但是v-show仅仅只是 display:none 的操作。</p>\n<p>​        很容易出现没有更新的情况，特别是使用了canvas绘制的。</p>\n"},{"title":"Vue-使用-内在","date":"2021-10-29T15:16:15.000Z","_content":"\n\n\n#  内在\n\n## 深入响应式原理\n\n​\t\t在前面我们可以知道，当我们修改了data里面的数据时，视图也会进行更新。这样使得状态的管理非常的直接。\n\n### 如何追踪变化\n\n​\t\tVue会将data里的数据使用 Object.defineProperty ，将这些 property 全部转为 getter/setter。因为 Object.defineProperty 是一个无法shim的特性。所以这也是Vue不支持IE8以及更低的版本的原因。\n\n​\t\tgetter/setter 在 property 被访问和修改的时候通知变更。\n\n​\t\t每一个组件的实例都对应一个 watcher 实例，他会在组件渲染的过程中把 接触过的数据 property 记录为依赖。然后当 setter 触发时，通知 watcher，从而重新渲染。\n\n<img src=\"Vue2-教程-内在\\image-20211214103613477.png\" alt=\"image-20211214103613477\" style=\"zoom:67%;\" />\n\n​\tdata会被变更为 getter和setter，然后在视图使用到数据时，便会调用getter，然后添加入了一个dep依赖(这个是使用一个数组进行维护)。当数据发生改变时，会通过notify通知给watcher，然后watcher将会把dep数组的数据重新渲染。\n\n\n\n### 检测变化的注意事项\n\n​\t\t由于JavaScript的限制，Vue不能检测数组和对象的变化。\n\n#### 对于对象\n\n​\t\t对于对象来说，无法检测 property 的添加或移除。所以property必须在data对象上存在才能让vue将它转换为响应式的。\n\n```\nvar vm = new Vue({\n  data:{\n    a:1\n  }\n})\n\n// `vm.a` 是响应式的\n\nvm.b = 2\n// `vm.b` 是非响应式的\n```\n\n​\t\t对于已经创建的实例，Vue不允许动态添加根级别的响应式 property。但是可以使用 Vue.set(object, propertyName, value) 方法向嵌套对象添加响应式 property。\n\n```\nVue.set(vm.someObject, 'b', 2)\n```\n\n​\t当然可以使用 vm.$set 实例方法，这也是全局 Vue.set 方法的别名\n\n```\nthis.$set(this.someObject, 'b', 2)\n\nthis.$set(this.a, 'b', 123)\n```\n\n​\t\t有时你可能需要为已有的对象赋值多个新的property，比如使用 Object.assign() 或者 _.extend()。但是，这样添加并不会触发事件。此时需要将新的对象返回覆盖才能触发。\n\n```\n// Object.assign(this.someObject, {a:1, b:2})\nthis.someObject = Object.assign({}, this.someObject, {a:1, b:2})\n```\n\n​\t通过这个方法，我们可以知道几个知识点：\n\n* Object.assign 是将第二个参数及其以后的赋值给第一个，对于重复的，会被覆盖，后面的会覆盖前面的。\n\n* 第二点，这里为什么会被更新呢，其实并不是将someObject的内部的对象进行了 getter和setter 操作，而是因为someObject被修改了地址，所以我们也可以知道，这个 Object.defineProperty 是将这个值所指向的位置的监听。\n\n  * 因为对象是堆的存放，而 Object.defineProperty 监听的是栈的值，所以对于对象内部的修改不会被监听到。而将新的对象赋值给了这个对象，此时对象的普通赋值是一个浅拷贝，只拷贝栈值，所以栈被修改了，导致了内部的数据全部都会进行一个监听。\n\n  * 而如果使用 this.$set(this.someObject, 'o', value)的话，仅仅只是将这个o的指向进行了监听，而不会监听其他的错误操作。比如：\n\n    * ```\n      this.a.c = 123\n      // 此时这个d加入了监听，但是对于c来说，并不会加入监听。因为c是一个错误添加方式。虽然不会进行监听，但是 {{ a }}这样的输出还是会将c进行显示的，因为输出的是a，a.c虽然没有加入监听，但是仍然是属于a的。\n      this.$set(this.a, 'd', 1)\n      \n      但是使用 Object.assign\n      这样，对于c来说也会进行监听，因为此时是将原来的this.a进行了栈的修改，对象已经不是一个对象了，此时Vue就会进行一个递归的操作，将新的对象全部进行一个监听。\n      this.a = Object.assign({}, this.a, {a:1, b:2})\n      ```\n\n\n\n#### 对于数组\n\n​\t\tVue对于数组的监听是将数组的方法进行了一个覆盖，在使用原来的方法的同时，也在里面加入了监听的方法，所以对于直接修改数组下标的将不会进行修改。\n\n​\t\tVue不能检测以下数组的变动：\n\n* 通过索引直接进行修改 arr[index] = newValue\n* 修改数组的长度 arr.length = newLength\n\n对于使用 下标进行修改的\n\n```\n这里可以使用，可以考虑JavaScript数组也是对象的想法\nthis.$set(this.arr, index, newValue)\n```\n\n```\nthis.splice(index, 1, newValue)\n```\n\n对于修改数组长度的\n\n```\nthis.arr.splice(newLength)\n```\n\n\n\n### 声明响应式 property\n\n​\t\t我们可以发现，前面的添加数据的方式，要不就是数组方法的添加，要不就是在对象里面进行添加，而并没有直接新添加一个对象的形式。由此可以知道：Vue是不运行动态添加根级响应式property的。对于根级响应式必须要提前进行申明。\n\n\n\n### 异步更新队列\n\n​\t\tVue在更新数据是异步进行更新的。对于数据的变化，Vue将开启一个队列。缓冲同一个事件循环的所有数据变更。如果watcher被多次触发，将只会被推入到队列中一次。这样可以不必要的操作和DOM的计算。然后在下一个事件循环中，在刷新队列执行的实际操作。 Promise.then() 、 MutationObserver 和 setImmediate，如果执行环境不支持，则会采用 setTimeout(fn, 0) 进行代替。\n\n​\t\t当然这样虽然有了好处，节省了性能，但是同时，如果我们要进行dom操作时将会出现问题，因为异步的原因，dom获取的值是在上一次所剩下的。此时便有了一个方法，this.$nextTick(callback)，将方法写入this.$nextTick，然后这个方法将会在下次事件循环，dom操作之后进行获取。\n\n```\nmethods: {\n    updateMessage: function () {\n        this.message = '已更新'\n        console.log(this.$el.textContent) // => '未更新'\n        this.$nextTick(function () {\n\t        console.log(this.$el.textContent) // => '已更新'\n        })\n    }\n}\n```\n\n​\t并且 this.$nextTick 返回的是一个 promise 对象，所以你可以使用新的 async/await 语法完成相同的事情\n\n```\nmethods: {\n  updateMessage: async function () {\n    this.message = '已更新'\n    console.log(this.$el.textContent) // => '未更新'\n    await this.$nextTick()\n    console.log(this.$el.textContent) // => '已更新'\n  }\n}\n```\n\n","source":"_drafts/Vue/Vue2-教程/Vue2-教程-内在.md","raw":"---\ntitle: Vue-使用-内在\ndate: 2021-10-29 23:16:15\ntags:\n - Vue\n - Vue2\n - 文档\ncategories:\n - Vue\n - Vue2\n---\n\n\n\n#  内在\n\n## 深入响应式原理\n\n​\t\t在前面我们可以知道，当我们修改了data里面的数据时，视图也会进行更新。这样使得状态的管理非常的直接。\n\n### 如何追踪变化\n\n​\t\tVue会将data里的数据使用 Object.defineProperty ，将这些 property 全部转为 getter/setter。因为 Object.defineProperty 是一个无法shim的特性。所以这也是Vue不支持IE8以及更低的版本的原因。\n\n​\t\tgetter/setter 在 property 被访问和修改的时候通知变更。\n\n​\t\t每一个组件的实例都对应一个 watcher 实例，他会在组件渲染的过程中把 接触过的数据 property 记录为依赖。然后当 setter 触发时，通知 watcher，从而重新渲染。\n\n<img src=\"Vue2-教程-内在\\image-20211214103613477.png\" alt=\"image-20211214103613477\" style=\"zoom:67%;\" />\n\n​\tdata会被变更为 getter和setter，然后在视图使用到数据时，便会调用getter，然后添加入了一个dep依赖(这个是使用一个数组进行维护)。当数据发生改变时，会通过notify通知给watcher，然后watcher将会把dep数组的数据重新渲染。\n\n\n\n### 检测变化的注意事项\n\n​\t\t由于JavaScript的限制，Vue不能检测数组和对象的变化。\n\n#### 对于对象\n\n​\t\t对于对象来说，无法检测 property 的添加或移除。所以property必须在data对象上存在才能让vue将它转换为响应式的。\n\n```\nvar vm = new Vue({\n  data:{\n    a:1\n  }\n})\n\n// `vm.a` 是响应式的\n\nvm.b = 2\n// `vm.b` 是非响应式的\n```\n\n​\t\t对于已经创建的实例，Vue不允许动态添加根级别的响应式 property。但是可以使用 Vue.set(object, propertyName, value) 方法向嵌套对象添加响应式 property。\n\n```\nVue.set(vm.someObject, 'b', 2)\n```\n\n​\t当然可以使用 vm.$set 实例方法，这也是全局 Vue.set 方法的别名\n\n```\nthis.$set(this.someObject, 'b', 2)\n\nthis.$set(this.a, 'b', 123)\n```\n\n​\t\t有时你可能需要为已有的对象赋值多个新的property，比如使用 Object.assign() 或者 _.extend()。但是，这样添加并不会触发事件。此时需要将新的对象返回覆盖才能触发。\n\n```\n// Object.assign(this.someObject, {a:1, b:2})\nthis.someObject = Object.assign({}, this.someObject, {a:1, b:2})\n```\n\n​\t通过这个方法，我们可以知道几个知识点：\n\n* Object.assign 是将第二个参数及其以后的赋值给第一个，对于重复的，会被覆盖，后面的会覆盖前面的。\n\n* 第二点，这里为什么会被更新呢，其实并不是将someObject的内部的对象进行了 getter和setter 操作，而是因为someObject被修改了地址，所以我们也可以知道，这个 Object.defineProperty 是将这个值所指向的位置的监听。\n\n  * 因为对象是堆的存放，而 Object.defineProperty 监听的是栈的值，所以对于对象内部的修改不会被监听到。而将新的对象赋值给了这个对象，此时对象的普通赋值是一个浅拷贝，只拷贝栈值，所以栈被修改了，导致了内部的数据全部都会进行一个监听。\n\n  * 而如果使用 this.$set(this.someObject, 'o', value)的话，仅仅只是将这个o的指向进行了监听，而不会监听其他的错误操作。比如：\n\n    * ```\n      this.a.c = 123\n      // 此时这个d加入了监听，但是对于c来说，并不会加入监听。因为c是一个错误添加方式。虽然不会进行监听，但是 {{ a }}这样的输出还是会将c进行显示的，因为输出的是a，a.c虽然没有加入监听，但是仍然是属于a的。\n      this.$set(this.a, 'd', 1)\n      \n      但是使用 Object.assign\n      这样，对于c来说也会进行监听，因为此时是将原来的this.a进行了栈的修改，对象已经不是一个对象了，此时Vue就会进行一个递归的操作，将新的对象全部进行一个监听。\n      this.a = Object.assign({}, this.a, {a:1, b:2})\n      ```\n\n\n\n#### 对于数组\n\n​\t\tVue对于数组的监听是将数组的方法进行了一个覆盖，在使用原来的方法的同时，也在里面加入了监听的方法，所以对于直接修改数组下标的将不会进行修改。\n\n​\t\tVue不能检测以下数组的变动：\n\n* 通过索引直接进行修改 arr[index] = newValue\n* 修改数组的长度 arr.length = newLength\n\n对于使用 下标进行修改的\n\n```\n这里可以使用，可以考虑JavaScript数组也是对象的想法\nthis.$set(this.arr, index, newValue)\n```\n\n```\nthis.splice(index, 1, newValue)\n```\n\n对于修改数组长度的\n\n```\nthis.arr.splice(newLength)\n```\n\n\n\n### 声明响应式 property\n\n​\t\t我们可以发现，前面的添加数据的方式，要不就是数组方法的添加，要不就是在对象里面进行添加，而并没有直接新添加一个对象的形式。由此可以知道：Vue是不运行动态添加根级响应式property的。对于根级响应式必须要提前进行申明。\n\n\n\n### 异步更新队列\n\n​\t\tVue在更新数据是异步进行更新的。对于数据的变化，Vue将开启一个队列。缓冲同一个事件循环的所有数据变更。如果watcher被多次触发，将只会被推入到队列中一次。这样可以不必要的操作和DOM的计算。然后在下一个事件循环中，在刷新队列执行的实际操作。 Promise.then() 、 MutationObserver 和 setImmediate，如果执行环境不支持，则会采用 setTimeout(fn, 0) 进行代替。\n\n​\t\t当然这样虽然有了好处，节省了性能，但是同时，如果我们要进行dom操作时将会出现问题，因为异步的原因，dom获取的值是在上一次所剩下的。此时便有了一个方法，this.$nextTick(callback)，将方法写入this.$nextTick，然后这个方法将会在下次事件循环，dom操作之后进行获取。\n\n```\nmethods: {\n    updateMessage: function () {\n        this.message = '已更新'\n        console.log(this.$el.textContent) // => '未更新'\n        this.$nextTick(function () {\n\t        console.log(this.$el.textContent) // => '已更新'\n        })\n    }\n}\n```\n\n​\t并且 this.$nextTick 返回的是一个 promise 对象，所以你可以使用新的 async/await 语法完成相同的事情\n\n```\nmethods: {\n  updateMessage: async function () {\n    this.message = '已更新'\n    console.log(this.$el.textContent) // => '未更新'\n    await this.$nextTick()\n    console.log(this.$el.textContent) // => '已更新'\n  }\n}\n```\n\n","slug":"Vue/Vue2-教程/Vue2-教程-内在","published":0,"updated":"2022-02-07T02:34:46.044Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckznhkk8i005wikubedbffwit","content":"<h1 id=\"内在\"><a href=\"#内在\" class=\"headerlink\" title=\"内在\"></a>内在</h1><h2 id=\"深入响应式原理\"><a href=\"#深入响应式原理\" class=\"headerlink\" title=\"深入响应式原理\"></a>深入响应式原理</h2><p>​        在前面我们可以知道，当我们修改了data里面的数据时，视图也会进行更新。这样使得状态的管理非常的直接。</p>\n<h3 id=\"如何追踪变化\"><a href=\"#如何追踪变化\" class=\"headerlink\" title=\"如何追踪变化\"></a>如何追踪变化</h3><p>​        Vue会将data里的数据使用 Object.defineProperty ，将这些 property 全部转为 getter/setter。因为 Object.defineProperty 是一个无法shim的特性。所以这也是Vue不支持IE8以及更低的版本的原因。</p>\n<p>​        getter/setter 在 property 被访问和修改的时候通知变更。</p>\n<p>​        每一个组件的实例都对应一个 watcher 实例，他会在组件渲染的过程中把 接触过的数据 property 记录为依赖。然后当 setter 触发时，通知 watcher，从而重新渲染。</p>\n<img src=\"/.io//image-20211214103613477.png\" alt=\"image-20211214103613477\" style=\"zoom:67%;\">\n\n<p>​    data会被变更为 getter和setter，然后在视图使用到数据时，便会调用getter，然后添加入了一个dep依赖(这个是使用一个数组进行维护)。当数据发生改变时，会通过notify通知给watcher，然后watcher将会把dep数组的数据重新渲染。</p>\n<h3 id=\"检测变化的注意事项\"><a href=\"#检测变化的注意事项\" class=\"headerlink\" title=\"检测变化的注意事项\"></a>检测变化的注意事项</h3><p>​        由于JavaScript的限制，Vue不能检测数组和对象的变化。</p>\n<h4 id=\"对于对象\"><a href=\"#对于对象\" class=\"headerlink\" title=\"对于对象\"></a>对于对象</h4><p>​        对于对象来说，无法检测 property 的添加或移除。所以property必须在data对象上存在才能让vue将它转换为响应式的。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var vm = new Vue(&#123;</span><br><span class=\"line\">  data:&#123;</span><br><span class=\"line\">    a:1</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">// `vm.a` 是响应式的</span><br><span class=\"line\"></span><br><span class=\"line\">vm.b = 2</span><br><span class=\"line\">// `vm.b` 是非响应式的</span><br></pre></td></tr></table></figure>\n\n<p>​        对于已经创建的实例，Vue不允许动态添加根级别的响应式 property。但是可以使用 Vue.set(object, propertyName, value) 方法向嵌套对象添加响应式 property。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Vue.set(vm.someObject, &#x27;b&#x27;, 2)</span><br></pre></td></tr></table></figure>\n\n<p>​    当然可以使用 vm.$set 实例方法，这也是全局 Vue.set 方法的别名</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">this.$set(this.someObject, &#x27;b&#x27;, 2)</span><br><span class=\"line\"></span><br><span class=\"line\">this.$set(this.a, &#x27;b&#x27;, 123)</span><br></pre></td></tr></table></figure>\n\n<p>​        有时你可能需要为已有的对象赋值多个新的property，比如使用 Object.assign() 或者 _.extend()。但是，这样添加并不会触发事件。此时需要将新的对象返回覆盖才能触发。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Object.assign(this.someObject, &#123;a:1, b:2&#125;)</span><br><span class=\"line\">this.someObject = Object.assign(&#123;&#125;, this.someObject, &#123;a:1, b:2&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>​    通过这个方法，我们可以知道几个知识点：</p>\n<ul>\n<li><p>Object.assign 是将第二个参数及其以后的赋值给第一个，对于重复的，会被覆盖，后面的会覆盖前面的。</p>\n</li>\n<li><p>第二点，这里为什么会被更新呢，其实并不是将someObject的内部的对象进行了 getter和setter 操作，而是因为someObject被修改了地址，所以我们也可以知道，这个 Object.defineProperty 是将这个值所指向的位置的监听。</p>\n<ul>\n<li><p>因为对象是堆的存放，而 Object.defineProperty 监听的是栈的值，所以对于对象内部的修改不会被监听到。而将新的对象赋值给了这个对象，此时对象的普通赋值是一个浅拷贝，只拷贝栈值，所以栈被修改了，导致了内部的数据全部都会进行一个监听。</p>\n</li>\n<li><p>而如果使用 this.$set(this.someObject, ‘o’, value)的话，仅仅只是将这个o的指向进行了监听，而不会监听其他的错误操作。比如：</p>\n<ul>\n<li><pre><code>this.a.c = 123\n// 此时这个d加入了监听，但是对于c来说，并不会加入监听。因为c是一个错误添加方式。虽然不会进行监听，但是 &#123;&#123; a &#125;&#125;这样的输出还是会将c进行显示的，因为输出的是a，a.c虽然没有加入监听，但是仍然是属于a的。\nthis.$set(this.a, &#39;d&#39;, 1)\n\n但是使用 Object.assign\n这样，对于c来说也会进行监听，因为此时是将原来的this.a进行了栈的修改，对象已经不是一个对象了，此时Vue就会进行一个递归的操作，将新的对象全部进行一个监听。\nthis.a = Object.assign(&#123;&#125;, this.a, &#123;a:1, b:2&#125;)\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">#### 对于数组</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\tVue对于数组的监听是将数组的方法进行了一个覆盖，在使用原来的方法的同时，也在里面加入了监听的方法，所以对于直接修改数组下标的将不会进行修改。</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\tVue不能检测以下数组的变动：</span><br><span class=\"line\"></span><br><span class=\"line\">* 通过索引直接进行修改 arr[index] = newValue</span><br><span class=\"line\">* 修改数组的长度 arr.length = newLength</span><br><span class=\"line\"></span><br><span class=\"line\">对于使用 下标进行修改的</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n这里可以使用，可以考虑JavaScript数组也是对象的想法\nthis.$set(this.arr, index, newValue)\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br></pre></td></tr></table></figure>\nthis.splice(index, 1, newValue)\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">对于修改数组长度的</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\nthis.arr.splice(newLength)\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">### 声明响应式 property</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t我们可以发现，前面的添加数据的方式，要不就是数组方法的添加，要不就是在对象里面进行添加，而并没有直接新添加一个对象的形式。由此可以知道：Vue是不运行动态添加根级响应式property的。对于根级响应式必须要提前进行申明。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">### 异步更新队列</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\tVue在更新数据是异步进行更新的。对于数据的变化，Vue将开启一个队列。缓冲同一个事件循环的所有数据变更。如果watcher被多次触发，将只会被推入到队列中一次。这样可以不必要的操作和DOM的计算。然后在下一个事件循环中，在刷新队列执行的实际操作。 Promise.then() 、 MutationObserver 和 setImmediate，如果执行环境不支持，则会采用 setTimeout(fn, 0) 进行代替。</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t当然这样虽然有了好处，节省了性能，但是同时，如果我们要进行dom操作时将会出现问题，因为异步的原因，dom获取的值是在上一次所剩下的。此时便有了一个方法，this.$nextTick(callback)，将方法写入this.$nextTick，然后这个方法将会在下次事件循环，dom操作之后进行获取。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\nmethods: &#123;\nupdateMessage: function () &#123;\n  this.message = &#39;已更新&#39;\n  console.log(this.$el.textContent) // =&gt; &#39;未更新&#39;\n  this.$nextTick(function () &#123;\n      console.log(this.$el.textContent) // =&gt; &#39;已更新&#39;\n  &#125;)\n&#125;\n&#125;\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">​\t并且 this.$nextTick 返回的是一个 promise 对象，所以你可以使用新的 async/await 语法完成相同的事情</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\nmethods: &#123;\nupdateMessage: async function () &#123;\nthis.message = &#39;已更新&#39;\nconsole.log(this.$el.textContent) // =&gt; &#39;未更新&#39;\nawait this.$nextTick()\nconsole.log(this.$el.textContent) // =&gt; &#39;已更新&#39;\n&#125;\n&#125;\n</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"内在\"><a href=\"#内在\" class=\"headerlink\" title=\"内在\"></a>内在</h1><h2 id=\"深入响应式原理\"><a href=\"#深入响应式原理\" class=\"headerlink\" title=\"深入响应式原理\"></a>深入响应式原理</h2><p>​        在前面我们可以知道，当我们修改了data里面的数据时，视图也会进行更新。这样使得状态的管理非常的直接。</p>\n<h3 id=\"如何追踪变化\"><a href=\"#如何追踪变化\" class=\"headerlink\" title=\"如何追踪变化\"></a>如何追踪变化</h3><p>​        Vue会将data里的数据使用 Object.defineProperty ，将这些 property 全部转为 getter/setter。因为 Object.defineProperty 是一个无法shim的特性。所以这也是Vue不支持IE8以及更低的版本的原因。</p>\n<p>​        getter/setter 在 property 被访问和修改的时候通知变更。</p>\n<p>​        每一个组件的实例都对应一个 watcher 实例，他会在组件渲染的过程中把 接触过的数据 property 记录为依赖。然后当 setter 触发时，通知 watcher，从而重新渲染。</p>\n<img src=\"/.io//image-20211214103613477.png\" alt=\"image-20211214103613477\" style=\"zoom:67%;\">\n\n<p>​    data会被变更为 getter和setter，然后在视图使用到数据时，便会调用getter，然后添加入了一个dep依赖(这个是使用一个数组进行维护)。当数据发生改变时，会通过notify通知给watcher，然后watcher将会把dep数组的数据重新渲染。</p>\n<h3 id=\"检测变化的注意事项\"><a href=\"#检测变化的注意事项\" class=\"headerlink\" title=\"检测变化的注意事项\"></a>检测变化的注意事项</h3><p>​        由于JavaScript的限制，Vue不能检测数组和对象的变化。</p>\n<h4 id=\"对于对象\"><a href=\"#对于对象\" class=\"headerlink\" title=\"对于对象\"></a>对于对象</h4><p>​        对于对象来说，无法检测 property 的添加或移除。所以property必须在data对象上存在才能让vue将它转换为响应式的。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var vm = new Vue(&#123;</span><br><span class=\"line\">  data:&#123;</span><br><span class=\"line\">    a:1</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">// `vm.a` 是响应式的</span><br><span class=\"line\"></span><br><span class=\"line\">vm.b = 2</span><br><span class=\"line\">// `vm.b` 是非响应式的</span><br></pre></td></tr></table></figure>\n\n<p>​        对于已经创建的实例，Vue不允许动态添加根级别的响应式 property。但是可以使用 Vue.set(object, propertyName, value) 方法向嵌套对象添加响应式 property。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Vue.set(vm.someObject, &#x27;b&#x27;, 2)</span><br></pre></td></tr></table></figure>\n\n<p>​    当然可以使用 vm.$set 实例方法，这也是全局 Vue.set 方法的别名</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">this.$set(this.someObject, &#x27;b&#x27;, 2)</span><br><span class=\"line\"></span><br><span class=\"line\">this.$set(this.a, &#x27;b&#x27;, 123)</span><br></pre></td></tr></table></figure>\n\n<p>​        有时你可能需要为已有的对象赋值多个新的property，比如使用 Object.assign() 或者 _.extend()。但是，这样添加并不会触发事件。此时需要将新的对象返回覆盖才能触发。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Object.assign(this.someObject, &#123;a:1, b:2&#125;)</span><br><span class=\"line\">this.someObject = Object.assign(&#123;&#125;, this.someObject, &#123;a:1, b:2&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>​    通过这个方法，我们可以知道几个知识点：</p>\n<ul>\n<li><p>Object.assign 是将第二个参数及其以后的赋值给第一个，对于重复的，会被覆盖，后面的会覆盖前面的。</p>\n</li>\n<li><p>第二点，这里为什么会被更新呢，其实并不是将someObject的内部的对象进行了 getter和setter 操作，而是因为someObject被修改了地址，所以我们也可以知道，这个 Object.defineProperty 是将这个值所指向的位置的监听。</p>\n<ul>\n<li><p>因为对象是堆的存放，而 Object.defineProperty 监听的是栈的值，所以对于对象内部的修改不会被监听到。而将新的对象赋值给了这个对象，此时对象的普通赋值是一个浅拷贝，只拷贝栈值，所以栈被修改了，导致了内部的数据全部都会进行一个监听。</p>\n</li>\n<li><p>而如果使用 this.$set(this.someObject, ‘o’, value)的话，仅仅只是将这个o的指向进行了监听，而不会监听其他的错误操作。比如：</p>\n<ul>\n<li><pre><code>this.a.c = 123\n// 此时这个d加入了监听，但是对于c来说，并不会加入监听。因为c是一个错误添加方式。虽然不会进行监听，但是 &#123;&#123; a &#125;&#125;这样的输出还是会将c进行显示的，因为输出的是a，a.c虽然没有加入监听，但是仍然是属于a的。\nthis.$set(this.a, &#39;d&#39;, 1)\n\n但是使用 Object.assign\n这样，对于c来说也会进行监听，因为此时是将原来的this.a进行了栈的修改，对象已经不是一个对象了，此时Vue就会进行一个递归的操作，将新的对象全部进行一个监听。\nthis.a = Object.assign(&#123;&#125;, this.a, &#123;a:1, b:2&#125;)\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">#### 对于数组</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\tVue对于数组的监听是将数组的方法进行了一个覆盖，在使用原来的方法的同时，也在里面加入了监听的方法，所以对于直接修改数组下标的将不会进行修改。</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\tVue不能检测以下数组的变动：</span><br><span class=\"line\"></span><br><span class=\"line\">* 通过索引直接进行修改 arr[index] = newValue</span><br><span class=\"line\">* 修改数组的长度 arr.length = newLength</span><br><span class=\"line\"></span><br><span class=\"line\">对于使用 下标进行修改的</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n这里可以使用，可以考虑JavaScript数组也是对象的想法\nthis.$set(this.arr, index, newValue)\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br></pre></td></tr></table></figure>\nthis.splice(index, 1, newValue)\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">对于修改数组长度的</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\nthis.arr.splice(newLength)\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">### 声明响应式 property</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t我们可以发现，前面的添加数据的方式，要不就是数组方法的添加，要不就是在对象里面进行添加，而并没有直接新添加一个对象的形式。由此可以知道：Vue是不运行动态添加根级响应式property的。对于根级响应式必须要提前进行申明。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">### 异步更新队列</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\tVue在更新数据是异步进行更新的。对于数据的变化，Vue将开启一个队列。缓冲同一个事件循环的所有数据变更。如果watcher被多次触发，将只会被推入到队列中一次。这样可以不必要的操作和DOM的计算。然后在下一个事件循环中，在刷新队列执行的实际操作。 Promise.then() 、 MutationObserver 和 setImmediate，如果执行环境不支持，则会采用 setTimeout(fn, 0) 进行代替。</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t当然这样虽然有了好处，节省了性能，但是同时，如果我们要进行dom操作时将会出现问题，因为异步的原因，dom获取的值是在上一次所剩下的。此时便有了一个方法，this.$nextTick(callback)，将方法写入this.$nextTick，然后这个方法将会在下次事件循环，dom操作之后进行获取。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\nmethods: &#123;\nupdateMessage: function () &#123;\n  this.message = &#39;已更新&#39;\n  console.log(this.$el.textContent) // =&gt; &#39;未更新&#39;\n  this.$nextTick(function () &#123;\n      console.log(this.$el.textContent) // =&gt; &#39;已更新&#39;\n  &#125;)\n&#125;\n&#125;\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">​\t并且 this.$nextTick 返回的是一个 promise 对象，所以你可以使用新的 async/await 语法完成相同的事情</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\nmethods: &#123;\nupdateMessage: async function () &#123;\nthis.message = &#39;已更新&#39;\nconsole.log(this.$el.textContent) // =&gt; &#39;未更新&#39;\nawait this.$nextTick()\nconsole.log(this.$el.textContent) // =&gt; &#39;已更新&#39;\n&#125;\n&#125;\n</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n"},{"title":"Vue-使用-工具","date":"2021-10-29T15:15:41.000Z","_content":"\n\n\n#  Vue2教程-工具\n\n## 单文件组件\n\n### 介绍\n\n​\t\t在开始的Vue项目中，我们使用 Vue.component 来定义全局组件，然后使用 new Vue({el: '#xx'}) 在每个页面内指定一个容器元素。\n\n* **全局定义**：强制要求每个 component 中的命名不重复\n* **字符串模板**：缺乏语法高亮，在HTML有多行的时候，需要用到 \\\n* **不支持CSS**：意味着当 HTML 和 JavaScript 组件化时，CSS 明显被遗漏\n* **没有构建步骤**：限制只能使用 HTML 和 ES5 JavaScript，而不能使用预处理器，如 Pug(formerly Jade) 和 Babel\n\n​\t因此对应的 .vue 单文件组件便解决了上述的方法。并且还可以使用 webpack 和 Browserify 等构建工具。\n\n#### 怎么看待关注点分离\n\n​\t\t关注点分离不等于文件类型分离。现代的UI开发中，相比于将代码分成三大层次相互交织，我们将其划分为松散耦合的组件在将其组合起来更合理一些。\n\n​\t\t在一个组件中，模板，逻辑和样式都是内部耦合的。但是组件和组件之间时解耦的。\n\n​\t当然，我们也仍然可以将 JavaScript、css 分离成独立的文件然后做到热重载和预编译。\n\n\n\n### 起步\n\n#### 例子沙箱\n\n#### 针对刚接触JavaScript模块开发系统的用户\n\n#### 针对高级用户\n\n​\t\tCLI 会为你搞定大多数工具的配置问题，同时也支持细粒度自定义[配置项](https://cli.vuejs.org/zh/config/)。\n\n​\t\t有时你会想从零搭建你自己的构建工具，这时你需要通过 [Vue Loader](https://vue-loader.vuejs.org/zh/) 手动配置 webpack。关于学习更多 webpack 的内容，请查阅[其官方文档](https://webpack.js.org/configuration/)和 [Webpack Academy](https://webpack.academy/p/the-core-concepts)。\n\n​\t分别看看上面的 cli loader webpack 来进行详细的了解。\n\n\n\n## 测试\n\n## TypeScript 支持\n\n## 生成环境部署\n\n### 开启生产环境模式\n\n### 模板预编译\n\n### 提取组件的CSS\n\n### 跟踪运行时错误\n","source":"_drafts/Vue/Vue2-教程/Vue2-教程-工具.md","raw":"---\ntitle: Vue-使用-工具\ndate: 2021-10-29 23:15:41\ntags:\n - Vue\n - Vue2\n - 文档\ncategories:\n - Vue\n - Vue2\n---\n\n\n\n#  Vue2教程-工具\n\n## 单文件组件\n\n### 介绍\n\n​\t\t在开始的Vue项目中，我们使用 Vue.component 来定义全局组件，然后使用 new Vue({el: '#xx'}) 在每个页面内指定一个容器元素。\n\n* **全局定义**：强制要求每个 component 中的命名不重复\n* **字符串模板**：缺乏语法高亮，在HTML有多行的时候，需要用到 \\\n* **不支持CSS**：意味着当 HTML 和 JavaScript 组件化时，CSS 明显被遗漏\n* **没有构建步骤**：限制只能使用 HTML 和 ES5 JavaScript，而不能使用预处理器，如 Pug(formerly Jade) 和 Babel\n\n​\t因此对应的 .vue 单文件组件便解决了上述的方法。并且还可以使用 webpack 和 Browserify 等构建工具。\n\n#### 怎么看待关注点分离\n\n​\t\t关注点分离不等于文件类型分离。现代的UI开发中，相比于将代码分成三大层次相互交织，我们将其划分为松散耦合的组件在将其组合起来更合理一些。\n\n​\t\t在一个组件中，模板，逻辑和样式都是内部耦合的。但是组件和组件之间时解耦的。\n\n​\t当然，我们也仍然可以将 JavaScript、css 分离成独立的文件然后做到热重载和预编译。\n\n\n\n### 起步\n\n#### 例子沙箱\n\n#### 针对刚接触JavaScript模块开发系统的用户\n\n#### 针对高级用户\n\n​\t\tCLI 会为你搞定大多数工具的配置问题，同时也支持细粒度自定义[配置项](https://cli.vuejs.org/zh/config/)。\n\n​\t\t有时你会想从零搭建你自己的构建工具，这时你需要通过 [Vue Loader](https://vue-loader.vuejs.org/zh/) 手动配置 webpack。关于学习更多 webpack 的内容，请查阅[其官方文档](https://webpack.js.org/configuration/)和 [Webpack Academy](https://webpack.academy/p/the-core-concepts)。\n\n​\t分别看看上面的 cli loader webpack 来进行详细的了解。\n\n\n\n## 测试\n\n## TypeScript 支持\n\n## 生成环境部署\n\n### 开启生产环境模式\n\n### 模板预编译\n\n### 提取组件的CSS\n\n### 跟踪运行时错误\n","slug":"Vue/Vue2-教程/Vue2-教程-工具","published":0,"updated":"2022-02-07T02:21:09.154Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckznhkk8i005zikubdlliemkp","content":"<h1 id=\"Vue2教程-工具\"><a href=\"#Vue2教程-工具\" class=\"headerlink\" title=\"Vue2教程-工具\"></a>Vue2教程-工具</h1><h2 id=\"单文件组件\"><a href=\"#单文件组件\" class=\"headerlink\" title=\"单文件组件\"></a>单文件组件</h2><h3 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h3><p>​        在开始的Vue项目中，我们使用 Vue.component 来定义全局组件，然后使用 new Vue({el: ‘#xx’}) 在每个页面内指定一个容器元素。</p>\n<ul>\n<li><strong>全局定义</strong>：强制要求每个 component 中的命名不重复</li>\n<li><strong>字符串模板</strong>：缺乏语法高亮，在HTML有多行的时候，需要用到 \\</li>\n<li><strong>不支持CSS</strong>：意味着当 HTML 和 JavaScript 组件化时，CSS 明显被遗漏</li>\n<li><strong>没有构建步骤</strong>：限制只能使用 HTML 和 ES5 JavaScript，而不能使用预处理器，如 Pug(formerly Jade) 和 Babel</li>\n</ul>\n<p>​    因此对应的 .vue 单文件组件便解决了上述的方法。并且还可以使用 webpack 和 Browserify 等构建工具。</p>\n<h4 id=\"怎么看待关注点分离\"><a href=\"#怎么看待关注点分离\" class=\"headerlink\" title=\"怎么看待关注点分离\"></a>怎么看待关注点分离</h4><p>​        关注点分离不等于文件类型分离。现代的UI开发中，相比于将代码分成三大层次相互交织，我们将其划分为松散耦合的组件在将其组合起来更合理一些。</p>\n<p>​        在一个组件中，模板，逻辑和样式都是内部耦合的。但是组件和组件之间时解耦的。</p>\n<p>​    当然，我们也仍然可以将 JavaScript、css 分离成独立的文件然后做到热重载和预编译。</p>\n<h3 id=\"起步\"><a href=\"#起步\" class=\"headerlink\" title=\"起步\"></a>起步</h3><h4 id=\"例子沙箱\"><a href=\"#例子沙箱\" class=\"headerlink\" title=\"例子沙箱\"></a>例子沙箱</h4><h4 id=\"针对刚接触JavaScript模块开发系统的用户\"><a href=\"#针对刚接触JavaScript模块开发系统的用户\" class=\"headerlink\" title=\"针对刚接触JavaScript模块开发系统的用户\"></a>针对刚接触JavaScript模块开发系统的用户</h4><h4 id=\"针对高级用户\"><a href=\"#针对高级用户\" class=\"headerlink\" title=\"针对高级用户\"></a>针对高级用户</h4><p>​        CLI 会为你搞定大多数工具的配置问题，同时也支持细粒度自定义<a href=\"https://cli.vuejs.org/zh/config/\">配置项</a>。</p>\n<p>​        有时你会想从零搭建你自己的构建工具，这时你需要通过 <a href=\"https://vue-loader.vuejs.org/zh/\">Vue Loader</a> 手动配置 webpack。关于学习更多 webpack 的内容，请查阅<a href=\"https://webpack.js.org/configuration/\">其官方文档</a>和 <a href=\"https://webpack.academy/p/the-core-concepts\">Webpack Academy</a>。</p>\n<p>​    分别看看上面的 cli loader webpack 来进行详细的了解。</p>\n<h2 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h2><h2 id=\"TypeScript-支持\"><a href=\"#TypeScript-支持\" class=\"headerlink\" title=\"TypeScript 支持\"></a>TypeScript 支持</h2><h2 id=\"生成环境部署\"><a href=\"#生成环境部署\" class=\"headerlink\" title=\"生成环境部署\"></a>生成环境部署</h2><h3 id=\"开启生产环境模式\"><a href=\"#开启生产环境模式\" class=\"headerlink\" title=\"开启生产环境模式\"></a>开启生产环境模式</h3><h3 id=\"模板预编译\"><a href=\"#模板预编译\" class=\"headerlink\" title=\"模板预编译\"></a>模板预编译</h3><h3 id=\"提取组件的CSS\"><a href=\"#提取组件的CSS\" class=\"headerlink\" title=\"提取组件的CSS\"></a>提取组件的CSS</h3><h3 id=\"跟踪运行时错误\"><a href=\"#跟踪运行时错误\" class=\"headerlink\" title=\"跟踪运行时错误\"></a>跟踪运行时错误</h3>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Vue2教程-工具\"><a href=\"#Vue2教程-工具\" class=\"headerlink\" title=\"Vue2教程-工具\"></a>Vue2教程-工具</h1><h2 id=\"单文件组件\"><a href=\"#单文件组件\" class=\"headerlink\" title=\"单文件组件\"></a>单文件组件</h2><h3 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h3><p>​        在开始的Vue项目中，我们使用 Vue.component 来定义全局组件，然后使用 new Vue({el: ‘#xx’}) 在每个页面内指定一个容器元素。</p>\n<ul>\n<li><strong>全局定义</strong>：强制要求每个 component 中的命名不重复</li>\n<li><strong>字符串模板</strong>：缺乏语法高亮，在HTML有多行的时候，需要用到 \\</li>\n<li><strong>不支持CSS</strong>：意味着当 HTML 和 JavaScript 组件化时，CSS 明显被遗漏</li>\n<li><strong>没有构建步骤</strong>：限制只能使用 HTML 和 ES5 JavaScript，而不能使用预处理器，如 Pug(formerly Jade) 和 Babel</li>\n</ul>\n<p>​    因此对应的 .vue 单文件组件便解决了上述的方法。并且还可以使用 webpack 和 Browserify 等构建工具。</p>\n<h4 id=\"怎么看待关注点分离\"><a href=\"#怎么看待关注点分离\" class=\"headerlink\" title=\"怎么看待关注点分离\"></a>怎么看待关注点分离</h4><p>​        关注点分离不等于文件类型分离。现代的UI开发中，相比于将代码分成三大层次相互交织，我们将其划分为松散耦合的组件在将其组合起来更合理一些。</p>\n<p>​        在一个组件中，模板，逻辑和样式都是内部耦合的。但是组件和组件之间时解耦的。</p>\n<p>​    当然，我们也仍然可以将 JavaScript、css 分离成独立的文件然后做到热重载和预编译。</p>\n<h3 id=\"起步\"><a href=\"#起步\" class=\"headerlink\" title=\"起步\"></a>起步</h3><h4 id=\"例子沙箱\"><a href=\"#例子沙箱\" class=\"headerlink\" title=\"例子沙箱\"></a>例子沙箱</h4><h4 id=\"针对刚接触JavaScript模块开发系统的用户\"><a href=\"#针对刚接触JavaScript模块开发系统的用户\" class=\"headerlink\" title=\"针对刚接触JavaScript模块开发系统的用户\"></a>针对刚接触JavaScript模块开发系统的用户</h4><h4 id=\"针对高级用户\"><a href=\"#针对高级用户\" class=\"headerlink\" title=\"针对高级用户\"></a>针对高级用户</h4><p>​        CLI 会为你搞定大多数工具的配置问题，同时也支持细粒度自定义<a href=\"https://cli.vuejs.org/zh/config/\">配置项</a>。</p>\n<p>​        有时你会想从零搭建你自己的构建工具，这时你需要通过 <a href=\"https://vue-loader.vuejs.org/zh/\">Vue Loader</a> 手动配置 webpack。关于学习更多 webpack 的内容，请查阅<a href=\"https://webpack.js.org/configuration/\">其官方文档</a>和 <a href=\"https://webpack.academy/p/the-core-concepts\">Webpack Academy</a>。</p>\n<p>​    分别看看上面的 cli loader webpack 来进行详细的了解。</p>\n<h2 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h2><h2 id=\"TypeScript-支持\"><a href=\"#TypeScript-支持\" class=\"headerlink\" title=\"TypeScript 支持\"></a>TypeScript 支持</h2><h2 id=\"生成环境部署\"><a href=\"#生成环境部署\" class=\"headerlink\" title=\"生成环境部署\"></a>生成环境部署</h2><h3 id=\"开启生产环境模式\"><a href=\"#开启生产环境模式\" class=\"headerlink\" title=\"开启生产环境模式\"></a>开启生产环境模式</h3><h3 id=\"模板预编译\"><a href=\"#模板预编译\" class=\"headerlink\" title=\"模板预编译\"></a>模板预编译</h3><h3 id=\"提取组件的CSS\"><a href=\"#提取组件的CSS\" class=\"headerlink\" title=\"提取组件的CSS\"></a>提取组件的CSS</h3><h3 id=\"跟踪运行时错误\"><a href=\"#跟踪运行时错误\" class=\"headerlink\" title=\"跟踪运行时错误\"></a>跟踪运行时错误</h3>"},{"title":"router3源码初学","date":"2022-02-11T08:00:22.000Z","_content":"\n\n\n# router3 源码初学\n\n​\t\t最近在学vue-router，然后在学习的过程中，顺便简单的翻阅翻阅源码来看看一些问题。后续也会认真的查看源码部分。\n\n​\t\t这个是 vue2 的部分。\n\n\n\n## beforeRouteEnter\n\n​\t\t在 beforeRouteEnter 中，我们发现如果在创建方法的时候创建了回调函数\n\n​\t\t我们发现如果定义了形参，那么就需要调用，否则就会无法跳转。这就很奇怪。\n\n\n\n​\t\t所以我现在先看看代码，因为是第一次看，所以也有很多看不懂，所以会猜测。\n\n先，在src目录里面搜寻 **beforeRouteEnter** ，然后查看 src/history/base 里面存在这个。**extractEnterGuards**\n\n![image-20220211173002676](router3源码\\image-20220211173002676.png)\n\n​\t\t可以发现，是在这里进行了使用。这个函数就是通过传递一个**activated**数组。然后调用 **extractGuards** 。这里activated就是路由匹配后，会处于routeEnter状态的路由数组。\n\n​\t\t![image-20220211173238506](router3源码/image-20220211173238506.png)\n\n​\t\t这个函数就是创建 guards，获取**flatMapComponents** 返回的数据。然后再调用**flatten** 作为返回值。\n\n​\t\t**flatMapComponents** 方法就是将每个matched里面的数组元素进行传递给 **flatten** \n\n其中，是从m.componets 里面获取key，然后循环，拿出 自己的 组件，实例，和m，key。然后传递给fn 进行调用，然后将返回值作为一个数组，然后循环了matched的length那么多次，最后返回给了 **flatten** 进行了合并。\n\n![image-20220211175019270](router3源码/image-20220211175019270.png) \n\n​\t\t**flatten** 合并数组，扁平化处理。\n\n这个是 route.matched 的路由数组\n\n<img src=\"router3源码/image-20220211184544135.png\" alt=\"image-20220211184544135\" style=\"zoom:67%;\" />\n\n这里传递的参数是，先 matched.map(m => {})，先取出匹配上的路由。进行循环。然后将路由里面的 m.components 就是获取路由里面的components，默认就是一个 default，然后就是map循环路由里面的components。然后取出components。instances，路由本身。key（就是组件名字。）\n\n<img src=\"router3源码/image-20220211190158819.png\" alt=\"image-20220211190158819\" style=\"zoom:67%;\" />\n\n\n\n![image-20220211173522407](router3源码/image-20220211173522407.png)\n\n```\n[1, 2], [2, 3] => [1, 2, 2, 3]\n```\n\n**flatMapComponents** 的fn是传递的方法\n\n![image-20220211174408513](router3源码/image-20220211174408513.png)\n\n​\t\t**guard**：就是调用这个 extractGuard 的返回值，参数分别为 def：m.components[key] 和 name beforeRouteEnter。\n\n![image-20220211175554195](router3源码/image-20220211175554195.png)\n\n​\t\t这个方法，先判断 def 是不是一个函数。然后对于不是函数的，调用 Vue.extend 方法。这个方法通过查看 API 可以知道是。\n\n<img src=\"router3源码/image-20220211175816841.png\" alt=\"image-20220211175816841\" style=\"zoom:67%;\" />\n\n​\t\t简单来看，就像是，先将def进行了extend，然后拿出里面的 options 的 beforeRouteEnter 参数。就是说从组件里面取出beforeRouteEnter方法。\n\n<img src=\"router3源码/image-20220211180402862.png\" alt=\"image-20220211180402862\" style=\"zoom:67%;\" />\n\n​\t\t所以，知道了 guard 是返回一个 自己定义的 **beforeRouteEnter** 方法。同时 **Vue.extend(def).options['beforeRouteEnter']** 返回的是一个数组（这里我认为应该是Vue的处理，方便混入或者其他情况的解决。但是对于源码我还没有了解。所以不怎么清楚）。\n\n\n\n​\t\t然后继续进入 **flatMapComponents** 查看 322 行。进行bind方法的调用（bind 函数是**extractGuards** 传递过来的一个方法）。\n\n![image-20220211185433641](router3源码/image-20220211185433641.png)\n\n​\t\t通过查看 extractEnterGuards 可以发现，这个会调用bind，然后return 一个 bindEnterGuard。\n\n![image-20220211190859440](router3源码/image-20220211190859440.png)\n\n​\t\t我们可以查看 bindEnterGuard 方法。来查看里面的跳转情况。\n\n​\t\t这个方法就是返回一个 routeEnterGuard 方法。然后在方法里面会返回一个guard的调用的返回值。这里guard 就是对应的 **beforeRouteEnter** 方法。\n\n​\t\t通过这个方法我们可以知道，**routeEnterGuard** 里面 guard 是我们自定的 **beforeRouteEnter** 方法。里面的参数中，第三个参数的箭头函数，就是代表了我们的 **beforeRouteEnter** 方法中的 next。同时我们如果输出next也可以发现是正确的。\n\n​\t\t所以我们在 beforeRouteEnter 里面调用next() ，其实就是调用这个方法。然后如果我们传递了参数，那么我们就会进行里面的操作。\n\n<img src=\"router3源码/image-20220211191050870.png\" alt=\"image-20220211191050870\" style=\"zoom:67%;\" />\n\n​\t\t同时我们发现，如果我们不调用next方法。这个 guard方法是不会调用的。\n","source":"_drafts/router/源码/router3源码.md","raw":"---\ntitle: router3源码初学\ndate: 2022-02-11 16:00:22\ntags:\n - router\ncategories:\n - router\n---\n\n\n\n# router3 源码初学\n\n​\t\t最近在学vue-router，然后在学习的过程中，顺便简单的翻阅翻阅源码来看看一些问题。后续也会认真的查看源码部分。\n\n​\t\t这个是 vue2 的部分。\n\n\n\n## beforeRouteEnter\n\n​\t\t在 beforeRouteEnter 中，我们发现如果在创建方法的时候创建了回调函数\n\n​\t\t我们发现如果定义了形参，那么就需要调用，否则就会无法跳转。这就很奇怪。\n\n\n\n​\t\t所以我现在先看看代码，因为是第一次看，所以也有很多看不懂，所以会猜测。\n\n先，在src目录里面搜寻 **beforeRouteEnter** ，然后查看 src/history/base 里面存在这个。**extractEnterGuards**\n\n![image-20220211173002676](router3源码\\image-20220211173002676.png)\n\n​\t\t可以发现，是在这里进行了使用。这个函数就是通过传递一个**activated**数组。然后调用 **extractGuards** 。这里activated就是路由匹配后，会处于routeEnter状态的路由数组。\n\n​\t\t![image-20220211173238506](router3源码/image-20220211173238506.png)\n\n​\t\t这个函数就是创建 guards，获取**flatMapComponents** 返回的数据。然后再调用**flatten** 作为返回值。\n\n​\t\t**flatMapComponents** 方法就是将每个matched里面的数组元素进行传递给 **flatten** \n\n其中，是从m.componets 里面获取key，然后循环，拿出 自己的 组件，实例，和m，key。然后传递给fn 进行调用，然后将返回值作为一个数组，然后循环了matched的length那么多次，最后返回给了 **flatten** 进行了合并。\n\n![image-20220211175019270](router3源码/image-20220211175019270.png) \n\n​\t\t**flatten** 合并数组，扁平化处理。\n\n这个是 route.matched 的路由数组\n\n<img src=\"router3源码/image-20220211184544135.png\" alt=\"image-20220211184544135\" style=\"zoom:67%;\" />\n\n这里传递的参数是，先 matched.map(m => {})，先取出匹配上的路由。进行循环。然后将路由里面的 m.components 就是获取路由里面的components，默认就是一个 default，然后就是map循环路由里面的components。然后取出components。instances，路由本身。key（就是组件名字。）\n\n<img src=\"router3源码/image-20220211190158819.png\" alt=\"image-20220211190158819\" style=\"zoom:67%;\" />\n\n\n\n![image-20220211173522407](router3源码/image-20220211173522407.png)\n\n```\n[1, 2], [2, 3] => [1, 2, 2, 3]\n```\n\n**flatMapComponents** 的fn是传递的方法\n\n![image-20220211174408513](router3源码/image-20220211174408513.png)\n\n​\t\t**guard**：就是调用这个 extractGuard 的返回值，参数分别为 def：m.components[key] 和 name beforeRouteEnter。\n\n![image-20220211175554195](router3源码/image-20220211175554195.png)\n\n​\t\t这个方法，先判断 def 是不是一个函数。然后对于不是函数的，调用 Vue.extend 方法。这个方法通过查看 API 可以知道是。\n\n<img src=\"router3源码/image-20220211175816841.png\" alt=\"image-20220211175816841\" style=\"zoom:67%;\" />\n\n​\t\t简单来看，就像是，先将def进行了extend，然后拿出里面的 options 的 beforeRouteEnter 参数。就是说从组件里面取出beforeRouteEnter方法。\n\n<img src=\"router3源码/image-20220211180402862.png\" alt=\"image-20220211180402862\" style=\"zoom:67%;\" />\n\n​\t\t所以，知道了 guard 是返回一个 自己定义的 **beforeRouteEnter** 方法。同时 **Vue.extend(def).options['beforeRouteEnter']** 返回的是一个数组（这里我认为应该是Vue的处理，方便混入或者其他情况的解决。但是对于源码我还没有了解。所以不怎么清楚）。\n\n\n\n​\t\t然后继续进入 **flatMapComponents** 查看 322 行。进行bind方法的调用（bind 函数是**extractGuards** 传递过来的一个方法）。\n\n![image-20220211185433641](router3源码/image-20220211185433641.png)\n\n​\t\t通过查看 extractEnterGuards 可以发现，这个会调用bind，然后return 一个 bindEnterGuard。\n\n![image-20220211190859440](router3源码/image-20220211190859440.png)\n\n​\t\t我们可以查看 bindEnterGuard 方法。来查看里面的跳转情况。\n\n​\t\t这个方法就是返回一个 routeEnterGuard 方法。然后在方法里面会返回一个guard的调用的返回值。这里guard 就是对应的 **beforeRouteEnter** 方法。\n\n​\t\t通过这个方法我们可以知道，**routeEnterGuard** 里面 guard 是我们自定的 **beforeRouteEnter** 方法。里面的参数中，第三个参数的箭头函数，就是代表了我们的 **beforeRouteEnter** 方法中的 next。同时我们如果输出next也可以发现是正确的。\n\n​\t\t所以我们在 beforeRouteEnter 里面调用next() ，其实就是调用这个方法。然后如果我们传递了参数，那么我们就会进行里面的操作。\n\n<img src=\"router3源码/image-20220211191050870.png\" alt=\"image-20220211191050870\" style=\"zoom:67%;\" />\n\n​\t\t同时我们发现，如果我们不调用next方法。这个 guard方法是不会调用的。\n","slug":"router/源码/router3源码","published":0,"updated":"2022-02-11T11:59:18.727Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckznhkk8j0063ikub543ohjqy","content":"<h1 id=\"router3-源码初学\"><a href=\"#router3-源码初学\" class=\"headerlink\" title=\"router3 源码初学\"></a>router3 源码初学</h1><p>​        最近在学vue-router，然后在学习的过程中，顺便简单的翻阅翻阅源码来看看一些问题。后续也会认真的查看源码部分。</p>\n<p>​        这个是 vue2 的部分。</p>\n<h2 id=\"beforeRouteEnter\"><a href=\"#beforeRouteEnter\" class=\"headerlink\" title=\"beforeRouteEnter\"></a>beforeRouteEnter</h2><p>​        在 beforeRouteEnter 中，我们发现如果在创建方法的时候创建了回调函数</p>\n<p>​        我们发现如果定义了形参，那么就需要调用，否则就会无法跳转。这就很奇怪。</p>\n<p>​        所以我现在先看看代码，因为是第一次看，所以也有很多看不懂，所以会猜测。</p>\n<p>先，在src目录里面搜寻 <strong>beforeRouteEnter</strong> ，然后查看 src/history/base 里面存在这个。<strong>extractEnterGuards</strong></p>\n<p><img src=\"/.io//router3%E6%BA%90%E7%A0%81%5Cimage-20220211173002676.png\" alt=\"image-20220211173002676\"></p>\n<p>​        可以发现，是在这里进行了使用。这个函数就是通过传递一个<strong>activated</strong>数组。然后调用 <strong>extractGuards</strong> 。这里activated就是路由匹配后，会处于routeEnter状态的路由数组。</p>\n<p>​        <img src=\"/.io//image-20220211173238506.png\" alt=\"image-20220211173238506\"></p>\n<p>​        这个函数就是创建 guards，获取<strong>flatMapComponents</strong> 返回的数据。然后再调用<strong>flatten</strong> 作为返回值。</p>\n<p>​        <strong>flatMapComponents</strong> 方法就是将每个matched里面的数组元素进行传递给 <strong>flatten</strong> </p>\n<p>其中，是从m.componets 里面获取key，然后循环，拿出 自己的 组件，实例，和m，key。然后传递给fn 进行调用，然后将返回值作为一个数组，然后循环了matched的length那么多次，最后返回给了 <strong>flatten</strong> 进行了合并。</p>\n<p><img src=\"/.io//image-20220211175019270.png\" alt=\"image-20220211175019270\"> </p>\n<p>​        <strong>flatten</strong> 合并数组，扁平化处理。</p>\n<p>这个是 route.matched 的路由数组</p>\n<img src=\"/.io//image-20220211184544135.png\" alt=\"image-20220211184544135\" style=\"zoom:67%;\">\n\n<p>这里传递的参数是，先 matched.map(m =&gt; {})，先取出匹配上的路由。进行循环。然后将路由里面的 m.components 就是获取路由里面的components，默认就是一个 default，然后就是map循环路由里面的components。然后取出components。instances，路由本身。key（就是组件名字。）</p>\n<img src=\"/.io//image-20220211190158819.png\" alt=\"image-20220211190158819\" style=\"zoom:67%;\">\n\n\n\n<p><img src=\"/.io//image-20220211173522407.png\" alt=\"image-20220211173522407\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[1, 2], [2, 3] =&gt; [1, 2, 2, 3]</span><br></pre></td></tr></table></figure>\n\n<p><strong>flatMapComponents</strong> 的fn是传递的方法</p>\n<p><img src=\"/.io//image-20220211174408513.png\" alt=\"image-20220211174408513\"></p>\n<p>​        <strong>guard</strong>：就是调用这个 extractGuard 的返回值，参数分别为 def：m.components[key] 和 name beforeRouteEnter。</p>\n<p><img src=\"/.io//image-20220211175554195.png\" alt=\"image-20220211175554195\"></p>\n<p>​        这个方法，先判断 def 是不是一个函数。然后对于不是函数的，调用 Vue.extend 方法。这个方法通过查看 API 可以知道是。</p>\n<img src=\"/.io//image-20220211175816841.png\" alt=\"image-20220211175816841\" style=\"zoom:67%;\">\n\n<p>​        简单来看，就像是，先将def进行了extend，然后拿出里面的 options 的 beforeRouteEnter 参数。就是说从组件里面取出beforeRouteEnter方法。</p>\n<img src=\"/.io//image-20220211180402862.png\" alt=\"image-20220211180402862\" style=\"zoom:67%;\">\n\n<p>​        所以，知道了 guard 是返回一个 自己定义的 <strong>beforeRouteEnter</strong> 方法。同时 <strong>Vue.extend(def).options[‘beforeRouteEnter’]</strong> 返回的是一个数组（这里我认为应该是Vue的处理，方便混入或者其他情况的解决。但是对于源码我还没有了解。所以不怎么清楚）。</p>\n<p>​        然后继续进入 <strong>flatMapComponents</strong> 查看 322 行。进行bind方法的调用（bind 函数是<strong>extractGuards</strong> 传递过来的一个方法）。</p>\n<p><img src=\"/.io//image-20220211185433641.png\" alt=\"image-20220211185433641\"></p>\n<p>​        通过查看 extractEnterGuards 可以发现，这个会调用bind，然后return 一个 bindEnterGuard。</p>\n<p><img src=\"/.io//image-20220211190859440.png\" alt=\"image-20220211190859440\"></p>\n<p>​        我们可以查看 bindEnterGuard 方法。来查看里面的跳转情况。</p>\n<p>​        这个方法就是返回一个 routeEnterGuard 方法。然后在方法里面会返回一个guard的调用的返回值。这里guard 就是对应的 <strong>beforeRouteEnter</strong> 方法。</p>\n<p>​        通过这个方法我们可以知道，<strong>routeEnterGuard</strong> 里面 guard 是我们自定的 <strong>beforeRouteEnter</strong> 方法。里面的参数中，第三个参数的箭头函数，就是代表了我们的 <strong>beforeRouteEnter</strong> 方法中的 next。同时我们如果输出next也可以发现是正确的。</p>\n<p>​        所以我们在 beforeRouteEnter 里面调用next() ，其实就是调用这个方法。然后如果我们传递了参数，那么我们就会进行里面的操作。</p>\n<img src=\"/.io//image-20220211191050870.png\" alt=\"image-20220211191050870\" style=\"zoom:67%;\">\n\n<p>​        同时我们发现，如果我们不调用next方法。这个 guard方法是不会调用的。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"router3-源码初学\"><a href=\"#router3-源码初学\" class=\"headerlink\" title=\"router3 源码初学\"></a>router3 源码初学</h1><p>​        最近在学vue-router，然后在学习的过程中，顺便简单的翻阅翻阅源码来看看一些问题。后续也会认真的查看源码部分。</p>\n<p>​        这个是 vue2 的部分。</p>\n<h2 id=\"beforeRouteEnter\"><a href=\"#beforeRouteEnter\" class=\"headerlink\" title=\"beforeRouteEnter\"></a>beforeRouteEnter</h2><p>​        在 beforeRouteEnter 中，我们发现如果在创建方法的时候创建了回调函数</p>\n<p>​        我们发现如果定义了形参，那么就需要调用，否则就会无法跳转。这就很奇怪。</p>\n<p>​        所以我现在先看看代码，因为是第一次看，所以也有很多看不懂，所以会猜测。</p>\n<p>先，在src目录里面搜寻 <strong>beforeRouteEnter</strong> ，然后查看 src/history/base 里面存在这个。<strong>extractEnterGuards</strong></p>\n<p><img src=\"/.io//router3%E6%BA%90%E7%A0%81%5Cimage-20220211173002676.png\" alt=\"image-20220211173002676\"></p>\n<p>​        可以发现，是在这里进行了使用。这个函数就是通过传递一个<strong>activated</strong>数组。然后调用 <strong>extractGuards</strong> 。这里activated就是路由匹配后，会处于routeEnter状态的路由数组。</p>\n<p>​        <img src=\"/.io//image-20220211173238506.png\" alt=\"image-20220211173238506\"></p>\n<p>​        这个函数就是创建 guards，获取<strong>flatMapComponents</strong> 返回的数据。然后再调用<strong>flatten</strong> 作为返回值。</p>\n<p>​        <strong>flatMapComponents</strong> 方法就是将每个matched里面的数组元素进行传递给 <strong>flatten</strong> </p>\n<p>其中，是从m.componets 里面获取key，然后循环，拿出 自己的 组件，实例，和m，key。然后传递给fn 进行调用，然后将返回值作为一个数组，然后循环了matched的length那么多次，最后返回给了 <strong>flatten</strong> 进行了合并。</p>\n<p><img src=\"/.io//image-20220211175019270.png\" alt=\"image-20220211175019270\"> </p>\n<p>​        <strong>flatten</strong> 合并数组，扁平化处理。</p>\n<p>这个是 route.matched 的路由数组</p>\n<img src=\"/.io//image-20220211184544135.png\" alt=\"image-20220211184544135\" style=\"zoom:67%;\">\n\n<p>这里传递的参数是，先 matched.map(m =&gt; {})，先取出匹配上的路由。进行循环。然后将路由里面的 m.components 就是获取路由里面的components，默认就是一个 default，然后就是map循环路由里面的components。然后取出components。instances，路由本身。key（就是组件名字。）</p>\n<img src=\"/.io//image-20220211190158819.png\" alt=\"image-20220211190158819\" style=\"zoom:67%;\">\n\n\n\n<p><img src=\"/.io//image-20220211173522407.png\" alt=\"image-20220211173522407\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[1, 2], [2, 3] =&gt; [1, 2, 2, 3]</span><br></pre></td></tr></table></figure>\n\n<p><strong>flatMapComponents</strong> 的fn是传递的方法</p>\n<p><img src=\"/.io//image-20220211174408513.png\" alt=\"image-20220211174408513\"></p>\n<p>​        <strong>guard</strong>：就是调用这个 extractGuard 的返回值，参数分别为 def：m.components[key] 和 name beforeRouteEnter。</p>\n<p><img src=\"/.io//image-20220211175554195.png\" alt=\"image-20220211175554195\"></p>\n<p>​        这个方法，先判断 def 是不是一个函数。然后对于不是函数的，调用 Vue.extend 方法。这个方法通过查看 API 可以知道是。</p>\n<img src=\"/.io//image-20220211175816841.png\" alt=\"image-20220211175816841\" style=\"zoom:67%;\">\n\n<p>​        简单来看，就像是，先将def进行了extend，然后拿出里面的 options 的 beforeRouteEnter 参数。就是说从组件里面取出beforeRouteEnter方法。</p>\n<img src=\"/.io//image-20220211180402862.png\" alt=\"image-20220211180402862\" style=\"zoom:67%;\">\n\n<p>​        所以，知道了 guard 是返回一个 自己定义的 <strong>beforeRouteEnter</strong> 方法。同时 <strong>Vue.extend(def).options[‘beforeRouteEnter’]</strong> 返回的是一个数组（这里我认为应该是Vue的处理，方便混入或者其他情况的解决。但是对于源码我还没有了解。所以不怎么清楚）。</p>\n<p>​        然后继续进入 <strong>flatMapComponents</strong> 查看 322 行。进行bind方法的调用（bind 函数是<strong>extractGuards</strong> 传递过来的一个方法）。</p>\n<p><img src=\"/.io//image-20220211185433641.png\" alt=\"image-20220211185433641\"></p>\n<p>​        通过查看 extractEnterGuards 可以发现，这个会调用bind，然后return 一个 bindEnterGuard。</p>\n<p><img src=\"/.io//image-20220211190859440.png\" alt=\"image-20220211190859440\"></p>\n<p>​        我们可以查看 bindEnterGuard 方法。来查看里面的跳转情况。</p>\n<p>​        这个方法就是返回一个 routeEnterGuard 方法。然后在方法里面会返回一个guard的调用的返回值。这里guard 就是对应的 <strong>beforeRouteEnter</strong> 方法。</p>\n<p>​        通过这个方法我们可以知道，<strong>routeEnterGuard</strong> 里面 guard 是我们自定的 <strong>beforeRouteEnter</strong> 方法。里面的参数中，第三个参数的箭头函数，就是代表了我们的 <strong>beforeRouteEnter</strong> 方法中的 next。同时我们如果输出next也可以发现是正确的。</p>\n<p>​        所以我们在 beforeRouteEnter 里面调用next() ，其实就是调用这个方法。然后如果我们传递了参数，那么我们就会进行里面的操作。</p>\n<img src=\"/.io//image-20220211191050870.png\" alt=\"image-20220211191050870\" style=\"zoom:67%;\">\n\n<p>​        同时我们发现，如果我们不调用next方法。这个 guard方法是不会调用的。</p>\n"},{"title":"Vue-使用-规模化","date":"2021-10-29T15:15:47.000Z","_content":"\n\n\n#  Vue2教程-规模化\n\n## 路由\n\n### 官方路由\n\n​\t\tvue-router\n\n​\t对于大多数单页面应用，都推荐使用官方支持的 [vue-router 库](https://github.com/vuejs/vue-router)。更多细节可以移步 [vue-router 文档](https://router.vuejs.org/)。\n\n\n\n### 从零开始的简单路由\n\n​\t\t将vue实例存储，然后通过一个 routes 对象，对象存储了vue实例。然后通过 window.location.pathname 来进行获取url，通过判断 url 来决定显示什么页面，\n\n```\nconst NotFound = { template: '<p>Page not found</p>' }\nconst Home = { template: '<p>home page</p>' }\nconst About = { template: '<p>about page</p>' }\n\nconst routes = {\n  '/': Home,\n  '/about': About\n}\n\nnew Vue({\n  el: '#app',\n  data: {\n    currentRoute: window.location.pathname\n  },\n  computed: {\n    ViewComponent () {\n      return routes[this.currentRoute] || NotFound\n    }\n  },\n  render (h) { return h(this.ViewComponent) }\n})\n```\n\n​\t唯一的好奇点就是。render函数也是一个会多次执行的，比如这里，return h(this.ViewComponent) 这里 viewcomponent 变化了，然后这个render也重新执行了一次。性质应该和computed 计算属性一样。是一个可以进行缓存的一个方法。\n\n\n\n## 状态管理\n\n### 类Flux状态管理的官方实现\n\n#### React的开发者参考一下信息\n\n### 简单状态管理起步使用\n\n​\t\t因为vue的data是单独的，不共享的，但是对于有些数据，我们需要进行共享，在a发生改变了之后，b也会发生改变，比如开始的 props 和 $emit()，但是，对于这个问题，我们发现这个的耦合过高，并且是针对于父子组件，如果组件的层级过高，需要再使用 **依赖注入** 进行跨组件使用。\n\n​\t下面这个例子就是进行的调用。他们共享了 sourceOfTruth，当A变更了 sourceOfTruth ，B也会自动的更新他们的视图。\n\n​\t但是，这样使用在调试的时候变为噩梦。因为你不知道变更出现在哪里。也不知道发生了什么变更。\n\n```\nconst sourceOfTruth = {}\n\nconst vmA = new Vue({\n\tdata: {\n\t\tsourceOfTruth\n\t}\n})\nconst vmB = new Vue({\n\tdata: {\n\t\tsourceOfTruth\n\t}\n})\n```\n\n​\t\t于是，对应的，我们便采用了一个简单的 store 模式。\n\n```\nconst store = {\n\tdebug: true,\n\tstate: {\n\t\tmessage: 'Hello!'\n\t},\n\tsetMessageAction(newValue) {\n\t\tif (this.debug) log('set message action triggered with', newValue)\n\t\tthis.state.message = newValue\n\t},\n\tclearMessageAction() {\n\t\tif (this.debug) log('clear message action triggrered')\n\t\tthis.state.message = ''\n\t}\n}\n```\n\n```\nconst vmA = new Vue({\n\tdata: {\n\t\tprivateState: {},\n\t\tsharedState: store.state\n\t}\n})\n```\n\n> 重要的是，注意你不应该在 action 中 替换原始的状态对象 - 组件和 store 需要引用同一个共享对象，变更才能够被观察到。\n\n​\t\t于是我们便延申了约定，组件不能直接变更 state，而是要执行action 来 dispatch 事件通知 store改变state。最终便达成了 flux 架构。\n\n\n\n## 服务端渲染\n\n### SSR完全指南\n\n​\t\t在 2.3 发布后我们发布了一份完整的构建 Vue 服务端渲染应用的指南。这份指南非常深入，适合已经熟悉 Vue、webpack 和 Node.js 开发的开发者阅读。请移步 [ssr.vuejs.org](https://ssr.vuejs.org/zh/)。\n\n### Nuxt.js\n\n​\t\t从头搭建一个服务端渲染的应用是相当复杂的。幸运的是，我们有一个优秀的社区项目 [Nuxt.js](https://nuxtjs.org/) 让这一切变得非常简单。Nuxt 是一个基于 Vue 生态的更高层的框架，为开发服务端渲染的 Vue 应用提供了极其便利的开发体验。更酷的是，你甚至可以用它来做为静态站生成器。推荐尝试。\n\n### Quasar Framework SSR + PWA\n\n​\t\t[Quasar Framework](https://quasar.dev/) 可以通过其一流的构建系统、合理的配置和开发者扩展性生成 (可选地和 PWA 互通的) SSR 应用，让你的想法的设计和构建变得轻而易举。你可以在服务端挑选执行超过上百款遵循“Material Design 2.0”的组件，并在浏览器端可用。你甚至可以管理网站的 `<meta>` 标签。Quasar 是一个基于 Node.js 和 webpack 的开发环境，它可以通过一套代码完成 SPA、PWA、SSR、Electron、Capacitor 和 Cordova 应用的快速开发。\n\n\n\n## 安全\n\n","source":"_drafts/Vue/Vue2-教程/Vue2-教程-规模化.md","raw":"---\ntitle: Vue-使用-规模化\ndate: 2021-10-29 23:15:47\ntags:\n - Vue\n - Vue2\n - 文档\ncategories:\n - Vue\n - Vue2\n---\n\n\n\n#  Vue2教程-规模化\n\n## 路由\n\n### 官方路由\n\n​\t\tvue-router\n\n​\t对于大多数单页面应用，都推荐使用官方支持的 [vue-router 库](https://github.com/vuejs/vue-router)。更多细节可以移步 [vue-router 文档](https://router.vuejs.org/)。\n\n\n\n### 从零开始的简单路由\n\n​\t\t将vue实例存储，然后通过一个 routes 对象，对象存储了vue实例。然后通过 window.location.pathname 来进行获取url，通过判断 url 来决定显示什么页面，\n\n```\nconst NotFound = { template: '<p>Page not found</p>' }\nconst Home = { template: '<p>home page</p>' }\nconst About = { template: '<p>about page</p>' }\n\nconst routes = {\n  '/': Home,\n  '/about': About\n}\n\nnew Vue({\n  el: '#app',\n  data: {\n    currentRoute: window.location.pathname\n  },\n  computed: {\n    ViewComponent () {\n      return routes[this.currentRoute] || NotFound\n    }\n  },\n  render (h) { return h(this.ViewComponent) }\n})\n```\n\n​\t唯一的好奇点就是。render函数也是一个会多次执行的，比如这里，return h(this.ViewComponent) 这里 viewcomponent 变化了，然后这个render也重新执行了一次。性质应该和computed 计算属性一样。是一个可以进行缓存的一个方法。\n\n\n\n## 状态管理\n\n### 类Flux状态管理的官方实现\n\n#### React的开发者参考一下信息\n\n### 简单状态管理起步使用\n\n​\t\t因为vue的data是单独的，不共享的，但是对于有些数据，我们需要进行共享，在a发生改变了之后，b也会发生改变，比如开始的 props 和 $emit()，但是，对于这个问题，我们发现这个的耦合过高，并且是针对于父子组件，如果组件的层级过高，需要再使用 **依赖注入** 进行跨组件使用。\n\n​\t下面这个例子就是进行的调用。他们共享了 sourceOfTruth，当A变更了 sourceOfTruth ，B也会自动的更新他们的视图。\n\n​\t但是，这样使用在调试的时候变为噩梦。因为你不知道变更出现在哪里。也不知道发生了什么变更。\n\n```\nconst sourceOfTruth = {}\n\nconst vmA = new Vue({\n\tdata: {\n\t\tsourceOfTruth\n\t}\n})\nconst vmB = new Vue({\n\tdata: {\n\t\tsourceOfTruth\n\t}\n})\n```\n\n​\t\t于是，对应的，我们便采用了一个简单的 store 模式。\n\n```\nconst store = {\n\tdebug: true,\n\tstate: {\n\t\tmessage: 'Hello!'\n\t},\n\tsetMessageAction(newValue) {\n\t\tif (this.debug) log('set message action triggered with', newValue)\n\t\tthis.state.message = newValue\n\t},\n\tclearMessageAction() {\n\t\tif (this.debug) log('clear message action triggrered')\n\t\tthis.state.message = ''\n\t}\n}\n```\n\n```\nconst vmA = new Vue({\n\tdata: {\n\t\tprivateState: {},\n\t\tsharedState: store.state\n\t}\n})\n```\n\n> 重要的是，注意你不应该在 action 中 替换原始的状态对象 - 组件和 store 需要引用同一个共享对象，变更才能够被观察到。\n\n​\t\t于是我们便延申了约定，组件不能直接变更 state，而是要执行action 来 dispatch 事件通知 store改变state。最终便达成了 flux 架构。\n\n\n\n## 服务端渲染\n\n### SSR完全指南\n\n​\t\t在 2.3 发布后我们发布了一份完整的构建 Vue 服务端渲染应用的指南。这份指南非常深入，适合已经熟悉 Vue、webpack 和 Node.js 开发的开发者阅读。请移步 [ssr.vuejs.org](https://ssr.vuejs.org/zh/)。\n\n### Nuxt.js\n\n​\t\t从头搭建一个服务端渲染的应用是相当复杂的。幸运的是，我们有一个优秀的社区项目 [Nuxt.js](https://nuxtjs.org/) 让这一切变得非常简单。Nuxt 是一个基于 Vue 生态的更高层的框架，为开发服务端渲染的 Vue 应用提供了极其便利的开发体验。更酷的是，你甚至可以用它来做为静态站生成器。推荐尝试。\n\n### Quasar Framework SSR + PWA\n\n​\t\t[Quasar Framework](https://quasar.dev/) 可以通过其一流的构建系统、合理的配置和开发者扩展性生成 (可选地和 PWA 互通的) SSR 应用，让你的想法的设计和构建变得轻而易举。你可以在服务端挑选执行超过上百款遵循“Material Design 2.0”的组件，并在浏览器端可用。你甚至可以管理网站的 `<meta>` 标签。Quasar 是一个基于 Node.js 和 webpack 的开发环境，它可以通过一套代码完成 SPA、PWA、SSR、Electron、Capacitor 和 Cordova 应用的快速开发。\n\n\n\n## 安全\n\n","slug":"Vue/Vue2-教程/Vue2-教程-规模化","published":0,"updated":"2022-02-07T02:21:09.154Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckznhkk8k0066ikubacvabqtp","content":"<h1 id=\"Vue2教程-规模化\"><a href=\"#Vue2教程-规模化\" class=\"headerlink\" title=\"Vue2教程-规模化\"></a>Vue2教程-规模化</h1><h2 id=\"路由\"><a href=\"#路由\" class=\"headerlink\" title=\"路由\"></a>路由</h2><h3 id=\"官方路由\"><a href=\"#官方路由\" class=\"headerlink\" title=\"官方路由\"></a>官方路由</h3><p>​        vue-router</p>\n<p>​    对于大多数单页面应用，都推荐使用官方支持的 <a href=\"https://github.com/vuejs/vue-router\">vue-router 库</a>。更多细节可以移步 <a href=\"https://router.vuejs.org/\">vue-router 文档</a>。</p>\n<h3 id=\"从零开始的简单路由\"><a href=\"#从零开始的简单路由\" class=\"headerlink\" title=\"从零开始的简单路由\"></a>从零开始的简单路由</h3><p>​        将vue实例存储，然后通过一个 routes 对象，对象存储了vue实例。然后通过 window.location.pathname 来进行获取url，通过判断 url 来决定显示什么页面，</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const NotFound = &#123; template: &#x27;&lt;p&gt;Page not found&lt;/p&gt;&#x27; &#125;</span><br><span class=\"line\">const Home = &#123; template: &#x27;&lt;p&gt;home page&lt;/p&gt;&#x27; &#125;</span><br><span class=\"line\">const About = &#123; template: &#x27;&lt;p&gt;about page&lt;/p&gt;&#x27; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const routes = &#123;</span><br><span class=\"line\">  &#x27;/&#x27;: Home,</span><br><span class=\"line\">  &#x27;/about&#x27;: About</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">new Vue(&#123;</span><br><span class=\"line\">  el: &#x27;#app&#x27;,</span><br><span class=\"line\">  data: &#123;</span><br><span class=\"line\">    currentRoute: window.location.pathname</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  computed: &#123;</span><br><span class=\"line\">    ViewComponent () &#123;</span><br><span class=\"line\">      return routes[this.currentRoute] || NotFound</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  render (h) &#123; return h(this.ViewComponent) &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>​    唯一的好奇点就是。render函数也是一个会多次执行的，比如这里，return h(this.ViewComponent) 这里 viewcomponent 变化了，然后这个render也重新执行了一次。性质应该和computed 计算属性一样。是一个可以进行缓存的一个方法。</p>\n<h2 id=\"状态管理\"><a href=\"#状态管理\" class=\"headerlink\" title=\"状态管理\"></a>状态管理</h2><h3 id=\"类Flux状态管理的官方实现\"><a href=\"#类Flux状态管理的官方实现\" class=\"headerlink\" title=\"类Flux状态管理的官方实现\"></a>类Flux状态管理的官方实现</h3><h4 id=\"React的开发者参考一下信息\"><a href=\"#React的开发者参考一下信息\" class=\"headerlink\" title=\"React的开发者参考一下信息\"></a>React的开发者参考一下信息</h4><h3 id=\"简单状态管理起步使用\"><a href=\"#简单状态管理起步使用\" class=\"headerlink\" title=\"简单状态管理起步使用\"></a>简单状态管理起步使用</h3><p>​        因为vue的data是单独的，不共享的，但是对于有些数据，我们需要进行共享，在a发生改变了之后，b也会发生改变，比如开始的 props 和 $emit()，但是，对于这个问题，我们发现这个的耦合过高，并且是针对于父子组件，如果组件的层级过高，需要再使用 <strong>依赖注入</strong> 进行跨组件使用。</p>\n<p>​    下面这个例子就是进行的调用。他们共享了 sourceOfTruth，当A变更了 sourceOfTruth ，B也会自动的更新他们的视图。</p>\n<p>​    但是，这样使用在调试的时候变为噩梦。因为你不知道变更出现在哪里。也不知道发生了什么变更。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const sourceOfTruth = &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const vmA = new Vue(&#123;</span><br><span class=\"line\">\tdata: &#123;</span><br><span class=\"line\">\t\tsourceOfTruth</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">const vmB = new Vue(&#123;</span><br><span class=\"line\">\tdata: &#123;</span><br><span class=\"line\">\t\tsourceOfTruth</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>​        于是，对应的，我们便采用了一个简单的 store 模式。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const store = &#123;</span><br><span class=\"line\">\tdebug: true,</span><br><span class=\"line\">\tstate: &#123;</span><br><span class=\"line\">\t\tmessage: &#x27;Hello!&#x27;</span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\">\tsetMessageAction(newValue) &#123;</span><br><span class=\"line\">\t\tif (this.debug) log(&#x27;set message action triggered with&#x27;, newValue)</span><br><span class=\"line\">\t\tthis.state.message = newValue</span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\">\tclearMessageAction() &#123;</span><br><span class=\"line\">\t\tif (this.debug) log(&#x27;clear message action triggrered&#x27;)</span><br><span class=\"line\">\t\tthis.state.message = &#x27;&#x27;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const vmA = new Vue(&#123;</span><br><span class=\"line\">\tdata: &#123;</span><br><span class=\"line\">\t\tprivateState: &#123;&#125;,</span><br><span class=\"line\">\t\tsharedState: store.state</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>重要的是，注意你不应该在 action 中 替换原始的状态对象 - 组件和 store 需要引用同一个共享对象，变更才能够被观察到。</p>\n</blockquote>\n<p>​        于是我们便延申了约定，组件不能直接变更 state，而是要执行action 来 dispatch 事件通知 store改变state。最终便达成了 flux 架构。</p>\n<h2 id=\"服务端渲染\"><a href=\"#服务端渲染\" class=\"headerlink\" title=\"服务端渲染\"></a>服务端渲染</h2><h3 id=\"SSR完全指南\"><a href=\"#SSR完全指南\" class=\"headerlink\" title=\"SSR完全指南\"></a>SSR完全指南</h3><p>​        在 2.3 发布后我们发布了一份完整的构建 Vue 服务端渲染应用的指南。这份指南非常深入，适合已经熟悉 Vue、webpack 和 Node.js 开发的开发者阅读。请移步 <a href=\"https://ssr.vuejs.org/zh/\">ssr.vuejs.org</a>。</p>\n<h3 id=\"Nuxt-js\"><a href=\"#Nuxt-js\" class=\"headerlink\" title=\"Nuxt.js\"></a>Nuxt.js</h3><p>​        从头搭建一个服务端渲染的应用是相当复杂的。幸运的是，我们有一个优秀的社区项目 <a href=\"https://nuxtjs.org/\">Nuxt.js</a> 让这一切变得非常简单。Nuxt 是一个基于 Vue 生态的更高层的框架，为开发服务端渲染的 Vue 应用提供了极其便利的开发体验。更酷的是，你甚至可以用它来做为静态站生成器。推荐尝试。</p>\n<h3 id=\"Quasar-Framework-SSR-PWA\"><a href=\"#Quasar-Framework-SSR-PWA\" class=\"headerlink\" title=\"Quasar Framework SSR + PWA\"></a>Quasar Framework SSR + PWA</h3><p>​        <a href=\"https://quasar.dev/\">Quasar Framework</a> 可以通过其一流的构建系统、合理的配置和开发者扩展性生成 (可选地和 PWA 互通的) SSR 应用，让你的想法的设计和构建变得轻而易举。你可以在服务端挑选执行超过上百款遵循“Material Design 2.0”的组件，并在浏览器端可用。你甚至可以管理网站的 <code>&lt;meta&gt;</code> 标签。Quasar 是一个基于 Node.js 和 webpack 的开发环境，它可以通过一套代码完成 SPA、PWA、SSR、Electron、Capacitor 和 Cordova 应用的快速开发。</p>\n<h2 id=\"安全\"><a href=\"#安全\" class=\"headerlink\" title=\"安全\"></a>安全</h2>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Vue2教程-规模化\"><a href=\"#Vue2教程-规模化\" class=\"headerlink\" title=\"Vue2教程-规模化\"></a>Vue2教程-规模化</h1><h2 id=\"路由\"><a href=\"#路由\" class=\"headerlink\" title=\"路由\"></a>路由</h2><h3 id=\"官方路由\"><a href=\"#官方路由\" class=\"headerlink\" title=\"官方路由\"></a>官方路由</h3><p>​        vue-router</p>\n<p>​    对于大多数单页面应用，都推荐使用官方支持的 <a href=\"https://github.com/vuejs/vue-router\">vue-router 库</a>。更多细节可以移步 <a href=\"https://router.vuejs.org/\">vue-router 文档</a>。</p>\n<h3 id=\"从零开始的简单路由\"><a href=\"#从零开始的简单路由\" class=\"headerlink\" title=\"从零开始的简单路由\"></a>从零开始的简单路由</h3><p>​        将vue实例存储，然后通过一个 routes 对象，对象存储了vue实例。然后通过 window.location.pathname 来进行获取url，通过判断 url 来决定显示什么页面，</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const NotFound = &#123; template: &#x27;&lt;p&gt;Page not found&lt;/p&gt;&#x27; &#125;</span><br><span class=\"line\">const Home = &#123; template: &#x27;&lt;p&gt;home page&lt;/p&gt;&#x27; &#125;</span><br><span class=\"line\">const About = &#123; template: &#x27;&lt;p&gt;about page&lt;/p&gt;&#x27; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const routes = &#123;</span><br><span class=\"line\">  &#x27;/&#x27;: Home,</span><br><span class=\"line\">  &#x27;/about&#x27;: About</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">new Vue(&#123;</span><br><span class=\"line\">  el: &#x27;#app&#x27;,</span><br><span class=\"line\">  data: &#123;</span><br><span class=\"line\">    currentRoute: window.location.pathname</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  computed: &#123;</span><br><span class=\"line\">    ViewComponent () &#123;</span><br><span class=\"line\">      return routes[this.currentRoute] || NotFound</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  render (h) &#123; return h(this.ViewComponent) &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>​    唯一的好奇点就是。render函数也是一个会多次执行的，比如这里，return h(this.ViewComponent) 这里 viewcomponent 变化了，然后这个render也重新执行了一次。性质应该和computed 计算属性一样。是一个可以进行缓存的一个方法。</p>\n<h2 id=\"状态管理\"><a href=\"#状态管理\" class=\"headerlink\" title=\"状态管理\"></a>状态管理</h2><h3 id=\"类Flux状态管理的官方实现\"><a href=\"#类Flux状态管理的官方实现\" class=\"headerlink\" title=\"类Flux状态管理的官方实现\"></a>类Flux状态管理的官方实现</h3><h4 id=\"React的开发者参考一下信息\"><a href=\"#React的开发者参考一下信息\" class=\"headerlink\" title=\"React的开发者参考一下信息\"></a>React的开发者参考一下信息</h4><h3 id=\"简单状态管理起步使用\"><a href=\"#简单状态管理起步使用\" class=\"headerlink\" title=\"简单状态管理起步使用\"></a>简单状态管理起步使用</h3><p>​        因为vue的data是单独的，不共享的，但是对于有些数据，我们需要进行共享，在a发生改变了之后，b也会发生改变，比如开始的 props 和 $emit()，但是，对于这个问题，我们发现这个的耦合过高，并且是针对于父子组件，如果组件的层级过高，需要再使用 <strong>依赖注入</strong> 进行跨组件使用。</p>\n<p>​    下面这个例子就是进行的调用。他们共享了 sourceOfTruth，当A变更了 sourceOfTruth ，B也会自动的更新他们的视图。</p>\n<p>​    但是，这样使用在调试的时候变为噩梦。因为你不知道变更出现在哪里。也不知道发生了什么变更。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const sourceOfTruth = &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const vmA = new Vue(&#123;</span><br><span class=\"line\">\tdata: &#123;</span><br><span class=\"line\">\t\tsourceOfTruth</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">const vmB = new Vue(&#123;</span><br><span class=\"line\">\tdata: &#123;</span><br><span class=\"line\">\t\tsourceOfTruth</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>​        于是，对应的，我们便采用了一个简单的 store 模式。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const store = &#123;</span><br><span class=\"line\">\tdebug: true,</span><br><span class=\"line\">\tstate: &#123;</span><br><span class=\"line\">\t\tmessage: &#x27;Hello!&#x27;</span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\">\tsetMessageAction(newValue) &#123;</span><br><span class=\"line\">\t\tif (this.debug) log(&#x27;set message action triggered with&#x27;, newValue)</span><br><span class=\"line\">\t\tthis.state.message = newValue</span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\">\tclearMessageAction() &#123;</span><br><span class=\"line\">\t\tif (this.debug) log(&#x27;clear message action triggrered&#x27;)</span><br><span class=\"line\">\t\tthis.state.message = &#x27;&#x27;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const vmA = new Vue(&#123;</span><br><span class=\"line\">\tdata: &#123;</span><br><span class=\"line\">\t\tprivateState: &#123;&#125;,</span><br><span class=\"line\">\t\tsharedState: store.state</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>重要的是，注意你不应该在 action 中 替换原始的状态对象 - 组件和 store 需要引用同一个共享对象，变更才能够被观察到。</p>\n</blockquote>\n<p>​        于是我们便延申了约定，组件不能直接变更 state，而是要执行action 来 dispatch 事件通知 store改变state。最终便达成了 flux 架构。</p>\n<h2 id=\"服务端渲染\"><a href=\"#服务端渲染\" class=\"headerlink\" title=\"服务端渲染\"></a>服务端渲染</h2><h3 id=\"SSR完全指南\"><a href=\"#SSR完全指南\" class=\"headerlink\" title=\"SSR完全指南\"></a>SSR完全指南</h3><p>​        在 2.3 发布后我们发布了一份完整的构建 Vue 服务端渲染应用的指南。这份指南非常深入，适合已经熟悉 Vue、webpack 和 Node.js 开发的开发者阅读。请移步 <a href=\"https://ssr.vuejs.org/zh/\">ssr.vuejs.org</a>。</p>\n<h3 id=\"Nuxt-js\"><a href=\"#Nuxt-js\" class=\"headerlink\" title=\"Nuxt.js\"></a>Nuxt.js</h3><p>​        从头搭建一个服务端渲染的应用是相当复杂的。幸运的是，我们有一个优秀的社区项目 <a href=\"https://nuxtjs.org/\">Nuxt.js</a> 让这一切变得非常简单。Nuxt 是一个基于 Vue 生态的更高层的框架，为开发服务端渲染的 Vue 应用提供了极其便利的开发体验。更酷的是，你甚至可以用它来做为静态站生成器。推荐尝试。</p>\n<h3 id=\"Quasar-Framework-SSR-PWA\"><a href=\"#Quasar-Framework-SSR-PWA\" class=\"headerlink\" title=\"Quasar Framework SSR + PWA\"></a>Quasar Framework SSR + PWA</h3><p>​        <a href=\"https://quasar.dev/\">Quasar Framework</a> 可以通过其一流的构建系统、合理的配置和开发者扩展性生成 (可选地和 PWA 互通的) SSR 应用，让你的想法的设计和构建变得轻而易举。你可以在服务端挑选执行超过上百款遵循“Material Design 2.0”的组件，并在浏览器端可用。你甚至可以管理网站的 <code>&lt;meta&gt;</code> 标签。Quasar 是一个基于 Node.js 和 webpack 的开发环境，它可以通过一套代码完成 SPA、PWA、SSR、Electron、Capacitor 和 Cordova 应用的快速开发。</p>\n<h2 id=\"安全\"><a href=\"#安全\" class=\"headerlink\" title=\"安全\"></a>安全</h2>"},{"title":"Vue-使用-过渡和动画","date":"2021-10-29T15:15:25.000Z","_content":"\n\n\n# 过渡和动画\n\n## 进入/离开和列表转换\n\n​\t\tVue提供了多种方法在DOM中的过渡效果\n\n* 自动为CSS过渡和动画应用类\n* 集成第三方CSS动画库，如 Animate.css\n* 在过渡钩子期间使用 JavaScript 直接操作 DOM\n* 集成第三方JavaScript动画库，例如 Velocity.js\n\n\n\n### 过渡单个元素/组件\n\n​\t\tVue 提供了一个`transition`包装组件，允许您在以下上下文中为任何元素或组件添加进入/离开转换：\n\n* 条件渲染（使用`v-if`）\n* 条件显示（使用`v-show`）\n* 动态组件\n* 组件根节点\n\n\n\n​\t\t在这里我直接复制官网的例子，并加以一个简单的说明，首先，对于transition来说，需要的是一个根组件（根元素），对于存在多个根组件的，便会只渲染一个，其次，对于不是非根元素进行的渲染显示不会有效果。\n\n```\n<div id=\"demo\">\n  <button v-on:click=\"show = !show\">\n    Toggle\n  </button>\n  <transition name=\"fade\">\n    <p v-if=\"show\">hello</p>\n  </transition>\n</div>\n\nnew Vue({\n  el: '#demo',\n  data: {\n    show: true\n  }\n})\n\n.fade-enter-active, .fade-leave-active {\n  transition: opacity .5s;\n}\n.fade-enter, .fade-leave-to /* .fade-leave-active below version 2.1.8 */ {\n  opacity: 0;\n}\n```\n\n当`transition`插入或删除包裹在组件中的元素时，会发生以下情况：\n\n1. Vue 会自动嗅探目标元素是否应用了 CSS 过渡或动画。如果是这样，CSS 过渡类将在适当的时间添加/删除。\n2. 如果转换组件提供了[JavaScript hooks](https://vuejs.org/v2/guide/transitions.html#JavaScript-Hooks)，这些 hooks 将在适当的时间被调用。\n3. 如果没有检测到 CSS 过渡/动画，也没有提供 JavaScript 钩子，插入和/或移除的 DOM 操作将在下一帧立即执行（注意：这是一个浏览器动画帧，与 Vue 的概念不同`nextTick`）。\n\n\n\n#### 过渡的类名\n\n​\t\t在进入/离开的过程中，会有6个 class 切换\n\n* v-enter\n  * 进入的起始状态，在插入元素之前添加，在插入元素后移除一帧\n* v-enter-active\n  * 进入的活动状态，在整个进入阶段应用。插入元素之前添加，在过渡完成时移除。定义进入过渡的事件、延迟和缓动曲线。\n* v-enter-to\n  * 2.1.8+\n  * 进入的结束状态。插入元素后添加一帧（同时 v-enter 删除），在过渡完成时删除。\n* v-leave\n  * 定义离开过渡的开始状态。在离开过渡被触发时立刻生效。下一帧被移除\n* v-leave-active\n  * 定义离开过渡生效时的状态。在离开过渡立刻生效，过渡完成被移除，同 v-enter-active\n* v-leave-to\n  * 2.1.8 +\n  * 定义离开过渡的结束状态。离开过渡被触发后下一帧生效（同时 v-leave 被删除）。过渡完成被移除\n\n\n\n![image-20211203152116522](Vue2-教程-过渡和动画\\image-20211203152116522.png)\n\n​\t\t在这些过渡的切换中，如果你使用一个没有名字的transition，则v-是这些类名的默认前缀。\n\n```\n<transition>\n    <p v-show=\"show\">hello</p>\n</transition>\n\n.v-enter-active,\n```\n\n​\t\t如果你使用了 `<transition name=\"my-transition\">` ，那么 `v-enter` 会替换为 `my-transition-enter` 。\n\n​\t\tv-enter-active 和 v-leave-active 可以控制进入/离开过渡的不同的缓和曲线。\n\n\n\n<img src=\"Vue2-教程-过渡和动画\\image-20211203154333481.png\" alt=\"image-20211203154333481\"  />\n\n​\t\t通过图示可以看出，当元素进行显示时：\n\n* 先插入 v-enter 和 v-enter-active， \n* 然后再下一帧删除 v-enter，出现了 v-enter-to\n* 然后结束了 v-enter-active 和 v-enter-to 消失。\n\nv-leave 是一样的效果。\n\n\n\n#### CSS过渡\n\n​\t\t和普通的过渡是没有什么区别的。\n\n```\n.bounce-enter-active {\n  animation: bounce-in .5s;\n}\n.bounce-leave-active {\n  animation: bounce-in .5s reverse;\n}\n\n@keyframes bounce-in {\n  0% {\n    transform: scale(0);\n  }\n  50% {\n    transform: scale(1.5);\n  }\n  100% {\n    transform: scale(1);\n  }\n}\n```\n\n\n\n#### 自定义过渡的类名\n\n​\t\t我们可以通过使用以下的属性来自定义过渡的类名。并且他们的优先级会高于普通的类名。因此对于使用其他第三方css库十分的有用。\n\n```\nenter-class\nenter-active-class\nenter-to-class (2.1.8+)\nleave-class\nleave-active-class\nleave-to-class (2.1.8+)\n```\n\n​\t\t这里name就是往常一样的name，然后在元素里面添加了标签，标签是 enter-xx-class，或者是 leave-xx-class 这种。\n\n```\n<transition\nname=\"custom-classes-transition\"\nenter-active-class=\"animated tada\"\nleave-active-class=\"animated bounceOutRight\"\n>\n    <p v-if=\"show\">hello</p>\n</transition>\n```\n\n\n\n#### 同时使用过渡和动画\n\n​\t\tVue为了能知道过渡的完成，必须设置相应的事件监听器。他可以是 transitionend 或者是 animationend，如果你只是使用了其中一种，Vue可以自动识别并设置监听。\n\n​\t\t但是如果你同时使用了 transition 和 animation，那么这种情况你就需要使用 type 属性来指定Vue需要监听的类型。\n\n​\t\t如果你不指定的话，我从使用上看来他会默认监听的是时间最长的那个，就是延迟时间和运行时间加起来最大的那个。\n\n```\n<transition name=\"slide-fade\" type=\"transition\">\n    <p v-if=\"show\"> content </p>\n</transition>\n```\n\n\n\n#### 显性的过渡持续时间\n\n​\t\t2.2.0 新增\n\n​\t\t默认情况下，Vue会自动计算出过渡时间。会等待过渡效果的 transitionend 和 animationend 事件。\n\n​\t\t但是，我们可以显性的设置一个过渡的持续时间。\n\n​\t\t下面这个代码的意思就是，对于使用了 duration 设置了显性的过渡时间了的，在到达过渡的时间之后，便会直接进行过渡的结束。\n\n```\n<transition :duration=\"1000\">...</transition>\n\n<transition :duration=\"{ enter: 500, leave: 800 }\">...</transition>\n```\n\n\n\n#### JavaScript 钩子\n\n​\t\t可以在属性中声明 JavaScript 钩子。\n\n​\t\t这里我简单介绍一下 JavaScript钩子的执行时机，虽然通过名字也能够大致猜的出来意思\n\n* before-enter： 简单来说就是在enter启动之前，就像是前面的 v-enter\n* enter： 就是在调用期间， v-enter-to，但是这个 JavaScript钩子 没有说版本要求，而 v-enter-to 是2.1.8以上的，所以这个应该是更像 v-enter-active 。\n* after-enter： 就是在就是结束时会进行的调用，应该接近于 animationend 或者 transitionend 这两个回调。\n* enter-cancalled： 就是在没有调用after-enter的时候就又进行了一次切换，此时就会调用 enter-cancalled 回调。\n\n```\n<transition\n  v-on:before-enter=\"beforeEnter\"\n  v-on:enter=\"enter\"\n  v-on:after-enter=\"afterEnter\"\n  v-on:enter-cancelled=\"enterCancelled\"\n\n  v-on:before-leave=\"beforeLeave\"\n  v-on:leave=\"leave\"\n  v-on:after-leave=\"afterLeave\"\n  v-on:leave-cancelled=\"leaveCancelled\"\n>\n  <!-- ... -->\n</transition>\n```\n\n​\t\t这里需要注意，\n\n* 当只用 JavaScript 过渡的时候，**在 `enter` 和 `leave` 中必须使用 `done` 进行回调**。否则，它们将被同步调用，过渡会立即完成。\n  * 这个我没有仔细使用过函数进行动画的过渡，而是进行一些其他的操作，但是这里 done的回调是必须的。因为我们可以看到如果不使用done函数，那么便不会调用 after-enter 来结束，所以这个done函数更像是 生成器函数的 next 一样。\n  * 这里我使用了css进行过渡，然后JavaScript进行钩子的调用，发现css的过渡没有出现效果，直接只能使用钩子的调用了。就算是使用自定义过渡类名属性 enter-class 这些也没有效果。\n* 推荐对于仅使用 JavaScript 过渡的元素添加 `v-bind:css=\"false\"`，Vue 会跳过 CSS 的检测。这也可以避免过渡过程中 CSS 的影响。\n* leaveCancelled 只能用于 v-show 中。\n\n```\n// ...\nmethods: {\n  // --------\n  // 进入中\n  // --------\n\n  beforeEnter: function (el) {\n    // ...\n  },\n  // 当与 CSS 结合使用时\n  // 回调函数 done 是可选的\n  enter: function (el, done) {\n    // ...\n    done()\n  },\n  afterEnter: function (el) {\n    // ...\n  },\n  enterCancelled: function (el) {\n    // ...\n  },\n\n  // --------\n  // 离开时\n  // --------\n\n  beforeLeave: function (el) {\n    // ...\n  },\n  // 当与 CSS 结合使用时\n  // 回调函数 done 是可选的\n  leave: function (el, done) {\n    // ...\n    done()\n  },\n  afterLeave: function (el) {\n    // ...\n  },\n  // leaveCancelled 只用于 v-show 中\n  leaveCancelled: function (el) {\n    // ...\n  }\n}\n```\n\n\n\n### 初始渲染的过渡\n\n​\t\t通过使用 appear 属性设置节点初始渲染的过渡\n\n​\t\t简单来说就是会在开始的时候有一个过渡的效果。\n\n```\n<transition appear>\n```\n\n​\t可以自定义 css 类名\n\n```\n<transition\n  appear\n  appear-class=\"custom-appear-class\"\n  appear-to-class=\"custom-appear-to-class\" (2.1.8+)\n  appear-active-class=\"custom-appear-active-class\"\n>\n```\n\n​\t自定义JavaScript 钩子\n\n```\n<transition\n  appear\n  v-on:before-appear=\"customBeforeAppearHook\"\n  v-on:appear=\"customAppearHook\"\n  v-on:after-appear=\"customAfterAppearHook\"\n  v-on:appear-cancelled=\"customAppearCancelledHook\"\n>\n```\n\n​\t\t在上面的例子中，无论是使用 appear attribute 还是使用 v-on:appear 钩子都会生成初始渲染的过渡。\n\n\n\n### 多个元素的过渡\n\n​\t\t对于原生的标签，可以使用 v-if / v-else 进行过渡。\n\n> 当有**相同标签名**的元素切换时，需要通过 `key` attribute 设置唯一的值来标记以让 Vue 区分它们，否则 Vue 为了效率只会替换相同标签内部的内容。即使在技术上没有必要，**给在 `<transition>` 组件中的多个元素设置 key 是一个更好的实践。**\n\n\n\n```\n<transition>\n  <button v-if=\"isEditing\" key=\"save\">\n    Save\n  </button>\n  <button v-else key=\"edit\">\n    Edit\n  </button>\n</transition>\n```\n\n​\t\t在某些场景，也可以通过给同一个元素的key属性设置不同的状态来代替 v-if 和 v-else。\n\n```\n<transition>\n  <button v-bind:key=\"isEditing\">\n    {{ isEditing ? 'Save' : 'Edit' }}\n  </button>\n</transition>\n```\n\n\n\n#### 过渡模式\n\n​\t\t简单来说就是元素的切换是同步的，所以会出现占位的问题，并且当使用的是 v-if 的时候，开始会占位，但是在过渡结束之后就会出现位置消失，然后后面的元素会补充上去。\n\n​\t\t所以此时我们就需要进行处理。\n\n​\t\t解决方式一般是使用定位的形式，因为定位是脱离了文档流的，所以就不会出现这个问题了。然后此时我们再使用一个 transition 进行过渡的显示便有了效果。\n\n\n\n​\t\t当然同时生效的进入和离开的过渡不能满足所有要求，所以Vue提供了**过渡模式** mode\n\n* `in-out` ：新元素先过渡，完成后旧元素过渡离开。\n* `out-in` ：旧元素先过渡，完成后新元素过渡进入。\n\n```\n<transition name=\"fade\" mode=\"out-in\">\n  <!-- ... the buttons ... -->\n</transition>\n```\n\n\n\n### 多组件的过渡\n\n​\t\t我们可以直接使用动态组件来进行组件之间的过渡\n\n```\n<transition name=\"component-fade\" mode=\"out-in\">\n  <component v-bind:is=\"view\"></component>\n</transition>\n```\n\n```\nnew Vue({\n  el: '#transition-components-demo',\n  data: {\n    view: 'v-a'\n  },\n  components: {\n    'v-a': {\n      template: '<div>Component A</div>'\n    },\n    'v-b': {\n      template: '<div>Component B</div>'\n    }\n  }\n})\n```\n\n\n\n### 列表过渡\n\n​\t\t对于使用v-for渲染时的过渡。可以使用 transition-group 组件。\n\n**特点**：\n\n* transition-group 会以一个真实的元素呈现：默认为 span，也可以通过 tag 属性来更换为其他元素。\n* 不能使用过渡模式。mode\n* 内部元素总是需要提供一个唯一的 key 属性值\n* CSS 过渡的类 将会应用在内部元素中，而不是这个 组件/容器 本身。\n\n\n\n​\t\t这里，首先name为list，其次使用了tag，默认不使用tag时为span，使用了tag为p，所以就是p标签进行包裹。然后内部是使用span标签进行的for循环。最后，使用transition-group，key值是必须的。\n\n```\n<transition-group name=\"list\" tag=\"p\">\n\t<span v-for=\"item in items\" v-bind:key=\"item\" class=\"list-item\">\n\t\t{{ item }}\n\t</span>\n</transition-group>\n```\n\n\n\n#### 列表的进入/离开过渡\n\n​\t\t列表的进入/离开过渡是和以前的过渡的方式是一样的。只是过渡变成了每一个小组件了。\n\n​\t\t问题就是过渡的平滑展现，比如新增的元素，周围的元素会瞬间移动到他们新布局的位置，而不是平滑的过渡。\n\n```\n.list-enter-active, .list-leave-active {\n  transition: all 1s;\n}\n.list-enter, .list-leave-to\n/* .list-leave-active for below version 2.1.8 */ {\n  opacity: 0;\n  transform: translateY(30px);\n}\n```\n\n\n\n#### 排序的过渡\n\n​\t\t可以通过使用 v-move 类来实现列表的移动。\n\n```\n<transition-group name=\"list\" tag=\"ul\">\n    <li v-for=\"(item, index) in items\" v-bind:key=\"item\" class=\"list-item\">\n\t\t{{ item }}\n    </li>\n</transition-group>\n\n.list-item {\n    transition: all 1s;\n}\n\n.list-enter,\n.list-leave-to {\n    opacity: 0;\n    transform: translateY(30px);\n}\n```\n\n​\t\t如果我对列表进行一次排序。就会发现动画的效果。\n\n​\t这个看起来很神奇，内部的实现，Vue 使用了一个叫 [FLIP](https://aerotwist.com/blog/flip-your-animations/) 简单的动画队列。\n\n​\t\t当然，前面的style样式对于增加排序时的效果都还是不错，但是对于删除来说，效果就不一样了。\n\n​\t于是我们对于要进行删除的元素进行了一个绝对定位。\n\n​\t对于为什么要使用绝对定位，那是因为当使用了绝对定位之后，那便不会在同一图层。然后此时后面的元素便会向前移动，然后再通过 transition: all .5s; 来进行一个动态的变化。\n\n```\n.list-leave-active {\n    position: absolute;\n}\n```\n\n> 需要注意的是使用 FLIP 过渡的元素不能设置为 `display: inline` 。作为替代方案，可以设置为 `display: inline-block` 或者放置于 flex 中\n\n\n\n**多维网格也可以进行过渡**：\n\n```\n<!DOCTYPE html>\n<html>\n  <head>\n    <title>List Move Transitions Sudoku Example</title>\n    <script src=\"https://unpkg.com/vue\"></script>\n    <link rel=\"stylesheet\" type=\"text/css\" href=\"./style.css\" />\n  </head>\n  <body>\n    <div id=\"sudoku-demo\" class=\"demo\">\n      <h1>Lazy Sudoku</h1>\n      <p>Keep hitting the shuffle button until you win.</p>\n\n      <button @click=\"shuffle\">\n        Shuffle\n      </button>\n      <transition-group name=\"cell\" tag=\"div\" class=\"container\">\n        <div v-for=\"cell in cells\" :key=\"cell.id\" class=\"cell\">\n          {{ cell.number }}\n        </div>\n      </transition-group>\n    </div>\n\n    <script>\n      new Vue({\n        el: \"#sudoku-demo\",\n        data: {\n          cells: Array.apply(null, { length: 81 }).map(function(_, index) {\n            return {\n              id: index,\n              number: (index % 9) + 1\n            };\n          })\n        },\n        methods: {\n          shuffle: function() {\n            this.cells = this.randomSort(this.cells);\n          },\n          randomSort(arr) {\n            const res = arr.slice();\n            for (let i=0; i<arr.length; i++) {\n              const index = this.randomIndex();\n              [res[i], res[index]] = [res[index], res[i]];\n            }\n\n            return res;\n          },\n          randomIndex() {\n            return Math.floor(Math.random() * this.cells.length);\n          }\n        }\n      });\n    </script>\n  </body>\n  \n  <style>\n.container {\n  display: flex;\n  flex-wrap: wrap;\n  width: 238px;\n  margin-top: 10px;\n}\n.cell {\n  display: flex;\n  justify-content: space-around;\n  align-items: center;\n  width: 25px;\n  height: 25px;\n  border: 1px solid #aaa;\n  margin-right: -1px;\n  margin-bottom: -1px;\n}\n.cell:nth-child(3n) {\n  margin-right: 0;\n}\n.cell:nth-child(27n) {\n  margin-bottom: 0;\n}\n.cell-move {\n  transition: transform 1s;\n}\n\n  </style>\n  \n</html>\n\n```\n\n\n\n#### 交错的过渡\n\n​\t\t通过data属性和JavaScript的通信，可以实现列表的交错过渡。简单来说就是使用js方法进行了渲染。因为 velocity 不能访问，所以没有进行实验。\n\n```\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/velocity/1.2.3/velocity.min.js\"></script>\n\n<div id=\"staggered-list-demo\">\n  <input v-model=\"query\">\n  <transition-group\n    name=\"staggered-fade\"\n    tag=\"ul\"\n    v-bind:css=\"false\"\n    v-on:before-enter=\"beforeEnter\"\n    v-on:enter=\"enter\"\n    v-on:leave=\"leave\"\n  >\n    <li\n      v-for=\"(item, index) in computedList\"\n      v-bind:key=\"item.msg\"\n      v-bind:data-index=\"index\"\n    >{{ item.msg }}</li>\n  </transition-group>\n</div>\n\nnew Vue({\n  el: '#staggered-list-demo',\n  data: {\n    query: '',\n    list: [\n      { msg: 'Bruce Lee' },\n      { msg: 'Jackie Chan' },\n      { msg: 'Chuck Norris' },\n      { msg: 'Jet Li' },\n      { msg: 'Kung Fury' }\n    ]\n  },\n  computed: {\n    computedList: function () {\n      var vm = this\n      return this.list.filter(function (item) {\n        return item.msg.toLowerCase().indexOf(vm.query.toLowerCase()) !== -1\n      })\n    }\n  },\n  methods: {\n    beforeEnter: function (el) {\n      el.style.opacity = 0\n      el.style.height = 0\n    },\n    enter: function (el, done) {\n      var delay = el.dataset.index * 150\n      setTimeout(function () {\n        Velocity(\n          el,\n          { opacity: 1, height: '1.6em' },\n          { complete: done }\n        )\n      }, delay)\n    },\n    leave: function (el, done) {\n      var delay = el.dataset.index * 150\n      setTimeout(function () {\n        Velocity(\n          el,\n          { opacity: 0, height: 0 },\n          { complete: done }\n        )\n      }, delay)\n    }\n  }\n})\n```\n\n\n\n### 可复用的过渡\n\n​\t\t可以使用Vue组件系统的实现复用。只需要将 transition 或者 transition-group 作为根组件。\n\n```\nVue.component('my-special-transition', {\n  template: '\\\n    <transition\\\n      name=\"very-special-transition\"\\\n      mode=\"out-in\"\\\n      v-on:before-enter=\"beforeEnter\"\\\n      v-on:after-enter=\"afterEnter\"\\\n    >\\\n      <slot></slot>\\\n    </transition>\\\n  ',\n  methods: {\n    beforeEnter: function (el) {\n      // ...\n    },\n    afterEnter: function (el) {\n      // ...\n    }\n  }\n})\n```\n\n​\t当然，可以使用函数式组件来完成这个任务。函数式组件我们后面在进行了解。\n\n```\nVue.component('my-special-transition', {\n  functional: true,\n  render: function (createElement, context) {\n    var data = {\n      props: {\n        name: 'very-special-transition',\n        mode: 'out-in'\n      },\n      on: {\n        beforeEnter: function (el) {\n          // ...\n        },\n        afterEnter: function (el) {\n          // ...\n        }\n      }\n    }\n    return createElement('transition', data, context.children)\n  }\n})\n```\n\n\n\n### 动态过渡\n\n​\t\t在Vue中，过渡也是数据驱动的。所以name也可以使用 v-bind 来进行绑定。\n\n```\n<transition v-bind:name=\"transitionName\">\n```\n\n​\t\t所有的过渡 attribute 都可以动态绑定。因为事件钩子都是方法。所以根据组件的状态不同，过渡也会有不同的表现。\n\n\n\n## 状态过渡\n\n​\t\t数据元素本身的特效，这些数据要么本身就以数值形式存储，要么可以转换为数值。\n\n- 数字和运算\n- 颜色的显示\n- SVG 节点的位置\n- 元素的大小和其他的 property\n\n\n\n### 状态动画与侦听器\n\n```\n<script src=\"https://cdn.jsdelivr.net/npm/tween.js@16.3.4\"></script>\n<script src=\"https://cdn.jsdelivr.net/npm/color-js@1.0.3\"></script>\n\n<div id=\"example-7\">\n  <input\n    v-model=\"colorQuery\"\n    v-on:keyup.enter=\"updateColor\"\n    placeholder=\"Enter a color\"\n  >\n  <button v-on:click=\"updateColor\">Update</button>\n  <p>Preview:</p>\n  <span\n    v-bind:style=\"{ backgroundColor: tweenedCSSColor }\"\n    class=\"example-7-color-preview\"\n  ></span>\n  <p>{{ tweenedCSSColor }}</p>\n</div>\n```\n\n```\nvar Color = net.brehaut.Color\n\nnew Vue({\n  el: '#example-7',\n  data: {\n    colorQuery: '',\n    color: {\n      red: 0,\n      green: 0,\n      blue: 0,\n      alpha: 1\n    },\n    tweenedColor: {}\n  },\n  created: function () {\n    this.tweenedColor = Object.assign({}, this.color)\n  },\n  watch: {\n    color: function () {\n      function animate () {\n        if (TWEEN.update()) {\n          requestAnimationFrame(animate)\n        }\n      }\n\n      new TWEEN.Tween(this.tweenedColor)\n        .to(this.color, 750)\n        .start()\n\n      animate()\n    }\n  },\n  computed: {\n    tweenedCSSColor: function () {\n      return new Color({\n        red: this.tweenedColor.red,\n        green: this.tweenedColor.green,\n        blue: this.tweenedColor.blue,\n        alpha: this.tweenedColor.alpha\n      }).toCSS()\n    }\n  },\n  methods: {\n    updateColor: function () {\n      this.color = new Color(this.colorQuery).toRGB()\n      this.colorQuery = ''\n    }\n  }\n})\n```\n\n```\n.example-7-color-preview {\n  display: inline-block;\n  width: 50px;\n  height: 50px;\n}\n```\n\n\n\n### 动态状态过渡\n\n​\t\t就像 Vue 的过渡组件一样，数据背后状态过渡会实时更新，这对于原型设计十分有用。当你修改一些变量，即使是一个简单的 SVG 多边形也可实现很多难以想象的效果。\n\n\n\n### 把过渡放到组件里\n\n```\n<script src=\"https://cdn.jsdelivr.net/npm/tween.js@16.3.4\"></script>\n\n<div id=\"example-8\">\n  <input v-model.number=\"firstNumber\" type=\"number\" step=\"20\"> +\n  <input v-model.number=\"secondNumber\" type=\"number\" step=\"20\"> =\n  {{ result }}\n  <p>\n    <animated-integer v-bind:value=\"firstNumber\"></animated-integer> +\n    <animated-integer v-bind:value=\"secondNumber\"></animated-integer> =\n    <animated-integer v-bind:value=\"result\"></animated-integer>\n  </p>\n</div>\n// 这种复杂的补间动画逻辑可以被复用\n// 任何整数都可以执行动画\n// 组件化使我们的界面十分清晰\n// 可以支持更多更复杂的动态过渡\n// 策略。\nVue.component('animated-integer', {\n  template: '<span>{{ tweeningValue }}</span>',\n  props: {\n    value: {\n      type: Number,\n      required: true\n    }\n  },\n  data: function () {\n    return {\n      tweeningValue: 0\n    }\n  },\n  watch: {\n    value: function (newValue, oldValue) {\n      this.tween(oldValue, newValue)\n    }\n  },\n  mounted: function () {\n    this.tween(0, this.value)\n  },\n  methods: {\n    tween: function (startValue, endValue) {\n      var vm = this\n      function animate () {\n        if (TWEEN.update()) {\n          requestAnimationFrame(animate)\n        }\n      }\n\n      new TWEEN.Tween({ tweeningValue: startValue })\n        .to({ tweeningValue: endValue }, 500)\n        .onUpdate(function () {\n          vm.tweeningValue = this.tweeningValue.toFixed(0)\n        })\n        .start()\n\n      animate()\n    }\n  }\n})\n\n// 所有的复杂度都已经从 Vue 的主实例中移除！\nnew Vue({\n  el: '#example-8',\n  data: {\n    firstNumber: 20,\n    secondNumber: 40\n  },\n  computed: {\n    result: function () {\n      return this.firstNumber + this.secondNumber\n    }\n  }\n})\n```\n\n\n\n### 赋予设计以生命\n\n","source":"_drafts/Vue/Vue2-教程/Vue2-教程-过渡和动画.md","raw":"---\ntitle: Vue-使用-过渡和动画\ndate: 2021-10-29 23:15:25\ntags:\n - Vue\n - Vue2\n - 文档\ncategories:\n - Vue\n - Vue2文档\n---\n\n\n\n# 过渡和动画\n\n## 进入/离开和列表转换\n\n​\t\tVue提供了多种方法在DOM中的过渡效果\n\n* 自动为CSS过渡和动画应用类\n* 集成第三方CSS动画库，如 Animate.css\n* 在过渡钩子期间使用 JavaScript 直接操作 DOM\n* 集成第三方JavaScript动画库，例如 Velocity.js\n\n\n\n### 过渡单个元素/组件\n\n​\t\tVue 提供了一个`transition`包装组件，允许您在以下上下文中为任何元素或组件添加进入/离开转换：\n\n* 条件渲染（使用`v-if`）\n* 条件显示（使用`v-show`）\n* 动态组件\n* 组件根节点\n\n\n\n​\t\t在这里我直接复制官网的例子，并加以一个简单的说明，首先，对于transition来说，需要的是一个根组件（根元素），对于存在多个根组件的，便会只渲染一个，其次，对于不是非根元素进行的渲染显示不会有效果。\n\n```\n<div id=\"demo\">\n  <button v-on:click=\"show = !show\">\n    Toggle\n  </button>\n  <transition name=\"fade\">\n    <p v-if=\"show\">hello</p>\n  </transition>\n</div>\n\nnew Vue({\n  el: '#demo',\n  data: {\n    show: true\n  }\n})\n\n.fade-enter-active, .fade-leave-active {\n  transition: opacity .5s;\n}\n.fade-enter, .fade-leave-to /* .fade-leave-active below version 2.1.8 */ {\n  opacity: 0;\n}\n```\n\n当`transition`插入或删除包裹在组件中的元素时，会发生以下情况：\n\n1. Vue 会自动嗅探目标元素是否应用了 CSS 过渡或动画。如果是这样，CSS 过渡类将在适当的时间添加/删除。\n2. 如果转换组件提供了[JavaScript hooks](https://vuejs.org/v2/guide/transitions.html#JavaScript-Hooks)，这些 hooks 将在适当的时间被调用。\n3. 如果没有检测到 CSS 过渡/动画，也没有提供 JavaScript 钩子，插入和/或移除的 DOM 操作将在下一帧立即执行（注意：这是一个浏览器动画帧，与 Vue 的概念不同`nextTick`）。\n\n\n\n#### 过渡的类名\n\n​\t\t在进入/离开的过程中，会有6个 class 切换\n\n* v-enter\n  * 进入的起始状态，在插入元素之前添加，在插入元素后移除一帧\n* v-enter-active\n  * 进入的活动状态，在整个进入阶段应用。插入元素之前添加，在过渡完成时移除。定义进入过渡的事件、延迟和缓动曲线。\n* v-enter-to\n  * 2.1.8+\n  * 进入的结束状态。插入元素后添加一帧（同时 v-enter 删除），在过渡完成时删除。\n* v-leave\n  * 定义离开过渡的开始状态。在离开过渡被触发时立刻生效。下一帧被移除\n* v-leave-active\n  * 定义离开过渡生效时的状态。在离开过渡立刻生效，过渡完成被移除，同 v-enter-active\n* v-leave-to\n  * 2.1.8 +\n  * 定义离开过渡的结束状态。离开过渡被触发后下一帧生效（同时 v-leave 被删除）。过渡完成被移除\n\n\n\n![image-20211203152116522](Vue2-教程-过渡和动画\\image-20211203152116522.png)\n\n​\t\t在这些过渡的切换中，如果你使用一个没有名字的transition，则v-是这些类名的默认前缀。\n\n```\n<transition>\n    <p v-show=\"show\">hello</p>\n</transition>\n\n.v-enter-active,\n```\n\n​\t\t如果你使用了 `<transition name=\"my-transition\">` ，那么 `v-enter` 会替换为 `my-transition-enter` 。\n\n​\t\tv-enter-active 和 v-leave-active 可以控制进入/离开过渡的不同的缓和曲线。\n\n\n\n<img src=\"Vue2-教程-过渡和动画\\image-20211203154333481.png\" alt=\"image-20211203154333481\"  />\n\n​\t\t通过图示可以看出，当元素进行显示时：\n\n* 先插入 v-enter 和 v-enter-active， \n* 然后再下一帧删除 v-enter，出现了 v-enter-to\n* 然后结束了 v-enter-active 和 v-enter-to 消失。\n\nv-leave 是一样的效果。\n\n\n\n#### CSS过渡\n\n​\t\t和普通的过渡是没有什么区别的。\n\n```\n.bounce-enter-active {\n  animation: bounce-in .5s;\n}\n.bounce-leave-active {\n  animation: bounce-in .5s reverse;\n}\n\n@keyframes bounce-in {\n  0% {\n    transform: scale(0);\n  }\n  50% {\n    transform: scale(1.5);\n  }\n  100% {\n    transform: scale(1);\n  }\n}\n```\n\n\n\n#### 自定义过渡的类名\n\n​\t\t我们可以通过使用以下的属性来自定义过渡的类名。并且他们的优先级会高于普通的类名。因此对于使用其他第三方css库十分的有用。\n\n```\nenter-class\nenter-active-class\nenter-to-class (2.1.8+)\nleave-class\nleave-active-class\nleave-to-class (2.1.8+)\n```\n\n​\t\t这里name就是往常一样的name，然后在元素里面添加了标签，标签是 enter-xx-class，或者是 leave-xx-class 这种。\n\n```\n<transition\nname=\"custom-classes-transition\"\nenter-active-class=\"animated tada\"\nleave-active-class=\"animated bounceOutRight\"\n>\n    <p v-if=\"show\">hello</p>\n</transition>\n```\n\n\n\n#### 同时使用过渡和动画\n\n​\t\tVue为了能知道过渡的完成，必须设置相应的事件监听器。他可以是 transitionend 或者是 animationend，如果你只是使用了其中一种，Vue可以自动识别并设置监听。\n\n​\t\t但是如果你同时使用了 transition 和 animation，那么这种情况你就需要使用 type 属性来指定Vue需要监听的类型。\n\n​\t\t如果你不指定的话，我从使用上看来他会默认监听的是时间最长的那个，就是延迟时间和运行时间加起来最大的那个。\n\n```\n<transition name=\"slide-fade\" type=\"transition\">\n    <p v-if=\"show\"> content </p>\n</transition>\n```\n\n\n\n#### 显性的过渡持续时间\n\n​\t\t2.2.0 新增\n\n​\t\t默认情况下，Vue会自动计算出过渡时间。会等待过渡效果的 transitionend 和 animationend 事件。\n\n​\t\t但是，我们可以显性的设置一个过渡的持续时间。\n\n​\t\t下面这个代码的意思就是，对于使用了 duration 设置了显性的过渡时间了的，在到达过渡的时间之后，便会直接进行过渡的结束。\n\n```\n<transition :duration=\"1000\">...</transition>\n\n<transition :duration=\"{ enter: 500, leave: 800 }\">...</transition>\n```\n\n\n\n#### JavaScript 钩子\n\n​\t\t可以在属性中声明 JavaScript 钩子。\n\n​\t\t这里我简单介绍一下 JavaScript钩子的执行时机，虽然通过名字也能够大致猜的出来意思\n\n* before-enter： 简单来说就是在enter启动之前，就像是前面的 v-enter\n* enter： 就是在调用期间， v-enter-to，但是这个 JavaScript钩子 没有说版本要求，而 v-enter-to 是2.1.8以上的，所以这个应该是更像 v-enter-active 。\n* after-enter： 就是在就是结束时会进行的调用，应该接近于 animationend 或者 transitionend 这两个回调。\n* enter-cancalled： 就是在没有调用after-enter的时候就又进行了一次切换，此时就会调用 enter-cancalled 回调。\n\n```\n<transition\n  v-on:before-enter=\"beforeEnter\"\n  v-on:enter=\"enter\"\n  v-on:after-enter=\"afterEnter\"\n  v-on:enter-cancelled=\"enterCancelled\"\n\n  v-on:before-leave=\"beforeLeave\"\n  v-on:leave=\"leave\"\n  v-on:after-leave=\"afterLeave\"\n  v-on:leave-cancelled=\"leaveCancelled\"\n>\n  <!-- ... -->\n</transition>\n```\n\n​\t\t这里需要注意，\n\n* 当只用 JavaScript 过渡的时候，**在 `enter` 和 `leave` 中必须使用 `done` 进行回调**。否则，它们将被同步调用，过渡会立即完成。\n  * 这个我没有仔细使用过函数进行动画的过渡，而是进行一些其他的操作，但是这里 done的回调是必须的。因为我们可以看到如果不使用done函数，那么便不会调用 after-enter 来结束，所以这个done函数更像是 生成器函数的 next 一样。\n  * 这里我使用了css进行过渡，然后JavaScript进行钩子的调用，发现css的过渡没有出现效果，直接只能使用钩子的调用了。就算是使用自定义过渡类名属性 enter-class 这些也没有效果。\n* 推荐对于仅使用 JavaScript 过渡的元素添加 `v-bind:css=\"false\"`，Vue 会跳过 CSS 的检测。这也可以避免过渡过程中 CSS 的影响。\n* leaveCancelled 只能用于 v-show 中。\n\n```\n// ...\nmethods: {\n  // --------\n  // 进入中\n  // --------\n\n  beforeEnter: function (el) {\n    // ...\n  },\n  // 当与 CSS 结合使用时\n  // 回调函数 done 是可选的\n  enter: function (el, done) {\n    // ...\n    done()\n  },\n  afterEnter: function (el) {\n    // ...\n  },\n  enterCancelled: function (el) {\n    // ...\n  },\n\n  // --------\n  // 离开时\n  // --------\n\n  beforeLeave: function (el) {\n    // ...\n  },\n  // 当与 CSS 结合使用时\n  // 回调函数 done 是可选的\n  leave: function (el, done) {\n    // ...\n    done()\n  },\n  afterLeave: function (el) {\n    // ...\n  },\n  // leaveCancelled 只用于 v-show 中\n  leaveCancelled: function (el) {\n    // ...\n  }\n}\n```\n\n\n\n### 初始渲染的过渡\n\n​\t\t通过使用 appear 属性设置节点初始渲染的过渡\n\n​\t\t简单来说就是会在开始的时候有一个过渡的效果。\n\n```\n<transition appear>\n```\n\n​\t可以自定义 css 类名\n\n```\n<transition\n  appear\n  appear-class=\"custom-appear-class\"\n  appear-to-class=\"custom-appear-to-class\" (2.1.8+)\n  appear-active-class=\"custom-appear-active-class\"\n>\n```\n\n​\t自定义JavaScript 钩子\n\n```\n<transition\n  appear\n  v-on:before-appear=\"customBeforeAppearHook\"\n  v-on:appear=\"customAppearHook\"\n  v-on:after-appear=\"customAfterAppearHook\"\n  v-on:appear-cancelled=\"customAppearCancelledHook\"\n>\n```\n\n​\t\t在上面的例子中，无论是使用 appear attribute 还是使用 v-on:appear 钩子都会生成初始渲染的过渡。\n\n\n\n### 多个元素的过渡\n\n​\t\t对于原生的标签，可以使用 v-if / v-else 进行过渡。\n\n> 当有**相同标签名**的元素切换时，需要通过 `key` attribute 设置唯一的值来标记以让 Vue 区分它们，否则 Vue 为了效率只会替换相同标签内部的内容。即使在技术上没有必要，**给在 `<transition>` 组件中的多个元素设置 key 是一个更好的实践。**\n\n\n\n```\n<transition>\n  <button v-if=\"isEditing\" key=\"save\">\n    Save\n  </button>\n  <button v-else key=\"edit\">\n    Edit\n  </button>\n</transition>\n```\n\n​\t\t在某些场景，也可以通过给同一个元素的key属性设置不同的状态来代替 v-if 和 v-else。\n\n```\n<transition>\n  <button v-bind:key=\"isEditing\">\n    {{ isEditing ? 'Save' : 'Edit' }}\n  </button>\n</transition>\n```\n\n\n\n#### 过渡模式\n\n​\t\t简单来说就是元素的切换是同步的，所以会出现占位的问题，并且当使用的是 v-if 的时候，开始会占位，但是在过渡结束之后就会出现位置消失，然后后面的元素会补充上去。\n\n​\t\t所以此时我们就需要进行处理。\n\n​\t\t解决方式一般是使用定位的形式，因为定位是脱离了文档流的，所以就不会出现这个问题了。然后此时我们再使用一个 transition 进行过渡的显示便有了效果。\n\n\n\n​\t\t当然同时生效的进入和离开的过渡不能满足所有要求，所以Vue提供了**过渡模式** mode\n\n* `in-out` ：新元素先过渡，完成后旧元素过渡离开。\n* `out-in` ：旧元素先过渡，完成后新元素过渡进入。\n\n```\n<transition name=\"fade\" mode=\"out-in\">\n  <!-- ... the buttons ... -->\n</transition>\n```\n\n\n\n### 多组件的过渡\n\n​\t\t我们可以直接使用动态组件来进行组件之间的过渡\n\n```\n<transition name=\"component-fade\" mode=\"out-in\">\n  <component v-bind:is=\"view\"></component>\n</transition>\n```\n\n```\nnew Vue({\n  el: '#transition-components-demo',\n  data: {\n    view: 'v-a'\n  },\n  components: {\n    'v-a': {\n      template: '<div>Component A</div>'\n    },\n    'v-b': {\n      template: '<div>Component B</div>'\n    }\n  }\n})\n```\n\n\n\n### 列表过渡\n\n​\t\t对于使用v-for渲染时的过渡。可以使用 transition-group 组件。\n\n**特点**：\n\n* transition-group 会以一个真实的元素呈现：默认为 span，也可以通过 tag 属性来更换为其他元素。\n* 不能使用过渡模式。mode\n* 内部元素总是需要提供一个唯一的 key 属性值\n* CSS 过渡的类 将会应用在内部元素中，而不是这个 组件/容器 本身。\n\n\n\n​\t\t这里，首先name为list，其次使用了tag，默认不使用tag时为span，使用了tag为p，所以就是p标签进行包裹。然后内部是使用span标签进行的for循环。最后，使用transition-group，key值是必须的。\n\n```\n<transition-group name=\"list\" tag=\"p\">\n\t<span v-for=\"item in items\" v-bind:key=\"item\" class=\"list-item\">\n\t\t{{ item }}\n\t</span>\n</transition-group>\n```\n\n\n\n#### 列表的进入/离开过渡\n\n​\t\t列表的进入/离开过渡是和以前的过渡的方式是一样的。只是过渡变成了每一个小组件了。\n\n​\t\t问题就是过渡的平滑展现，比如新增的元素，周围的元素会瞬间移动到他们新布局的位置，而不是平滑的过渡。\n\n```\n.list-enter-active, .list-leave-active {\n  transition: all 1s;\n}\n.list-enter, .list-leave-to\n/* .list-leave-active for below version 2.1.8 */ {\n  opacity: 0;\n  transform: translateY(30px);\n}\n```\n\n\n\n#### 排序的过渡\n\n​\t\t可以通过使用 v-move 类来实现列表的移动。\n\n```\n<transition-group name=\"list\" tag=\"ul\">\n    <li v-for=\"(item, index) in items\" v-bind:key=\"item\" class=\"list-item\">\n\t\t{{ item }}\n    </li>\n</transition-group>\n\n.list-item {\n    transition: all 1s;\n}\n\n.list-enter,\n.list-leave-to {\n    opacity: 0;\n    transform: translateY(30px);\n}\n```\n\n​\t\t如果我对列表进行一次排序。就会发现动画的效果。\n\n​\t这个看起来很神奇，内部的实现，Vue 使用了一个叫 [FLIP](https://aerotwist.com/blog/flip-your-animations/) 简单的动画队列。\n\n​\t\t当然，前面的style样式对于增加排序时的效果都还是不错，但是对于删除来说，效果就不一样了。\n\n​\t于是我们对于要进行删除的元素进行了一个绝对定位。\n\n​\t对于为什么要使用绝对定位，那是因为当使用了绝对定位之后，那便不会在同一图层。然后此时后面的元素便会向前移动，然后再通过 transition: all .5s; 来进行一个动态的变化。\n\n```\n.list-leave-active {\n    position: absolute;\n}\n```\n\n> 需要注意的是使用 FLIP 过渡的元素不能设置为 `display: inline` 。作为替代方案，可以设置为 `display: inline-block` 或者放置于 flex 中\n\n\n\n**多维网格也可以进行过渡**：\n\n```\n<!DOCTYPE html>\n<html>\n  <head>\n    <title>List Move Transitions Sudoku Example</title>\n    <script src=\"https://unpkg.com/vue\"></script>\n    <link rel=\"stylesheet\" type=\"text/css\" href=\"./style.css\" />\n  </head>\n  <body>\n    <div id=\"sudoku-demo\" class=\"demo\">\n      <h1>Lazy Sudoku</h1>\n      <p>Keep hitting the shuffle button until you win.</p>\n\n      <button @click=\"shuffle\">\n        Shuffle\n      </button>\n      <transition-group name=\"cell\" tag=\"div\" class=\"container\">\n        <div v-for=\"cell in cells\" :key=\"cell.id\" class=\"cell\">\n          {{ cell.number }}\n        </div>\n      </transition-group>\n    </div>\n\n    <script>\n      new Vue({\n        el: \"#sudoku-demo\",\n        data: {\n          cells: Array.apply(null, { length: 81 }).map(function(_, index) {\n            return {\n              id: index,\n              number: (index % 9) + 1\n            };\n          })\n        },\n        methods: {\n          shuffle: function() {\n            this.cells = this.randomSort(this.cells);\n          },\n          randomSort(arr) {\n            const res = arr.slice();\n            for (let i=0; i<arr.length; i++) {\n              const index = this.randomIndex();\n              [res[i], res[index]] = [res[index], res[i]];\n            }\n\n            return res;\n          },\n          randomIndex() {\n            return Math.floor(Math.random() * this.cells.length);\n          }\n        }\n      });\n    </script>\n  </body>\n  \n  <style>\n.container {\n  display: flex;\n  flex-wrap: wrap;\n  width: 238px;\n  margin-top: 10px;\n}\n.cell {\n  display: flex;\n  justify-content: space-around;\n  align-items: center;\n  width: 25px;\n  height: 25px;\n  border: 1px solid #aaa;\n  margin-right: -1px;\n  margin-bottom: -1px;\n}\n.cell:nth-child(3n) {\n  margin-right: 0;\n}\n.cell:nth-child(27n) {\n  margin-bottom: 0;\n}\n.cell-move {\n  transition: transform 1s;\n}\n\n  </style>\n  \n</html>\n\n```\n\n\n\n#### 交错的过渡\n\n​\t\t通过data属性和JavaScript的通信，可以实现列表的交错过渡。简单来说就是使用js方法进行了渲染。因为 velocity 不能访问，所以没有进行实验。\n\n```\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/velocity/1.2.3/velocity.min.js\"></script>\n\n<div id=\"staggered-list-demo\">\n  <input v-model=\"query\">\n  <transition-group\n    name=\"staggered-fade\"\n    tag=\"ul\"\n    v-bind:css=\"false\"\n    v-on:before-enter=\"beforeEnter\"\n    v-on:enter=\"enter\"\n    v-on:leave=\"leave\"\n  >\n    <li\n      v-for=\"(item, index) in computedList\"\n      v-bind:key=\"item.msg\"\n      v-bind:data-index=\"index\"\n    >{{ item.msg }}</li>\n  </transition-group>\n</div>\n\nnew Vue({\n  el: '#staggered-list-demo',\n  data: {\n    query: '',\n    list: [\n      { msg: 'Bruce Lee' },\n      { msg: 'Jackie Chan' },\n      { msg: 'Chuck Norris' },\n      { msg: 'Jet Li' },\n      { msg: 'Kung Fury' }\n    ]\n  },\n  computed: {\n    computedList: function () {\n      var vm = this\n      return this.list.filter(function (item) {\n        return item.msg.toLowerCase().indexOf(vm.query.toLowerCase()) !== -1\n      })\n    }\n  },\n  methods: {\n    beforeEnter: function (el) {\n      el.style.opacity = 0\n      el.style.height = 0\n    },\n    enter: function (el, done) {\n      var delay = el.dataset.index * 150\n      setTimeout(function () {\n        Velocity(\n          el,\n          { opacity: 1, height: '1.6em' },\n          { complete: done }\n        )\n      }, delay)\n    },\n    leave: function (el, done) {\n      var delay = el.dataset.index * 150\n      setTimeout(function () {\n        Velocity(\n          el,\n          { opacity: 0, height: 0 },\n          { complete: done }\n        )\n      }, delay)\n    }\n  }\n})\n```\n\n\n\n### 可复用的过渡\n\n​\t\t可以使用Vue组件系统的实现复用。只需要将 transition 或者 transition-group 作为根组件。\n\n```\nVue.component('my-special-transition', {\n  template: '\\\n    <transition\\\n      name=\"very-special-transition\"\\\n      mode=\"out-in\"\\\n      v-on:before-enter=\"beforeEnter\"\\\n      v-on:after-enter=\"afterEnter\"\\\n    >\\\n      <slot></slot>\\\n    </transition>\\\n  ',\n  methods: {\n    beforeEnter: function (el) {\n      // ...\n    },\n    afterEnter: function (el) {\n      // ...\n    }\n  }\n})\n```\n\n​\t当然，可以使用函数式组件来完成这个任务。函数式组件我们后面在进行了解。\n\n```\nVue.component('my-special-transition', {\n  functional: true,\n  render: function (createElement, context) {\n    var data = {\n      props: {\n        name: 'very-special-transition',\n        mode: 'out-in'\n      },\n      on: {\n        beforeEnter: function (el) {\n          // ...\n        },\n        afterEnter: function (el) {\n          // ...\n        }\n      }\n    }\n    return createElement('transition', data, context.children)\n  }\n})\n```\n\n\n\n### 动态过渡\n\n​\t\t在Vue中，过渡也是数据驱动的。所以name也可以使用 v-bind 来进行绑定。\n\n```\n<transition v-bind:name=\"transitionName\">\n```\n\n​\t\t所有的过渡 attribute 都可以动态绑定。因为事件钩子都是方法。所以根据组件的状态不同，过渡也会有不同的表现。\n\n\n\n## 状态过渡\n\n​\t\t数据元素本身的特效，这些数据要么本身就以数值形式存储，要么可以转换为数值。\n\n- 数字和运算\n- 颜色的显示\n- SVG 节点的位置\n- 元素的大小和其他的 property\n\n\n\n### 状态动画与侦听器\n\n```\n<script src=\"https://cdn.jsdelivr.net/npm/tween.js@16.3.4\"></script>\n<script src=\"https://cdn.jsdelivr.net/npm/color-js@1.0.3\"></script>\n\n<div id=\"example-7\">\n  <input\n    v-model=\"colorQuery\"\n    v-on:keyup.enter=\"updateColor\"\n    placeholder=\"Enter a color\"\n  >\n  <button v-on:click=\"updateColor\">Update</button>\n  <p>Preview:</p>\n  <span\n    v-bind:style=\"{ backgroundColor: tweenedCSSColor }\"\n    class=\"example-7-color-preview\"\n  ></span>\n  <p>{{ tweenedCSSColor }}</p>\n</div>\n```\n\n```\nvar Color = net.brehaut.Color\n\nnew Vue({\n  el: '#example-7',\n  data: {\n    colorQuery: '',\n    color: {\n      red: 0,\n      green: 0,\n      blue: 0,\n      alpha: 1\n    },\n    tweenedColor: {}\n  },\n  created: function () {\n    this.tweenedColor = Object.assign({}, this.color)\n  },\n  watch: {\n    color: function () {\n      function animate () {\n        if (TWEEN.update()) {\n          requestAnimationFrame(animate)\n        }\n      }\n\n      new TWEEN.Tween(this.tweenedColor)\n        .to(this.color, 750)\n        .start()\n\n      animate()\n    }\n  },\n  computed: {\n    tweenedCSSColor: function () {\n      return new Color({\n        red: this.tweenedColor.red,\n        green: this.tweenedColor.green,\n        blue: this.tweenedColor.blue,\n        alpha: this.tweenedColor.alpha\n      }).toCSS()\n    }\n  },\n  methods: {\n    updateColor: function () {\n      this.color = new Color(this.colorQuery).toRGB()\n      this.colorQuery = ''\n    }\n  }\n})\n```\n\n```\n.example-7-color-preview {\n  display: inline-block;\n  width: 50px;\n  height: 50px;\n}\n```\n\n\n\n### 动态状态过渡\n\n​\t\t就像 Vue 的过渡组件一样，数据背后状态过渡会实时更新，这对于原型设计十分有用。当你修改一些变量，即使是一个简单的 SVG 多边形也可实现很多难以想象的效果。\n\n\n\n### 把过渡放到组件里\n\n```\n<script src=\"https://cdn.jsdelivr.net/npm/tween.js@16.3.4\"></script>\n\n<div id=\"example-8\">\n  <input v-model.number=\"firstNumber\" type=\"number\" step=\"20\"> +\n  <input v-model.number=\"secondNumber\" type=\"number\" step=\"20\"> =\n  {{ result }}\n  <p>\n    <animated-integer v-bind:value=\"firstNumber\"></animated-integer> +\n    <animated-integer v-bind:value=\"secondNumber\"></animated-integer> =\n    <animated-integer v-bind:value=\"result\"></animated-integer>\n  </p>\n</div>\n// 这种复杂的补间动画逻辑可以被复用\n// 任何整数都可以执行动画\n// 组件化使我们的界面十分清晰\n// 可以支持更多更复杂的动态过渡\n// 策略。\nVue.component('animated-integer', {\n  template: '<span>{{ tweeningValue }}</span>',\n  props: {\n    value: {\n      type: Number,\n      required: true\n    }\n  },\n  data: function () {\n    return {\n      tweeningValue: 0\n    }\n  },\n  watch: {\n    value: function (newValue, oldValue) {\n      this.tween(oldValue, newValue)\n    }\n  },\n  mounted: function () {\n    this.tween(0, this.value)\n  },\n  methods: {\n    tween: function (startValue, endValue) {\n      var vm = this\n      function animate () {\n        if (TWEEN.update()) {\n          requestAnimationFrame(animate)\n        }\n      }\n\n      new TWEEN.Tween({ tweeningValue: startValue })\n        .to({ tweeningValue: endValue }, 500)\n        .onUpdate(function () {\n          vm.tweeningValue = this.tweeningValue.toFixed(0)\n        })\n        .start()\n\n      animate()\n    }\n  }\n})\n\n// 所有的复杂度都已经从 Vue 的主实例中移除！\nnew Vue({\n  el: '#example-8',\n  data: {\n    firstNumber: 20,\n    secondNumber: 40\n  },\n  computed: {\n    result: function () {\n      return this.firstNumber + this.secondNumber\n    }\n  }\n})\n```\n\n\n\n### 赋予设计以生命\n\n","slug":"Vue/Vue2-教程/Vue2-教程-过渡和动画","published":0,"updated":"2022-02-07T02:34:19.740Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckznhkk8k006aikubct7r2880","content":"<h1 id=\"过渡和动画\"><a href=\"#过渡和动画\" class=\"headerlink\" title=\"过渡和动画\"></a>过渡和动画</h1><h2 id=\"进入-离开和列表转换\"><a href=\"#进入-离开和列表转换\" class=\"headerlink\" title=\"进入/离开和列表转换\"></a>进入/离开和列表转换</h2><p>​        Vue提供了多种方法在DOM中的过渡效果</p>\n<ul>\n<li>自动为CSS过渡和动画应用类</li>\n<li>集成第三方CSS动画库，如 Animate.css</li>\n<li>在过渡钩子期间使用 JavaScript 直接操作 DOM</li>\n<li>集成第三方JavaScript动画库，例如 Velocity.js</li>\n</ul>\n<h3 id=\"过渡单个元素-组件\"><a href=\"#过渡单个元素-组件\" class=\"headerlink\" title=\"过渡单个元素/组件\"></a>过渡单个元素/组件</h3><p>​        Vue 提供了一个<code>transition</code>包装组件，允许您在以下上下文中为任何元素或组件添加进入/离开转换：</p>\n<ul>\n<li>条件渲染（使用<code>v-if</code>）</li>\n<li>条件显示（使用<code>v-show</code>）</li>\n<li>动态组件</li>\n<li>组件根节点</li>\n</ul>\n<p>​        在这里我直接复制官网的例子，并加以一个简单的说明，首先，对于transition来说，需要的是一个根组件（根元素），对于存在多个根组件的，便会只渲染一个，其次，对于不是非根元素进行的渲染显示不会有效果。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=&quot;demo&quot;&gt;</span><br><span class=\"line\">  &lt;button v-on:click=&quot;show = !show&quot;&gt;</span><br><span class=\"line\">    Toggle</span><br><span class=\"line\">  &lt;/button&gt;</span><br><span class=\"line\">  &lt;transition name=&quot;fade&quot;&gt;</span><br><span class=\"line\">    &lt;p v-if=&quot;show&quot;&gt;hello&lt;/p&gt;</span><br><span class=\"line\">  &lt;/transition&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">new Vue(&#123;</span><br><span class=\"line\">  el: &#x27;#demo&#x27;,</span><br><span class=\"line\">  data: &#123;</span><br><span class=\"line\">    show: true</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">.fade-enter-active, .fade-leave-active &#123;</span><br><span class=\"line\">  transition: opacity .5s;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.fade-enter, .fade-leave-to /* .fade-leave-active below version 2.1.8 */ &#123;</span><br><span class=\"line\">  opacity: 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当<code>transition</code>插入或删除包裹在组件中的元素时，会发生以下情况：</p>\n<ol>\n<li>Vue 会自动嗅探目标元素是否应用了 CSS 过渡或动画。如果是这样，CSS 过渡类将在适当的时间添加/删除。</li>\n<li>如果转换组件提供了<a href=\"https://vuejs.org/v2/guide/transitions.html#JavaScript-Hooks\">JavaScript hooks</a>，这些 hooks 将在适当的时间被调用。</li>\n<li>如果没有检测到 CSS 过渡/动画，也没有提供 JavaScript 钩子，插入和/或移除的 DOM 操作将在下一帧立即执行（注意：这是一个浏览器动画帧，与 Vue 的概念不同<code>nextTick</code>）。</li>\n</ol>\n<h4 id=\"过渡的类名\"><a href=\"#过渡的类名\" class=\"headerlink\" title=\"过渡的类名\"></a>过渡的类名</h4><p>​        在进入/离开的过程中，会有6个 class 切换</p>\n<ul>\n<li>v-enter<ul>\n<li>进入的起始状态，在插入元素之前添加，在插入元素后移除一帧</li>\n</ul>\n</li>\n<li>v-enter-active<ul>\n<li>进入的活动状态，在整个进入阶段应用。插入元素之前添加，在过渡完成时移除。定义进入过渡的事件、延迟和缓动曲线。</li>\n</ul>\n</li>\n<li>v-enter-to<ul>\n<li>2.1.8+</li>\n<li>进入的结束状态。插入元素后添加一帧（同时 v-enter 删除），在过渡完成时删除。</li>\n</ul>\n</li>\n<li>v-leave<ul>\n<li>定义离开过渡的开始状态。在离开过渡被触发时立刻生效。下一帧被移除</li>\n</ul>\n</li>\n<li>v-leave-active<ul>\n<li>定义离开过渡生效时的状态。在离开过渡立刻生效，过渡完成被移除，同 v-enter-active</li>\n</ul>\n</li>\n<li>v-leave-to<ul>\n<li>2.1.8 +</li>\n<li>定义离开过渡的结束状态。离开过渡被触发后下一帧生效（同时 v-leave 被删除）。过渡完成被移除</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"/.io//Vue2-%E6%95%99%E7%A8%8B-%E8%BF%87%E6%B8%A1%E5%92%8C%E5%8A%A8%E7%94%BB%5Cimage-20211203152116522.png\" alt=\"image-20211203152116522\"></p>\n<p>​        在这些过渡的切换中，如果你使用一个没有名字的transition，则v-是这些类名的默认前缀。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;transition&gt;</span><br><span class=\"line\">    &lt;p v-show=&quot;show&quot;&gt;hello&lt;/p&gt;</span><br><span class=\"line\">&lt;/transition&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">.v-enter-active,</span><br></pre></td></tr></table></figure>\n\n<p>​        如果你使用了 <code>&lt;transition name=&quot;my-transition&quot;&gt;</code> ，那么 <code>v-enter</code> 会替换为 <code>my-transition-enter</code> 。</p>\n<p>​        v-enter-active 和 v-leave-active 可以控制进入/离开过渡的不同的缓和曲线。</p>\n<img src=\"/.io//image-20211203154333481.png\" alt=\"image-20211203154333481\">\n\n<p>​        通过图示可以看出，当元素进行显示时：</p>\n<ul>\n<li>先插入 v-enter 和 v-enter-active， </li>\n<li>然后再下一帧删除 v-enter，出现了 v-enter-to</li>\n<li>然后结束了 v-enter-active 和 v-enter-to 消失。</li>\n</ul>\n<p>v-leave 是一样的效果。</p>\n<h4 id=\"CSS过渡\"><a href=\"#CSS过渡\" class=\"headerlink\" title=\"CSS过渡\"></a>CSS过渡</h4><p>​        和普通的过渡是没有什么区别的。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.bounce-enter-active &#123;</span><br><span class=\"line\">  animation: bounce-in .5s;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.bounce-leave-active &#123;</span><br><span class=\"line\">  animation: bounce-in .5s reverse;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@keyframes bounce-in &#123;</span><br><span class=\"line\">  0% &#123;</span><br><span class=\"line\">    transform: scale(0);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  50% &#123;</span><br><span class=\"line\">    transform: scale(1.5);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  100% &#123;</span><br><span class=\"line\">    transform: scale(1);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"自定义过渡的类名\"><a href=\"#自定义过渡的类名\" class=\"headerlink\" title=\"自定义过渡的类名\"></a>自定义过渡的类名</h4><p>​        我们可以通过使用以下的属性来自定义过渡的类名。并且他们的优先级会高于普通的类名。因此对于使用其他第三方css库十分的有用。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">enter-class</span><br><span class=\"line\">enter-active-class</span><br><span class=\"line\">enter-to-class (2.1.8+)</span><br><span class=\"line\">leave-class</span><br><span class=\"line\">leave-active-class</span><br><span class=\"line\">leave-to-class (2.1.8+)</span><br></pre></td></tr></table></figure>\n\n<p>​        这里name就是往常一样的name，然后在元素里面添加了标签，标签是 enter-xx-class，或者是 leave-xx-class 这种。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;transition</span><br><span class=\"line\">name=&quot;custom-classes-transition&quot;</span><br><span class=\"line\">enter-active-class=&quot;animated tada&quot;</span><br><span class=\"line\">leave-active-class=&quot;animated bounceOutRight&quot;</span><br><span class=\"line\">&gt;</span><br><span class=\"line\">    &lt;p v-if=&quot;show&quot;&gt;hello&lt;/p&gt;</span><br><span class=\"line\">&lt;/transition&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"同时使用过渡和动画\"><a href=\"#同时使用过渡和动画\" class=\"headerlink\" title=\"同时使用过渡和动画\"></a>同时使用过渡和动画</h4><p>​        Vue为了能知道过渡的完成，必须设置相应的事件监听器。他可以是 transitionend 或者是 animationend，如果你只是使用了其中一种，Vue可以自动识别并设置监听。</p>\n<p>​        但是如果你同时使用了 transition 和 animation，那么这种情况你就需要使用 type 属性来指定Vue需要监听的类型。</p>\n<p>​        如果你不指定的话，我从使用上看来他会默认监听的是时间最长的那个，就是延迟时间和运行时间加起来最大的那个。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;transition name=&quot;slide-fade&quot; type=&quot;transition&quot;&gt;</span><br><span class=\"line\">    &lt;p v-if=&quot;show&quot;&gt; content &lt;/p&gt;</span><br><span class=\"line\">&lt;/transition&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"显性的过渡持续时间\"><a href=\"#显性的过渡持续时间\" class=\"headerlink\" title=\"显性的过渡持续时间\"></a>显性的过渡持续时间</h4><p>​        2.2.0 新增</p>\n<p>​        默认情况下，Vue会自动计算出过渡时间。会等待过渡效果的 transitionend 和 animationend 事件。</p>\n<p>​        但是，我们可以显性的设置一个过渡的持续时间。</p>\n<p>​        下面这个代码的意思就是，对于使用了 duration 设置了显性的过渡时间了的，在到达过渡的时间之后，便会直接进行过渡的结束。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;transition :duration=&quot;1000&quot;&gt;...&lt;/transition&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;transition :duration=&quot;&#123; enter: 500, leave: 800 &#125;&quot;&gt;...&lt;/transition&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"JavaScript-钩子\"><a href=\"#JavaScript-钩子\" class=\"headerlink\" title=\"JavaScript 钩子\"></a>JavaScript 钩子</h4><p>​        可以在属性中声明 JavaScript 钩子。</p>\n<p>​        这里我简单介绍一下 JavaScript钩子的执行时机，虽然通过名字也能够大致猜的出来意思</p>\n<ul>\n<li>before-enter： 简单来说就是在enter启动之前，就像是前面的 v-enter</li>\n<li>enter： 就是在调用期间， v-enter-to，但是这个 JavaScript钩子 没有说版本要求，而 v-enter-to 是2.1.8以上的，所以这个应该是更像 v-enter-active 。</li>\n<li>after-enter： 就是在就是结束时会进行的调用，应该接近于 animationend 或者 transitionend 这两个回调。</li>\n<li>enter-cancalled： 就是在没有调用after-enter的时候就又进行了一次切换，此时就会调用 enter-cancalled 回调。</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;transition</span><br><span class=\"line\">  v-on:before-enter=&quot;beforeEnter&quot;</span><br><span class=\"line\">  v-on:enter=&quot;enter&quot;</span><br><span class=\"line\">  v-on:after-enter=&quot;afterEnter&quot;</span><br><span class=\"line\">  v-on:enter-cancelled=&quot;enterCancelled&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">  v-on:before-leave=&quot;beforeLeave&quot;</span><br><span class=\"line\">  v-on:leave=&quot;leave&quot;</span><br><span class=\"line\">  v-on:after-leave=&quot;afterLeave&quot;</span><br><span class=\"line\">  v-on:leave-cancelled=&quot;leaveCancelled&quot;</span><br><span class=\"line\">&gt;</span><br><span class=\"line\">  &lt;!-- ... --&gt;</span><br><span class=\"line\">&lt;/transition&gt;</span><br></pre></td></tr></table></figure>\n\n<p>​        这里需要注意，</p>\n<ul>\n<li>当只用 JavaScript 过渡的时候，<strong>在 <code>enter</code> 和 <code>leave</code> 中必须使用 <code>done</code> 进行回调</strong>。否则，它们将被同步调用，过渡会立即完成。<ul>\n<li>这个我没有仔细使用过函数进行动画的过渡，而是进行一些其他的操作，但是这里 done的回调是必须的。因为我们可以看到如果不使用done函数，那么便不会调用 after-enter 来结束，所以这个done函数更像是 生成器函数的 next 一样。</li>\n<li>这里我使用了css进行过渡，然后JavaScript进行钩子的调用，发现css的过渡没有出现效果，直接只能使用钩子的调用了。就算是使用自定义过渡类名属性 enter-class 这些也没有效果。</li>\n</ul>\n</li>\n<li>推荐对于仅使用 JavaScript 过渡的元素添加 <code>v-bind:css=&quot;false&quot;</code>，Vue 会跳过 CSS 的检测。这也可以避免过渡过程中 CSS 的影响。</li>\n<li>leaveCancelled 只能用于 v-show 中。</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// ...</span><br><span class=\"line\">methods: &#123;</span><br><span class=\"line\">  // --------</span><br><span class=\"line\">  // 进入中</span><br><span class=\"line\">  // --------</span><br><span class=\"line\"></span><br><span class=\"line\">  beforeEnter: function (el) &#123;</span><br><span class=\"line\">    // ...</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  // 当与 CSS 结合使用时</span><br><span class=\"line\">  // 回调函数 done 是可选的</span><br><span class=\"line\">  enter: function (el, done) &#123;</span><br><span class=\"line\">    // ...</span><br><span class=\"line\">    done()</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  afterEnter: function (el) &#123;</span><br><span class=\"line\">    // ...</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  enterCancelled: function (el) &#123;</span><br><span class=\"line\">    // ...</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  // --------</span><br><span class=\"line\">  // 离开时</span><br><span class=\"line\">  // --------</span><br><span class=\"line\"></span><br><span class=\"line\">  beforeLeave: function (el) &#123;</span><br><span class=\"line\">    // ...</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  // 当与 CSS 结合使用时</span><br><span class=\"line\">  // 回调函数 done 是可选的</span><br><span class=\"line\">  leave: function (el, done) &#123;</span><br><span class=\"line\">    // ...</span><br><span class=\"line\">    done()</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  afterLeave: function (el) &#123;</span><br><span class=\"line\">    // ...</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  // leaveCancelled 只用于 v-show 中</span><br><span class=\"line\">  leaveCancelled: function (el) &#123;</span><br><span class=\"line\">    // ...</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"初始渲染的过渡\"><a href=\"#初始渲染的过渡\" class=\"headerlink\" title=\"初始渲染的过渡\"></a>初始渲染的过渡</h3><p>​        通过使用 appear 属性设置节点初始渲染的过渡</p>\n<p>​        简单来说就是会在开始的时候有一个过渡的效果。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;transition appear&gt;</span><br></pre></td></tr></table></figure>\n\n<p>​    可以自定义 css 类名</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;transition</span><br><span class=\"line\">  appear</span><br><span class=\"line\">  appear-class=&quot;custom-appear-class&quot;</span><br><span class=\"line\">  appear-to-class=&quot;custom-appear-to-class&quot; (2.1.8+)</span><br><span class=\"line\">  appear-active-class=&quot;custom-appear-active-class&quot;</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n\n<p>​    自定义JavaScript 钩子</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;transition</span><br><span class=\"line\">  appear</span><br><span class=\"line\">  v-on:before-appear=&quot;customBeforeAppearHook&quot;</span><br><span class=\"line\">  v-on:appear=&quot;customAppearHook&quot;</span><br><span class=\"line\">  v-on:after-appear=&quot;customAfterAppearHook&quot;</span><br><span class=\"line\">  v-on:appear-cancelled=&quot;customAppearCancelledHook&quot;</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n\n<p>​        在上面的例子中，无论是使用 appear attribute 还是使用 v-on:appear 钩子都会生成初始渲染的过渡。</p>\n<h3 id=\"多个元素的过渡\"><a href=\"#多个元素的过渡\" class=\"headerlink\" title=\"多个元素的过渡\"></a>多个元素的过渡</h3><p>​        对于原生的标签，可以使用 v-if / v-else 进行过渡。</p>\n<blockquote>\n<p>当有<strong>相同标签名</strong>的元素切换时，需要通过 <code>key</code> attribute 设置唯一的值来标记以让 Vue 区分它们，否则 Vue 为了效率只会替换相同标签内部的内容。即使在技术上没有必要，<strong>给在 <code>&lt;transition&gt;</code> 组件中的多个元素设置 key 是一个更好的实践。</strong></p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;transition&gt;</span><br><span class=\"line\">  &lt;button v-if=&quot;isEditing&quot; key=&quot;save&quot;&gt;</span><br><span class=\"line\">    Save</span><br><span class=\"line\">  &lt;/button&gt;</span><br><span class=\"line\">  &lt;button v-else key=&quot;edit&quot;&gt;</span><br><span class=\"line\">    Edit</span><br><span class=\"line\">  &lt;/button&gt;</span><br><span class=\"line\">&lt;/transition&gt;</span><br></pre></td></tr></table></figure>\n\n<p>​        在某些场景，也可以通过给同一个元素的key属性设置不同的状态来代替 v-if 和 v-else。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;transition&gt;</span><br><span class=\"line\">  &lt;button v-bind:key=&quot;isEditing&quot;&gt;</span><br><span class=\"line\">    &#123;&#123; isEditing ? &#x27;Save&#x27; : &#x27;Edit&#x27; &#125;&#125;</span><br><span class=\"line\">  &lt;/button&gt;</span><br><span class=\"line\">&lt;/transition&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"过渡模式\"><a href=\"#过渡模式\" class=\"headerlink\" title=\"过渡模式\"></a>过渡模式</h4><p>​        简单来说就是元素的切换是同步的，所以会出现占位的问题，并且当使用的是 v-if 的时候，开始会占位，但是在过渡结束之后就会出现位置消失，然后后面的元素会补充上去。</p>\n<p>​        所以此时我们就需要进行处理。</p>\n<p>​        解决方式一般是使用定位的形式，因为定位是脱离了文档流的，所以就不会出现这个问题了。然后此时我们再使用一个 transition 进行过渡的显示便有了效果。</p>\n<p>​        当然同时生效的进入和离开的过渡不能满足所有要求，所以Vue提供了<strong>过渡模式</strong> mode</p>\n<ul>\n<li><code>in-out</code> ：新元素先过渡，完成后旧元素过渡离开。</li>\n<li><code>out-in</code> ：旧元素先过渡，完成后新元素过渡进入。</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;transition name=&quot;fade&quot; mode=&quot;out-in&quot;&gt;</span><br><span class=\"line\">  &lt;!-- ... the buttons ... --&gt;</span><br><span class=\"line\">&lt;/transition&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"多组件的过渡\"><a href=\"#多组件的过渡\" class=\"headerlink\" title=\"多组件的过渡\"></a>多组件的过渡</h3><p>​        我们可以直接使用动态组件来进行组件之间的过渡</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;transition name=&quot;component-fade&quot; mode=&quot;out-in&quot;&gt;</span><br><span class=\"line\">  &lt;component v-bind:is=&quot;view&quot;&gt;&lt;/component&gt;</span><br><span class=\"line\">&lt;/transition&gt;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new Vue(&#123;</span><br><span class=\"line\">  el: &#x27;#transition-components-demo&#x27;,</span><br><span class=\"line\">  data: &#123;</span><br><span class=\"line\">    view: &#x27;v-a&#x27;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  components: &#123;</span><br><span class=\"line\">    &#x27;v-a&#x27;: &#123;</span><br><span class=\"line\">      template: &#x27;&lt;div&gt;Component A&lt;/div&gt;&#x27;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#x27;v-b&#x27;: &#123;</span><br><span class=\"line\">      template: &#x27;&lt;div&gt;Component B&lt;/div&gt;&#x27;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"列表过渡\"><a href=\"#列表过渡\" class=\"headerlink\" title=\"列表过渡\"></a>列表过渡</h3><p>​        对于使用v-for渲染时的过渡。可以使用 transition-group 组件。</p>\n<p><strong>特点</strong>：</p>\n<ul>\n<li>transition-group 会以一个真实的元素呈现：默认为 span，也可以通过 tag 属性来更换为其他元素。</li>\n<li>不能使用过渡模式。mode</li>\n<li>内部元素总是需要提供一个唯一的 key 属性值</li>\n<li>CSS 过渡的类 将会应用在内部元素中，而不是这个 组件/容器 本身。</li>\n</ul>\n<p>​        这里，首先name为list，其次使用了tag，默认不使用tag时为span，使用了tag为p，所以就是p标签进行包裹。然后内部是使用span标签进行的for循环。最后，使用transition-group，key值是必须的。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;transition-group name=&quot;list&quot; tag=&quot;p&quot;&gt;</span><br><span class=\"line\">\t&lt;span v-for=&quot;item in items&quot; v-bind:key=&quot;item&quot; class=&quot;list-item&quot;&gt;</span><br><span class=\"line\">\t\t&#123;&#123; item &#125;&#125;</span><br><span class=\"line\">\t&lt;/span&gt;</span><br><span class=\"line\">&lt;/transition-group&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"列表的进入-离开过渡\"><a href=\"#列表的进入-离开过渡\" class=\"headerlink\" title=\"列表的进入/离开过渡\"></a>列表的进入/离开过渡</h4><p>​        列表的进入/离开过渡是和以前的过渡的方式是一样的。只是过渡变成了每一个小组件了。</p>\n<p>​        问题就是过渡的平滑展现，比如新增的元素，周围的元素会瞬间移动到他们新布局的位置，而不是平滑的过渡。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.list-enter-active, .list-leave-active &#123;</span><br><span class=\"line\">  transition: all 1s;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.list-enter, .list-leave-to</span><br><span class=\"line\">/* .list-leave-active for below version 2.1.8 */ &#123;</span><br><span class=\"line\">  opacity: 0;</span><br><span class=\"line\">  transform: translateY(30px);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"排序的过渡\"><a href=\"#排序的过渡\" class=\"headerlink\" title=\"排序的过渡\"></a>排序的过渡</h4><p>​        可以通过使用 v-move 类来实现列表的移动。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;transition-group name=&quot;list&quot; tag=&quot;ul&quot;&gt;</span><br><span class=\"line\">    &lt;li v-for=&quot;(item, index) in items&quot; v-bind:key=&quot;item&quot; class=&quot;list-item&quot;&gt;</span><br><span class=\"line\">\t\t&#123;&#123; item &#125;&#125;</span><br><span class=\"line\">    &lt;/li&gt;</span><br><span class=\"line\">&lt;/transition-group&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">.list-item &#123;</span><br><span class=\"line\">    transition: all 1s;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.list-enter,</span><br><span class=\"line\">.list-leave-to &#123;</span><br><span class=\"line\">    opacity: 0;</span><br><span class=\"line\">    transform: translateY(30px);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>​        如果我对列表进行一次排序。就会发现动画的效果。</p>\n<p>​    这个看起来很神奇，内部的实现，Vue 使用了一个叫 <a href=\"https://aerotwist.com/blog/flip-your-animations/\">FLIP</a> 简单的动画队列。</p>\n<p>​        当然，前面的style样式对于增加排序时的效果都还是不错，但是对于删除来说，效果就不一样了。</p>\n<p>​    于是我们对于要进行删除的元素进行了一个绝对定位。</p>\n<p>​    对于为什么要使用绝对定位，那是因为当使用了绝对定位之后，那便不会在同一图层。然后此时后面的元素便会向前移动，然后再通过 transition: all .5s; 来进行一个动态的变化。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.list-leave-active &#123;</span><br><span class=\"line\">    position: absolute;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>需要注意的是使用 FLIP 过渡的元素不能设置为 <code>display: inline</code> 。作为替代方案，可以设置为 <code>display: inline-block</code> 或者放置于 flex 中</p>\n</blockquote>\n<p><strong>多维网格也可以进行过渡</strong>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">  &lt;head&gt;</span><br><span class=\"line\">    &lt;title&gt;List Move Transitions Sudoku Example&lt;/title&gt;</span><br><span class=\"line\">    &lt;script src=&quot;https://unpkg.com/vue&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">    &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;./style.css&quot; /&gt;</span><br><span class=\"line\">  &lt;/head&gt;</span><br><span class=\"line\">  &lt;body&gt;</span><br><span class=\"line\">    &lt;div id=&quot;sudoku-demo&quot; class=&quot;demo&quot;&gt;</span><br><span class=\"line\">      &lt;h1&gt;Lazy Sudoku&lt;/h1&gt;</span><br><span class=\"line\">      &lt;p&gt;Keep hitting the shuffle button until you win.&lt;/p&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">      &lt;button @click=&quot;shuffle&quot;&gt;</span><br><span class=\"line\">        Shuffle</span><br><span class=\"line\">      &lt;/button&gt;</span><br><span class=\"line\">      &lt;transition-group name=&quot;cell&quot; tag=&quot;div&quot; class=&quot;container&quot;&gt;</span><br><span class=\"line\">        &lt;div v-for=&quot;cell in cells&quot; :key=&quot;cell.id&quot; class=&quot;cell&quot;&gt;</span><br><span class=\"line\">          &#123;&#123; cell.number &#125;&#125;</span><br><span class=\"line\">        &lt;/div&gt;</span><br><span class=\"line\">      &lt;/transition-group&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;script&gt;</span><br><span class=\"line\">      new Vue(&#123;</span><br><span class=\"line\">        el: &quot;#sudoku-demo&quot;,</span><br><span class=\"line\">        data: &#123;</span><br><span class=\"line\">          cells: Array.apply(null, &#123; length: 81 &#125;).map(function(_, index) &#123;</span><br><span class=\"line\">            return &#123;</span><br><span class=\"line\">              id: index,</span><br><span class=\"line\">              number: (index % 9) + 1</span><br><span class=\"line\">            &#125;;</span><br><span class=\"line\">          &#125;)</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        methods: &#123;</span><br><span class=\"line\">          shuffle: function() &#123;</span><br><span class=\"line\">            this.cells = this.randomSort(this.cells);</span><br><span class=\"line\">          &#125;,</span><br><span class=\"line\">          randomSort(arr) &#123;</span><br><span class=\"line\">            const res = arr.slice();</span><br><span class=\"line\">            for (let i=0; i&lt;arr.length; i++) &#123;</span><br><span class=\"line\">              const index = this.randomIndex();</span><br><span class=\"line\">              [res[i], res[index]] = [res[index], res[i]];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            return res;</span><br><span class=\"line\">          &#125;,</span><br><span class=\"line\">          randomIndex() &#123;</span><br><span class=\"line\">            return Math.floor(Math.random() * this.cells.length);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">    &lt;/script&gt;</span><br><span class=\"line\">  &lt;/body&gt;</span><br><span class=\"line\">  </span><br><span class=\"line\">  &lt;style&gt;</span><br><span class=\"line\">.container &#123;</span><br><span class=\"line\">  display: flex;</span><br><span class=\"line\">  flex-wrap: wrap;</span><br><span class=\"line\">  width: 238px;</span><br><span class=\"line\">  margin-top: 10px;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.cell &#123;</span><br><span class=\"line\">  display: flex;</span><br><span class=\"line\">  justify-content: space-around;</span><br><span class=\"line\">  align-items: center;</span><br><span class=\"line\">  width: 25px;</span><br><span class=\"line\">  height: 25px;</span><br><span class=\"line\">  border: 1px solid #aaa;</span><br><span class=\"line\">  margin-right: -1px;</span><br><span class=\"line\">  margin-bottom: -1px;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.cell:nth-child(3n) &#123;</span><br><span class=\"line\">  margin-right: 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.cell:nth-child(27n) &#123;</span><br><span class=\"line\">  margin-bottom: 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.cell-move &#123;</span><br><span class=\"line\">  transition: transform 1s;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  &lt;/style&gt;</span><br><span class=\"line\">  </span><br><span class=\"line\">&lt;/html&gt;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"交错的过渡\"><a href=\"#交错的过渡\" class=\"headerlink\" title=\"交错的过渡\"></a>交错的过渡</h4><p>​        通过data属性和JavaScript的通信，可以实现列表的交错过渡。简单来说就是使用js方法进行了渲染。因为 velocity 不能访问，所以没有进行实验。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/velocity/1.2.3/velocity.min.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;div id=&quot;staggered-list-demo&quot;&gt;</span><br><span class=\"line\">  &lt;input v-model=&quot;query&quot;&gt;</span><br><span class=\"line\">  &lt;transition-group</span><br><span class=\"line\">    name=&quot;staggered-fade&quot;</span><br><span class=\"line\">    tag=&quot;ul&quot;</span><br><span class=\"line\">    v-bind:css=&quot;false&quot;</span><br><span class=\"line\">    v-on:before-enter=&quot;beforeEnter&quot;</span><br><span class=\"line\">    v-on:enter=&quot;enter&quot;</span><br><span class=\"line\">    v-on:leave=&quot;leave&quot;</span><br><span class=\"line\">  &gt;</span><br><span class=\"line\">    &lt;li</span><br><span class=\"line\">      v-for=&quot;(item, index) in computedList&quot;</span><br><span class=\"line\">      v-bind:key=&quot;item.msg&quot;</span><br><span class=\"line\">      v-bind:data-index=&quot;index&quot;</span><br><span class=\"line\">    &gt;&#123;&#123; item.msg &#125;&#125;&lt;/li&gt;</span><br><span class=\"line\">  &lt;/transition-group&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">new Vue(&#123;</span><br><span class=\"line\">  el: &#x27;#staggered-list-demo&#x27;,</span><br><span class=\"line\">  data: &#123;</span><br><span class=\"line\">    query: &#x27;&#x27;,</span><br><span class=\"line\">    list: [</span><br><span class=\"line\">      &#123; msg: &#x27;Bruce Lee&#x27; &#125;,</span><br><span class=\"line\">      &#123; msg: &#x27;Jackie Chan&#x27; &#125;,</span><br><span class=\"line\">      &#123; msg: &#x27;Chuck Norris&#x27; &#125;,</span><br><span class=\"line\">      &#123; msg: &#x27;Jet Li&#x27; &#125;,</span><br><span class=\"line\">      &#123; msg: &#x27;Kung Fury&#x27; &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  computed: &#123;</span><br><span class=\"line\">    computedList: function () &#123;</span><br><span class=\"line\">      var vm = this</span><br><span class=\"line\">      return this.list.filter(function (item) &#123;</span><br><span class=\"line\">        return item.msg.toLowerCase().indexOf(vm.query.toLowerCase()) !== -1</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  methods: &#123;</span><br><span class=\"line\">    beforeEnter: function (el) &#123;</span><br><span class=\"line\">      el.style.opacity = 0</span><br><span class=\"line\">      el.style.height = 0</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    enter: function (el, done) &#123;</span><br><span class=\"line\">      var delay = el.dataset.index * 150</span><br><span class=\"line\">      setTimeout(function () &#123;</span><br><span class=\"line\">        Velocity(</span><br><span class=\"line\">          el,</span><br><span class=\"line\">          &#123; opacity: 1, height: &#x27;1.6em&#x27; &#125;,</span><br><span class=\"line\">          &#123; complete: done &#125;</span><br><span class=\"line\">        )</span><br><span class=\"line\">      &#125;, delay)</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    leave: function (el, done) &#123;</span><br><span class=\"line\">      var delay = el.dataset.index * 150</span><br><span class=\"line\">      setTimeout(function () &#123;</span><br><span class=\"line\">        Velocity(</span><br><span class=\"line\">          el,</span><br><span class=\"line\">          &#123; opacity: 0, height: 0 &#125;,</span><br><span class=\"line\">          &#123; complete: done &#125;</span><br><span class=\"line\">        )</span><br><span class=\"line\">      &#125;, delay)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"可复用的过渡\"><a href=\"#可复用的过渡\" class=\"headerlink\" title=\"可复用的过渡\"></a>可复用的过渡</h3><p>​        可以使用Vue组件系统的实现复用。只需要将 transition 或者 transition-group 作为根组件。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Vue.component(&#x27;my-special-transition&#x27;, &#123;</span><br><span class=\"line\">  template: &#x27;\\</span><br><span class=\"line\">    &lt;transition\\</span><br><span class=\"line\">      name=&quot;very-special-transition&quot;\\</span><br><span class=\"line\">      mode=&quot;out-in&quot;\\</span><br><span class=\"line\">      v-on:before-enter=&quot;beforeEnter&quot;\\</span><br><span class=\"line\">      v-on:after-enter=&quot;afterEnter&quot;\\</span><br><span class=\"line\">    &gt;\\</span><br><span class=\"line\">      &lt;slot&gt;&lt;/slot&gt;\\</span><br><span class=\"line\">    &lt;/transition&gt;\\</span><br><span class=\"line\">  &#x27;,</span><br><span class=\"line\">  methods: &#123;</span><br><span class=\"line\">    beforeEnter: function (el) &#123;</span><br><span class=\"line\">      // ...</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    afterEnter: function (el) &#123;</span><br><span class=\"line\">      // ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>​    当然，可以使用函数式组件来完成这个任务。函数式组件我们后面在进行了解。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Vue.component(&#x27;my-special-transition&#x27;, &#123;</span><br><span class=\"line\">  functional: true,</span><br><span class=\"line\">  render: function (createElement, context) &#123;</span><br><span class=\"line\">    var data = &#123;</span><br><span class=\"line\">      props: &#123;</span><br><span class=\"line\">        name: &#x27;very-special-transition&#x27;,</span><br><span class=\"line\">        mode: &#x27;out-in&#x27;</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      on: &#123;</span><br><span class=\"line\">        beforeEnter: function (el) &#123;</span><br><span class=\"line\">          // ...</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        afterEnter: function (el) &#123;</span><br><span class=\"line\">          // ...</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return createElement(&#x27;transition&#x27;, data, context.children)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"动态过渡\"><a href=\"#动态过渡\" class=\"headerlink\" title=\"动态过渡\"></a>动态过渡</h3><p>​        在Vue中，过渡也是数据驱动的。所以name也可以使用 v-bind 来进行绑定。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;transition v-bind:name=&quot;transitionName&quot;&gt;</span><br></pre></td></tr></table></figure>\n\n<p>​        所有的过渡 attribute 都可以动态绑定。因为事件钩子都是方法。所以根据组件的状态不同，过渡也会有不同的表现。</p>\n<h2 id=\"状态过渡\"><a href=\"#状态过渡\" class=\"headerlink\" title=\"状态过渡\"></a>状态过渡</h2><p>​        数据元素本身的特效，这些数据要么本身就以数值形式存储，要么可以转换为数值。</p>\n<ul>\n<li>数字和运算</li>\n<li>颜色的显示</li>\n<li>SVG 节点的位置</li>\n<li>元素的大小和其他的 property</li>\n</ul>\n<h3 id=\"状态动画与侦听器\"><a href=\"#状态动画与侦听器\" class=\"headerlink\" title=\"状态动画与侦听器\"></a>状态动画与侦听器</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script src=&quot;https://cdn.jsdelivr.net/npm/tween.js@16.3.4&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;script src=&quot;https://cdn.jsdelivr.net/npm/color-js@1.0.3&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;div id=&quot;example-7&quot;&gt;</span><br><span class=\"line\">  &lt;input</span><br><span class=\"line\">    v-model=&quot;colorQuery&quot;</span><br><span class=\"line\">    v-on:keyup.enter=&quot;updateColor&quot;</span><br><span class=\"line\">    placeholder=&quot;Enter a color&quot;</span><br><span class=\"line\">  &gt;</span><br><span class=\"line\">  &lt;button v-on:click=&quot;updateColor&quot;&gt;Update&lt;/button&gt;</span><br><span class=\"line\">  &lt;p&gt;Preview:&lt;/p&gt;</span><br><span class=\"line\">  &lt;span</span><br><span class=\"line\">    v-bind:style=&quot;&#123; backgroundColor: tweenedCSSColor &#125;&quot;</span><br><span class=\"line\">    class=&quot;example-7-color-preview&quot;</span><br><span class=\"line\">  &gt;&lt;/span&gt;</span><br><span class=\"line\">  &lt;p&gt;&#123;&#123; tweenedCSSColor &#125;&#125;&lt;/p&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var Color = net.brehaut.Color</span><br><span class=\"line\"></span><br><span class=\"line\">new Vue(&#123;</span><br><span class=\"line\">  el: &#x27;#example-7&#x27;,</span><br><span class=\"line\">  data: &#123;</span><br><span class=\"line\">    colorQuery: &#x27;&#x27;,</span><br><span class=\"line\">    color: &#123;</span><br><span class=\"line\">      red: 0,</span><br><span class=\"line\">      green: 0,</span><br><span class=\"line\">      blue: 0,</span><br><span class=\"line\">      alpha: 1</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    tweenedColor: &#123;&#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  created: function () &#123;</span><br><span class=\"line\">    this.tweenedColor = Object.assign(&#123;&#125;, this.color)</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  watch: &#123;</span><br><span class=\"line\">    color: function () &#123;</span><br><span class=\"line\">      function animate () &#123;</span><br><span class=\"line\">        if (TWEEN.update()) &#123;</span><br><span class=\"line\">          requestAnimationFrame(animate)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      new TWEEN.Tween(this.tweenedColor)</span><br><span class=\"line\">        .to(this.color, 750)</span><br><span class=\"line\">        .start()</span><br><span class=\"line\"></span><br><span class=\"line\">      animate()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  computed: &#123;</span><br><span class=\"line\">    tweenedCSSColor: function () &#123;</span><br><span class=\"line\">      return new Color(&#123;</span><br><span class=\"line\">        red: this.tweenedColor.red,</span><br><span class=\"line\">        green: this.tweenedColor.green,</span><br><span class=\"line\">        blue: this.tweenedColor.blue,</span><br><span class=\"line\">        alpha: this.tweenedColor.alpha</span><br><span class=\"line\">      &#125;).toCSS()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  methods: &#123;</span><br><span class=\"line\">    updateColor: function () &#123;</span><br><span class=\"line\">      this.color = new Color(this.colorQuery).toRGB()</span><br><span class=\"line\">      this.colorQuery = &#x27;&#x27;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.example-7-color-preview &#123;</span><br><span class=\"line\">  display: inline-block;</span><br><span class=\"line\">  width: 50px;</span><br><span class=\"line\">  height: 50px;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"动态状态过渡\"><a href=\"#动态状态过渡\" class=\"headerlink\" title=\"动态状态过渡\"></a>动态状态过渡</h3><p>​        就像 Vue 的过渡组件一样，数据背后状态过渡会实时更新，这对于原型设计十分有用。当你修改一些变量，即使是一个简单的 SVG 多边形也可实现很多难以想象的效果。</p>\n<h3 id=\"把过渡放到组件里\"><a href=\"#把过渡放到组件里\" class=\"headerlink\" title=\"把过渡放到组件里\"></a>把过渡放到组件里</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script src=&quot;https://cdn.jsdelivr.net/npm/tween.js@16.3.4&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;div id=&quot;example-8&quot;&gt;</span><br><span class=\"line\">  &lt;input v-model.number=&quot;firstNumber&quot; type=&quot;number&quot; step=&quot;20&quot;&gt; +</span><br><span class=\"line\">  &lt;input v-model.number=&quot;secondNumber&quot; type=&quot;number&quot; step=&quot;20&quot;&gt; =</span><br><span class=\"line\">  &#123;&#123; result &#125;&#125;</span><br><span class=\"line\">  &lt;p&gt;</span><br><span class=\"line\">    &lt;animated-integer v-bind:value=&quot;firstNumber&quot;&gt;&lt;/animated-integer&gt; +</span><br><span class=\"line\">    &lt;animated-integer v-bind:value=&quot;secondNumber&quot;&gt;&lt;/animated-integer&gt; =</span><br><span class=\"line\">    &lt;animated-integer v-bind:value=&quot;result&quot;&gt;&lt;/animated-integer&gt;</span><br><span class=\"line\">  &lt;/p&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">// 这种复杂的补间动画逻辑可以被复用</span><br><span class=\"line\">// 任何整数都可以执行动画</span><br><span class=\"line\">// 组件化使我们的界面十分清晰</span><br><span class=\"line\">// 可以支持更多更复杂的动态过渡</span><br><span class=\"line\">// 策略。</span><br><span class=\"line\">Vue.component(&#x27;animated-integer&#x27;, &#123;</span><br><span class=\"line\">  template: &#x27;&lt;span&gt;&#123;&#123; tweeningValue &#125;&#125;&lt;/span&gt;&#x27;,</span><br><span class=\"line\">  props: &#123;</span><br><span class=\"line\">    value: &#123;</span><br><span class=\"line\">      type: Number,</span><br><span class=\"line\">      required: true</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  data: function () &#123;</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">      tweeningValue: 0</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  watch: &#123;</span><br><span class=\"line\">    value: function (newValue, oldValue) &#123;</span><br><span class=\"line\">      this.tween(oldValue, newValue)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  mounted: function () &#123;</span><br><span class=\"line\">    this.tween(0, this.value)</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  methods: &#123;</span><br><span class=\"line\">    tween: function (startValue, endValue) &#123;</span><br><span class=\"line\">      var vm = this</span><br><span class=\"line\">      function animate () &#123;</span><br><span class=\"line\">        if (TWEEN.update()) &#123;</span><br><span class=\"line\">          requestAnimationFrame(animate)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      new TWEEN.Tween(&#123; tweeningValue: startValue &#125;)</span><br><span class=\"line\">        .to(&#123; tweeningValue: endValue &#125;, 500)</span><br><span class=\"line\">        .onUpdate(function () &#123;</span><br><span class=\"line\">          vm.tweeningValue = this.tweeningValue.toFixed(0)</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        .start()</span><br><span class=\"line\"></span><br><span class=\"line\">      animate()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">// 所有的复杂度都已经从 Vue 的主实例中移除！</span><br><span class=\"line\">new Vue(&#123;</span><br><span class=\"line\">  el: &#x27;#example-8&#x27;,</span><br><span class=\"line\">  data: &#123;</span><br><span class=\"line\">    firstNumber: 20,</span><br><span class=\"line\">    secondNumber: 40</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  computed: &#123;</span><br><span class=\"line\">    result: function () &#123;</span><br><span class=\"line\">      return this.firstNumber + this.secondNumber</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"赋予设计以生命\"><a href=\"#赋予设计以生命\" class=\"headerlink\" title=\"赋予设计以生命\"></a>赋予设计以生命</h3>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"过渡和动画\"><a href=\"#过渡和动画\" class=\"headerlink\" title=\"过渡和动画\"></a>过渡和动画</h1><h2 id=\"进入-离开和列表转换\"><a href=\"#进入-离开和列表转换\" class=\"headerlink\" title=\"进入/离开和列表转换\"></a>进入/离开和列表转换</h2><p>​        Vue提供了多种方法在DOM中的过渡效果</p>\n<ul>\n<li>自动为CSS过渡和动画应用类</li>\n<li>集成第三方CSS动画库，如 Animate.css</li>\n<li>在过渡钩子期间使用 JavaScript 直接操作 DOM</li>\n<li>集成第三方JavaScript动画库，例如 Velocity.js</li>\n</ul>\n<h3 id=\"过渡单个元素-组件\"><a href=\"#过渡单个元素-组件\" class=\"headerlink\" title=\"过渡单个元素/组件\"></a>过渡单个元素/组件</h3><p>​        Vue 提供了一个<code>transition</code>包装组件，允许您在以下上下文中为任何元素或组件添加进入/离开转换：</p>\n<ul>\n<li>条件渲染（使用<code>v-if</code>）</li>\n<li>条件显示（使用<code>v-show</code>）</li>\n<li>动态组件</li>\n<li>组件根节点</li>\n</ul>\n<p>​        在这里我直接复制官网的例子，并加以一个简单的说明，首先，对于transition来说，需要的是一个根组件（根元素），对于存在多个根组件的，便会只渲染一个，其次，对于不是非根元素进行的渲染显示不会有效果。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=&quot;demo&quot;&gt;</span><br><span class=\"line\">  &lt;button v-on:click=&quot;show = !show&quot;&gt;</span><br><span class=\"line\">    Toggle</span><br><span class=\"line\">  &lt;/button&gt;</span><br><span class=\"line\">  &lt;transition name=&quot;fade&quot;&gt;</span><br><span class=\"line\">    &lt;p v-if=&quot;show&quot;&gt;hello&lt;/p&gt;</span><br><span class=\"line\">  &lt;/transition&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">new Vue(&#123;</span><br><span class=\"line\">  el: &#x27;#demo&#x27;,</span><br><span class=\"line\">  data: &#123;</span><br><span class=\"line\">    show: true</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">.fade-enter-active, .fade-leave-active &#123;</span><br><span class=\"line\">  transition: opacity .5s;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.fade-enter, .fade-leave-to /* .fade-leave-active below version 2.1.8 */ &#123;</span><br><span class=\"line\">  opacity: 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当<code>transition</code>插入或删除包裹在组件中的元素时，会发生以下情况：</p>\n<ol>\n<li>Vue 会自动嗅探目标元素是否应用了 CSS 过渡或动画。如果是这样，CSS 过渡类将在适当的时间添加/删除。</li>\n<li>如果转换组件提供了<a href=\"https://vuejs.org/v2/guide/transitions.html#JavaScript-Hooks\">JavaScript hooks</a>，这些 hooks 将在适当的时间被调用。</li>\n<li>如果没有检测到 CSS 过渡/动画，也没有提供 JavaScript 钩子，插入和/或移除的 DOM 操作将在下一帧立即执行（注意：这是一个浏览器动画帧，与 Vue 的概念不同<code>nextTick</code>）。</li>\n</ol>\n<h4 id=\"过渡的类名\"><a href=\"#过渡的类名\" class=\"headerlink\" title=\"过渡的类名\"></a>过渡的类名</h4><p>​        在进入/离开的过程中，会有6个 class 切换</p>\n<ul>\n<li>v-enter<ul>\n<li>进入的起始状态，在插入元素之前添加，在插入元素后移除一帧</li>\n</ul>\n</li>\n<li>v-enter-active<ul>\n<li>进入的活动状态，在整个进入阶段应用。插入元素之前添加，在过渡完成时移除。定义进入过渡的事件、延迟和缓动曲线。</li>\n</ul>\n</li>\n<li>v-enter-to<ul>\n<li>2.1.8+</li>\n<li>进入的结束状态。插入元素后添加一帧（同时 v-enter 删除），在过渡完成时删除。</li>\n</ul>\n</li>\n<li>v-leave<ul>\n<li>定义离开过渡的开始状态。在离开过渡被触发时立刻生效。下一帧被移除</li>\n</ul>\n</li>\n<li>v-leave-active<ul>\n<li>定义离开过渡生效时的状态。在离开过渡立刻生效，过渡完成被移除，同 v-enter-active</li>\n</ul>\n</li>\n<li>v-leave-to<ul>\n<li>2.1.8 +</li>\n<li>定义离开过渡的结束状态。离开过渡被触发后下一帧生效（同时 v-leave 被删除）。过渡完成被移除</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"/.io//Vue2-%E6%95%99%E7%A8%8B-%E8%BF%87%E6%B8%A1%E5%92%8C%E5%8A%A8%E7%94%BB%5Cimage-20211203152116522.png\" alt=\"image-20211203152116522\"></p>\n<p>​        在这些过渡的切换中，如果你使用一个没有名字的transition，则v-是这些类名的默认前缀。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;transition&gt;</span><br><span class=\"line\">    &lt;p v-show=&quot;show&quot;&gt;hello&lt;/p&gt;</span><br><span class=\"line\">&lt;/transition&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">.v-enter-active,</span><br></pre></td></tr></table></figure>\n\n<p>​        如果你使用了 <code>&lt;transition name=&quot;my-transition&quot;&gt;</code> ，那么 <code>v-enter</code> 会替换为 <code>my-transition-enter</code> 。</p>\n<p>​        v-enter-active 和 v-leave-active 可以控制进入/离开过渡的不同的缓和曲线。</p>\n<img src=\"/.io//image-20211203154333481.png\" alt=\"image-20211203154333481\">\n\n<p>​        通过图示可以看出，当元素进行显示时：</p>\n<ul>\n<li>先插入 v-enter 和 v-enter-active， </li>\n<li>然后再下一帧删除 v-enter，出现了 v-enter-to</li>\n<li>然后结束了 v-enter-active 和 v-enter-to 消失。</li>\n</ul>\n<p>v-leave 是一样的效果。</p>\n<h4 id=\"CSS过渡\"><a href=\"#CSS过渡\" class=\"headerlink\" title=\"CSS过渡\"></a>CSS过渡</h4><p>​        和普通的过渡是没有什么区别的。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.bounce-enter-active &#123;</span><br><span class=\"line\">  animation: bounce-in .5s;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.bounce-leave-active &#123;</span><br><span class=\"line\">  animation: bounce-in .5s reverse;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@keyframes bounce-in &#123;</span><br><span class=\"line\">  0% &#123;</span><br><span class=\"line\">    transform: scale(0);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  50% &#123;</span><br><span class=\"line\">    transform: scale(1.5);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  100% &#123;</span><br><span class=\"line\">    transform: scale(1);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"自定义过渡的类名\"><a href=\"#自定义过渡的类名\" class=\"headerlink\" title=\"自定义过渡的类名\"></a>自定义过渡的类名</h4><p>​        我们可以通过使用以下的属性来自定义过渡的类名。并且他们的优先级会高于普通的类名。因此对于使用其他第三方css库十分的有用。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">enter-class</span><br><span class=\"line\">enter-active-class</span><br><span class=\"line\">enter-to-class (2.1.8+)</span><br><span class=\"line\">leave-class</span><br><span class=\"line\">leave-active-class</span><br><span class=\"line\">leave-to-class (2.1.8+)</span><br></pre></td></tr></table></figure>\n\n<p>​        这里name就是往常一样的name，然后在元素里面添加了标签，标签是 enter-xx-class，或者是 leave-xx-class 这种。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;transition</span><br><span class=\"line\">name=&quot;custom-classes-transition&quot;</span><br><span class=\"line\">enter-active-class=&quot;animated tada&quot;</span><br><span class=\"line\">leave-active-class=&quot;animated bounceOutRight&quot;</span><br><span class=\"line\">&gt;</span><br><span class=\"line\">    &lt;p v-if=&quot;show&quot;&gt;hello&lt;/p&gt;</span><br><span class=\"line\">&lt;/transition&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"同时使用过渡和动画\"><a href=\"#同时使用过渡和动画\" class=\"headerlink\" title=\"同时使用过渡和动画\"></a>同时使用过渡和动画</h4><p>​        Vue为了能知道过渡的完成，必须设置相应的事件监听器。他可以是 transitionend 或者是 animationend，如果你只是使用了其中一种，Vue可以自动识别并设置监听。</p>\n<p>​        但是如果你同时使用了 transition 和 animation，那么这种情况你就需要使用 type 属性来指定Vue需要监听的类型。</p>\n<p>​        如果你不指定的话，我从使用上看来他会默认监听的是时间最长的那个，就是延迟时间和运行时间加起来最大的那个。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;transition name=&quot;slide-fade&quot; type=&quot;transition&quot;&gt;</span><br><span class=\"line\">    &lt;p v-if=&quot;show&quot;&gt; content &lt;/p&gt;</span><br><span class=\"line\">&lt;/transition&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"显性的过渡持续时间\"><a href=\"#显性的过渡持续时间\" class=\"headerlink\" title=\"显性的过渡持续时间\"></a>显性的过渡持续时间</h4><p>​        2.2.0 新增</p>\n<p>​        默认情况下，Vue会自动计算出过渡时间。会等待过渡效果的 transitionend 和 animationend 事件。</p>\n<p>​        但是，我们可以显性的设置一个过渡的持续时间。</p>\n<p>​        下面这个代码的意思就是，对于使用了 duration 设置了显性的过渡时间了的，在到达过渡的时间之后，便会直接进行过渡的结束。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;transition :duration=&quot;1000&quot;&gt;...&lt;/transition&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;transition :duration=&quot;&#123; enter: 500, leave: 800 &#125;&quot;&gt;...&lt;/transition&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"JavaScript-钩子\"><a href=\"#JavaScript-钩子\" class=\"headerlink\" title=\"JavaScript 钩子\"></a>JavaScript 钩子</h4><p>​        可以在属性中声明 JavaScript 钩子。</p>\n<p>​        这里我简单介绍一下 JavaScript钩子的执行时机，虽然通过名字也能够大致猜的出来意思</p>\n<ul>\n<li>before-enter： 简单来说就是在enter启动之前，就像是前面的 v-enter</li>\n<li>enter： 就是在调用期间， v-enter-to，但是这个 JavaScript钩子 没有说版本要求，而 v-enter-to 是2.1.8以上的，所以这个应该是更像 v-enter-active 。</li>\n<li>after-enter： 就是在就是结束时会进行的调用，应该接近于 animationend 或者 transitionend 这两个回调。</li>\n<li>enter-cancalled： 就是在没有调用after-enter的时候就又进行了一次切换，此时就会调用 enter-cancalled 回调。</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;transition</span><br><span class=\"line\">  v-on:before-enter=&quot;beforeEnter&quot;</span><br><span class=\"line\">  v-on:enter=&quot;enter&quot;</span><br><span class=\"line\">  v-on:after-enter=&quot;afterEnter&quot;</span><br><span class=\"line\">  v-on:enter-cancelled=&quot;enterCancelled&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">  v-on:before-leave=&quot;beforeLeave&quot;</span><br><span class=\"line\">  v-on:leave=&quot;leave&quot;</span><br><span class=\"line\">  v-on:after-leave=&quot;afterLeave&quot;</span><br><span class=\"line\">  v-on:leave-cancelled=&quot;leaveCancelled&quot;</span><br><span class=\"line\">&gt;</span><br><span class=\"line\">  &lt;!-- ... --&gt;</span><br><span class=\"line\">&lt;/transition&gt;</span><br></pre></td></tr></table></figure>\n\n<p>​        这里需要注意，</p>\n<ul>\n<li>当只用 JavaScript 过渡的时候，<strong>在 <code>enter</code> 和 <code>leave</code> 中必须使用 <code>done</code> 进行回调</strong>。否则，它们将被同步调用，过渡会立即完成。<ul>\n<li>这个我没有仔细使用过函数进行动画的过渡，而是进行一些其他的操作，但是这里 done的回调是必须的。因为我们可以看到如果不使用done函数，那么便不会调用 after-enter 来结束，所以这个done函数更像是 生成器函数的 next 一样。</li>\n<li>这里我使用了css进行过渡，然后JavaScript进行钩子的调用，发现css的过渡没有出现效果，直接只能使用钩子的调用了。就算是使用自定义过渡类名属性 enter-class 这些也没有效果。</li>\n</ul>\n</li>\n<li>推荐对于仅使用 JavaScript 过渡的元素添加 <code>v-bind:css=&quot;false&quot;</code>，Vue 会跳过 CSS 的检测。这也可以避免过渡过程中 CSS 的影响。</li>\n<li>leaveCancelled 只能用于 v-show 中。</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// ...</span><br><span class=\"line\">methods: &#123;</span><br><span class=\"line\">  // --------</span><br><span class=\"line\">  // 进入中</span><br><span class=\"line\">  // --------</span><br><span class=\"line\"></span><br><span class=\"line\">  beforeEnter: function (el) &#123;</span><br><span class=\"line\">    // ...</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  // 当与 CSS 结合使用时</span><br><span class=\"line\">  // 回调函数 done 是可选的</span><br><span class=\"line\">  enter: function (el, done) &#123;</span><br><span class=\"line\">    // ...</span><br><span class=\"line\">    done()</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  afterEnter: function (el) &#123;</span><br><span class=\"line\">    // ...</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  enterCancelled: function (el) &#123;</span><br><span class=\"line\">    // ...</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  // --------</span><br><span class=\"line\">  // 离开时</span><br><span class=\"line\">  // --------</span><br><span class=\"line\"></span><br><span class=\"line\">  beforeLeave: function (el) &#123;</span><br><span class=\"line\">    // ...</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  // 当与 CSS 结合使用时</span><br><span class=\"line\">  // 回调函数 done 是可选的</span><br><span class=\"line\">  leave: function (el, done) &#123;</span><br><span class=\"line\">    // ...</span><br><span class=\"line\">    done()</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  afterLeave: function (el) &#123;</span><br><span class=\"line\">    // ...</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  // leaveCancelled 只用于 v-show 中</span><br><span class=\"line\">  leaveCancelled: function (el) &#123;</span><br><span class=\"line\">    // ...</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"初始渲染的过渡\"><a href=\"#初始渲染的过渡\" class=\"headerlink\" title=\"初始渲染的过渡\"></a>初始渲染的过渡</h3><p>​        通过使用 appear 属性设置节点初始渲染的过渡</p>\n<p>​        简单来说就是会在开始的时候有一个过渡的效果。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;transition appear&gt;</span><br></pre></td></tr></table></figure>\n\n<p>​    可以自定义 css 类名</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;transition</span><br><span class=\"line\">  appear</span><br><span class=\"line\">  appear-class=&quot;custom-appear-class&quot;</span><br><span class=\"line\">  appear-to-class=&quot;custom-appear-to-class&quot; (2.1.8+)</span><br><span class=\"line\">  appear-active-class=&quot;custom-appear-active-class&quot;</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n\n<p>​    自定义JavaScript 钩子</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;transition</span><br><span class=\"line\">  appear</span><br><span class=\"line\">  v-on:before-appear=&quot;customBeforeAppearHook&quot;</span><br><span class=\"line\">  v-on:appear=&quot;customAppearHook&quot;</span><br><span class=\"line\">  v-on:after-appear=&quot;customAfterAppearHook&quot;</span><br><span class=\"line\">  v-on:appear-cancelled=&quot;customAppearCancelledHook&quot;</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n\n<p>​        在上面的例子中，无论是使用 appear attribute 还是使用 v-on:appear 钩子都会生成初始渲染的过渡。</p>\n<h3 id=\"多个元素的过渡\"><a href=\"#多个元素的过渡\" class=\"headerlink\" title=\"多个元素的过渡\"></a>多个元素的过渡</h3><p>​        对于原生的标签，可以使用 v-if / v-else 进行过渡。</p>\n<blockquote>\n<p>当有<strong>相同标签名</strong>的元素切换时，需要通过 <code>key</code> attribute 设置唯一的值来标记以让 Vue 区分它们，否则 Vue 为了效率只会替换相同标签内部的内容。即使在技术上没有必要，<strong>给在 <code>&lt;transition&gt;</code> 组件中的多个元素设置 key 是一个更好的实践。</strong></p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;transition&gt;</span><br><span class=\"line\">  &lt;button v-if=&quot;isEditing&quot; key=&quot;save&quot;&gt;</span><br><span class=\"line\">    Save</span><br><span class=\"line\">  &lt;/button&gt;</span><br><span class=\"line\">  &lt;button v-else key=&quot;edit&quot;&gt;</span><br><span class=\"line\">    Edit</span><br><span class=\"line\">  &lt;/button&gt;</span><br><span class=\"line\">&lt;/transition&gt;</span><br></pre></td></tr></table></figure>\n\n<p>​        在某些场景，也可以通过给同一个元素的key属性设置不同的状态来代替 v-if 和 v-else。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;transition&gt;</span><br><span class=\"line\">  &lt;button v-bind:key=&quot;isEditing&quot;&gt;</span><br><span class=\"line\">    &#123;&#123; isEditing ? &#x27;Save&#x27; : &#x27;Edit&#x27; &#125;&#125;</span><br><span class=\"line\">  &lt;/button&gt;</span><br><span class=\"line\">&lt;/transition&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"过渡模式\"><a href=\"#过渡模式\" class=\"headerlink\" title=\"过渡模式\"></a>过渡模式</h4><p>​        简单来说就是元素的切换是同步的，所以会出现占位的问题，并且当使用的是 v-if 的时候，开始会占位，但是在过渡结束之后就会出现位置消失，然后后面的元素会补充上去。</p>\n<p>​        所以此时我们就需要进行处理。</p>\n<p>​        解决方式一般是使用定位的形式，因为定位是脱离了文档流的，所以就不会出现这个问题了。然后此时我们再使用一个 transition 进行过渡的显示便有了效果。</p>\n<p>​        当然同时生效的进入和离开的过渡不能满足所有要求，所以Vue提供了<strong>过渡模式</strong> mode</p>\n<ul>\n<li><code>in-out</code> ：新元素先过渡，完成后旧元素过渡离开。</li>\n<li><code>out-in</code> ：旧元素先过渡，完成后新元素过渡进入。</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;transition name=&quot;fade&quot; mode=&quot;out-in&quot;&gt;</span><br><span class=\"line\">  &lt;!-- ... the buttons ... --&gt;</span><br><span class=\"line\">&lt;/transition&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"多组件的过渡\"><a href=\"#多组件的过渡\" class=\"headerlink\" title=\"多组件的过渡\"></a>多组件的过渡</h3><p>​        我们可以直接使用动态组件来进行组件之间的过渡</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;transition name=&quot;component-fade&quot; mode=&quot;out-in&quot;&gt;</span><br><span class=\"line\">  &lt;component v-bind:is=&quot;view&quot;&gt;&lt;/component&gt;</span><br><span class=\"line\">&lt;/transition&gt;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new Vue(&#123;</span><br><span class=\"line\">  el: &#x27;#transition-components-demo&#x27;,</span><br><span class=\"line\">  data: &#123;</span><br><span class=\"line\">    view: &#x27;v-a&#x27;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  components: &#123;</span><br><span class=\"line\">    &#x27;v-a&#x27;: &#123;</span><br><span class=\"line\">      template: &#x27;&lt;div&gt;Component A&lt;/div&gt;&#x27;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#x27;v-b&#x27;: &#123;</span><br><span class=\"line\">      template: &#x27;&lt;div&gt;Component B&lt;/div&gt;&#x27;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"列表过渡\"><a href=\"#列表过渡\" class=\"headerlink\" title=\"列表过渡\"></a>列表过渡</h3><p>​        对于使用v-for渲染时的过渡。可以使用 transition-group 组件。</p>\n<p><strong>特点</strong>：</p>\n<ul>\n<li>transition-group 会以一个真实的元素呈现：默认为 span，也可以通过 tag 属性来更换为其他元素。</li>\n<li>不能使用过渡模式。mode</li>\n<li>内部元素总是需要提供一个唯一的 key 属性值</li>\n<li>CSS 过渡的类 将会应用在内部元素中，而不是这个 组件/容器 本身。</li>\n</ul>\n<p>​        这里，首先name为list，其次使用了tag，默认不使用tag时为span，使用了tag为p，所以就是p标签进行包裹。然后内部是使用span标签进行的for循环。最后，使用transition-group，key值是必须的。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;transition-group name=&quot;list&quot; tag=&quot;p&quot;&gt;</span><br><span class=\"line\">\t&lt;span v-for=&quot;item in items&quot; v-bind:key=&quot;item&quot; class=&quot;list-item&quot;&gt;</span><br><span class=\"line\">\t\t&#123;&#123; item &#125;&#125;</span><br><span class=\"line\">\t&lt;/span&gt;</span><br><span class=\"line\">&lt;/transition-group&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"列表的进入-离开过渡\"><a href=\"#列表的进入-离开过渡\" class=\"headerlink\" title=\"列表的进入/离开过渡\"></a>列表的进入/离开过渡</h4><p>​        列表的进入/离开过渡是和以前的过渡的方式是一样的。只是过渡变成了每一个小组件了。</p>\n<p>​        问题就是过渡的平滑展现，比如新增的元素，周围的元素会瞬间移动到他们新布局的位置，而不是平滑的过渡。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.list-enter-active, .list-leave-active &#123;</span><br><span class=\"line\">  transition: all 1s;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.list-enter, .list-leave-to</span><br><span class=\"line\">/* .list-leave-active for below version 2.1.8 */ &#123;</span><br><span class=\"line\">  opacity: 0;</span><br><span class=\"line\">  transform: translateY(30px);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"排序的过渡\"><a href=\"#排序的过渡\" class=\"headerlink\" title=\"排序的过渡\"></a>排序的过渡</h4><p>​        可以通过使用 v-move 类来实现列表的移动。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;transition-group name=&quot;list&quot; tag=&quot;ul&quot;&gt;</span><br><span class=\"line\">    &lt;li v-for=&quot;(item, index) in items&quot; v-bind:key=&quot;item&quot; class=&quot;list-item&quot;&gt;</span><br><span class=\"line\">\t\t&#123;&#123; item &#125;&#125;</span><br><span class=\"line\">    &lt;/li&gt;</span><br><span class=\"line\">&lt;/transition-group&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">.list-item &#123;</span><br><span class=\"line\">    transition: all 1s;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.list-enter,</span><br><span class=\"line\">.list-leave-to &#123;</span><br><span class=\"line\">    opacity: 0;</span><br><span class=\"line\">    transform: translateY(30px);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>​        如果我对列表进行一次排序。就会发现动画的效果。</p>\n<p>​    这个看起来很神奇，内部的实现，Vue 使用了一个叫 <a href=\"https://aerotwist.com/blog/flip-your-animations/\">FLIP</a> 简单的动画队列。</p>\n<p>​        当然，前面的style样式对于增加排序时的效果都还是不错，但是对于删除来说，效果就不一样了。</p>\n<p>​    于是我们对于要进行删除的元素进行了一个绝对定位。</p>\n<p>​    对于为什么要使用绝对定位，那是因为当使用了绝对定位之后，那便不会在同一图层。然后此时后面的元素便会向前移动，然后再通过 transition: all .5s; 来进行一个动态的变化。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.list-leave-active &#123;</span><br><span class=\"line\">    position: absolute;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>需要注意的是使用 FLIP 过渡的元素不能设置为 <code>display: inline</code> 。作为替代方案，可以设置为 <code>display: inline-block</code> 或者放置于 flex 中</p>\n</blockquote>\n<p><strong>多维网格也可以进行过渡</strong>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">  &lt;head&gt;</span><br><span class=\"line\">    &lt;title&gt;List Move Transitions Sudoku Example&lt;/title&gt;</span><br><span class=\"line\">    &lt;script src=&quot;https://unpkg.com/vue&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">    &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;./style.css&quot; /&gt;</span><br><span class=\"line\">  &lt;/head&gt;</span><br><span class=\"line\">  &lt;body&gt;</span><br><span class=\"line\">    &lt;div id=&quot;sudoku-demo&quot; class=&quot;demo&quot;&gt;</span><br><span class=\"line\">      &lt;h1&gt;Lazy Sudoku&lt;/h1&gt;</span><br><span class=\"line\">      &lt;p&gt;Keep hitting the shuffle button until you win.&lt;/p&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">      &lt;button @click=&quot;shuffle&quot;&gt;</span><br><span class=\"line\">        Shuffle</span><br><span class=\"line\">      &lt;/button&gt;</span><br><span class=\"line\">      &lt;transition-group name=&quot;cell&quot; tag=&quot;div&quot; class=&quot;container&quot;&gt;</span><br><span class=\"line\">        &lt;div v-for=&quot;cell in cells&quot; :key=&quot;cell.id&quot; class=&quot;cell&quot;&gt;</span><br><span class=\"line\">          &#123;&#123; cell.number &#125;&#125;</span><br><span class=\"line\">        &lt;/div&gt;</span><br><span class=\"line\">      &lt;/transition-group&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;script&gt;</span><br><span class=\"line\">      new Vue(&#123;</span><br><span class=\"line\">        el: &quot;#sudoku-demo&quot;,</span><br><span class=\"line\">        data: &#123;</span><br><span class=\"line\">          cells: Array.apply(null, &#123; length: 81 &#125;).map(function(_, index) &#123;</span><br><span class=\"line\">            return &#123;</span><br><span class=\"line\">              id: index,</span><br><span class=\"line\">              number: (index % 9) + 1</span><br><span class=\"line\">            &#125;;</span><br><span class=\"line\">          &#125;)</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        methods: &#123;</span><br><span class=\"line\">          shuffle: function() &#123;</span><br><span class=\"line\">            this.cells = this.randomSort(this.cells);</span><br><span class=\"line\">          &#125;,</span><br><span class=\"line\">          randomSort(arr) &#123;</span><br><span class=\"line\">            const res = arr.slice();</span><br><span class=\"line\">            for (let i=0; i&lt;arr.length; i++) &#123;</span><br><span class=\"line\">              const index = this.randomIndex();</span><br><span class=\"line\">              [res[i], res[index]] = [res[index], res[i]];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            return res;</span><br><span class=\"line\">          &#125;,</span><br><span class=\"line\">          randomIndex() &#123;</span><br><span class=\"line\">            return Math.floor(Math.random() * this.cells.length);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">    &lt;/script&gt;</span><br><span class=\"line\">  &lt;/body&gt;</span><br><span class=\"line\">  </span><br><span class=\"line\">  &lt;style&gt;</span><br><span class=\"line\">.container &#123;</span><br><span class=\"line\">  display: flex;</span><br><span class=\"line\">  flex-wrap: wrap;</span><br><span class=\"line\">  width: 238px;</span><br><span class=\"line\">  margin-top: 10px;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.cell &#123;</span><br><span class=\"line\">  display: flex;</span><br><span class=\"line\">  justify-content: space-around;</span><br><span class=\"line\">  align-items: center;</span><br><span class=\"line\">  width: 25px;</span><br><span class=\"line\">  height: 25px;</span><br><span class=\"line\">  border: 1px solid #aaa;</span><br><span class=\"line\">  margin-right: -1px;</span><br><span class=\"line\">  margin-bottom: -1px;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.cell:nth-child(3n) &#123;</span><br><span class=\"line\">  margin-right: 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.cell:nth-child(27n) &#123;</span><br><span class=\"line\">  margin-bottom: 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.cell-move &#123;</span><br><span class=\"line\">  transition: transform 1s;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  &lt;/style&gt;</span><br><span class=\"line\">  </span><br><span class=\"line\">&lt;/html&gt;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"交错的过渡\"><a href=\"#交错的过渡\" class=\"headerlink\" title=\"交错的过渡\"></a>交错的过渡</h4><p>​        通过data属性和JavaScript的通信，可以实现列表的交错过渡。简单来说就是使用js方法进行了渲染。因为 velocity 不能访问，所以没有进行实验。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/velocity/1.2.3/velocity.min.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;div id=&quot;staggered-list-demo&quot;&gt;</span><br><span class=\"line\">  &lt;input v-model=&quot;query&quot;&gt;</span><br><span class=\"line\">  &lt;transition-group</span><br><span class=\"line\">    name=&quot;staggered-fade&quot;</span><br><span class=\"line\">    tag=&quot;ul&quot;</span><br><span class=\"line\">    v-bind:css=&quot;false&quot;</span><br><span class=\"line\">    v-on:before-enter=&quot;beforeEnter&quot;</span><br><span class=\"line\">    v-on:enter=&quot;enter&quot;</span><br><span class=\"line\">    v-on:leave=&quot;leave&quot;</span><br><span class=\"line\">  &gt;</span><br><span class=\"line\">    &lt;li</span><br><span class=\"line\">      v-for=&quot;(item, index) in computedList&quot;</span><br><span class=\"line\">      v-bind:key=&quot;item.msg&quot;</span><br><span class=\"line\">      v-bind:data-index=&quot;index&quot;</span><br><span class=\"line\">    &gt;&#123;&#123; item.msg &#125;&#125;&lt;/li&gt;</span><br><span class=\"line\">  &lt;/transition-group&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">new Vue(&#123;</span><br><span class=\"line\">  el: &#x27;#staggered-list-demo&#x27;,</span><br><span class=\"line\">  data: &#123;</span><br><span class=\"line\">    query: &#x27;&#x27;,</span><br><span class=\"line\">    list: [</span><br><span class=\"line\">      &#123; msg: &#x27;Bruce Lee&#x27; &#125;,</span><br><span class=\"line\">      &#123; msg: &#x27;Jackie Chan&#x27; &#125;,</span><br><span class=\"line\">      &#123; msg: &#x27;Chuck Norris&#x27; &#125;,</span><br><span class=\"line\">      &#123; msg: &#x27;Jet Li&#x27; &#125;,</span><br><span class=\"line\">      &#123; msg: &#x27;Kung Fury&#x27; &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  computed: &#123;</span><br><span class=\"line\">    computedList: function () &#123;</span><br><span class=\"line\">      var vm = this</span><br><span class=\"line\">      return this.list.filter(function (item) &#123;</span><br><span class=\"line\">        return item.msg.toLowerCase().indexOf(vm.query.toLowerCase()) !== -1</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  methods: &#123;</span><br><span class=\"line\">    beforeEnter: function (el) &#123;</span><br><span class=\"line\">      el.style.opacity = 0</span><br><span class=\"line\">      el.style.height = 0</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    enter: function (el, done) &#123;</span><br><span class=\"line\">      var delay = el.dataset.index * 150</span><br><span class=\"line\">      setTimeout(function () &#123;</span><br><span class=\"line\">        Velocity(</span><br><span class=\"line\">          el,</span><br><span class=\"line\">          &#123; opacity: 1, height: &#x27;1.6em&#x27; &#125;,</span><br><span class=\"line\">          &#123; complete: done &#125;</span><br><span class=\"line\">        )</span><br><span class=\"line\">      &#125;, delay)</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    leave: function (el, done) &#123;</span><br><span class=\"line\">      var delay = el.dataset.index * 150</span><br><span class=\"line\">      setTimeout(function () &#123;</span><br><span class=\"line\">        Velocity(</span><br><span class=\"line\">          el,</span><br><span class=\"line\">          &#123; opacity: 0, height: 0 &#125;,</span><br><span class=\"line\">          &#123; complete: done &#125;</span><br><span class=\"line\">        )</span><br><span class=\"line\">      &#125;, delay)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"可复用的过渡\"><a href=\"#可复用的过渡\" class=\"headerlink\" title=\"可复用的过渡\"></a>可复用的过渡</h3><p>​        可以使用Vue组件系统的实现复用。只需要将 transition 或者 transition-group 作为根组件。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Vue.component(&#x27;my-special-transition&#x27;, &#123;</span><br><span class=\"line\">  template: &#x27;\\</span><br><span class=\"line\">    &lt;transition\\</span><br><span class=\"line\">      name=&quot;very-special-transition&quot;\\</span><br><span class=\"line\">      mode=&quot;out-in&quot;\\</span><br><span class=\"line\">      v-on:before-enter=&quot;beforeEnter&quot;\\</span><br><span class=\"line\">      v-on:after-enter=&quot;afterEnter&quot;\\</span><br><span class=\"line\">    &gt;\\</span><br><span class=\"line\">      &lt;slot&gt;&lt;/slot&gt;\\</span><br><span class=\"line\">    &lt;/transition&gt;\\</span><br><span class=\"line\">  &#x27;,</span><br><span class=\"line\">  methods: &#123;</span><br><span class=\"line\">    beforeEnter: function (el) &#123;</span><br><span class=\"line\">      // ...</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    afterEnter: function (el) &#123;</span><br><span class=\"line\">      // ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>​    当然，可以使用函数式组件来完成这个任务。函数式组件我们后面在进行了解。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Vue.component(&#x27;my-special-transition&#x27;, &#123;</span><br><span class=\"line\">  functional: true,</span><br><span class=\"line\">  render: function (createElement, context) &#123;</span><br><span class=\"line\">    var data = &#123;</span><br><span class=\"line\">      props: &#123;</span><br><span class=\"line\">        name: &#x27;very-special-transition&#x27;,</span><br><span class=\"line\">        mode: &#x27;out-in&#x27;</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      on: &#123;</span><br><span class=\"line\">        beforeEnter: function (el) &#123;</span><br><span class=\"line\">          // ...</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        afterEnter: function (el) &#123;</span><br><span class=\"line\">          // ...</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return createElement(&#x27;transition&#x27;, data, context.children)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"动态过渡\"><a href=\"#动态过渡\" class=\"headerlink\" title=\"动态过渡\"></a>动态过渡</h3><p>​        在Vue中，过渡也是数据驱动的。所以name也可以使用 v-bind 来进行绑定。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;transition v-bind:name=&quot;transitionName&quot;&gt;</span><br></pre></td></tr></table></figure>\n\n<p>​        所有的过渡 attribute 都可以动态绑定。因为事件钩子都是方法。所以根据组件的状态不同，过渡也会有不同的表现。</p>\n<h2 id=\"状态过渡\"><a href=\"#状态过渡\" class=\"headerlink\" title=\"状态过渡\"></a>状态过渡</h2><p>​        数据元素本身的特效，这些数据要么本身就以数值形式存储，要么可以转换为数值。</p>\n<ul>\n<li>数字和运算</li>\n<li>颜色的显示</li>\n<li>SVG 节点的位置</li>\n<li>元素的大小和其他的 property</li>\n</ul>\n<h3 id=\"状态动画与侦听器\"><a href=\"#状态动画与侦听器\" class=\"headerlink\" title=\"状态动画与侦听器\"></a>状态动画与侦听器</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script src=&quot;https://cdn.jsdelivr.net/npm/tween.js@16.3.4&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;script src=&quot;https://cdn.jsdelivr.net/npm/color-js@1.0.3&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;div id=&quot;example-7&quot;&gt;</span><br><span class=\"line\">  &lt;input</span><br><span class=\"line\">    v-model=&quot;colorQuery&quot;</span><br><span class=\"line\">    v-on:keyup.enter=&quot;updateColor&quot;</span><br><span class=\"line\">    placeholder=&quot;Enter a color&quot;</span><br><span class=\"line\">  &gt;</span><br><span class=\"line\">  &lt;button v-on:click=&quot;updateColor&quot;&gt;Update&lt;/button&gt;</span><br><span class=\"line\">  &lt;p&gt;Preview:&lt;/p&gt;</span><br><span class=\"line\">  &lt;span</span><br><span class=\"line\">    v-bind:style=&quot;&#123; backgroundColor: tweenedCSSColor &#125;&quot;</span><br><span class=\"line\">    class=&quot;example-7-color-preview&quot;</span><br><span class=\"line\">  &gt;&lt;/span&gt;</span><br><span class=\"line\">  &lt;p&gt;&#123;&#123; tweenedCSSColor &#125;&#125;&lt;/p&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var Color = net.brehaut.Color</span><br><span class=\"line\"></span><br><span class=\"line\">new Vue(&#123;</span><br><span class=\"line\">  el: &#x27;#example-7&#x27;,</span><br><span class=\"line\">  data: &#123;</span><br><span class=\"line\">    colorQuery: &#x27;&#x27;,</span><br><span class=\"line\">    color: &#123;</span><br><span class=\"line\">      red: 0,</span><br><span class=\"line\">      green: 0,</span><br><span class=\"line\">      blue: 0,</span><br><span class=\"line\">      alpha: 1</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    tweenedColor: &#123;&#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  created: function () &#123;</span><br><span class=\"line\">    this.tweenedColor = Object.assign(&#123;&#125;, this.color)</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  watch: &#123;</span><br><span class=\"line\">    color: function () &#123;</span><br><span class=\"line\">      function animate () &#123;</span><br><span class=\"line\">        if (TWEEN.update()) &#123;</span><br><span class=\"line\">          requestAnimationFrame(animate)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      new TWEEN.Tween(this.tweenedColor)</span><br><span class=\"line\">        .to(this.color, 750)</span><br><span class=\"line\">        .start()</span><br><span class=\"line\"></span><br><span class=\"line\">      animate()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  computed: &#123;</span><br><span class=\"line\">    tweenedCSSColor: function () &#123;</span><br><span class=\"line\">      return new Color(&#123;</span><br><span class=\"line\">        red: this.tweenedColor.red,</span><br><span class=\"line\">        green: this.tweenedColor.green,</span><br><span class=\"line\">        blue: this.tweenedColor.blue,</span><br><span class=\"line\">        alpha: this.tweenedColor.alpha</span><br><span class=\"line\">      &#125;).toCSS()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  methods: &#123;</span><br><span class=\"line\">    updateColor: function () &#123;</span><br><span class=\"line\">      this.color = new Color(this.colorQuery).toRGB()</span><br><span class=\"line\">      this.colorQuery = &#x27;&#x27;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.example-7-color-preview &#123;</span><br><span class=\"line\">  display: inline-block;</span><br><span class=\"line\">  width: 50px;</span><br><span class=\"line\">  height: 50px;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"动态状态过渡\"><a href=\"#动态状态过渡\" class=\"headerlink\" title=\"动态状态过渡\"></a>动态状态过渡</h3><p>​        就像 Vue 的过渡组件一样，数据背后状态过渡会实时更新，这对于原型设计十分有用。当你修改一些变量，即使是一个简单的 SVG 多边形也可实现很多难以想象的效果。</p>\n<h3 id=\"把过渡放到组件里\"><a href=\"#把过渡放到组件里\" class=\"headerlink\" title=\"把过渡放到组件里\"></a>把过渡放到组件里</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script src=&quot;https://cdn.jsdelivr.net/npm/tween.js@16.3.4&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;div id=&quot;example-8&quot;&gt;</span><br><span class=\"line\">  &lt;input v-model.number=&quot;firstNumber&quot; type=&quot;number&quot; step=&quot;20&quot;&gt; +</span><br><span class=\"line\">  &lt;input v-model.number=&quot;secondNumber&quot; type=&quot;number&quot; step=&quot;20&quot;&gt; =</span><br><span class=\"line\">  &#123;&#123; result &#125;&#125;</span><br><span class=\"line\">  &lt;p&gt;</span><br><span class=\"line\">    &lt;animated-integer v-bind:value=&quot;firstNumber&quot;&gt;&lt;/animated-integer&gt; +</span><br><span class=\"line\">    &lt;animated-integer v-bind:value=&quot;secondNumber&quot;&gt;&lt;/animated-integer&gt; =</span><br><span class=\"line\">    &lt;animated-integer v-bind:value=&quot;result&quot;&gt;&lt;/animated-integer&gt;</span><br><span class=\"line\">  &lt;/p&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">// 这种复杂的补间动画逻辑可以被复用</span><br><span class=\"line\">// 任何整数都可以执行动画</span><br><span class=\"line\">// 组件化使我们的界面十分清晰</span><br><span class=\"line\">// 可以支持更多更复杂的动态过渡</span><br><span class=\"line\">// 策略。</span><br><span class=\"line\">Vue.component(&#x27;animated-integer&#x27;, &#123;</span><br><span class=\"line\">  template: &#x27;&lt;span&gt;&#123;&#123; tweeningValue &#125;&#125;&lt;/span&gt;&#x27;,</span><br><span class=\"line\">  props: &#123;</span><br><span class=\"line\">    value: &#123;</span><br><span class=\"line\">      type: Number,</span><br><span class=\"line\">      required: true</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  data: function () &#123;</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">      tweeningValue: 0</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  watch: &#123;</span><br><span class=\"line\">    value: function (newValue, oldValue) &#123;</span><br><span class=\"line\">      this.tween(oldValue, newValue)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  mounted: function () &#123;</span><br><span class=\"line\">    this.tween(0, this.value)</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  methods: &#123;</span><br><span class=\"line\">    tween: function (startValue, endValue) &#123;</span><br><span class=\"line\">      var vm = this</span><br><span class=\"line\">      function animate () &#123;</span><br><span class=\"line\">        if (TWEEN.update()) &#123;</span><br><span class=\"line\">          requestAnimationFrame(animate)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      new TWEEN.Tween(&#123; tweeningValue: startValue &#125;)</span><br><span class=\"line\">        .to(&#123; tweeningValue: endValue &#125;, 500)</span><br><span class=\"line\">        .onUpdate(function () &#123;</span><br><span class=\"line\">          vm.tweeningValue = this.tweeningValue.toFixed(0)</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        .start()</span><br><span class=\"line\"></span><br><span class=\"line\">      animate()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">// 所有的复杂度都已经从 Vue 的主实例中移除！</span><br><span class=\"line\">new Vue(&#123;</span><br><span class=\"line\">  el: &#x27;#example-8&#x27;,</span><br><span class=\"line\">  data: &#123;</span><br><span class=\"line\">    firstNumber: 20,</span><br><span class=\"line\">    secondNumber: 40</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  computed: &#123;</span><br><span class=\"line\">    result: function () &#123;</span><br><span class=\"line\">      return this.firstNumber + this.secondNumber</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"赋予设计以生命\"><a href=\"#赋予设计以生命\" class=\"headerlink\" title=\"赋予设计以生命\"></a>赋予设计以生命</h3>"},{"title":"async和await的基本使用","date":"2021-11-07T02:34:28.000Z","_content":"\n\n\n#  async和await\n\n​\t\t简单来说就像是将一个异步转化为一个同步的操作。\n\n​\t\t简单的使用方式\n\n```\nasync function name() {\n\tawait xxx;\n\t\n\treturn 3;\n}\n```\n\n​\t\t首先，await需要在 async之内，否则会报错，其次await等待的是一个promise对象，否则就没有什么效果。\n\n**上面的函数的执行：**\n\n* 先执行了async函数，创建了一个Promise，此时为pending阶段\n* 然后进入函数内部，执行到了await部分。如果await后面接一个promise的行为，等待一个resolve的返回，async函数内部后面的一些方法不会执行，但是不会影响到外面的函数的继续 运行。\n* 接收到了resolve，将其值返回。\n* 然后继续运行，直到结束或return，有return x，则为resolve(x); 如果是返回一个promise方法，则获取其resolve或者reject进行执行。\n\n\n\n​\t\t先看看示例\n\n```\nasync function test() {\n\n  let a = await new Promise((resolve, reject) => {\n    setTimeout(() => {\n      resolve(1);\n    }, 2000);\n  })\n  console.log(a);\n\n  return 3;\n}\n\ntest().then((res) => console.log(res));\nconsole.log(111);\n```\n\n​\t\t我们分析一下：\n\n* 首先，可以知道a=1，test的resolve为3。\n* 然后就是执行的顺序了，\n* async函数执行，发现是一个promise的方法，直接先执行后续函数。然后再执行promise，这个是调度的机制\n* async函数内部执行，虽然a后面是一个promise方法，但是使用了await，所以后面的会等待。\n* 输出a，执行后面的，return 3\n* return 3，就类似于了Promise.resolve(3)，所以test.then 可以调用。\n\n\n\n## reject处理\n\n​\t\t我们同时也可以发现，如果在 async函数内部调用了reject，会直接抛出异常。\n\n​\t\t此时我们的处理方式，一般来说趋向于使用try，catch进行错误捕获，然后对错误进行处理。\n\n对于错误的处理也有两种方式：\n\n* ```\n  async function test() {\n  \n    let a = await new Promise((resolve, reject) => {\n      setTimeout(() => {\n        reject(1);\n      }, 100);\n    }).catch(e => console.log('err'));\n    console.log(a);\n  \n    return 123;\n  }\n  \n  test()\n  ```\n\n* ```\n    try {\n      a = await new Promise((resolve, reject) => {\n        setTimeout(() => {\n          reject(1);\n        }, 100);\n      });\n      console.log(a);\n    } catch (e) {\n      console.log(e + ' -- ');\n      console.log('err');\n    }\n    \n  输出：\n  1 --\n  err\n  \n  ```\n\n注意点：\n\n​\t这里catch的e，是reject传递的值。\n\n\n\n","source":"_posts/JavaScript/ES6/async和await的基本使用.md","raw":"---\ntitle: async和await的基本使用\ndate: 2021-11-07 10:34:28\ntags:\n - JavaScript\n - Promise\ncategories:\n - JavaScript\n - Promise\n---\n\n\n\n#  async和await\n\n​\t\t简单来说就像是将一个异步转化为一个同步的操作。\n\n​\t\t简单的使用方式\n\n```\nasync function name() {\n\tawait xxx;\n\t\n\treturn 3;\n}\n```\n\n​\t\t首先，await需要在 async之内，否则会报错，其次await等待的是一个promise对象，否则就没有什么效果。\n\n**上面的函数的执行：**\n\n* 先执行了async函数，创建了一个Promise，此时为pending阶段\n* 然后进入函数内部，执行到了await部分。如果await后面接一个promise的行为，等待一个resolve的返回，async函数内部后面的一些方法不会执行，但是不会影响到外面的函数的继续 运行。\n* 接收到了resolve，将其值返回。\n* 然后继续运行，直到结束或return，有return x，则为resolve(x); 如果是返回一个promise方法，则获取其resolve或者reject进行执行。\n\n\n\n​\t\t先看看示例\n\n```\nasync function test() {\n\n  let a = await new Promise((resolve, reject) => {\n    setTimeout(() => {\n      resolve(1);\n    }, 2000);\n  })\n  console.log(a);\n\n  return 3;\n}\n\ntest().then((res) => console.log(res));\nconsole.log(111);\n```\n\n​\t\t我们分析一下：\n\n* 首先，可以知道a=1，test的resolve为3。\n* 然后就是执行的顺序了，\n* async函数执行，发现是一个promise的方法，直接先执行后续函数。然后再执行promise，这个是调度的机制\n* async函数内部执行，虽然a后面是一个promise方法，但是使用了await，所以后面的会等待。\n* 输出a，执行后面的，return 3\n* return 3，就类似于了Promise.resolve(3)，所以test.then 可以调用。\n\n\n\n## reject处理\n\n​\t\t我们同时也可以发现，如果在 async函数内部调用了reject，会直接抛出异常。\n\n​\t\t此时我们的处理方式，一般来说趋向于使用try，catch进行错误捕获，然后对错误进行处理。\n\n对于错误的处理也有两种方式：\n\n* ```\n  async function test() {\n  \n    let a = await new Promise((resolve, reject) => {\n      setTimeout(() => {\n        reject(1);\n      }, 100);\n    }).catch(e => console.log('err'));\n    console.log(a);\n  \n    return 123;\n  }\n  \n  test()\n  ```\n\n* ```\n    try {\n      a = await new Promise((resolve, reject) => {\n        setTimeout(() => {\n          reject(1);\n        }, 100);\n      });\n      console.log(a);\n    } catch (e) {\n      console.log(e + ' -- ');\n      console.log('err');\n    }\n    \n  输出：\n  1 --\n  err\n  \n  ```\n\n注意点：\n\n​\t这里catch的e，是reject传递的值。\n\n\n\n","slug":"JavaScript/ES6/async和await的基本使用","published":1,"updated":"2021-12-09T01:56:49.404Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckznhkk8l006eikubed07b7sj","content":"<h1 id=\"async和await\"><a href=\"#async和await\" class=\"headerlink\" title=\"async和await\"></a>async和await</h1><p>​        简单来说就像是将一个异步转化为一个同步的操作。</p>\n<p>​        简单的使用方式</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">async function name() &#123;</span><br><span class=\"line\">\tawait xxx;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\treturn 3;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>​        首先，await需要在 async之内，否则会报错，其次await等待的是一个promise对象，否则就没有什么效果。</p>\n<p><strong>上面的函数的执行：</strong></p>\n<ul>\n<li>先执行了async函数，创建了一个Promise，此时为pending阶段</li>\n<li>然后进入函数内部，执行到了await部分。如果await后面接一个promise的行为，等待一个resolve的返回，async函数内部后面的一些方法不会执行，但是不会影响到外面的函数的继续 运行。</li>\n<li>接收到了resolve，将其值返回。</li>\n<li>然后继续运行，直到结束或return，有return x，则为resolve(x); 如果是返回一个promise方法，则获取其resolve或者reject进行执行。</li>\n</ul>\n<p>​        先看看示例</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">async function test() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  let a = await new Promise((resolve, reject) =&gt; &#123;</span><br><span class=\"line\">    setTimeout(() =&gt; &#123;</span><br><span class=\"line\">      resolve(1);</span><br><span class=\"line\">    &#125;, 2000);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  console.log(a);</span><br><span class=\"line\"></span><br><span class=\"line\">  return 3;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">test().then((res) =&gt; console.log(res));</span><br><span class=\"line\">console.log(111);</span><br></pre></td></tr></table></figure>\n\n<p>​        我们分析一下：</p>\n<ul>\n<li>首先，可以知道a=1，test的resolve为3。</li>\n<li>然后就是执行的顺序了，</li>\n<li>async函数执行，发现是一个promise的方法，直接先执行后续函数。然后再执行promise，这个是调度的机制</li>\n<li>async函数内部执行，虽然a后面是一个promise方法，但是使用了await，所以后面的会等待。</li>\n<li>输出a，执行后面的，return 3</li>\n<li>return 3，就类似于了Promise.resolve(3)，所以test.then 可以调用。</li>\n</ul>\n<h2 id=\"reject处理\"><a href=\"#reject处理\" class=\"headerlink\" title=\"reject处理\"></a>reject处理</h2><p>​        我们同时也可以发现，如果在 async函数内部调用了reject，会直接抛出异常。</p>\n<p>​        此时我们的处理方式，一般来说趋向于使用try，catch进行错误捕获，然后对错误进行处理。</p>\n<p>对于错误的处理也有两种方式：</p>\n<ul>\n<li>```<br>async function test() {  let a = await new Promise((resolve, reject) =&gt; {<pre><code>setTimeout(() =&gt; &#123;\n  reject(1);\n&#125;, 100);\n</code></pre>\n  }).catch(e =&gt; console.log(‘err’));<br>  console.log(a);  return 123;<br>}test()<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">* ```</span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">      a = await new Promise((resolve, reject) =&gt; &#123;</span><br><span class=\"line\">        setTimeout(() =&gt; &#123;</span><br><span class=\"line\">          reject(1);</span><br><span class=\"line\">        &#125;, 100);</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">      console.log(a);</span><br><span class=\"line\">    &#125; catch (e) &#123;</span><br><span class=\"line\">      console.log(e + &#x27; -- &#x27;);</span><br><span class=\"line\">      console.log(&#x27;err&#x27;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">  输出：</span><br><span class=\"line\">  1 --</span><br><span class=\"line\">  err</span><br><span class=\"line\">  </span><br></pre></td></tr></table></figure></li>\n</ul>\n<p>注意点：</p>\n<p>​    这里catch的e，是reject传递的值。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"async和await\"><a href=\"#async和await\" class=\"headerlink\" title=\"async和await\"></a>async和await</h1><p>​        简单来说就像是将一个异步转化为一个同步的操作。</p>\n<p>​        简单的使用方式</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">async function name() &#123;</span><br><span class=\"line\">\tawait xxx;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\treturn 3;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>​        首先，await需要在 async之内，否则会报错，其次await等待的是一个promise对象，否则就没有什么效果。</p>\n<p><strong>上面的函数的执行：</strong></p>\n<ul>\n<li>先执行了async函数，创建了一个Promise，此时为pending阶段</li>\n<li>然后进入函数内部，执行到了await部分。如果await后面接一个promise的行为，等待一个resolve的返回，async函数内部后面的一些方法不会执行，但是不会影响到外面的函数的继续 运行。</li>\n<li>接收到了resolve，将其值返回。</li>\n<li>然后继续运行，直到结束或return，有return x，则为resolve(x); 如果是返回一个promise方法，则获取其resolve或者reject进行执行。</li>\n</ul>\n<p>​        先看看示例</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">async function test() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  let a = await new Promise((resolve, reject) =&gt; &#123;</span><br><span class=\"line\">    setTimeout(() =&gt; &#123;</span><br><span class=\"line\">      resolve(1);</span><br><span class=\"line\">    &#125;, 2000);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  console.log(a);</span><br><span class=\"line\"></span><br><span class=\"line\">  return 3;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">test().then((res) =&gt; console.log(res));</span><br><span class=\"line\">console.log(111);</span><br></pre></td></tr></table></figure>\n\n<p>​        我们分析一下：</p>\n<ul>\n<li>首先，可以知道a=1，test的resolve为3。</li>\n<li>然后就是执行的顺序了，</li>\n<li>async函数执行，发现是一个promise的方法，直接先执行后续函数。然后再执行promise，这个是调度的机制</li>\n<li>async函数内部执行，虽然a后面是一个promise方法，但是使用了await，所以后面的会等待。</li>\n<li>输出a，执行后面的，return 3</li>\n<li>return 3，就类似于了Promise.resolve(3)，所以test.then 可以调用。</li>\n</ul>\n<h2 id=\"reject处理\"><a href=\"#reject处理\" class=\"headerlink\" title=\"reject处理\"></a>reject处理</h2><p>​        我们同时也可以发现，如果在 async函数内部调用了reject，会直接抛出异常。</p>\n<p>​        此时我们的处理方式，一般来说趋向于使用try，catch进行错误捕获，然后对错误进行处理。</p>\n<p>对于错误的处理也有两种方式：</p>\n<ul>\n<li>```<br>async function test() {  let a = await new Promise((resolve, reject) =&gt; {<pre><code>setTimeout(() =&gt; &#123;\n  reject(1);\n&#125;, 100);\n</code></pre>\n  }).catch(e =&gt; console.log(‘err’));<br>  console.log(a);  return 123;<br>}test()<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">* ```</span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">      a = await new Promise((resolve, reject) =&gt; &#123;</span><br><span class=\"line\">        setTimeout(() =&gt; &#123;</span><br><span class=\"line\">          reject(1);</span><br><span class=\"line\">        &#125;, 100);</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">      console.log(a);</span><br><span class=\"line\">    &#125; catch (e) &#123;</span><br><span class=\"line\">      console.log(e + &#x27; -- &#x27;);</span><br><span class=\"line\">      console.log(&#x27;err&#x27;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">  输出：</span><br><span class=\"line\">  1 --</span><br><span class=\"line\">  err</span><br><span class=\"line\">  </span><br></pre></td></tr></table></figure></li>\n</ul>\n<p>注意点：</p>\n<p>​    这里catch的e，是reject传递的值。</p>\n"},{"title":"JavaScript箭头函数","date":"2021-11-10T11:42:56.000Z","_content":"\n\n\n#  JavaScript箭头函数\n\n```\nhttps://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions\n```\n\n\n\n​\t\t**箭头函数表达式**的语法比[函数表达式](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/function)更简洁，并且没有自己的`this`，`arguments`，`super`或`new.target`。箭头函数表达式更适用于那些本来需要匿名函数的地方，并且它不能用作构造函数。\n\n## 特点\n\n* 没有自己的this，它只会从自己的作用域链的上一层继承this。\n* 没有arguments，不能使用自己的arguments对象。使用的arguments都是自己作用域的arguments。\n* 不能用做构造函数，代表了不能使用new方法。使用了new方法会抛出异常。\n* 与严格模式的关系，除了this指向以外，其他规则不变\n* 通过call方法和apply进行调用的this指向被忽略\n* 没有prototype属性\n* 不能使用yield关键字，不能用作函数生成器\n* 参数和箭头不能换行\n* 箭头函数具有与常规函数不同的特殊[运算符优先级](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Operator_Precedence)解析规则。 **call || () => {}** 会先执行call || () 然后再执行 => {}，所以要在后面使用(), 进行分割。\n\n\n\n## 语法\n\n```\nlet fn = (args) => {\n  xxxx\n  return ;\n}\n```\n\n​\t\t对于单个参数的可以简写，()\n\n```\nv => {}\n```\n\n​\t\t对于只有一条return 语句的，{}\n\n```\n() => xxx;\n```\n\n\n\n**高级语法**：\n\n​\t\t因为这里首先只有一个直接的return 语句，所以可以省略了{}，然后返回的是对象，所以添加了{}，导致的问题就是不知道这个括号所代表的含义，所以使用了()，来进行区分。\n\n```\n//加括号的函数体返回对象字面量表达式：\nparams => ({foo: bar})\n```\n\n​\t\t剩余参数，简单来说就是一个es6的一个赋值方式 ...args，后面的参数都会放入这个数组\n\n​\t\t默认参数，就是不带参数和带的undefined的参数 param=defaultValue\n\n```\n//支持剩余参数和默认参数\n(param1, param2, ...rest) => { statements }\n(param1 = defaultValue1, param2, …, paramN = defaultValueN) => {\nstatements }\n\n```\n\n​\t\t就是es6的解构方法。详细的解构方法，我们可以后续在填。\n\n```\n//同样支持参数列表解构\nlet f = ([a, b] = [1, 2], {x: c} = {x: a + b}) => a + b + c;\nf();  // 6\n```\n\n\n\n## this指向\n\n​\t\t箭头函数的一个特点就是this指向的固定，这里我们可以知道箭头函数的this指向是定义时词法作用域的指向。\n\n​\t\t这里可能就有一个思考了，为什么这个会和定义时的词法作用域相关。而不是和使用时的作用域相关。我们也许就该这样思考了，**也许**说明在定义阶段，如果有使用了this的方法，会进行一个提前的指向。\n\n​\t\t箭头函数不会创建自己的`this,它只会从自己的作用域链的上一层继承this` 函数，语法块等都有自己的作用域链{} \n\n​\t\t作用域链，其实就是箭头函数this指向的是一个词法环境，词法环境在es6中的定义已经和作用域链相差无几。对象是不生成词法环境，但是注意普通函数可以将对象也作为一个this的指向。\n\n\n\n​\t\t**这里有个小知识点**：\n\n* 就是node端和浏览器端，对于var的定义不同：\n  * node不会将var定义的变量加入全局。\n  * 浏览器端会将var定义的变量加入全局。\n  \n  \n\n","source":"_posts/JavaScript/ES6/JavaScript箭头函数.md","raw":"---\ntitle: JavaScript箭头函数\ndate: 2021-11-10 19:42:56\ntags:\n - JavaScript\n - 随笔\n - 箭头函数\ncategories:\n - JavaScript\n - 随笔\n---\n\n\n\n#  JavaScript箭头函数\n\n```\nhttps://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions\n```\n\n\n\n​\t\t**箭头函数表达式**的语法比[函数表达式](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/function)更简洁，并且没有自己的`this`，`arguments`，`super`或`new.target`。箭头函数表达式更适用于那些本来需要匿名函数的地方，并且它不能用作构造函数。\n\n## 特点\n\n* 没有自己的this，它只会从自己的作用域链的上一层继承this。\n* 没有arguments，不能使用自己的arguments对象。使用的arguments都是自己作用域的arguments。\n* 不能用做构造函数，代表了不能使用new方法。使用了new方法会抛出异常。\n* 与严格模式的关系，除了this指向以外，其他规则不变\n* 通过call方法和apply进行调用的this指向被忽略\n* 没有prototype属性\n* 不能使用yield关键字，不能用作函数生成器\n* 参数和箭头不能换行\n* 箭头函数具有与常规函数不同的特殊[运算符优先级](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Operator_Precedence)解析规则。 **call || () => {}** 会先执行call || () 然后再执行 => {}，所以要在后面使用(), 进行分割。\n\n\n\n## 语法\n\n```\nlet fn = (args) => {\n  xxxx\n  return ;\n}\n```\n\n​\t\t对于单个参数的可以简写，()\n\n```\nv => {}\n```\n\n​\t\t对于只有一条return 语句的，{}\n\n```\n() => xxx;\n```\n\n\n\n**高级语法**：\n\n​\t\t因为这里首先只有一个直接的return 语句，所以可以省略了{}，然后返回的是对象，所以添加了{}，导致的问题就是不知道这个括号所代表的含义，所以使用了()，来进行区分。\n\n```\n//加括号的函数体返回对象字面量表达式：\nparams => ({foo: bar})\n```\n\n​\t\t剩余参数，简单来说就是一个es6的一个赋值方式 ...args，后面的参数都会放入这个数组\n\n​\t\t默认参数，就是不带参数和带的undefined的参数 param=defaultValue\n\n```\n//支持剩余参数和默认参数\n(param1, param2, ...rest) => { statements }\n(param1 = defaultValue1, param2, …, paramN = defaultValueN) => {\nstatements }\n\n```\n\n​\t\t就是es6的解构方法。详细的解构方法，我们可以后续在填。\n\n```\n//同样支持参数列表解构\nlet f = ([a, b] = [1, 2], {x: c} = {x: a + b}) => a + b + c;\nf();  // 6\n```\n\n\n\n## this指向\n\n​\t\t箭头函数的一个特点就是this指向的固定，这里我们可以知道箭头函数的this指向是定义时词法作用域的指向。\n\n​\t\t这里可能就有一个思考了，为什么这个会和定义时的词法作用域相关。而不是和使用时的作用域相关。我们也许就该这样思考了，**也许**说明在定义阶段，如果有使用了this的方法，会进行一个提前的指向。\n\n​\t\t箭头函数不会创建自己的`this,它只会从自己的作用域链的上一层继承this` 函数，语法块等都有自己的作用域链{} \n\n​\t\t作用域链，其实就是箭头函数this指向的是一个词法环境，词法环境在es6中的定义已经和作用域链相差无几。对象是不生成词法环境，但是注意普通函数可以将对象也作为一个this的指向。\n\n\n\n​\t\t**这里有个小知识点**：\n\n* 就是node端和浏览器端，对于var的定义不同：\n  * node不会将var定义的变量加入全局。\n  * 浏览器端会将var定义的变量加入全局。\n  \n  \n\n","slug":"JavaScript/ES6/JavaScript箭头函数","published":1,"updated":"2021-12-09T01:56:49.404Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckznhkk8m006iikub70p406e6","content":"<h1 id=\"JavaScript箭头函数\"><a href=\"#JavaScript箭头函数\" class=\"headerlink\" title=\"JavaScript箭头函数\"></a>JavaScript箭头函数</h1><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions</span><br></pre></td></tr></table></figure>\n\n\n\n<p>​        <strong>箭头函数表达式</strong>的语法比<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/function\">函数表达式</a>更简洁，并且没有自己的<code>this</code>，<code>arguments</code>，<code>super</code>或<code>new.target</code>。箭头函数表达式更适用于那些本来需要匿名函数的地方，并且它不能用作构造函数。</p>\n<h2 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h2><ul>\n<li>没有自己的this，它只会从自己的作用域链的上一层继承this。</li>\n<li>没有arguments，不能使用自己的arguments对象。使用的arguments都是自己作用域的arguments。</li>\n<li>不能用做构造函数，代表了不能使用new方法。使用了new方法会抛出异常。</li>\n<li>与严格模式的关系，除了this指向以外，其他规则不变</li>\n<li>通过call方法和apply进行调用的this指向被忽略</li>\n<li>没有prototype属性</li>\n<li>不能使用yield关键字，不能用作函数生成器</li>\n<li>参数和箭头不能换行</li>\n<li>箭头函数具有与常规函数不同的特殊<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Operator_Precedence\">运算符优先级</a>解析规则。 <strong>call || () =&gt; {}</strong> 会先执行call || () 然后再执行 =&gt; {}，所以要在后面使用(), 进行分割。</li>\n</ul>\n<h2 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let fn = (args) =&gt; &#123;</span><br><span class=\"line\">  xxxx</span><br><span class=\"line\">  return ;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>​        对于单个参数的可以简写，()</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">v =&gt; &#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>​        对于只有一条return 语句的，{}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">() =&gt; xxx;</span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>高级语法</strong>：</p>\n<p>​        因为这里首先只有一个直接的return 语句，所以可以省略了{}，然后返回的是对象，所以添加了{}，导致的问题就是不知道这个括号所代表的含义，所以使用了()，来进行区分。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//加括号的函数体返回对象字面量表达式：</span><br><span class=\"line\">params =&gt; (&#123;foo: bar&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>​        剩余参数，简单来说就是一个es6的一个赋值方式 …args，后面的参数都会放入这个数组</p>\n<p>​        默认参数，就是不带参数和带的undefined的参数 param=defaultValue</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//支持剩余参数和默认参数</span><br><span class=\"line\">(param1, param2, ...rest) =&gt; &#123; statements &#125;</span><br><span class=\"line\">(param1 = defaultValue1, param2, …, paramN = defaultValueN) =&gt; &#123;</span><br><span class=\"line\">statements &#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>​        就是es6的解构方法。详细的解构方法，我们可以后续在填。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//同样支持参数列表解构</span><br><span class=\"line\">let f = ([a, b] = [1, 2], &#123;x: c&#125; = &#123;x: a + b&#125;) =&gt; a + b + c;</span><br><span class=\"line\">f();  // 6</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"this指向\"><a href=\"#this指向\" class=\"headerlink\" title=\"this指向\"></a>this指向</h2><p>​        箭头函数的一个特点就是this指向的固定，这里我们可以知道箭头函数的this指向是定义时词法作用域的指向。</p>\n<p>​        这里可能就有一个思考了，为什么这个会和定义时的词法作用域相关。而不是和使用时的作用域相关。我们也许就该这样思考了，<strong>也许</strong>说明在定义阶段，如果有使用了this的方法，会进行一个提前的指向。</p>\n<p>​        箭头函数不会创建自己的<code>this,它只会从自己的作用域链的上一层继承this</code> 函数，语法块等都有自己的作用域链{} </p>\n<p>​        作用域链，其实就是箭头函数this指向的是一个词法环境，词法环境在es6中的定义已经和作用域链相差无几。对象是不生成词法环境，但是注意普通函数可以将对象也作为一个this的指向。</p>\n<p>​        <strong>这里有个小知识点</strong>：</p>\n<ul>\n<li>就是node端和浏览器端，对于var的定义不同：<ul>\n<li>node不会将var定义的变量加入全局。</li>\n<li>浏览器端会将var定义的变量加入全局。</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"JavaScript箭头函数\"><a href=\"#JavaScript箭头函数\" class=\"headerlink\" title=\"JavaScript箭头函数\"></a>JavaScript箭头函数</h1><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions</span><br></pre></td></tr></table></figure>\n\n\n\n<p>​        <strong>箭头函数表达式</strong>的语法比<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/function\">函数表达式</a>更简洁，并且没有自己的<code>this</code>，<code>arguments</code>，<code>super</code>或<code>new.target</code>。箭头函数表达式更适用于那些本来需要匿名函数的地方，并且它不能用作构造函数。</p>\n<h2 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h2><ul>\n<li>没有自己的this，它只会从自己的作用域链的上一层继承this。</li>\n<li>没有arguments，不能使用自己的arguments对象。使用的arguments都是自己作用域的arguments。</li>\n<li>不能用做构造函数，代表了不能使用new方法。使用了new方法会抛出异常。</li>\n<li>与严格模式的关系，除了this指向以外，其他规则不变</li>\n<li>通过call方法和apply进行调用的this指向被忽略</li>\n<li>没有prototype属性</li>\n<li>不能使用yield关键字，不能用作函数生成器</li>\n<li>参数和箭头不能换行</li>\n<li>箭头函数具有与常规函数不同的特殊<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Operator_Precedence\">运算符优先级</a>解析规则。 <strong>call || () =&gt; {}</strong> 会先执行call || () 然后再执行 =&gt; {}，所以要在后面使用(), 进行分割。</li>\n</ul>\n<h2 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let fn = (args) =&gt; &#123;</span><br><span class=\"line\">  xxxx</span><br><span class=\"line\">  return ;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>​        对于单个参数的可以简写，()</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">v =&gt; &#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>​        对于只有一条return 语句的，{}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">() =&gt; xxx;</span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>高级语法</strong>：</p>\n<p>​        因为这里首先只有一个直接的return 语句，所以可以省略了{}，然后返回的是对象，所以添加了{}，导致的问题就是不知道这个括号所代表的含义，所以使用了()，来进行区分。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//加括号的函数体返回对象字面量表达式：</span><br><span class=\"line\">params =&gt; (&#123;foo: bar&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>​        剩余参数，简单来说就是一个es6的一个赋值方式 …args，后面的参数都会放入这个数组</p>\n<p>​        默认参数，就是不带参数和带的undefined的参数 param=defaultValue</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//支持剩余参数和默认参数</span><br><span class=\"line\">(param1, param2, ...rest) =&gt; &#123; statements &#125;</span><br><span class=\"line\">(param1 = defaultValue1, param2, …, paramN = defaultValueN) =&gt; &#123;</span><br><span class=\"line\">statements &#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>​        就是es6的解构方法。详细的解构方法，我们可以后续在填。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//同样支持参数列表解构</span><br><span class=\"line\">let f = ([a, b] = [1, 2], &#123;x: c&#125; = &#123;x: a + b&#125;) =&gt; a + b + c;</span><br><span class=\"line\">f();  // 6</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"this指向\"><a href=\"#this指向\" class=\"headerlink\" title=\"this指向\"></a>this指向</h2><p>​        箭头函数的一个特点就是this指向的固定，这里我们可以知道箭头函数的this指向是定义时词法作用域的指向。</p>\n<p>​        这里可能就有一个思考了，为什么这个会和定义时的词法作用域相关。而不是和使用时的作用域相关。我们也许就该这样思考了，<strong>也许</strong>说明在定义阶段，如果有使用了this的方法，会进行一个提前的指向。</p>\n<p>​        箭头函数不会创建自己的<code>this,它只会从自己的作用域链的上一层继承this</code> 函数，语法块等都有自己的作用域链{} </p>\n<p>​        作用域链，其实就是箭头函数this指向的是一个词法环境，词法环境在es6中的定义已经和作用域链相差无几。对象是不生成词法环境，但是注意普通函数可以将对象也作为一个this的指向。</p>\n<p>​        <strong>这里有个小知识点</strong>：</p>\n<ul>\n<li>就是node端和浏览器端，对于var的定义不同：<ul>\n<li>node不会将var定义的变量加入全局。</li>\n<li>浏览器端会将var定义的变量加入全局。</li>\n</ul>\n</li>\n</ul>\n"},{"title":"JavaScript-冒泡和捕获","date":"2021-10-29T02:54:26.000Z","_content":"\n\n\n **前言:**\n\n#### **JavaScript-DOM的监听方式**\n\n```\ndom.addEventListener('click', function (e) {\n  console.log('father1 捕获');\n}, true);\n\ndom.onclick = function (e) {\n  console.log('a2 冒泡');\n}\n```\n\n在这里,又被称为 **DOM0级** 和 **DOM2级**\n\n**0级DOM**:\n\n* 标签内部的 onclick 事件\n* JavaScript 的 onclick = function() {} 函数\n\n**2级DOM:**\n\n* 就是标准的事件模型\n* **addEventListener** 和 **removeEventListener**\n\n\n\n#  JavaScript-冒泡和捕获\n\n参考文章，感觉写的很详细\n\n```\nhttps://blog.csdn.net/sinat_33523805/article/details/94018242\n```\n\n​\t\t在一个 `Event` 的事件中，存在三个阶段：`捕获，目标和冒泡`\n\n**三个阶段的顺序：**\n\n* 首先是从根节点出发，到达目标节点，若此过程中触发了事件，则被称为**捕获阶段**\n\n* 然后当节点到达定义点击事件的目标节点时，处于**目标阶段**\n\n* 在目标节点触发事件后，最后就会一路往上回到根节点，处于 **冒泡阶段**\n\n  ​\t给一张对应的图片。\n\n<img src=\"JavaScript-冒泡和捕获/image-20210907141230550.png\" alt=\"image-20210907141230550\" style=\"zoom:67%;\" />\n\n​\t\t如何在创建一个点击监听的时候，同时定义是处于冒泡还是捕获阶段。\n\n​\t\t通过一个 `addEventListener` 函数的参数，分别为 **事件名， 回调函数， 在什么阶段执行**。第三个参数就是判断是处于什么阶段的。**true代表捕获阶段，false代表了冒泡阶段**。\n\n​\t\t对于target，顺序不是按照捕获和冒泡的顺序，而是按照监听函数的创建顺序。\n\n​\t\t可以通过 `event.eventPhase` 的值来判断是处于哪个阶段。\n\n​\t\t\t`1，捕获阶段。2，目标阶段。3，冒泡阶段`\n\n```\n  father.addEventListener('click', function (e) {\n    console.log('father 捕获');\n    console.log(e.eventPhase);\t// 1\n  }, true);\n  father.addEventListener('click', function (e) {\n    console.log('father 冒泡');\n  }, false);\n\n  children.addEventListener('click', function (e) {\n    console.log('children 冒泡');\n  }, false);\n  children.addEventListener('click', function (e) {\n    console.log('children 捕获');\n  }, true);\n```\n\n```\nfather 捕获\nchildren 冒泡\nchildren 捕获\nfather 冒泡\n```\n\n\n\n**结论：**\n\n* 捕获是从根到target， 冒泡是从target到根。\n\n* 先捕获，后冒泡。\n* 可以通过 `addEventListener` 的第三个参数来决定这个监听处于捕获还是处于冒泡。默认是冒泡阶段。\n* 对于 `target` 元素，没有捕获冒泡一说，先定义先执行。\n* 可以通过 `event.eventPhase` 来判断当前处于什么阶段。\n\n\n\n# 取消事件传递\n\n​\t\t通过这三个方式 `stopPropagation()` 、`prenventDefault()`、`return false;`、`stopImmediatePropagation()`。\n\n* `stopPropagation()` \n  * 会停止事件的传递。但是不会阻止事件的默认方法。\n\n* `stopImmediatIePropagation()` \n  * 同上，但是对于多个相同的事件都会被阻止。具体区别一会儿看案例.\n\n* `prenventDefault()` \n  * 取消掉元素的默认行为.\n\n* `return false;` \n  * 会取消默认行为,但是只能用于 DOM0级.\n  * 但是不会终止事件的传递.\n\n\n\n## stopPropagation 和 stopImmediatIePropagation 的使用\n\n```\nchildren1.addEventListener('click', function (e) {\n\tconsole.log('a 捕获');\n\te.stopPropagation();\n}, true);\t//为true,代表了捕获.\n  \nchildren1.addEventListener('click', function (e) {\n    console.log('a1 捕获');\n}, true);\t//为true,代表了捕获.\n\n这里对上面进行了 stopPropagation 所以会停止传递,但是\n\t对于上层元素,传递会直接停止,所以如果是在捕获层进行了使用,那么就会在调用了本层方法后,就会停止, 如果是在冒泡层进行使用,就会结束后续的冒泡行为.\n\t对于 target 的使用,因为 target 不分冒泡和捕获,所以两个都会执行.\n执行结果:\tfather 捕获, target 捕获, target 冒泡(阻止了事件的继续.虽然这个阻止放在了 捕获 位置, 但是对于 target 是不分 冒泡 和 捕获 的.所以 target 的冒泡也会执行.)\n\t其中对于 target 的捕获和冒泡的顺序,按照定义的顺序执行.\n\n对于 stopImmediatIePropagation 的使用,大体上和上面起始差不多,最大的区别就是,不但会停止传递,并且会停止本层的相同事件.\n比如代码类型:\n\n    children1.addEventListener('click', function (e) {\n        console.log('a 捕获');\n    \te.stopImmediatePropagation();\n    }, true);\n    children1.addEventListener('click', function (e) {\n        console.log('a1 捕获');\n    }, true);\n    children1.addEventListener('click', function (e) {\n        console.log('a 冒泡');\n    }, false);\n\t\n\t我这里定义了两个相同的捕获. 但是使用的是 e.stopImmediatePropagation(); 所以,对于相同的事件都会停止,然后因为这个 stopImmediatePropagation 放在了最上面定义的位置,所以放在下面的都不会执行. 如果我把这个函数的位置放在了第二个,那么第一个还是会执行\n执行结果:\n\tfather 捕获, target 捕获(阻止了事件的传递. 并且因为target的捕获和冒泡属于同一类型,所以都被阻止了.)\n```\n\n**简单总结:**\n\n* **stopPropagation**\n  * 对于非target, 会阻止后续的事件, 但是对于相同的事件不会阻止.\n  * 对于 target, 因为 target 是**不分冒泡和捕获**,所以只会阻止上级元素的事件,对于 target 的**冒泡** 和 **捕获** 都不会阻止.\n* **stopImmediatIePropagation**\n  * 这个不但会阻止后续的事件, 对于相同的事件也会阻止.\n* **相同点**是: 他们都**不会阻止元素的默认事件的执行,就算是捕获和冒泡没有到target.**\n\n\n\n## prenventDefault 使用\n\n**作用:**\n\n​\t取消元素的默认行为.如果放在了父元素,那么子元素的所有默认行为都会被取消.\n\n**使用方式:**\n\n```\n  children1.addEventListener('click', function (e) {\n    console.log('a 捕获');\n    e.preventDefault();\n  }, true);\n  \n这个很简单.\n```\n\n\n\n## return false; 的使用\n\n这个的使用方式不和上面的一样.\n\n```\n  children1.onclick = function (e) {\n    console.log('a2 冒泡');\n    return false;\n  }\n  \n不能在 addEventListener 的回调函数里面使用. 因为这个是通过return 的值为false,来进行的定义,如果要使用 addEventListener 的回调的话, 函数的返回值不能正确返回,但是要怎么实现我也不知道.\n```\n\n\n\n# 事件委托\n\n​\t\t理解很简单, 就是子元素的点击, 父级也可以进行捕获和冒泡, 很多人说事件委托是利用的冒泡原理, 但是通过前面的学习我们可以知道,事件委托,无非就是 子元素 的点击可以被父元素所监听到. 所以这里肯定会感觉不对, 然后我去网上看了一篇文章,  然后断章取义了一番.\n\n```\nhttps://blog.csdn.net/mmrsdym/article/details/39209375\n```\n\n​\t\t我了解到了,为什么事件委托要使用的是冒泡原理, 而不是使用的捕获的原因.\n\n​\t\t大概的意思就是, 一个元素是先进行的捕获行为, 然后再进行的冒泡行为. 所以如果我们将事件委托放在了, 捕获上面. 如果要阻止事件的行为, 那么就会让子元素的所有事件都不能执行, 而放在了事件的冒泡的话, 子元素的一些行为还是可以执行的.  所以这就是为什么事件委托需要放在冒泡的原因. ","source":"_posts/JavaScript/概念/JavaScript-冒泡和捕获.md","raw":"---\ntitle: JavaScript-冒泡和捕获\ndate: 2021-10-29 10:54:26\ntags:\n - JavaScript\n - 冒泡\n - 捕获\n - 事件委托\ncategories:\n - JavaScript\n---\n\n\n\n **前言:**\n\n#### **JavaScript-DOM的监听方式**\n\n```\ndom.addEventListener('click', function (e) {\n  console.log('father1 捕获');\n}, true);\n\ndom.onclick = function (e) {\n  console.log('a2 冒泡');\n}\n```\n\n在这里,又被称为 **DOM0级** 和 **DOM2级**\n\n**0级DOM**:\n\n* 标签内部的 onclick 事件\n* JavaScript 的 onclick = function() {} 函数\n\n**2级DOM:**\n\n* 就是标准的事件模型\n* **addEventListener** 和 **removeEventListener**\n\n\n\n#  JavaScript-冒泡和捕获\n\n参考文章，感觉写的很详细\n\n```\nhttps://blog.csdn.net/sinat_33523805/article/details/94018242\n```\n\n​\t\t在一个 `Event` 的事件中，存在三个阶段：`捕获，目标和冒泡`\n\n**三个阶段的顺序：**\n\n* 首先是从根节点出发，到达目标节点，若此过程中触发了事件，则被称为**捕获阶段**\n\n* 然后当节点到达定义点击事件的目标节点时，处于**目标阶段**\n\n* 在目标节点触发事件后，最后就会一路往上回到根节点，处于 **冒泡阶段**\n\n  ​\t给一张对应的图片。\n\n<img src=\"JavaScript-冒泡和捕获/image-20210907141230550.png\" alt=\"image-20210907141230550\" style=\"zoom:67%;\" />\n\n​\t\t如何在创建一个点击监听的时候，同时定义是处于冒泡还是捕获阶段。\n\n​\t\t通过一个 `addEventListener` 函数的参数，分别为 **事件名， 回调函数， 在什么阶段执行**。第三个参数就是判断是处于什么阶段的。**true代表捕获阶段，false代表了冒泡阶段**。\n\n​\t\t对于target，顺序不是按照捕获和冒泡的顺序，而是按照监听函数的创建顺序。\n\n​\t\t可以通过 `event.eventPhase` 的值来判断是处于哪个阶段。\n\n​\t\t\t`1，捕获阶段。2，目标阶段。3，冒泡阶段`\n\n```\n  father.addEventListener('click', function (e) {\n    console.log('father 捕获');\n    console.log(e.eventPhase);\t// 1\n  }, true);\n  father.addEventListener('click', function (e) {\n    console.log('father 冒泡');\n  }, false);\n\n  children.addEventListener('click', function (e) {\n    console.log('children 冒泡');\n  }, false);\n  children.addEventListener('click', function (e) {\n    console.log('children 捕获');\n  }, true);\n```\n\n```\nfather 捕获\nchildren 冒泡\nchildren 捕获\nfather 冒泡\n```\n\n\n\n**结论：**\n\n* 捕获是从根到target， 冒泡是从target到根。\n\n* 先捕获，后冒泡。\n* 可以通过 `addEventListener` 的第三个参数来决定这个监听处于捕获还是处于冒泡。默认是冒泡阶段。\n* 对于 `target` 元素，没有捕获冒泡一说，先定义先执行。\n* 可以通过 `event.eventPhase` 来判断当前处于什么阶段。\n\n\n\n# 取消事件传递\n\n​\t\t通过这三个方式 `stopPropagation()` 、`prenventDefault()`、`return false;`、`stopImmediatePropagation()`。\n\n* `stopPropagation()` \n  * 会停止事件的传递。但是不会阻止事件的默认方法。\n\n* `stopImmediatIePropagation()` \n  * 同上，但是对于多个相同的事件都会被阻止。具体区别一会儿看案例.\n\n* `prenventDefault()` \n  * 取消掉元素的默认行为.\n\n* `return false;` \n  * 会取消默认行为,但是只能用于 DOM0级.\n  * 但是不会终止事件的传递.\n\n\n\n## stopPropagation 和 stopImmediatIePropagation 的使用\n\n```\nchildren1.addEventListener('click', function (e) {\n\tconsole.log('a 捕获');\n\te.stopPropagation();\n}, true);\t//为true,代表了捕获.\n  \nchildren1.addEventListener('click', function (e) {\n    console.log('a1 捕获');\n}, true);\t//为true,代表了捕获.\n\n这里对上面进行了 stopPropagation 所以会停止传递,但是\n\t对于上层元素,传递会直接停止,所以如果是在捕获层进行了使用,那么就会在调用了本层方法后,就会停止, 如果是在冒泡层进行使用,就会结束后续的冒泡行为.\n\t对于 target 的使用,因为 target 不分冒泡和捕获,所以两个都会执行.\n执行结果:\tfather 捕获, target 捕获, target 冒泡(阻止了事件的继续.虽然这个阻止放在了 捕获 位置, 但是对于 target 是不分 冒泡 和 捕获 的.所以 target 的冒泡也会执行.)\n\t其中对于 target 的捕获和冒泡的顺序,按照定义的顺序执行.\n\n对于 stopImmediatIePropagation 的使用,大体上和上面起始差不多,最大的区别就是,不但会停止传递,并且会停止本层的相同事件.\n比如代码类型:\n\n    children1.addEventListener('click', function (e) {\n        console.log('a 捕获');\n    \te.stopImmediatePropagation();\n    }, true);\n    children1.addEventListener('click', function (e) {\n        console.log('a1 捕获');\n    }, true);\n    children1.addEventListener('click', function (e) {\n        console.log('a 冒泡');\n    }, false);\n\t\n\t我这里定义了两个相同的捕获. 但是使用的是 e.stopImmediatePropagation(); 所以,对于相同的事件都会停止,然后因为这个 stopImmediatePropagation 放在了最上面定义的位置,所以放在下面的都不会执行. 如果我把这个函数的位置放在了第二个,那么第一个还是会执行\n执行结果:\n\tfather 捕获, target 捕获(阻止了事件的传递. 并且因为target的捕获和冒泡属于同一类型,所以都被阻止了.)\n```\n\n**简单总结:**\n\n* **stopPropagation**\n  * 对于非target, 会阻止后续的事件, 但是对于相同的事件不会阻止.\n  * 对于 target, 因为 target 是**不分冒泡和捕获**,所以只会阻止上级元素的事件,对于 target 的**冒泡** 和 **捕获** 都不会阻止.\n* **stopImmediatIePropagation**\n  * 这个不但会阻止后续的事件, 对于相同的事件也会阻止.\n* **相同点**是: 他们都**不会阻止元素的默认事件的执行,就算是捕获和冒泡没有到target.**\n\n\n\n## prenventDefault 使用\n\n**作用:**\n\n​\t取消元素的默认行为.如果放在了父元素,那么子元素的所有默认行为都会被取消.\n\n**使用方式:**\n\n```\n  children1.addEventListener('click', function (e) {\n    console.log('a 捕获');\n    e.preventDefault();\n  }, true);\n  \n这个很简单.\n```\n\n\n\n## return false; 的使用\n\n这个的使用方式不和上面的一样.\n\n```\n  children1.onclick = function (e) {\n    console.log('a2 冒泡');\n    return false;\n  }\n  \n不能在 addEventListener 的回调函数里面使用. 因为这个是通过return 的值为false,来进行的定义,如果要使用 addEventListener 的回调的话, 函数的返回值不能正确返回,但是要怎么实现我也不知道.\n```\n\n\n\n# 事件委托\n\n​\t\t理解很简单, 就是子元素的点击, 父级也可以进行捕获和冒泡, 很多人说事件委托是利用的冒泡原理, 但是通过前面的学习我们可以知道,事件委托,无非就是 子元素 的点击可以被父元素所监听到. 所以这里肯定会感觉不对, 然后我去网上看了一篇文章,  然后断章取义了一番.\n\n```\nhttps://blog.csdn.net/mmrsdym/article/details/39209375\n```\n\n​\t\t我了解到了,为什么事件委托要使用的是冒泡原理, 而不是使用的捕获的原因.\n\n​\t\t大概的意思就是, 一个元素是先进行的捕获行为, 然后再进行的冒泡行为. 所以如果我们将事件委托放在了, 捕获上面. 如果要阻止事件的行为, 那么就会让子元素的所有事件都不能执行, 而放在了事件的冒泡的话, 子元素的一些行为还是可以执行的.  所以这就是为什么事件委托需要放在冒泡的原因. ","slug":"JavaScript/概念/JavaScript-冒泡和捕获","published":1,"updated":"2021-12-09T01:56:49.404Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckznhkk8m006likub4nor5vxw","content":"<p> <strong>前言:</strong></p>\n<h4 id=\"JavaScript-DOM的监听方式\"><a href=\"#JavaScript-DOM的监听方式\" class=\"headerlink\" title=\"JavaScript-DOM的监听方式\"></a><strong>JavaScript-DOM的监听方式</strong></h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dom.addEventListener(&#x27;click&#x27;, function (e) &#123;</span><br><span class=\"line\">  console.log(&#x27;father1 捕获&#x27;);</span><br><span class=\"line\">&#125;, true);</span><br><span class=\"line\"></span><br><span class=\"line\">dom.onclick = function (e) &#123;</span><br><span class=\"line\">  console.log(&#x27;a2 冒泡&#x27;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在这里,又被称为 <strong>DOM0级</strong> 和 <strong>DOM2级</strong></p>\n<p><strong>0级DOM</strong>:</p>\n<ul>\n<li>标签内部的 onclick 事件</li>\n<li>JavaScript 的 onclick = function() {} 函数</li>\n</ul>\n<p><strong>2级DOM:</strong></p>\n<ul>\n<li>就是标准的事件模型</li>\n<li><strong>addEventListener</strong> 和 <strong>removeEventListener</strong></li>\n</ul>\n<h1 id=\"JavaScript-冒泡和捕获\"><a href=\"#JavaScript-冒泡和捕获\" class=\"headerlink\" title=\"JavaScript-冒泡和捕获\"></a>JavaScript-冒泡和捕获</h1><p>参考文章，感觉写的很详细</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://blog.csdn.net/sinat_33523805/article/details/94018242</span><br></pre></td></tr></table></figure>\n\n<p>​        在一个 <code>Event</code> 的事件中，存在三个阶段：<code>捕获，目标和冒泡</code></p>\n<p><strong>三个阶段的顺序：</strong></p>\n<ul>\n<li><p>首先是从根节点出发，到达目标节点，若此过程中触发了事件，则被称为<strong>捕获阶段</strong></p>\n</li>\n<li><p>然后当节点到达定义点击事件的目标节点时，处于<strong>目标阶段</strong></p>\n</li>\n<li><p>在目标节点触发事件后，最后就会一路往上回到根节点，处于 <strong>冒泡阶段</strong></p>\n<p>​    给一张对应的图片。</p>\n</li>\n</ul>\n<img src=\"/.io//image-20210907141230550.png\" alt=\"image-20210907141230550\" style=\"zoom:67%;\">\n\n<p>​        如何在创建一个点击监听的时候，同时定义是处于冒泡还是捕获阶段。</p>\n<p>​        通过一个 <code>addEventListener</code> 函数的参数，分别为 <strong>事件名， 回调函数， 在什么阶段执行</strong>。第三个参数就是判断是处于什么阶段的。<strong>true代表捕获阶段，false代表了冒泡阶段</strong>。</p>\n<p>​        对于target，顺序不是按照捕获和冒泡的顺序，而是按照监听函数的创建顺序。</p>\n<p>​        可以通过 <code>event.eventPhase</code> 的值来判断是处于哪个阶段。</p>\n<p>​            <code>1，捕获阶段。2，目标阶段。3，冒泡阶段</code></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">father.addEventListener(&#x27;click&#x27;, function (e) &#123;</span><br><span class=\"line\">  console.log(&#x27;father 捕获&#x27;);</span><br><span class=\"line\">  console.log(e.eventPhase);\t// 1</span><br><span class=\"line\">&#125;, true);</span><br><span class=\"line\">father.addEventListener(&#x27;click&#x27;, function (e) &#123;</span><br><span class=\"line\">  console.log(&#x27;father 冒泡&#x27;);</span><br><span class=\"line\">&#125;, false);</span><br><span class=\"line\"></span><br><span class=\"line\">children.addEventListener(&#x27;click&#x27;, function (e) &#123;</span><br><span class=\"line\">  console.log(&#x27;children 冒泡&#x27;);</span><br><span class=\"line\">&#125;, false);</span><br><span class=\"line\">children.addEventListener(&#x27;click&#x27;, function (e) &#123;</span><br><span class=\"line\">  console.log(&#x27;children 捕获&#x27;);</span><br><span class=\"line\">&#125;, true);</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">father 捕获</span><br><span class=\"line\">children 冒泡</span><br><span class=\"line\">children 捕获</span><br><span class=\"line\">father 冒泡</span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>结论：</strong></p>\n<ul>\n<li><p>捕获是从根到target， 冒泡是从target到根。</p>\n</li>\n<li><p>先捕获，后冒泡。</p>\n</li>\n<li><p>可以通过 <code>addEventListener</code> 的第三个参数来决定这个监听处于捕获还是处于冒泡。默认是冒泡阶段。</p>\n</li>\n<li><p>对于 <code>target</code> 元素，没有捕获冒泡一说，先定义先执行。</p>\n</li>\n<li><p>可以通过 <code>event.eventPhase</code> 来判断当前处于什么阶段。</p>\n</li>\n</ul>\n<h1 id=\"取消事件传递\"><a href=\"#取消事件传递\" class=\"headerlink\" title=\"取消事件传递\"></a>取消事件传递</h1><p>​        通过这三个方式 <code>stopPropagation()</code> 、<code>prenventDefault()</code>、<code>return false;</code>、<code>stopImmediatePropagation()</code>。</p>\n<ul>\n<li><p><code>stopPropagation()</code> </p>\n<ul>\n<li>会停止事件的传递。但是不会阻止事件的默认方法。</li>\n</ul>\n</li>\n<li><p><code>stopImmediatIePropagation()</code> </p>\n<ul>\n<li>同上，但是对于多个相同的事件都会被阻止。具体区别一会儿看案例.</li>\n</ul>\n</li>\n<li><p><code>prenventDefault()</code> </p>\n<ul>\n<li>取消掉元素的默认行为.</li>\n</ul>\n</li>\n<li><p><code>return false;</code> </p>\n<ul>\n<li>会取消默认行为,但是只能用于 DOM0级.</li>\n<li>但是不会终止事件的传递.</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"stopPropagation-和-stopImmediatIePropagation-的使用\"><a href=\"#stopPropagation-和-stopImmediatIePropagation-的使用\" class=\"headerlink\" title=\"stopPropagation 和 stopImmediatIePropagation 的使用\"></a>stopPropagation 和 stopImmediatIePropagation 的使用</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">children1.addEventListener(&#x27;click&#x27;, function (e) &#123;</span><br><span class=\"line\">\tconsole.log(&#x27;a 捕获&#x27;);</span><br><span class=\"line\">\te.stopPropagation();</span><br><span class=\"line\">&#125;, true);\t//为true,代表了捕获.</span><br><span class=\"line\">  </span><br><span class=\"line\">children1.addEventListener(&#x27;click&#x27;, function (e) &#123;</span><br><span class=\"line\">    console.log(&#x27;a1 捕获&#x27;);</span><br><span class=\"line\">&#125;, true);\t//为true,代表了捕获.</span><br><span class=\"line\"></span><br><span class=\"line\">这里对上面进行了 stopPropagation 所以会停止传递,但是</span><br><span class=\"line\">\t对于上层元素,传递会直接停止,所以如果是在捕获层进行了使用,那么就会在调用了本层方法后,就会停止, 如果是在冒泡层进行使用,就会结束后续的冒泡行为.</span><br><span class=\"line\">\t对于 target 的使用,因为 target 不分冒泡和捕获,所以两个都会执行.</span><br><span class=\"line\">执行结果:\tfather 捕获, target 捕获, target 冒泡(阻止了事件的继续.虽然这个阻止放在了 捕获 位置, 但是对于 target 是不分 冒泡 和 捕获 的.所以 target 的冒泡也会执行.)</span><br><span class=\"line\">\t其中对于 target 的捕获和冒泡的顺序,按照定义的顺序执行.</span><br><span class=\"line\"></span><br><span class=\"line\">对于 stopImmediatIePropagation 的使用,大体上和上面起始差不多,最大的区别就是,不但会停止传递,并且会停止本层的相同事件.</span><br><span class=\"line\">比如代码类型:</span><br><span class=\"line\"></span><br><span class=\"line\">    children1.addEventListener(&#x27;click&#x27;, function (e) &#123;</span><br><span class=\"line\">        console.log(&#x27;a 捕获&#x27;);</span><br><span class=\"line\">    \te.stopImmediatePropagation();</span><br><span class=\"line\">    &#125;, true);</span><br><span class=\"line\">    children1.addEventListener(&#x27;click&#x27;, function (e) &#123;</span><br><span class=\"line\">        console.log(&#x27;a1 捕获&#x27;);</span><br><span class=\"line\">    &#125;, true);</span><br><span class=\"line\">    children1.addEventListener(&#x27;click&#x27;, function (e) &#123;</span><br><span class=\"line\">        console.log(&#x27;a 冒泡&#x27;);</span><br><span class=\"line\">    &#125;, false);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t我这里定义了两个相同的捕获. 但是使用的是 e.stopImmediatePropagation(); 所以,对于相同的事件都会停止,然后因为这个 stopImmediatePropagation 放在了最上面定义的位置,所以放在下面的都不会执行. 如果我把这个函数的位置放在了第二个,那么第一个还是会执行</span><br><span class=\"line\">执行结果:</span><br><span class=\"line\">\tfather 捕获, target 捕获(阻止了事件的传递. 并且因为target的捕获和冒泡属于同一类型,所以都被阻止了.)</span><br></pre></td></tr></table></figure>\n\n<p><strong>简单总结:</strong></p>\n<ul>\n<li><strong>stopPropagation</strong><ul>\n<li>对于非target, 会阻止后续的事件, 但是对于相同的事件不会阻止.</li>\n<li>对于 target, 因为 target 是<strong>不分冒泡和捕获</strong>,所以只会阻止上级元素的事件,对于 target 的<strong>冒泡</strong> 和 <strong>捕获</strong> 都不会阻止.</li>\n</ul>\n</li>\n<li><strong>stopImmediatIePropagation</strong><ul>\n<li>这个不但会阻止后续的事件, 对于相同的事件也会阻止.</li>\n</ul>\n</li>\n<li><strong>相同点</strong>是: 他们都<strong>不会阻止元素的默认事件的执行,就算是捕获和冒泡没有到target.</strong></li>\n</ul>\n<h2 id=\"prenventDefault-使用\"><a href=\"#prenventDefault-使用\" class=\"headerlink\" title=\"prenventDefault 使用\"></a>prenventDefault 使用</h2><p><strong>作用:</strong></p>\n<p>​    取消元素的默认行为.如果放在了父元素,那么子元素的所有默认行为都会被取消.</p>\n<p><strong>使用方式:</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  children1.addEventListener(&#x27;click&#x27;, function (e) &#123;</span><br><span class=\"line\">    console.log(&#x27;a 捕获&#x27;);</span><br><span class=\"line\">    e.preventDefault();</span><br><span class=\"line\">  &#125;, true);</span><br><span class=\"line\">  </span><br><span class=\"line\">这个很简单.</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"return-false-的使用\"><a href=\"#return-false-的使用\" class=\"headerlink\" title=\"return false; 的使用\"></a>return false; 的使用</h2><p>这个的使用方式不和上面的一样.</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  children1.onclick = function (e) &#123;</span><br><span class=\"line\">    console.log(&#x27;a2 冒泡&#x27;);</span><br><span class=\"line\">    return false;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">不能在 addEventListener 的回调函数里面使用. 因为这个是通过return 的值为false,来进行的定义,如果要使用 addEventListener 的回调的话, 函数的返回值不能正确返回,但是要怎么实现我也不知道.</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"事件委托\"><a href=\"#事件委托\" class=\"headerlink\" title=\"事件委托\"></a>事件委托</h1><p>​        理解很简单, 就是子元素的点击, 父级也可以进行捕获和冒泡, 很多人说事件委托是利用的冒泡原理, 但是通过前面的学习我们可以知道,事件委托,无非就是 子元素 的点击可以被父元素所监听到. 所以这里肯定会感觉不对, 然后我去网上看了一篇文章,  然后断章取义了一番.</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://blog.csdn.net/mmrsdym/article/details/39209375</span><br></pre></td></tr></table></figure>\n\n<p>​        我了解到了,为什么事件委托要使用的是冒泡原理, 而不是使用的捕获的原因.</p>\n<p>​        大概的意思就是, 一个元素是先进行的捕获行为, 然后再进行的冒泡行为. 所以如果我们将事件委托放在了, 捕获上面. 如果要阻止事件的行为, 那么就会让子元素的所有事件都不能执行, 而放在了事件的冒泡的话, 子元素的一些行为还是可以执行的.  所以这就是为什么事件委托需要放在冒泡的原因. </p>\n","site":{"data":{}},"excerpt":"","more":"<p> <strong>前言:</strong></p>\n<h4 id=\"JavaScript-DOM的监听方式\"><a href=\"#JavaScript-DOM的监听方式\" class=\"headerlink\" title=\"JavaScript-DOM的监听方式\"></a><strong>JavaScript-DOM的监听方式</strong></h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dom.addEventListener(&#x27;click&#x27;, function (e) &#123;</span><br><span class=\"line\">  console.log(&#x27;father1 捕获&#x27;);</span><br><span class=\"line\">&#125;, true);</span><br><span class=\"line\"></span><br><span class=\"line\">dom.onclick = function (e) &#123;</span><br><span class=\"line\">  console.log(&#x27;a2 冒泡&#x27;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在这里,又被称为 <strong>DOM0级</strong> 和 <strong>DOM2级</strong></p>\n<p><strong>0级DOM</strong>:</p>\n<ul>\n<li>标签内部的 onclick 事件</li>\n<li>JavaScript 的 onclick = function() {} 函数</li>\n</ul>\n<p><strong>2级DOM:</strong></p>\n<ul>\n<li>就是标准的事件模型</li>\n<li><strong>addEventListener</strong> 和 <strong>removeEventListener</strong></li>\n</ul>\n<h1 id=\"JavaScript-冒泡和捕获\"><a href=\"#JavaScript-冒泡和捕获\" class=\"headerlink\" title=\"JavaScript-冒泡和捕获\"></a>JavaScript-冒泡和捕获</h1><p>参考文章，感觉写的很详细</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://blog.csdn.net/sinat_33523805/article/details/94018242</span><br></pre></td></tr></table></figure>\n\n<p>​        在一个 <code>Event</code> 的事件中，存在三个阶段：<code>捕获，目标和冒泡</code></p>\n<p><strong>三个阶段的顺序：</strong></p>\n<ul>\n<li><p>首先是从根节点出发，到达目标节点，若此过程中触发了事件，则被称为<strong>捕获阶段</strong></p>\n</li>\n<li><p>然后当节点到达定义点击事件的目标节点时，处于<strong>目标阶段</strong></p>\n</li>\n<li><p>在目标节点触发事件后，最后就会一路往上回到根节点，处于 <strong>冒泡阶段</strong></p>\n<p>​    给一张对应的图片。</p>\n</li>\n</ul>\n<img src=\"/.io//image-20210907141230550.png\" alt=\"image-20210907141230550\" style=\"zoom:67%;\">\n\n<p>​        如何在创建一个点击监听的时候，同时定义是处于冒泡还是捕获阶段。</p>\n<p>​        通过一个 <code>addEventListener</code> 函数的参数，分别为 <strong>事件名， 回调函数， 在什么阶段执行</strong>。第三个参数就是判断是处于什么阶段的。<strong>true代表捕获阶段，false代表了冒泡阶段</strong>。</p>\n<p>​        对于target，顺序不是按照捕获和冒泡的顺序，而是按照监听函数的创建顺序。</p>\n<p>​        可以通过 <code>event.eventPhase</code> 的值来判断是处于哪个阶段。</p>\n<p>​            <code>1，捕获阶段。2，目标阶段。3，冒泡阶段</code></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">father.addEventListener(&#x27;click&#x27;, function (e) &#123;</span><br><span class=\"line\">  console.log(&#x27;father 捕获&#x27;);</span><br><span class=\"line\">  console.log(e.eventPhase);\t// 1</span><br><span class=\"line\">&#125;, true);</span><br><span class=\"line\">father.addEventListener(&#x27;click&#x27;, function (e) &#123;</span><br><span class=\"line\">  console.log(&#x27;father 冒泡&#x27;);</span><br><span class=\"line\">&#125;, false);</span><br><span class=\"line\"></span><br><span class=\"line\">children.addEventListener(&#x27;click&#x27;, function (e) &#123;</span><br><span class=\"line\">  console.log(&#x27;children 冒泡&#x27;);</span><br><span class=\"line\">&#125;, false);</span><br><span class=\"line\">children.addEventListener(&#x27;click&#x27;, function (e) &#123;</span><br><span class=\"line\">  console.log(&#x27;children 捕获&#x27;);</span><br><span class=\"line\">&#125;, true);</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">father 捕获</span><br><span class=\"line\">children 冒泡</span><br><span class=\"line\">children 捕获</span><br><span class=\"line\">father 冒泡</span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>结论：</strong></p>\n<ul>\n<li><p>捕获是从根到target， 冒泡是从target到根。</p>\n</li>\n<li><p>先捕获，后冒泡。</p>\n</li>\n<li><p>可以通过 <code>addEventListener</code> 的第三个参数来决定这个监听处于捕获还是处于冒泡。默认是冒泡阶段。</p>\n</li>\n<li><p>对于 <code>target</code> 元素，没有捕获冒泡一说，先定义先执行。</p>\n</li>\n<li><p>可以通过 <code>event.eventPhase</code> 来判断当前处于什么阶段。</p>\n</li>\n</ul>\n<h1 id=\"取消事件传递\"><a href=\"#取消事件传递\" class=\"headerlink\" title=\"取消事件传递\"></a>取消事件传递</h1><p>​        通过这三个方式 <code>stopPropagation()</code> 、<code>prenventDefault()</code>、<code>return false;</code>、<code>stopImmediatePropagation()</code>。</p>\n<ul>\n<li><p><code>stopPropagation()</code> </p>\n<ul>\n<li>会停止事件的传递。但是不会阻止事件的默认方法。</li>\n</ul>\n</li>\n<li><p><code>stopImmediatIePropagation()</code> </p>\n<ul>\n<li>同上，但是对于多个相同的事件都会被阻止。具体区别一会儿看案例.</li>\n</ul>\n</li>\n<li><p><code>prenventDefault()</code> </p>\n<ul>\n<li>取消掉元素的默认行为.</li>\n</ul>\n</li>\n<li><p><code>return false;</code> </p>\n<ul>\n<li>会取消默认行为,但是只能用于 DOM0级.</li>\n<li>但是不会终止事件的传递.</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"stopPropagation-和-stopImmediatIePropagation-的使用\"><a href=\"#stopPropagation-和-stopImmediatIePropagation-的使用\" class=\"headerlink\" title=\"stopPropagation 和 stopImmediatIePropagation 的使用\"></a>stopPropagation 和 stopImmediatIePropagation 的使用</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">children1.addEventListener(&#x27;click&#x27;, function (e) &#123;</span><br><span class=\"line\">\tconsole.log(&#x27;a 捕获&#x27;);</span><br><span class=\"line\">\te.stopPropagation();</span><br><span class=\"line\">&#125;, true);\t//为true,代表了捕获.</span><br><span class=\"line\">  </span><br><span class=\"line\">children1.addEventListener(&#x27;click&#x27;, function (e) &#123;</span><br><span class=\"line\">    console.log(&#x27;a1 捕获&#x27;);</span><br><span class=\"line\">&#125;, true);\t//为true,代表了捕获.</span><br><span class=\"line\"></span><br><span class=\"line\">这里对上面进行了 stopPropagation 所以会停止传递,但是</span><br><span class=\"line\">\t对于上层元素,传递会直接停止,所以如果是在捕获层进行了使用,那么就会在调用了本层方法后,就会停止, 如果是在冒泡层进行使用,就会结束后续的冒泡行为.</span><br><span class=\"line\">\t对于 target 的使用,因为 target 不分冒泡和捕获,所以两个都会执行.</span><br><span class=\"line\">执行结果:\tfather 捕获, target 捕获, target 冒泡(阻止了事件的继续.虽然这个阻止放在了 捕获 位置, 但是对于 target 是不分 冒泡 和 捕获 的.所以 target 的冒泡也会执行.)</span><br><span class=\"line\">\t其中对于 target 的捕获和冒泡的顺序,按照定义的顺序执行.</span><br><span class=\"line\"></span><br><span class=\"line\">对于 stopImmediatIePropagation 的使用,大体上和上面起始差不多,最大的区别就是,不但会停止传递,并且会停止本层的相同事件.</span><br><span class=\"line\">比如代码类型:</span><br><span class=\"line\"></span><br><span class=\"line\">    children1.addEventListener(&#x27;click&#x27;, function (e) &#123;</span><br><span class=\"line\">        console.log(&#x27;a 捕获&#x27;);</span><br><span class=\"line\">    \te.stopImmediatePropagation();</span><br><span class=\"line\">    &#125;, true);</span><br><span class=\"line\">    children1.addEventListener(&#x27;click&#x27;, function (e) &#123;</span><br><span class=\"line\">        console.log(&#x27;a1 捕获&#x27;);</span><br><span class=\"line\">    &#125;, true);</span><br><span class=\"line\">    children1.addEventListener(&#x27;click&#x27;, function (e) &#123;</span><br><span class=\"line\">        console.log(&#x27;a 冒泡&#x27;);</span><br><span class=\"line\">    &#125;, false);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t我这里定义了两个相同的捕获. 但是使用的是 e.stopImmediatePropagation(); 所以,对于相同的事件都会停止,然后因为这个 stopImmediatePropagation 放在了最上面定义的位置,所以放在下面的都不会执行. 如果我把这个函数的位置放在了第二个,那么第一个还是会执行</span><br><span class=\"line\">执行结果:</span><br><span class=\"line\">\tfather 捕获, target 捕获(阻止了事件的传递. 并且因为target的捕获和冒泡属于同一类型,所以都被阻止了.)</span><br></pre></td></tr></table></figure>\n\n<p><strong>简单总结:</strong></p>\n<ul>\n<li><strong>stopPropagation</strong><ul>\n<li>对于非target, 会阻止后续的事件, 但是对于相同的事件不会阻止.</li>\n<li>对于 target, 因为 target 是<strong>不分冒泡和捕获</strong>,所以只会阻止上级元素的事件,对于 target 的<strong>冒泡</strong> 和 <strong>捕获</strong> 都不会阻止.</li>\n</ul>\n</li>\n<li><strong>stopImmediatIePropagation</strong><ul>\n<li>这个不但会阻止后续的事件, 对于相同的事件也会阻止.</li>\n</ul>\n</li>\n<li><strong>相同点</strong>是: 他们都<strong>不会阻止元素的默认事件的执行,就算是捕获和冒泡没有到target.</strong></li>\n</ul>\n<h2 id=\"prenventDefault-使用\"><a href=\"#prenventDefault-使用\" class=\"headerlink\" title=\"prenventDefault 使用\"></a>prenventDefault 使用</h2><p><strong>作用:</strong></p>\n<p>​    取消元素的默认行为.如果放在了父元素,那么子元素的所有默认行为都会被取消.</p>\n<p><strong>使用方式:</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  children1.addEventListener(&#x27;click&#x27;, function (e) &#123;</span><br><span class=\"line\">    console.log(&#x27;a 捕获&#x27;);</span><br><span class=\"line\">    e.preventDefault();</span><br><span class=\"line\">  &#125;, true);</span><br><span class=\"line\">  </span><br><span class=\"line\">这个很简单.</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"return-false-的使用\"><a href=\"#return-false-的使用\" class=\"headerlink\" title=\"return false; 的使用\"></a>return false; 的使用</h2><p>这个的使用方式不和上面的一样.</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  children1.onclick = function (e) &#123;</span><br><span class=\"line\">    console.log(&#x27;a2 冒泡&#x27;);</span><br><span class=\"line\">    return false;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">不能在 addEventListener 的回调函数里面使用. 因为这个是通过return 的值为false,来进行的定义,如果要使用 addEventListener 的回调的话, 函数的返回值不能正确返回,但是要怎么实现我也不知道.</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"事件委托\"><a href=\"#事件委托\" class=\"headerlink\" title=\"事件委托\"></a>事件委托</h1><p>​        理解很简单, 就是子元素的点击, 父级也可以进行捕获和冒泡, 很多人说事件委托是利用的冒泡原理, 但是通过前面的学习我们可以知道,事件委托,无非就是 子元素 的点击可以被父元素所监听到. 所以这里肯定会感觉不对, 然后我去网上看了一篇文章,  然后断章取义了一番.</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://blog.csdn.net/mmrsdym/article/details/39209375</span><br></pre></td></tr></table></figure>\n\n<p>​        我了解到了,为什么事件委托要使用的是冒泡原理, 而不是使用的捕获的原因.</p>\n<p>​        大概的意思就是, 一个元素是先进行的捕获行为, 然后再进行的冒泡行为. 所以如果我们将事件委托放在了, 捕获上面. 如果要阻止事件的行为, 那么就会让子元素的所有事件都不能执行, 而放在了事件的冒泡的话, 子元素的一些行为还是可以执行的.  所以这就是为什么事件委托需要放在冒泡的原因. </p>\n"},{"title":"JavaScript-ES6解构","date":"2021-11-11T14:14:32.000Z","_content":"\n\n\n#  JavaScript 解构赋值\n\n```\nhttps://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment\n```\n\n\n\n​\t\t**解构赋值**语法是一种 Javascript 表达式。通过**解构赋值,** 可以将属性/值从对象/数组中取出,赋值给其他变量。\n\n​\t\t简单来说，就是对于一个赋值变得简单起来。\n\n\n\n## 语法\n\n### [a, b] = arr;\n\n* 多余的不会被赋值\n* 少的会变成undefined\n* 注意要避免arr为null和undefined，对象同样，需要是数组和对象才行。\n\n```\nlet arr = [1, 3, 5];\n\nlet [a, b] = arr;\nconsole.log(a, b);\n\n1, 3\n```\n\n\n\n### [a, b, ...rest] = arr;\n\n* 这里，对于多余的都会变成第三个的数组\n* 少于的，前面两个是undefined， 第三个数组会是一个空数组。\n* 剩余元素必须在最后一个。\n\n```\nlet arr = [1, 3, 4, 2, ];\n\nlet [a, b, ...res] = arr;\nconsole.log(a, b, res);\n\n1 3 [ 4, 2 ]\n```\n\n\n\n### ({ a, b } = obj);\n\n* 这个是以名称为主，需要找到obj内部的a，如果没有，那么就会变成undefined，其次，这里的值是可以是原型上的。 obj.\\_\\_proto\\_\\_ 只要原型链上存在也会赋值。\n* 其次，这里需要添加括号，或者是定义时进行解构赋值，这里的作用可能是避免大括号的影响了编译的判断。\n* **注意**：赋值语句周围的圆括号 `( ... )` 在使用对象字面量无声明解构赋值时是必须的。 `{a, b} = {a: 1, b: 2}` 不是有效的独立语法，因为左边的 `{a, b}` 被认为是一个块而不是对象字面量。\n\n* 然而，`({a, b} = {a: 1, b: 2})` 是有效的，正如 `var {a, b} = {a: 1, b: 2}`你的 `( ... )` 表达式之前需要有一个分号，否则它可能会被当成上一行中的函数执行。\n\n```\nlet obj = {\n  a: 10,\n  b: 20,\n  c: 30\n};\nlet a,c;\n({a, c} = obj);\nconsole.log(a, c);\n\n10, 30\n```\n\n​\t\tor\n\n```\nlet obj = {\n  a: 10,\n  b: 20,\n  c: 30\n};\nlet {a, b} = obj;\nconsole.log(a, b);\n\n10, 20\n```\n\n\n\n### ({a, b, ...rest} = obj);\n\n* 这里是将前面没有进行赋值的对象全部加入了最后一个对象。\n* 其次，最后一个是不会进入原型链进行查找赋值的。\n* 如果没有了，那么便会变成空对象。\n\n```\nlet obj = {\n  a: 10,\n  b: 20,\n  c: 30\n};\nobj.__proto__ = {\n  x: 1111,\n}\nlet {a, ...res} = obj;\nconsole.log(a, res);\n```\n\n\n\n### [a=4] / {a = 10} 解构默认值\n\n* 简单来说就是设置一个默认值，不会变成undefined\n* 对于对象也有效果 \n* 默认值可以是对象。\n\n```\nvar a, b;\n\n[a=5, b=7] = [1];    //[a=5, b=7] = [1, undefined]; ,就算是这样也是 1， 7\nconsole.log(a); // 1\nconsole.log(b); // 7\n```\n\n```\n({a=5, b=7} = {\n  a: 3,\n});\nconsole.log(a); // 1\nconsole.log(b); // 7\n\n({a=5, b= { x: 1 }} = { a: 3 }); 并且还能使用赋值默认对象效果。\n```\n\n\n\n### [a, b] = [b, a]; 交换变量\n\n* 交换的变量可以是对象，也可以是值类型。\n* ({a, b} = {b, a});  这个没有交换变量的效果。\n\n```\nlet a= {a: 4},\n    b= {x:3};\n[a, b] = [b, a];\nconsole.log(a, b);\n```\n\n\n\n### 忽略值 [a, , b] = arr;\n\n* 可以对不要的值不使用变量进行存储，使用 `, ,` 这样就能达到忽略的效果\n* 对象不能使用忽略值的效果，会报错，\n* `[, ,] = arr` ， 这样可以忽略全部返回值\n\n```\nfunction f() {\n  return [1, 2, 3];\n}\n\nvar [a, , b] = f();\nconsole.log(a); // 1\nconsole.log(b); // 3\n```\n\n\n\n### 命名赋值 {p: foo} = obj; 别名\n\n* 只能用于对象\n* 可以将其重新命名。\n* 可以将命名赋值和默认值一同使用 {p:foo = 10}\n\n```\nvar o = {p: 42, q: true};\nvar {p: foo, q: bar} = o;\n\nconsole.log(foo); // 42\nconsole.log(bar); // true \n```\n\n\n\n### 方法参数的赋值 \n\n* 首先，function fn(op = {}) {}\n\n```\nfunction drawES2015Chart({size = 'big', cords = { x: 0, y: 0 }, radius = 25} = {}) {}\n上面这个写法很高级，但是有点难以理解。\n\nfunction fn(o = {x: 'x', c: 1}) {}\n这个写法，虽然可以理解了，但是如果传参时添加了一个参数便会全部覆盖，达不到想要的效果。\n\nfunction fn(o = {}) {}\n此时如果没有传入参数则会变成一个空对象，然后我们再将这个o换成一个对象\n\nfunction fn({x = 3} = {}) {}\n此时，如果不传入参数，那么先是一个空对象，然后再将空对象赋值给了前面的，然后就会生成一个 x=3 的数了。\n如果传入的对象里面没有x，同样也是生成x=3的数。\n所以此时再去看最开始那个就应该能够看懂了\n\nfunction fn({x = 3}) {}\n这里的区别，在于如果没有传入任何值，那么将会报错，而上面使用了空对象，可以不传递参数。\n```\n\n> 在上面的 **`drawES2015Chart`** 的函数签名中，解构的左手边被分配给右手边的空对象字面值：`{size = 'big', cords = {x: 0, y: 0}, radius = 25} = {}`。你也可以在没有右侧分配的情况下编写函数。但是，如果你忽略了右边的赋值，那么函数会在被调用的时候查找至少一个被提供的参数，而在当前的形式下，你可以直接调用 `**drawES2015Chart()**` 而不提供任何参数。如果你希望能够在不提供任何参数的情况下调用该函数，则当前的设计非常有用，而另一种方法在您确保将对象传递给函数时非常有用。\n\n\n\n### 解构一个嵌套对象和数组\n\n* 没啥讲的，但是却有点东西，对象别名使用了 []， 进行了数组赋值，然后再在里面进行了对象赋值，{}\n\n```\nconst metadata = {\n  title: 'Scratchpad',\n  translations: [\n    {\n      locale: 'de',\n      localization_tags: [],\n      last_edit: '2014-04-14T08:43:37',\n      url: '/de/docs/Tools/Scratchpad',\n      title: 'JavaScript-Umgebung'\n    }\n  ],\n  url: '/en-US/docs/Tools/Scratchpad'\n};\n\nlet {\n  title: englishTitle, // rename\n  translations: [\n    {\n       title: localeTitle, // rename\n    },\n  ],\n} = metadata;\n\nconsole.log(englishTitle); // \"Scratchpad\"\nconsole.log(localeTitle);  // \"JavaScript-Umgebung\"\n```\n\n\n\n### for of 迭代和解构\n\n```\nvar people = [\n  {\n    name: 'Mike Smith',\n    family: {\n      mother: 'Jane Smith',\n      father: 'Harry Smith',\n      sister: 'Samantha Smith'\n    },\n    age: 35\n  },\n  {\n    name: 'Tom Jones',\n    family: {\n      mother: 'Norah Jones',\n      father: 'Richard Jones',\n      brother: 'Howard Jones'\n    },\n    age: 25\n  }\n];\n\nfor (var {name: n, family: {father: f}} of people) {\n  console.log('Name: ' + n + ', Father: ' + f);\n}\n```\n\n\n\n### 计算属性名，可以被解构\n\n* 简单来说，就是key变成了一个变量，然后使用[]， 来将一个常量换成了一个变量\n\n```\nlet key = \"z\";\nlet { [key]: foo } = { z: \"bar\" };\n\nconsole.log(foo); // \"bar\"\n```\n\n\n\n### 无效的标识符作为一个属性名\n\n在这里，fizz-buzz 是一个无效的变量名，我们使用字符串形式，然后加上别名进行操作。\n\n```\nconst foo = { 'fizz-buzz': true };\nconst { 'fizz-buzz': fizzBuzz } = foo;\n\nconsole.log(fizzBuzz); // \"true\"\n```\n\n","source":"_posts/JavaScript/ES6/JavaScript-ES6解构.md","raw":"---\ntitle: JavaScript-ES6解构\ndate: 2021-11-11 22:14:32\ntags:\n - JavaScript\n - ES6\n - 解构赋值\ncategories:\n - JavaScript\n - ES6\n---\n\n\n\n#  JavaScript 解构赋值\n\n```\nhttps://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment\n```\n\n\n\n​\t\t**解构赋值**语法是一种 Javascript 表达式。通过**解构赋值,** 可以将属性/值从对象/数组中取出,赋值给其他变量。\n\n​\t\t简单来说，就是对于一个赋值变得简单起来。\n\n\n\n## 语法\n\n### [a, b] = arr;\n\n* 多余的不会被赋值\n* 少的会变成undefined\n* 注意要避免arr为null和undefined，对象同样，需要是数组和对象才行。\n\n```\nlet arr = [1, 3, 5];\n\nlet [a, b] = arr;\nconsole.log(a, b);\n\n1, 3\n```\n\n\n\n### [a, b, ...rest] = arr;\n\n* 这里，对于多余的都会变成第三个的数组\n* 少于的，前面两个是undefined， 第三个数组会是一个空数组。\n* 剩余元素必须在最后一个。\n\n```\nlet arr = [1, 3, 4, 2, ];\n\nlet [a, b, ...res] = arr;\nconsole.log(a, b, res);\n\n1 3 [ 4, 2 ]\n```\n\n\n\n### ({ a, b } = obj);\n\n* 这个是以名称为主，需要找到obj内部的a，如果没有，那么就会变成undefined，其次，这里的值是可以是原型上的。 obj.\\_\\_proto\\_\\_ 只要原型链上存在也会赋值。\n* 其次，这里需要添加括号，或者是定义时进行解构赋值，这里的作用可能是避免大括号的影响了编译的判断。\n* **注意**：赋值语句周围的圆括号 `( ... )` 在使用对象字面量无声明解构赋值时是必须的。 `{a, b} = {a: 1, b: 2}` 不是有效的独立语法，因为左边的 `{a, b}` 被认为是一个块而不是对象字面量。\n\n* 然而，`({a, b} = {a: 1, b: 2})` 是有效的，正如 `var {a, b} = {a: 1, b: 2}`你的 `( ... )` 表达式之前需要有一个分号，否则它可能会被当成上一行中的函数执行。\n\n```\nlet obj = {\n  a: 10,\n  b: 20,\n  c: 30\n};\nlet a,c;\n({a, c} = obj);\nconsole.log(a, c);\n\n10, 30\n```\n\n​\t\tor\n\n```\nlet obj = {\n  a: 10,\n  b: 20,\n  c: 30\n};\nlet {a, b} = obj;\nconsole.log(a, b);\n\n10, 20\n```\n\n\n\n### ({a, b, ...rest} = obj);\n\n* 这里是将前面没有进行赋值的对象全部加入了最后一个对象。\n* 其次，最后一个是不会进入原型链进行查找赋值的。\n* 如果没有了，那么便会变成空对象。\n\n```\nlet obj = {\n  a: 10,\n  b: 20,\n  c: 30\n};\nobj.__proto__ = {\n  x: 1111,\n}\nlet {a, ...res} = obj;\nconsole.log(a, res);\n```\n\n\n\n### [a=4] / {a = 10} 解构默认值\n\n* 简单来说就是设置一个默认值，不会变成undefined\n* 对于对象也有效果 \n* 默认值可以是对象。\n\n```\nvar a, b;\n\n[a=5, b=7] = [1];    //[a=5, b=7] = [1, undefined]; ,就算是这样也是 1， 7\nconsole.log(a); // 1\nconsole.log(b); // 7\n```\n\n```\n({a=5, b=7} = {\n  a: 3,\n});\nconsole.log(a); // 1\nconsole.log(b); // 7\n\n({a=5, b= { x: 1 }} = { a: 3 }); 并且还能使用赋值默认对象效果。\n```\n\n\n\n### [a, b] = [b, a]; 交换变量\n\n* 交换的变量可以是对象，也可以是值类型。\n* ({a, b} = {b, a});  这个没有交换变量的效果。\n\n```\nlet a= {a: 4},\n    b= {x:3};\n[a, b] = [b, a];\nconsole.log(a, b);\n```\n\n\n\n### 忽略值 [a, , b] = arr;\n\n* 可以对不要的值不使用变量进行存储，使用 `, ,` 这样就能达到忽略的效果\n* 对象不能使用忽略值的效果，会报错，\n* `[, ,] = arr` ， 这样可以忽略全部返回值\n\n```\nfunction f() {\n  return [1, 2, 3];\n}\n\nvar [a, , b] = f();\nconsole.log(a); // 1\nconsole.log(b); // 3\n```\n\n\n\n### 命名赋值 {p: foo} = obj; 别名\n\n* 只能用于对象\n* 可以将其重新命名。\n* 可以将命名赋值和默认值一同使用 {p:foo = 10}\n\n```\nvar o = {p: 42, q: true};\nvar {p: foo, q: bar} = o;\n\nconsole.log(foo); // 42\nconsole.log(bar); // true \n```\n\n\n\n### 方法参数的赋值 \n\n* 首先，function fn(op = {}) {}\n\n```\nfunction drawES2015Chart({size = 'big', cords = { x: 0, y: 0 }, radius = 25} = {}) {}\n上面这个写法很高级，但是有点难以理解。\n\nfunction fn(o = {x: 'x', c: 1}) {}\n这个写法，虽然可以理解了，但是如果传参时添加了一个参数便会全部覆盖，达不到想要的效果。\n\nfunction fn(o = {}) {}\n此时如果没有传入参数则会变成一个空对象，然后我们再将这个o换成一个对象\n\nfunction fn({x = 3} = {}) {}\n此时，如果不传入参数，那么先是一个空对象，然后再将空对象赋值给了前面的，然后就会生成一个 x=3 的数了。\n如果传入的对象里面没有x，同样也是生成x=3的数。\n所以此时再去看最开始那个就应该能够看懂了\n\nfunction fn({x = 3}) {}\n这里的区别，在于如果没有传入任何值，那么将会报错，而上面使用了空对象，可以不传递参数。\n```\n\n> 在上面的 **`drawES2015Chart`** 的函数签名中，解构的左手边被分配给右手边的空对象字面值：`{size = 'big', cords = {x: 0, y: 0}, radius = 25} = {}`。你也可以在没有右侧分配的情况下编写函数。但是，如果你忽略了右边的赋值，那么函数会在被调用的时候查找至少一个被提供的参数，而在当前的形式下，你可以直接调用 `**drawES2015Chart()**` 而不提供任何参数。如果你希望能够在不提供任何参数的情况下调用该函数，则当前的设计非常有用，而另一种方法在您确保将对象传递给函数时非常有用。\n\n\n\n### 解构一个嵌套对象和数组\n\n* 没啥讲的，但是却有点东西，对象别名使用了 []， 进行了数组赋值，然后再在里面进行了对象赋值，{}\n\n```\nconst metadata = {\n  title: 'Scratchpad',\n  translations: [\n    {\n      locale: 'de',\n      localization_tags: [],\n      last_edit: '2014-04-14T08:43:37',\n      url: '/de/docs/Tools/Scratchpad',\n      title: 'JavaScript-Umgebung'\n    }\n  ],\n  url: '/en-US/docs/Tools/Scratchpad'\n};\n\nlet {\n  title: englishTitle, // rename\n  translations: [\n    {\n       title: localeTitle, // rename\n    },\n  ],\n} = metadata;\n\nconsole.log(englishTitle); // \"Scratchpad\"\nconsole.log(localeTitle);  // \"JavaScript-Umgebung\"\n```\n\n\n\n### for of 迭代和解构\n\n```\nvar people = [\n  {\n    name: 'Mike Smith',\n    family: {\n      mother: 'Jane Smith',\n      father: 'Harry Smith',\n      sister: 'Samantha Smith'\n    },\n    age: 35\n  },\n  {\n    name: 'Tom Jones',\n    family: {\n      mother: 'Norah Jones',\n      father: 'Richard Jones',\n      brother: 'Howard Jones'\n    },\n    age: 25\n  }\n];\n\nfor (var {name: n, family: {father: f}} of people) {\n  console.log('Name: ' + n + ', Father: ' + f);\n}\n```\n\n\n\n### 计算属性名，可以被解构\n\n* 简单来说，就是key变成了一个变量，然后使用[]， 来将一个常量换成了一个变量\n\n```\nlet key = \"z\";\nlet { [key]: foo } = { z: \"bar\" };\n\nconsole.log(foo); // \"bar\"\n```\n\n\n\n### 无效的标识符作为一个属性名\n\n在这里，fizz-buzz 是一个无效的变量名，我们使用字符串形式，然后加上别名进行操作。\n\n```\nconst foo = { 'fizz-buzz': true };\nconst { 'fizz-buzz': fizzBuzz } = foo;\n\nconsole.log(fizzBuzz); // \"true\"\n```\n\n","slug":"JavaScript/ES6/JavaScript-ES6解构","published":1,"updated":"2021-12-09T01:56:49.404Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckznhkk8n006nikub0v73e8hn","content":"<h1 id=\"JavaScript-解构赋值\"><a href=\"#JavaScript-解构赋值\" class=\"headerlink\" title=\"JavaScript 解构赋值\"></a>JavaScript 解构赋值</h1><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment</span><br></pre></td></tr></table></figure>\n\n\n\n<p>​        <strong>解构赋值</strong>语法是一种 Javascript 表达式。通过<strong>解构赋值,</strong> 可以将属性/值从对象/数组中取出,赋值给其他变量。</p>\n<p>​        简单来说，就是对于一个赋值变得简单起来。</p>\n<h2 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h2><h3 id=\"a-b-arr\"><a href=\"#a-b-arr\" class=\"headerlink\" title=\"[a, b] = arr;\"></a>[a, b] = arr;</h3><ul>\n<li>多余的不会被赋值</li>\n<li>少的会变成undefined</li>\n<li>注意要避免arr为null和undefined，对象同样，需要是数组和对象才行。</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let arr = [1, 3, 5];</span><br><span class=\"line\"></span><br><span class=\"line\">let [a, b] = arr;</span><br><span class=\"line\">console.log(a, b);</span><br><span class=\"line\"></span><br><span class=\"line\">1, 3</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"a-b-…rest-arr\"><a href=\"#a-b-…rest-arr\" class=\"headerlink\" title=\"[a, b, …rest] = arr;\"></a>[a, b, …rest] = arr;</h3><ul>\n<li>这里，对于多余的都会变成第三个的数组</li>\n<li>少于的，前面两个是undefined， 第三个数组会是一个空数组。</li>\n<li>剩余元素必须在最后一个。</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let arr = [1, 3, 4, 2, ];</span><br><span class=\"line\"></span><br><span class=\"line\">let [a, b, ...res] = arr;</span><br><span class=\"line\">console.log(a, b, res);</span><br><span class=\"line\"></span><br><span class=\"line\">1 3 [ 4, 2 ]</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"a-b-obj\"><a href=\"#a-b-obj\" class=\"headerlink\" title=\"({ a, b } = obj);\"></a>({ a, b } = obj);</h3><ul>\n<li><p>这个是以名称为主，需要找到obj内部的a，如果没有，那么就会变成undefined，其次，这里的值是可以是原型上的。 obj.__proto__ 只要原型链上存在也会赋值。</p>\n</li>\n<li><p>其次，这里需要添加括号，或者是定义时进行解构赋值，这里的作用可能是避免大括号的影响了编译的判断。</p>\n</li>\n<li><p><strong>注意</strong>：赋值语句周围的圆括号 <code>( ... )</code> 在使用对象字面量无声明解构赋值时是必须的。 <code>&#123;a, b&#125; = &#123;a: 1, b: 2&#125;</code> 不是有效的独立语法，因为左边的 <code>&#123;a, b&#125;</code> 被认为是一个块而不是对象字面量。</p>\n</li>\n<li><p>然而，<code>(&#123;a, b&#125; = &#123;a: 1, b: 2&#125;)</code> 是有效的，正如 <code>var &#123;a, b&#125; = &#123;a: 1, b: 2&#125;</code>你的 <code>( ... )</code> 表达式之前需要有一个分号，否则它可能会被当成上一行中的函数执行。</p>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let obj = &#123;</span><br><span class=\"line\">  a: 10,</span><br><span class=\"line\">  b: 20,</span><br><span class=\"line\">  c: 30</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">let a,c;</span><br><span class=\"line\">(&#123;a, c&#125; = obj);</span><br><span class=\"line\">console.log(a, c);</span><br><span class=\"line\"></span><br><span class=\"line\">10, 30</span><br></pre></td></tr></table></figure>\n\n<p>​        or</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let obj = &#123;</span><br><span class=\"line\">  a: 10,</span><br><span class=\"line\">  b: 20,</span><br><span class=\"line\">  c: 30</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">let &#123;a, b&#125; = obj;</span><br><span class=\"line\">console.log(a, b);</span><br><span class=\"line\"></span><br><span class=\"line\">10, 20</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"a-b-…rest-obj\"><a href=\"#a-b-…rest-obj\" class=\"headerlink\" title=\"({a, b, …rest} = obj);\"></a>({a, b, …rest} = obj);</h3><ul>\n<li>这里是将前面没有进行赋值的对象全部加入了最后一个对象。</li>\n<li>其次，最后一个是不会进入原型链进行查找赋值的。</li>\n<li>如果没有了，那么便会变成空对象。</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let obj = &#123;</span><br><span class=\"line\">  a: 10,</span><br><span class=\"line\">  b: 20,</span><br><span class=\"line\">  c: 30</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">obj.__proto__ = &#123;</span><br><span class=\"line\">  x: 1111,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let &#123;a, ...res&#125; = obj;</span><br><span class=\"line\">console.log(a, res);</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"a-4-a-10-解构默认值\"><a href=\"#a-4-a-10-解构默认值\" class=\"headerlink\" title=\"[a=4] / {a = 10} 解构默认值\"></a>[a=4] / {a = 10} 解构默认值</h3><ul>\n<li>简单来说就是设置一个默认值，不会变成undefined</li>\n<li>对于对象也有效果 </li>\n<li>默认值可以是对象。</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a, b;</span><br><span class=\"line\"></span><br><span class=\"line\">[a=5, b=7] = [1];    //[a=5, b=7] = [1, undefined]; ,就算是这样也是 1， 7</span><br><span class=\"line\">console.log(a); // 1</span><br><span class=\"line\">console.log(b); // 7</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(&#123;a=5, b=7&#125; = &#123;</span><br><span class=\"line\">  a: 3,</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">console.log(a); // 1</span><br><span class=\"line\">console.log(b); // 7</span><br><span class=\"line\"></span><br><span class=\"line\">(&#123;a=5, b= &#123; x: 1 &#125;&#125; = &#123; a: 3 &#125;); 并且还能使用赋值默认对象效果。</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"a-b-b-a-交换变量\"><a href=\"#a-b-b-a-交换变量\" class=\"headerlink\" title=\"[a, b] = [b, a]; 交换变量\"></a>[a, b] = [b, a]; 交换变量</h3><ul>\n<li>交换的变量可以是对象，也可以是值类型。</li>\n<li>({a, b} = {b, a});  这个没有交换变量的效果。</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let a= &#123;a: 4&#125;,</span><br><span class=\"line\">    b= &#123;x:3&#125;;</span><br><span class=\"line\">[a, b] = [b, a];</span><br><span class=\"line\">console.log(a, b);</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"忽略值-a-b-arr\"><a href=\"#忽略值-a-b-arr\" class=\"headerlink\" title=\"忽略值 [a, , b] = arr;\"></a>忽略值 [a, , b] = arr;</h3><ul>\n<li>可以对不要的值不使用变量进行存储，使用 <code>, ,</code> 这样就能达到忽略的效果</li>\n<li>对象不能使用忽略值的效果，会报错，</li>\n<li><code>[, ,] = arr</code> ， 这样可以忽略全部返回值</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function f() &#123;</span><br><span class=\"line\">  return [1, 2, 3];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var [a, , b] = f();</span><br><span class=\"line\">console.log(a); // 1</span><br><span class=\"line\">console.log(b); // 3</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"命名赋值-p-foo-obj-别名\"><a href=\"#命名赋值-p-foo-obj-别名\" class=\"headerlink\" title=\"命名赋值 {p: foo} = obj; 别名\"></a>命名赋值 {p: foo} = obj; 别名</h3><ul>\n<li>只能用于对象</li>\n<li>可以将其重新命名。</li>\n<li>可以将命名赋值和默认值一同使用 {p:foo = 10}</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var o = &#123;p: 42, q: true&#125;;</span><br><span class=\"line\">var &#123;p: foo, q: bar&#125; = o;</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(foo); // 42</span><br><span class=\"line\">console.log(bar); // true </span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"方法参数的赋值\"><a href=\"#方法参数的赋值\" class=\"headerlink\" title=\"方法参数的赋值\"></a>方法参数的赋值</h3><ul>\n<li>首先，function fn(op = {}) {}</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function drawES2015Chart(&#123;size = &#x27;big&#x27;, cords = &#123; x: 0, y: 0 &#125;, radius = 25&#125; = &#123;&#125;) &#123;&#125;</span><br><span class=\"line\">上面这个写法很高级，但是有点难以理解。</span><br><span class=\"line\"></span><br><span class=\"line\">function fn(o = &#123;x: &#x27;x&#x27;, c: 1&#125;) &#123;&#125;</span><br><span class=\"line\">这个写法，虽然可以理解了，但是如果传参时添加了一个参数便会全部覆盖，达不到想要的效果。</span><br><span class=\"line\"></span><br><span class=\"line\">function fn(o = &#123;&#125;) &#123;&#125;</span><br><span class=\"line\">此时如果没有传入参数则会变成一个空对象，然后我们再将这个o换成一个对象</span><br><span class=\"line\"></span><br><span class=\"line\">function fn(&#123;x = 3&#125; = &#123;&#125;) &#123;&#125;</span><br><span class=\"line\">此时，如果不传入参数，那么先是一个空对象，然后再将空对象赋值给了前面的，然后就会生成一个 x=3 的数了。</span><br><span class=\"line\">如果传入的对象里面没有x，同样也是生成x=3的数。</span><br><span class=\"line\">所以此时再去看最开始那个就应该能够看懂了</span><br><span class=\"line\"></span><br><span class=\"line\">function fn(&#123;x = 3&#125;) &#123;&#125;</span><br><span class=\"line\">这里的区别，在于如果没有传入任何值，那么将会报错，而上面使用了空对象，可以不传递参数。</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>在上面的 <strong><code>drawES2015Chart</code></strong> 的函数签名中，解构的左手边被分配给右手边的空对象字面值：<code>&#123;size = &#39;big&#39;, cords = &#123;x: 0, y: 0&#125;, radius = 25&#125; = &#123;&#125;</code>。你也可以在没有右侧分配的情况下编写函数。但是，如果你忽略了右边的赋值，那么函数会在被调用的时候查找至少一个被提供的参数，而在当前的形式下，你可以直接调用 <code>**drawES2015Chart()**</code> 而不提供任何参数。如果你希望能够在不提供任何参数的情况下调用该函数，则当前的设计非常有用，而另一种方法在您确保将对象传递给函数时非常有用。</p>\n</blockquote>\n<h3 id=\"解构一个嵌套对象和数组\"><a href=\"#解构一个嵌套对象和数组\" class=\"headerlink\" title=\"解构一个嵌套对象和数组\"></a>解构一个嵌套对象和数组</h3><ul>\n<li>没啥讲的，但是却有点东西，对象别名使用了 []， 进行了数组赋值，然后再在里面进行了对象赋值，{}</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const metadata = &#123;</span><br><span class=\"line\">  title: &#x27;Scratchpad&#x27;,</span><br><span class=\"line\">  translations: [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      locale: &#x27;de&#x27;,</span><br><span class=\"line\">      localization_tags: [],</span><br><span class=\"line\">      last_edit: &#x27;2014-04-14T08:43:37&#x27;,</span><br><span class=\"line\">      url: &#x27;/de/docs/Tools/Scratchpad&#x27;,</span><br><span class=\"line\">      title: &#x27;JavaScript-Umgebung&#x27;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  ],</span><br><span class=\"line\">  url: &#x27;/en-US/docs/Tools/Scratchpad&#x27;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">let &#123;</span><br><span class=\"line\">  title: englishTitle, // rename</span><br><span class=\"line\">  translations: [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">       title: localeTitle, // rename</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  ],</span><br><span class=\"line\">&#125; = metadata;</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(englishTitle); // &quot;Scratchpad&quot;</span><br><span class=\"line\">console.log(localeTitle);  // &quot;JavaScript-Umgebung&quot;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"for-of-迭代和解构\"><a href=\"#for-of-迭代和解构\" class=\"headerlink\" title=\"for of 迭代和解构\"></a>for of 迭代和解构</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var people = [</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    name: &#x27;Mike Smith&#x27;,</span><br><span class=\"line\">    family: &#123;</span><br><span class=\"line\">      mother: &#x27;Jane Smith&#x27;,</span><br><span class=\"line\">      father: &#x27;Harry Smith&#x27;,</span><br><span class=\"line\">      sister: &#x27;Samantha Smith&#x27;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    age: 35</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    name: &#x27;Tom Jones&#x27;,</span><br><span class=\"line\">    family: &#123;</span><br><span class=\"line\">      mother: &#x27;Norah Jones&#x27;,</span><br><span class=\"line\">      father: &#x27;Richard Jones&#x27;,</span><br><span class=\"line\">      brother: &#x27;Howard Jones&#x27;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    age: 25</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">];</span><br><span class=\"line\"></span><br><span class=\"line\">for (var &#123;name: n, family: &#123;father: f&#125;&#125; of people) &#123;</span><br><span class=\"line\">  console.log(&#x27;Name: &#x27; + n + &#x27;, Father: &#x27; + f);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"计算属性名，可以被解构\"><a href=\"#计算属性名，可以被解构\" class=\"headerlink\" title=\"计算属性名，可以被解构\"></a>计算属性名，可以被解构</h3><ul>\n<li>简单来说，就是key变成了一个变量，然后使用[]， 来将一个常量换成了一个变量</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let key = &quot;z&quot;;</span><br><span class=\"line\">let &#123; [key]: foo &#125; = &#123; z: &quot;bar&quot; &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(foo); // &quot;bar&quot;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"无效的标识符作为一个属性名\"><a href=\"#无效的标识符作为一个属性名\" class=\"headerlink\" title=\"无效的标识符作为一个属性名\"></a>无效的标识符作为一个属性名</h3><p>在这里，fizz-buzz 是一个无效的变量名，我们使用字符串形式，然后加上别名进行操作。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const foo = &#123; &#x27;fizz-buzz&#x27;: true &#125;;</span><br><span class=\"line\">const &#123; &#x27;fizz-buzz&#x27;: fizzBuzz &#125; = foo;</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(fizzBuzz); // &quot;true&quot;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"JavaScript-解构赋值\"><a href=\"#JavaScript-解构赋值\" class=\"headerlink\" title=\"JavaScript 解构赋值\"></a>JavaScript 解构赋值</h1><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment</span><br></pre></td></tr></table></figure>\n\n\n\n<p>​        <strong>解构赋值</strong>语法是一种 Javascript 表达式。通过<strong>解构赋值,</strong> 可以将属性/值从对象/数组中取出,赋值给其他变量。</p>\n<p>​        简单来说，就是对于一个赋值变得简单起来。</p>\n<h2 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h2><h3 id=\"a-b-arr\"><a href=\"#a-b-arr\" class=\"headerlink\" title=\"[a, b] = arr;\"></a>[a, b] = arr;</h3><ul>\n<li>多余的不会被赋值</li>\n<li>少的会变成undefined</li>\n<li>注意要避免arr为null和undefined，对象同样，需要是数组和对象才行。</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let arr = [1, 3, 5];</span><br><span class=\"line\"></span><br><span class=\"line\">let [a, b] = arr;</span><br><span class=\"line\">console.log(a, b);</span><br><span class=\"line\"></span><br><span class=\"line\">1, 3</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"a-b-…rest-arr\"><a href=\"#a-b-…rest-arr\" class=\"headerlink\" title=\"[a, b, …rest] = arr;\"></a>[a, b, …rest] = arr;</h3><ul>\n<li>这里，对于多余的都会变成第三个的数组</li>\n<li>少于的，前面两个是undefined， 第三个数组会是一个空数组。</li>\n<li>剩余元素必须在最后一个。</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let arr = [1, 3, 4, 2, ];</span><br><span class=\"line\"></span><br><span class=\"line\">let [a, b, ...res] = arr;</span><br><span class=\"line\">console.log(a, b, res);</span><br><span class=\"line\"></span><br><span class=\"line\">1 3 [ 4, 2 ]</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"a-b-obj\"><a href=\"#a-b-obj\" class=\"headerlink\" title=\"({ a, b } = obj);\"></a>({ a, b } = obj);</h3><ul>\n<li><p>这个是以名称为主，需要找到obj内部的a，如果没有，那么就会变成undefined，其次，这里的值是可以是原型上的。 obj.__proto__ 只要原型链上存在也会赋值。</p>\n</li>\n<li><p>其次，这里需要添加括号，或者是定义时进行解构赋值，这里的作用可能是避免大括号的影响了编译的判断。</p>\n</li>\n<li><p><strong>注意</strong>：赋值语句周围的圆括号 <code>( ... )</code> 在使用对象字面量无声明解构赋值时是必须的。 <code>&#123;a, b&#125; = &#123;a: 1, b: 2&#125;</code> 不是有效的独立语法，因为左边的 <code>&#123;a, b&#125;</code> 被认为是一个块而不是对象字面量。</p>\n</li>\n<li><p>然而，<code>(&#123;a, b&#125; = &#123;a: 1, b: 2&#125;)</code> 是有效的，正如 <code>var &#123;a, b&#125; = &#123;a: 1, b: 2&#125;</code>你的 <code>( ... )</code> 表达式之前需要有一个分号，否则它可能会被当成上一行中的函数执行。</p>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let obj = &#123;</span><br><span class=\"line\">  a: 10,</span><br><span class=\"line\">  b: 20,</span><br><span class=\"line\">  c: 30</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">let a,c;</span><br><span class=\"line\">(&#123;a, c&#125; = obj);</span><br><span class=\"line\">console.log(a, c);</span><br><span class=\"line\"></span><br><span class=\"line\">10, 30</span><br></pre></td></tr></table></figure>\n\n<p>​        or</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let obj = &#123;</span><br><span class=\"line\">  a: 10,</span><br><span class=\"line\">  b: 20,</span><br><span class=\"line\">  c: 30</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">let &#123;a, b&#125; = obj;</span><br><span class=\"line\">console.log(a, b);</span><br><span class=\"line\"></span><br><span class=\"line\">10, 20</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"a-b-…rest-obj\"><a href=\"#a-b-…rest-obj\" class=\"headerlink\" title=\"({a, b, …rest} = obj);\"></a>({a, b, …rest} = obj);</h3><ul>\n<li>这里是将前面没有进行赋值的对象全部加入了最后一个对象。</li>\n<li>其次，最后一个是不会进入原型链进行查找赋值的。</li>\n<li>如果没有了，那么便会变成空对象。</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let obj = &#123;</span><br><span class=\"line\">  a: 10,</span><br><span class=\"line\">  b: 20,</span><br><span class=\"line\">  c: 30</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">obj.__proto__ = &#123;</span><br><span class=\"line\">  x: 1111,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let &#123;a, ...res&#125; = obj;</span><br><span class=\"line\">console.log(a, res);</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"a-4-a-10-解构默认值\"><a href=\"#a-4-a-10-解构默认值\" class=\"headerlink\" title=\"[a=4] / {a = 10} 解构默认值\"></a>[a=4] / {a = 10} 解构默认值</h3><ul>\n<li>简单来说就是设置一个默认值，不会变成undefined</li>\n<li>对于对象也有效果 </li>\n<li>默认值可以是对象。</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a, b;</span><br><span class=\"line\"></span><br><span class=\"line\">[a=5, b=7] = [1];    //[a=5, b=7] = [1, undefined]; ,就算是这样也是 1， 7</span><br><span class=\"line\">console.log(a); // 1</span><br><span class=\"line\">console.log(b); // 7</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(&#123;a=5, b=7&#125; = &#123;</span><br><span class=\"line\">  a: 3,</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">console.log(a); // 1</span><br><span class=\"line\">console.log(b); // 7</span><br><span class=\"line\"></span><br><span class=\"line\">(&#123;a=5, b= &#123; x: 1 &#125;&#125; = &#123; a: 3 &#125;); 并且还能使用赋值默认对象效果。</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"a-b-b-a-交换变量\"><a href=\"#a-b-b-a-交换变量\" class=\"headerlink\" title=\"[a, b] = [b, a]; 交换变量\"></a>[a, b] = [b, a]; 交换变量</h3><ul>\n<li>交换的变量可以是对象，也可以是值类型。</li>\n<li>({a, b} = {b, a});  这个没有交换变量的效果。</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let a= &#123;a: 4&#125;,</span><br><span class=\"line\">    b= &#123;x:3&#125;;</span><br><span class=\"line\">[a, b] = [b, a];</span><br><span class=\"line\">console.log(a, b);</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"忽略值-a-b-arr\"><a href=\"#忽略值-a-b-arr\" class=\"headerlink\" title=\"忽略值 [a, , b] = arr;\"></a>忽略值 [a, , b] = arr;</h3><ul>\n<li>可以对不要的值不使用变量进行存储，使用 <code>, ,</code> 这样就能达到忽略的效果</li>\n<li>对象不能使用忽略值的效果，会报错，</li>\n<li><code>[, ,] = arr</code> ， 这样可以忽略全部返回值</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function f() &#123;</span><br><span class=\"line\">  return [1, 2, 3];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var [a, , b] = f();</span><br><span class=\"line\">console.log(a); // 1</span><br><span class=\"line\">console.log(b); // 3</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"命名赋值-p-foo-obj-别名\"><a href=\"#命名赋值-p-foo-obj-别名\" class=\"headerlink\" title=\"命名赋值 {p: foo} = obj; 别名\"></a>命名赋值 {p: foo} = obj; 别名</h3><ul>\n<li>只能用于对象</li>\n<li>可以将其重新命名。</li>\n<li>可以将命名赋值和默认值一同使用 {p:foo = 10}</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var o = &#123;p: 42, q: true&#125;;</span><br><span class=\"line\">var &#123;p: foo, q: bar&#125; = o;</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(foo); // 42</span><br><span class=\"line\">console.log(bar); // true </span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"方法参数的赋值\"><a href=\"#方法参数的赋值\" class=\"headerlink\" title=\"方法参数的赋值\"></a>方法参数的赋值</h3><ul>\n<li>首先，function fn(op = {}) {}</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function drawES2015Chart(&#123;size = &#x27;big&#x27;, cords = &#123; x: 0, y: 0 &#125;, radius = 25&#125; = &#123;&#125;) &#123;&#125;</span><br><span class=\"line\">上面这个写法很高级，但是有点难以理解。</span><br><span class=\"line\"></span><br><span class=\"line\">function fn(o = &#123;x: &#x27;x&#x27;, c: 1&#125;) &#123;&#125;</span><br><span class=\"line\">这个写法，虽然可以理解了，但是如果传参时添加了一个参数便会全部覆盖，达不到想要的效果。</span><br><span class=\"line\"></span><br><span class=\"line\">function fn(o = &#123;&#125;) &#123;&#125;</span><br><span class=\"line\">此时如果没有传入参数则会变成一个空对象，然后我们再将这个o换成一个对象</span><br><span class=\"line\"></span><br><span class=\"line\">function fn(&#123;x = 3&#125; = &#123;&#125;) &#123;&#125;</span><br><span class=\"line\">此时，如果不传入参数，那么先是一个空对象，然后再将空对象赋值给了前面的，然后就会生成一个 x=3 的数了。</span><br><span class=\"line\">如果传入的对象里面没有x，同样也是生成x=3的数。</span><br><span class=\"line\">所以此时再去看最开始那个就应该能够看懂了</span><br><span class=\"line\"></span><br><span class=\"line\">function fn(&#123;x = 3&#125;) &#123;&#125;</span><br><span class=\"line\">这里的区别，在于如果没有传入任何值，那么将会报错，而上面使用了空对象，可以不传递参数。</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>在上面的 <strong><code>drawES2015Chart</code></strong> 的函数签名中，解构的左手边被分配给右手边的空对象字面值：<code>&#123;size = &#39;big&#39;, cords = &#123;x: 0, y: 0&#125;, radius = 25&#125; = &#123;&#125;</code>。你也可以在没有右侧分配的情况下编写函数。但是，如果你忽略了右边的赋值，那么函数会在被调用的时候查找至少一个被提供的参数，而在当前的形式下，你可以直接调用 <code>**drawES2015Chart()**</code> 而不提供任何参数。如果你希望能够在不提供任何参数的情况下调用该函数，则当前的设计非常有用，而另一种方法在您确保将对象传递给函数时非常有用。</p>\n</blockquote>\n<h3 id=\"解构一个嵌套对象和数组\"><a href=\"#解构一个嵌套对象和数组\" class=\"headerlink\" title=\"解构一个嵌套对象和数组\"></a>解构一个嵌套对象和数组</h3><ul>\n<li>没啥讲的，但是却有点东西，对象别名使用了 []， 进行了数组赋值，然后再在里面进行了对象赋值，{}</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const metadata = &#123;</span><br><span class=\"line\">  title: &#x27;Scratchpad&#x27;,</span><br><span class=\"line\">  translations: [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      locale: &#x27;de&#x27;,</span><br><span class=\"line\">      localization_tags: [],</span><br><span class=\"line\">      last_edit: &#x27;2014-04-14T08:43:37&#x27;,</span><br><span class=\"line\">      url: &#x27;/de/docs/Tools/Scratchpad&#x27;,</span><br><span class=\"line\">      title: &#x27;JavaScript-Umgebung&#x27;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  ],</span><br><span class=\"line\">  url: &#x27;/en-US/docs/Tools/Scratchpad&#x27;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">let &#123;</span><br><span class=\"line\">  title: englishTitle, // rename</span><br><span class=\"line\">  translations: [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">       title: localeTitle, // rename</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  ],</span><br><span class=\"line\">&#125; = metadata;</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(englishTitle); // &quot;Scratchpad&quot;</span><br><span class=\"line\">console.log(localeTitle);  // &quot;JavaScript-Umgebung&quot;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"for-of-迭代和解构\"><a href=\"#for-of-迭代和解构\" class=\"headerlink\" title=\"for of 迭代和解构\"></a>for of 迭代和解构</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var people = [</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    name: &#x27;Mike Smith&#x27;,</span><br><span class=\"line\">    family: &#123;</span><br><span class=\"line\">      mother: &#x27;Jane Smith&#x27;,</span><br><span class=\"line\">      father: &#x27;Harry Smith&#x27;,</span><br><span class=\"line\">      sister: &#x27;Samantha Smith&#x27;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    age: 35</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    name: &#x27;Tom Jones&#x27;,</span><br><span class=\"line\">    family: &#123;</span><br><span class=\"line\">      mother: &#x27;Norah Jones&#x27;,</span><br><span class=\"line\">      father: &#x27;Richard Jones&#x27;,</span><br><span class=\"line\">      brother: &#x27;Howard Jones&#x27;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    age: 25</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">];</span><br><span class=\"line\"></span><br><span class=\"line\">for (var &#123;name: n, family: &#123;father: f&#125;&#125; of people) &#123;</span><br><span class=\"line\">  console.log(&#x27;Name: &#x27; + n + &#x27;, Father: &#x27; + f);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"计算属性名，可以被解构\"><a href=\"#计算属性名，可以被解构\" class=\"headerlink\" title=\"计算属性名，可以被解构\"></a>计算属性名，可以被解构</h3><ul>\n<li>简单来说，就是key变成了一个变量，然后使用[]， 来将一个常量换成了一个变量</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let key = &quot;z&quot;;</span><br><span class=\"line\">let &#123; [key]: foo &#125; = &#123; z: &quot;bar&quot; &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(foo); // &quot;bar&quot;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"无效的标识符作为一个属性名\"><a href=\"#无效的标识符作为一个属性名\" class=\"headerlink\" title=\"无效的标识符作为一个属性名\"></a>无效的标识符作为一个属性名</h3><p>在这里，fizz-buzz 是一个无效的变量名，我们使用字符串形式，然后加上别名进行操作。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const foo = &#123; &#x27;fizz-buzz&#x27;: true &#125;;</span><br><span class=\"line\">const &#123; &#x27;fizz-buzz&#x27;: fizzBuzz &#125; = foo;</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(fizzBuzz); // &quot;true&quot;</span><br></pre></td></tr></table></figure>\n\n"},{"title":"ES6随笔1","date":"2021-11-12T06:10:35.000Z","_content":"\n\n\n#  ES6随笔1\n\n```\nhttps://juejin.cn/post/7016520448204603423\n```\n\n\n\n## 数组合并并去重\n\n​\t\t先使用扩展运算符进行转化为一个数组，然后再使用set方式去重。\n\n```\nlet arr1 = [1, 3, 5];\nlet arr2 = [1, 6, 12];\n\nlet arr = [...new Set([...arr1, ...arr2])];\nconsole.log(arr);\n```\n\n\n\n## 对象合并\n\n```\nlet obj = {...obj1, ...obj2};\n```\n\n\n\n## 字符串拼接加判断\n\n使用模板字符串，模板字符串内部的${}，可以放入任意的JavaScript表达式\n\n```\nconst result = `${name}${score > 60 ? '的考试及格' : '的考试不及格'}`;\n```\n\n\n\n## 使用 includes 进行或判断\n\n```\nconst arr = [1, 2, 3];\nif (arr.includes(type)) {}\n\n就等于了\nif (type === 1 || type===2 || type===3) {}\n```\n\n\n\n## 使用 find 和 filter 进行查找\n\n* find 的特点是只查找第一个满足的\n* filter是将所有满足的作为一个新的数组返回。\n\n```\narr.filter(v => {\n\treturn v === 3;\n})\n\narr.find(v => {\n\treturn v === 3;\n})\n```\n\n\n\n## 扁平化数组\n\n* Object.values，这个代表了取出对象的属性值，然后作为一个数组。\n* flat 是一个扁平化数组的方法，Infinity作用是将很多层扁平化为一层。具体的可以取MDN进行查看。\n* 注意： `flat` 方法不支持IE浏览器\n\n```\nconst deps = {\n\tkey: [],\n\tkey1: []\n};\n\nlet member = Object.values(deps).flat(Infinity);\n```\n\n\n\n## 空值合并运算符 ??\n\n* `??` 代表了如果 左侧的变量是 null或者是undefined时，那么将会返回右侧的操作数。\n\n```\nlet a ?? ''\n```\n\n\n\n## 异步函数\n\n* 就是Promise.all 和 Promise.race 的使用\n* 以及可以使用 async 函数。\n* 避免生成回调地狱。\n\n","source":"_posts/JavaScript/ES6/ES6随笔1.md","raw":"---\ntitle: ES6随笔1\ndate: 2021-11-12 14:10:35\ntags:\n - JavaScript\n - ES6\n - 随笔\ncategories:\n - JavaScript\n - 随笔\n---\n\n\n\n#  ES6随笔1\n\n```\nhttps://juejin.cn/post/7016520448204603423\n```\n\n\n\n## 数组合并并去重\n\n​\t\t先使用扩展运算符进行转化为一个数组，然后再使用set方式去重。\n\n```\nlet arr1 = [1, 3, 5];\nlet arr2 = [1, 6, 12];\n\nlet arr = [...new Set([...arr1, ...arr2])];\nconsole.log(arr);\n```\n\n\n\n## 对象合并\n\n```\nlet obj = {...obj1, ...obj2};\n```\n\n\n\n## 字符串拼接加判断\n\n使用模板字符串，模板字符串内部的${}，可以放入任意的JavaScript表达式\n\n```\nconst result = `${name}${score > 60 ? '的考试及格' : '的考试不及格'}`;\n```\n\n\n\n## 使用 includes 进行或判断\n\n```\nconst arr = [1, 2, 3];\nif (arr.includes(type)) {}\n\n就等于了\nif (type === 1 || type===2 || type===3) {}\n```\n\n\n\n## 使用 find 和 filter 进行查找\n\n* find 的特点是只查找第一个满足的\n* filter是将所有满足的作为一个新的数组返回。\n\n```\narr.filter(v => {\n\treturn v === 3;\n})\n\narr.find(v => {\n\treturn v === 3;\n})\n```\n\n\n\n## 扁平化数组\n\n* Object.values，这个代表了取出对象的属性值，然后作为一个数组。\n* flat 是一个扁平化数组的方法，Infinity作用是将很多层扁平化为一层。具体的可以取MDN进行查看。\n* 注意： `flat` 方法不支持IE浏览器\n\n```\nconst deps = {\n\tkey: [],\n\tkey1: []\n};\n\nlet member = Object.values(deps).flat(Infinity);\n```\n\n\n\n## 空值合并运算符 ??\n\n* `??` 代表了如果 左侧的变量是 null或者是undefined时，那么将会返回右侧的操作数。\n\n```\nlet a ?? ''\n```\n\n\n\n## 异步函数\n\n* 就是Promise.all 和 Promise.race 的使用\n* 以及可以使用 async 函数。\n* 避免生成回调地狱。\n\n","slug":"JavaScript/ES6/ES6随笔1","published":1,"updated":"2021-12-09T01:56:49.404Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckznhkk8n006sikubfiq85fn6","content":"<h1 id=\"ES6随笔1\"><a href=\"#ES6随笔1\" class=\"headerlink\" title=\"ES6随笔1\"></a>ES6随笔1</h1><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://juejin.cn/post/7016520448204603423</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"数组合并并去重\"><a href=\"#数组合并并去重\" class=\"headerlink\" title=\"数组合并并去重\"></a>数组合并并去重</h2><p>​        先使用扩展运算符进行转化为一个数组，然后再使用set方式去重。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let arr1 = [1, 3, 5];</span><br><span class=\"line\">let arr2 = [1, 6, 12];</span><br><span class=\"line\"></span><br><span class=\"line\">let arr = [...new Set([...arr1, ...arr2])];</span><br><span class=\"line\">console.log(arr);</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"对象合并\"><a href=\"#对象合并\" class=\"headerlink\" title=\"对象合并\"></a>对象合并</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let obj = &#123;...obj1, ...obj2&#125;;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"字符串拼接加判断\"><a href=\"#字符串拼接加判断\" class=\"headerlink\" title=\"字符串拼接加判断\"></a>字符串拼接加判断</h2><p>使用模板字符串，模板字符串内部的${}，可以放入任意的JavaScript表达式</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const result = `$&#123;name&#125;$&#123;score &gt; 60 ? &#x27;的考试及格&#x27; : &#x27;的考试不及格&#x27;&#125;`;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"使用-includes-进行或判断\"><a href=\"#使用-includes-进行或判断\" class=\"headerlink\" title=\"使用 includes 进行或判断\"></a>使用 includes 进行或判断</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const arr = [1, 2, 3];</span><br><span class=\"line\">if (arr.includes(type)) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">就等于了</span><br><span class=\"line\">if (type === 1 || type===2 || type===3) &#123;&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"使用-find-和-filter-进行查找\"><a href=\"#使用-find-和-filter-进行查找\" class=\"headerlink\" title=\"使用 find 和 filter 进行查找\"></a>使用 find 和 filter 进行查找</h2><ul>\n<li>find 的特点是只查找第一个满足的</li>\n<li>filter是将所有满足的作为一个新的数组返回。</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">arr.filter(v =&gt; &#123;</span><br><span class=\"line\">\treturn v === 3;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">arr.find(v =&gt; &#123;</span><br><span class=\"line\">\treturn v === 3;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"扁平化数组\"><a href=\"#扁平化数组\" class=\"headerlink\" title=\"扁平化数组\"></a>扁平化数组</h2><ul>\n<li>Object.values，这个代表了取出对象的属性值，然后作为一个数组。</li>\n<li>flat 是一个扁平化数组的方法，Infinity作用是将很多层扁平化为一层。具体的可以取MDN进行查看。</li>\n<li>注意： <code>flat</code> 方法不支持IE浏览器</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const deps = &#123;</span><br><span class=\"line\">\tkey: [],</span><br><span class=\"line\">\tkey1: []</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">let member = Object.values(deps).flat(Infinity);</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"空值合并运算符\"><a href=\"#空值合并运算符\" class=\"headerlink\" title=\"空值合并运算符 ??\"></a>空值合并运算符 ??</h2><ul>\n<li><code>??</code> 代表了如果 左侧的变量是 null或者是undefined时，那么将会返回右侧的操作数。</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let a ?? &#x27;&#x27;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"异步函数\"><a href=\"#异步函数\" class=\"headerlink\" title=\"异步函数\"></a>异步函数</h2><ul>\n<li>就是Promise.all 和 Promise.race 的使用</li>\n<li>以及可以使用 async 函数。</li>\n<li>避免生成回调地狱。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"ES6随笔1\"><a href=\"#ES6随笔1\" class=\"headerlink\" title=\"ES6随笔1\"></a>ES6随笔1</h1><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://juejin.cn/post/7016520448204603423</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"数组合并并去重\"><a href=\"#数组合并并去重\" class=\"headerlink\" title=\"数组合并并去重\"></a>数组合并并去重</h2><p>​        先使用扩展运算符进行转化为一个数组，然后再使用set方式去重。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let arr1 = [1, 3, 5];</span><br><span class=\"line\">let arr2 = [1, 6, 12];</span><br><span class=\"line\"></span><br><span class=\"line\">let arr = [...new Set([...arr1, ...arr2])];</span><br><span class=\"line\">console.log(arr);</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"对象合并\"><a href=\"#对象合并\" class=\"headerlink\" title=\"对象合并\"></a>对象合并</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let obj = &#123;...obj1, ...obj2&#125;;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"字符串拼接加判断\"><a href=\"#字符串拼接加判断\" class=\"headerlink\" title=\"字符串拼接加判断\"></a>字符串拼接加判断</h2><p>使用模板字符串，模板字符串内部的${}，可以放入任意的JavaScript表达式</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const result = `$&#123;name&#125;$&#123;score &gt; 60 ? &#x27;的考试及格&#x27; : &#x27;的考试不及格&#x27;&#125;`;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"使用-includes-进行或判断\"><a href=\"#使用-includes-进行或判断\" class=\"headerlink\" title=\"使用 includes 进行或判断\"></a>使用 includes 进行或判断</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const arr = [1, 2, 3];</span><br><span class=\"line\">if (arr.includes(type)) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">就等于了</span><br><span class=\"line\">if (type === 1 || type===2 || type===3) &#123;&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"使用-find-和-filter-进行查找\"><a href=\"#使用-find-和-filter-进行查找\" class=\"headerlink\" title=\"使用 find 和 filter 进行查找\"></a>使用 find 和 filter 进行查找</h2><ul>\n<li>find 的特点是只查找第一个满足的</li>\n<li>filter是将所有满足的作为一个新的数组返回。</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">arr.filter(v =&gt; &#123;</span><br><span class=\"line\">\treturn v === 3;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">arr.find(v =&gt; &#123;</span><br><span class=\"line\">\treturn v === 3;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"扁平化数组\"><a href=\"#扁平化数组\" class=\"headerlink\" title=\"扁平化数组\"></a>扁平化数组</h2><ul>\n<li>Object.values，这个代表了取出对象的属性值，然后作为一个数组。</li>\n<li>flat 是一个扁平化数组的方法，Infinity作用是将很多层扁平化为一层。具体的可以取MDN进行查看。</li>\n<li>注意： <code>flat</code> 方法不支持IE浏览器</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const deps = &#123;</span><br><span class=\"line\">\tkey: [],</span><br><span class=\"line\">\tkey1: []</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">let member = Object.values(deps).flat(Infinity);</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"空值合并运算符\"><a href=\"#空值合并运算符\" class=\"headerlink\" title=\"空值合并运算符 ??\"></a>空值合并运算符 ??</h2><ul>\n<li><code>??</code> 代表了如果 左侧的变量是 null或者是undefined时，那么将会返回右侧的操作数。</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let a ?? &#x27;&#x27;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"异步函数\"><a href=\"#异步函数\" class=\"headerlink\" title=\"异步函数\"></a>异步函数</h2><ul>\n<li>就是Promise.all 和 Promise.race 的使用</li>\n<li>以及可以使用 async 函数。</li>\n<li>避免生成回调地狱。</li>\n</ul>\n"},{"title":"JavaScript原型链","date":"2021-11-09T12:57:32.000Z","_content":"\n\n\n **注意：**\n\n**这里的内容为本人的理解，不敢保正。**\n\n\n\n#  JavaScript原型链\n\n先看一张图，简单来说\n\n​\t\t原型其实就是一个方法的实例，然后每一个方法的实例有一个\\_\\_proto\\_\\_ 的指向。这个指向会直到指到null为止。这样所生产的就是一个原型链，对于在本层找不到的方法，会通过原型链逐层向上查找。\n\n​\t\t一个方法是和一个原型对应的，而一个原型又是一个另一个方法的实例，所以这里的对应关系在于，一个方法的实例默认是没有constructor构造函数，此时这个实例就是一个单纯的底层实例，但是如果我们将一个构造函数的原型指向了这个实例，并且将这个实例的构造器指向了原型， 那么这个实例就已经算是一个原型了，此时就已经不是一个单纯的底层实例了。\n\n​\t\t顶层的方法就是 Function，顶层的原型就是Object.prototype，而Object方法确实使用了Function的原型。\n\n<img src=\"JavaScript原型链/290701352241158.jpg\" alt=\"290701352241158\" style=\"zoom:67%;\" />\n\n\n\n# JavaScript 继承\n\n\n\n```\nfunction Fn() {\n  this.name = 1;\n}\n\nlet a = new Fn();\n\n此时的\na.__proto__ = Fn.prototype\na.__proto__.constructor = Fn;\n```\n\n## new 方法的行为\n\n​\t\t我们要这样思考，这个new方法。\n\n* new 一个方法，会创建的一个this的指向。\n* 然后会执行这个方法，执行结束之后。\n* 创建一个 \\_\\_proto\\_\\_  指向了 方法的 prototype 的指向。\n* 然后就进行返回。\n\n```\nlet _this = {};\nlet result = Fn.apply(_this, args);\n_this.__proto__ = Fn.prototype;\nreturn typeof result === 'object' ? result : __this__;\n```\n\n​\t\t同时这里，在进行 new 方法的调用时，我们知道，如果返回的是一个引用类型，那么便会直接返回这个引用类型，如果返回的是一个值类型，那么返回的便是自己所创建的this指向。我们可以知道一个引用类型，无论你是使用的new方法，还是直接进行的创建的引用类型。其结果都会创建原型。\n\n**注意**：\n\n​\t\t对于一个值类型，进行了new 方法，也会变成引用类型的。\n\n```\nlet x = new Number(1);\nlet y = new Number(1);\n\nconsole.log(x === y); //false\n```\n\n\n\n## **JavaScript 继承**：\n\n### 继承的思路\n\n继承，简单的理解就是，子类的实例可以访问父类的方法\n\n同时我们可以知道，父类的方法，创建的实例才能进行调用。\n\n而父类的prototype，已经可以算作为父类的父类的方法了。\n\n所以，我们在不考虑上级的方法之前，需要将父类的方法进行传递，\n\n这里，可以考虑使用一个新的对象进行指定。如果我一个新对象\n\n\n\n### 原型和构造器\n\n这里和Java的一个不同点\n\n我印象中，Java是子类有多个，父类越来越少的一种情况，\n\n<img src=\"JavaScript原型链/image-20211110100356010.png\" alt=\"image-20211110100356010\" style=\"zoom:67%;\" />\n\n​\t\t一开始，我是这样思考的，构造函数和实例是对应的，而构造函数的原型应该是属于上层的一个实例了。\n\n​\t\t但是你仔细观察，发现，一个构造函数的原型是和构造函数进行了对应。思想应该是每个实例都有一个原型，但是其原型默认是没有constructor的（这里可以使用 hasOwnProperty 进行证明）。我们所使用的constructor属性其实都是我们的实例的原型  \\_\\_proto\\_\\_ 中的constructor，但是实例的原型为什么会带有constructor，这里我的认为是，一个函数默认在词法编译阶段，会默认指向一个prototype，而这个行为就是 \n\n```\nFn.protorype = new Object();\nFn.prototype.constructor = Fn;\n```\n\n​\t简单来说，就是在没有指定的情况下，默认先创建一个顶级的对象实例，里面只有最原始的方法，然后再对这个实例创建一个本函数的构造行为。\n\n<img src=\"JavaScript原型链/image-20211110101346723.png\" alt=\"image-20211110101346723\" style=\"zoom:67%;\" />\n\n​\t\t而这个JavaScript是每个子类，都会将父类进行一次实例的操作，所以造成了每个父类的实例和子类的构造函数一一对应了。\n\n\n\n### new 方法实现\n\n#### **`new` 关键字会进行如下的操作：**\n\n1. 创建一个空的简单JavaScript对象（即`{}`）；\n2. 为步骤1新创建的对象添加属性**__proto__**，将该属性链接至构造函数的原型对象 ；\n3. 将步骤1新创建的对象作为`this`的上下文 ；\n4. 如果该函数没有返回对象，则返回`this`。\n\n#### **当代码 `new Foo(...)` 执行时，会发生以下事情：**\n\n1. 一个继承自 `Foo.prototype` 的新对象被创建。\n2. 使用指定的参数调用构造函数 *`Foo`*，并将 `this` 绑定到新创建的对象。`new Foo` 等同于 *`new Foo`*`()`，也就是没有指定参数列表，*`Foo`* 不带任何参数调用的情况。\n3. 由构造函数返回的对象就是 `new` 表达式的结果。如果构造函数没有显式返回一个对象，则使用步骤1创建的对象。（一般情况下，构造函数不返回值，但是用户可以选择主动返回对象，来覆盖正常的对象创建步骤）\n\n```\nfunction create(Fn, ...args) {\n  let _this = {};\n  let result = Fn.apply(_this, args);\n  _this.__proto__ = Fn.prototype;\n  return typeof result === 'object' ? result : _this;\n}\n```\n\n\n\n### 继承的方式\n\n#### 原型链继承\n\n```\nChildren.prototype = new Father();\nChildren.prototype.constructor = Children;\n```\n\n​\t\t很简单的理解，就是直接将子类的原型修改为了父类的实例，然后再对实例的constructor进行一个校准，修改为子类的构造。\n\n​\t\t执行new方法的行为的步骤：\n\n* 产生一个this指向，\\_\\_proto\\_\\_  的添加，指向为children.prototype。就是 Father的实例。\n* 执行children的构造函数，this指向的调用。\n* 返回。\n\n\n\n**缺点**：\n\n* 对于要在原型上添加修改的方法，需要在 new Father 之后，因为这个是直接将一个地址进行了转换。\n* 其次就是不会将参数传递到父类。只适合不带参数的。\n* 因为实例是在直接对原型的创建，所以，所有的实例都是共有的。当然，因为这个创建本就无法带参数，共有实例其实并没有什么问题。\n\n\n\n#### 组合继承\n\n```\nfunction Children() {\n\tFather.call(this);\n}\nChildren.prototype = new Father();\nChildren.prototype.constructor = Children;\n```\n\n​\t\t这个和原型链继承大同小异，就是多了一个在构造函数内部使用call方法调用父类。使用call方法调用时是不会产生 \\_\\_proto\\_\\_  和 constructor 的。但是你可能会发现自己测试还是有啊，但是你仔细观察，其实你自己测试所生成的 \\_\\_proto\\_\\_  和 constructor 是在创建对象的时候生成的。所以，其实并没有真正的生成。\n\n\n\n**缺点**：\n\n* new 方法 和 call 方法都生成了一份实例。\n\n\n\n#### 寄生组合继承\n\n```\nfunction Children() {\n\tFather.call(this);\n}\n(function () {\n\tlet Super = function() {};\n\tSuper.prototype = Father.prototype;\n\tChildren.prototype = new Super();\n\tChildren.prototype.constructor = Children;\n})();\n```\n\n​\t\t我们可以查看这个和 组合继承的区别，使用了一个空方法将Father的原型复制了过来，所以new所生成的方法就只生成了一个空对象，和一个原型。Father的方法实则已经在call方法里面进行了调用。\n\n\n\n##### 寄生组合继承的思考\n\n为什么我们会这样使用寄生组合继承\n\n我们可以从各个方面进行思考，\n\n首先继承无非就是子类想要使用上父类的元素，然后这里就需要调用父类的方法\n\n```\nfunction Children() {\n\t\n}\nChildren.prototype = new Father();\n\n这个方法的问题是无法传参。\n这里修改了原型指向，所以需要进行构造函数的指向转变\nChildren.prototype.constructor = Children;\n```\n\n```\nfunction Children() {\n\tlet instance = new Father(xxx);\n\t\n\treturn instance;\n}\n\n这个方法是可以传递参数了，但是这个方法就不是父类的实例了，因为是在子类被创建，所以我们要不就是对子类也同用这个instance对象进行操作。但是这样有点不符合一种规范\n这里是使用了instance方式，而instance实则是父类的实例，所以如果需要进行子类实例的操作。需要在new Fahter的后面，然后将this转换成instance，然后对于proto和构造 函数都是父函数的。很有问题的感觉\n```\n\n```\nfunction Children() {\n\tFather.call(this);\n}\n\n在这里，我是将父元素的方法进行了执行，当然，如果是对于父元素返回的是一个对象的，那么将会是一个不同的操作，但是在正常的情况下，通过这个可以获取到父元素的构造函数执行方法，但是，问题在于没有原型指向的改变。所以我们需要进行原型指向的改变。\n简单来说，这里已经获取到了父函数的实例对象，只需要将原型指向进行改变即可\nChildren.prototype = new Father();\nChildren.prototype.constructor = Children;\n通过上面这个方法，我们获取到了原型的指向，修改为了父元素的实例。唯一的问题就是进行了两次Father的使用，可以考虑对于父函数的实例进行一个处理\n\nlet Super = funtion() {};\nSuper.prototype = Father.prototype;\nChildren.prototype = new Super();\nChildren.prototype.constructor = Children;\n区别，new的是Super，Super里面没有实例，所以里面只有一个原型的指向。\n而Super的原型的指向已经被修改为了Father的原型。\n此时我们只需要在对构造函数进行一个修改即可。\n```\n\n\n\n所以最后我们使用了寄生组合继承，方式就是在内部使用call方法调用了父函数，获取了父函数的实例方法，然后在外部创建一个空函数，原型指向了父函数的原型，然后再对其实例赋值给了子类的原型，此时因为空函数的实例内部是没有的，所以其实内部的共有属性就只有proto，和 constructor。然后在修改原型的构造。\n\n​\t\t所以整的来说，这个方式，只生成了相同的父类的实例的方法，并且放在了子类的实例中，所以不会出现共有属性，其次就是原型是在外部进行的实现，所以原型又是共有的。其次就是对原型的构造函数进行了指向。\n\n​\t\t所以很完美。","source":"_posts/JavaScript/概念/JavaScript原型链.md","raw":"---\ntitle: JavaScript原型链\ndate: 2021-11-09 20:57:32\ntags:\n - JavaScript\n - 原型链\n - 随笔\ncategories:\n - JavaScript\n - 随笔\n---\n\n\n\n **注意：**\n\n**这里的内容为本人的理解，不敢保正。**\n\n\n\n#  JavaScript原型链\n\n先看一张图，简单来说\n\n​\t\t原型其实就是一个方法的实例，然后每一个方法的实例有一个\\_\\_proto\\_\\_ 的指向。这个指向会直到指到null为止。这样所生产的就是一个原型链，对于在本层找不到的方法，会通过原型链逐层向上查找。\n\n​\t\t一个方法是和一个原型对应的，而一个原型又是一个另一个方法的实例，所以这里的对应关系在于，一个方法的实例默认是没有constructor构造函数，此时这个实例就是一个单纯的底层实例，但是如果我们将一个构造函数的原型指向了这个实例，并且将这个实例的构造器指向了原型， 那么这个实例就已经算是一个原型了，此时就已经不是一个单纯的底层实例了。\n\n​\t\t顶层的方法就是 Function，顶层的原型就是Object.prototype，而Object方法确实使用了Function的原型。\n\n<img src=\"JavaScript原型链/290701352241158.jpg\" alt=\"290701352241158\" style=\"zoom:67%;\" />\n\n\n\n# JavaScript 继承\n\n\n\n```\nfunction Fn() {\n  this.name = 1;\n}\n\nlet a = new Fn();\n\n此时的\na.__proto__ = Fn.prototype\na.__proto__.constructor = Fn;\n```\n\n## new 方法的行为\n\n​\t\t我们要这样思考，这个new方法。\n\n* new 一个方法，会创建的一个this的指向。\n* 然后会执行这个方法，执行结束之后。\n* 创建一个 \\_\\_proto\\_\\_  指向了 方法的 prototype 的指向。\n* 然后就进行返回。\n\n```\nlet _this = {};\nlet result = Fn.apply(_this, args);\n_this.__proto__ = Fn.prototype;\nreturn typeof result === 'object' ? result : __this__;\n```\n\n​\t\t同时这里，在进行 new 方法的调用时，我们知道，如果返回的是一个引用类型，那么便会直接返回这个引用类型，如果返回的是一个值类型，那么返回的便是自己所创建的this指向。我们可以知道一个引用类型，无论你是使用的new方法，还是直接进行的创建的引用类型。其结果都会创建原型。\n\n**注意**：\n\n​\t\t对于一个值类型，进行了new 方法，也会变成引用类型的。\n\n```\nlet x = new Number(1);\nlet y = new Number(1);\n\nconsole.log(x === y); //false\n```\n\n\n\n## **JavaScript 继承**：\n\n### 继承的思路\n\n继承，简单的理解就是，子类的实例可以访问父类的方法\n\n同时我们可以知道，父类的方法，创建的实例才能进行调用。\n\n而父类的prototype，已经可以算作为父类的父类的方法了。\n\n所以，我们在不考虑上级的方法之前，需要将父类的方法进行传递，\n\n这里，可以考虑使用一个新的对象进行指定。如果我一个新对象\n\n\n\n### 原型和构造器\n\n这里和Java的一个不同点\n\n我印象中，Java是子类有多个，父类越来越少的一种情况，\n\n<img src=\"JavaScript原型链/image-20211110100356010.png\" alt=\"image-20211110100356010\" style=\"zoom:67%;\" />\n\n​\t\t一开始，我是这样思考的，构造函数和实例是对应的，而构造函数的原型应该是属于上层的一个实例了。\n\n​\t\t但是你仔细观察，发现，一个构造函数的原型是和构造函数进行了对应。思想应该是每个实例都有一个原型，但是其原型默认是没有constructor的（这里可以使用 hasOwnProperty 进行证明）。我们所使用的constructor属性其实都是我们的实例的原型  \\_\\_proto\\_\\_ 中的constructor，但是实例的原型为什么会带有constructor，这里我的认为是，一个函数默认在词法编译阶段，会默认指向一个prototype，而这个行为就是 \n\n```\nFn.protorype = new Object();\nFn.prototype.constructor = Fn;\n```\n\n​\t简单来说，就是在没有指定的情况下，默认先创建一个顶级的对象实例，里面只有最原始的方法，然后再对这个实例创建一个本函数的构造行为。\n\n<img src=\"JavaScript原型链/image-20211110101346723.png\" alt=\"image-20211110101346723\" style=\"zoom:67%;\" />\n\n​\t\t而这个JavaScript是每个子类，都会将父类进行一次实例的操作，所以造成了每个父类的实例和子类的构造函数一一对应了。\n\n\n\n### new 方法实现\n\n#### **`new` 关键字会进行如下的操作：**\n\n1. 创建一个空的简单JavaScript对象（即`{}`）；\n2. 为步骤1新创建的对象添加属性**__proto__**，将该属性链接至构造函数的原型对象 ；\n3. 将步骤1新创建的对象作为`this`的上下文 ；\n4. 如果该函数没有返回对象，则返回`this`。\n\n#### **当代码 `new Foo(...)` 执行时，会发生以下事情：**\n\n1. 一个继承自 `Foo.prototype` 的新对象被创建。\n2. 使用指定的参数调用构造函数 *`Foo`*，并将 `this` 绑定到新创建的对象。`new Foo` 等同于 *`new Foo`*`()`，也就是没有指定参数列表，*`Foo`* 不带任何参数调用的情况。\n3. 由构造函数返回的对象就是 `new` 表达式的结果。如果构造函数没有显式返回一个对象，则使用步骤1创建的对象。（一般情况下，构造函数不返回值，但是用户可以选择主动返回对象，来覆盖正常的对象创建步骤）\n\n```\nfunction create(Fn, ...args) {\n  let _this = {};\n  let result = Fn.apply(_this, args);\n  _this.__proto__ = Fn.prototype;\n  return typeof result === 'object' ? result : _this;\n}\n```\n\n\n\n### 继承的方式\n\n#### 原型链继承\n\n```\nChildren.prototype = new Father();\nChildren.prototype.constructor = Children;\n```\n\n​\t\t很简单的理解，就是直接将子类的原型修改为了父类的实例，然后再对实例的constructor进行一个校准，修改为子类的构造。\n\n​\t\t执行new方法的行为的步骤：\n\n* 产生一个this指向，\\_\\_proto\\_\\_  的添加，指向为children.prototype。就是 Father的实例。\n* 执行children的构造函数，this指向的调用。\n* 返回。\n\n\n\n**缺点**：\n\n* 对于要在原型上添加修改的方法，需要在 new Father 之后，因为这个是直接将一个地址进行了转换。\n* 其次就是不会将参数传递到父类。只适合不带参数的。\n* 因为实例是在直接对原型的创建，所以，所有的实例都是共有的。当然，因为这个创建本就无法带参数，共有实例其实并没有什么问题。\n\n\n\n#### 组合继承\n\n```\nfunction Children() {\n\tFather.call(this);\n}\nChildren.prototype = new Father();\nChildren.prototype.constructor = Children;\n```\n\n​\t\t这个和原型链继承大同小异，就是多了一个在构造函数内部使用call方法调用父类。使用call方法调用时是不会产生 \\_\\_proto\\_\\_  和 constructor 的。但是你可能会发现自己测试还是有啊，但是你仔细观察，其实你自己测试所生成的 \\_\\_proto\\_\\_  和 constructor 是在创建对象的时候生成的。所以，其实并没有真正的生成。\n\n\n\n**缺点**：\n\n* new 方法 和 call 方法都生成了一份实例。\n\n\n\n#### 寄生组合继承\n\n```\nfunction Children() {\n\tFather.call(this);\n}\n(function () {\n\tlet Super = function() {};\n\tSuper.prototype = Father.prototype;\n\tChildren.prototype = new Super();\n\tChildren.prototype.constructor = Children;\n})();\n```\n\n​\t\t我们可以查看这个和 组合继承的区别，使用了一个空方法将Father的原型复制了过来，所以new所生成的方法就只生成了一个空对象，和一个原型。Father的方法实则已经在call方法里面进行了调用。\n\n\n\n##### 寄生组合继承的思考\n\n为什么我们会这样使用寄生组合继承\n\n我们可以从各个方面进行思考，\n\n首先继承无非就是子类想要使用上父类的元素，然后这里就需要调用父类的方法\n\n```\nfunction Children() {\n\t\n}\nChildren.prototype = new Father();\n\n这个方法的问题是无法传参。\n这里修改了原型指向，所以需要进行构造函数的指向转变\nChildren.prototype.constructor = Children;\n```\n\n```\nfunction Children() {\n\tlet instance = new Father(xxx);\n\t\n\treturn instance;\n}\n\n这个方法是可以传递参数了，但是这个方法就不是父类的实例了，因为是在子类被创建，所以我们要不就是对子类也同用这个instance对象进行操作。但是这样有点不符合一种规范\n这里是使用了instance方式，而instance实则是父类的实例，所以如果需要进行子类实例的操作。需要在new Fahter的后面，然后将this转换成instance，然后对于proto和构造 函数都是父函数的。很有问题的感觉\n```\n\n```\nfunction Children() {\n\tFather.call(this);\n}\n\n在这里，我是将父元素的方法进行了执行，当然，如果是对于父元素返回的是一个对象的，那么将会是一个不同的操作，但是在正常的情况下，通过这个可以获取到父元素的构造函数执行方法，但是，问题在于没有原型指向的改变。所以我们需要进行原型指向的改变。\n简单来说，这里已经获取到了父函数的实例对象，只需要将原型指向进行改变即可\nChildren.prototype = new Father();\nChildren.prototype.constructor = Children;\n通过上面这个方法，我们获取到了原型的指向，修改为了父元素的实例。唯一的问题就是进行了两次Father的使用，可以考虑对于父函数的实例进行一个处理\n\nlet Super = funtion() {};\nSuper.prototype = Father.prototype;\nChildren.prototype = new Super();\nChildren.prototype.constructor = Children;\n区别，new的是Super，Super里面没有实例，所以里面只有一个原型的指向。\n而Super的原型的指向已经被修改为了Father的原型。\n此时我们只需要在对构造函数进行一个修改即可。\n```\n\n\n\n所以最后我们使用了寄生组合继承，方式就是在内部使用call方法调用了父函数，获取了父函数的实例方法，然后在外部创建一个空函数，原型指向了父函数的原型，然后再对其实例赋值给了子类的原型，此时因为空函数的实例内部是没有的，所以其实内部的共有属性就只有proto，和 constructor。然后在修改原型的构造。\n\n​\t\t所以整的来说，这个方式，只生成了相同的父类的实例的方法，并且放在了子类的实例中，所以不会出现共有属性，其次就是原型是在外部进行的实现，所以原型又是共有的。其次就是对原型的构造函数进行了指向。\n\n​\t\t所以很完美。","slug":"JavaScript/概念/JavaScript原型链","published":1,"updated":"2021-12-09T01:56:49.404Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckznhkk8o006vikub3vib9425","content":"<p> <strong>注意：</strong></p>\n<p><strong>这里的内容为本人的理解，不敢保正。</strong></p>\n<h1 id=\"JavaScript原型链\"><a href=\"#JavaScript原型链\" class=\"headerlink\" title=\"JavaScript原型链\"></a>JavaScript原型链</h1><p>先看一张图，简单来说</p>\n<p>​        原型其实就是一个方法的实例，然后每一个方法的实例有一个__proto__ 的指向。这个指向会直到指到null为止。这样所生产的就是一个原型链，对于在本层找不到的方法，会通过原型链逐层向上查找。</p>\n<p>​        一个方法是和一个原型对应的，而一个原型又是一个另一个方法的实例，所以这里的对应关系在于，一个方法的实例默认是没有constructor构造函数，此时这个实例就是一个单纯的底层实例，但是如果我们将一个构造函数的原型指向了这个实例，并且将这个实例的构造器指向了原型， 那么这个实例就已经算是一个原型了，此时就已经不是一个单纯的底层实例了。</p>\n<p>​        顶层的方法就是 Function，顶层的原型就是Object.prototype，而Object方法确实使用了Function的原型。</p>\n<img src=\"/.io//290701352241158.jpg\" alt=\"290701352241158\" style=\"zoom:67%;\">\n\n\n\n<h1 id=\"JavaScript-继承\"><a href=\"#JavaScript-继承\" class=\"headerlink\" title=\"JavaScript 继承\"></a>JavaScript 继承</h1><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Fn() &#123;</span><br><span class=\"line\">  this.name = 1;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">let a = new Fn();</span><br><span class=\"line\"></span><br><span class=\"line\">此时的</span><br><span class=\"line\">a.__proto__ = Fn.prototype</span><br><span class=\"line\">a.__proto__.constructor = Fn;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"new-方法的行为\"><a href=\"#new-方法的行为\" class=\"headerlink\" title=\"new 方法的行为\"></a>new 方法的行为</h2><p>​        我们要这样思考，这个new方法。</p>\n<ul>\n<li>new 一个方法，会创建的一个this的指向。</li>\n<li>然后会执行这个方法，执行结束之后。</li>\n<li>创建一个 __proto__  指向了 方法的 prototype 的指向。</li>\n<li>然后就进行返回。</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let _this = &#123;&#125;;</span><br><span class=\"line\">let result = Fn.apply(_this, args);</span><br><span class=\"line\">_this.__proto__ = Fn.prototype;</span><br><span class=\"line\">return typeof result === &#x27;object&#x27; ? result : __this__;</span><br></pre></td></tr></table></figure>\n\n<p>​        同时这里，在进行 new 方法的调用时，我们知道，如果返回的是一个引用类型，那么便会直接返回这个引用类型，如果返回的是一个值类型，那么返回的便是自己所创建的this指向。我们可以知道一个引用类型，无论你是使用的new方法，还是直接进行的创建的引用类型。其结果都会创建原型。</p>\n<p><strong>注意</strong>：</p>\n<p>​        对于一个值类型，进行了new 方法，也会变成引用类型的。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let x = new Number(1);</span><br><span class=\"line\">let y = new Number(1);</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(x === y); //false</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"JavaScript-继承：\"><a href=\"#JavaScript-继承：\" class=\"headerlink\" title=\"JavaScript 继承：\"></a><strong>JavaScript 继承</strong>：</h2><h3 id=\"继承的思路\"><a href=\"#继承的思路\" class=\"headerlink\" title=\"继承的思路\"></a>继承的思路</h3><p>继承，简单的理解就是，子类的实例可以访问父类的方法</p>\n<p>同时我们可以知道，父类的方法，创建的实例才能进行调用。</p>\n<p>而父类的prototype，已经可以算作为父类的父类的方法了。</p>\n<p>所以，我们在不考虑上级的方法之前，需要将父类的方法进行传递，</p>\n<p>这里，可以考虑使用一个新的对象进行指定。如果我一个新对象</p>\n<h3 id=\"原型和构造器\"><a href=\"#原型和构造器\" class=\"headerlink\" title=\"原型和构造器\"></a>原型和构造器</h3><p>这里和Java的一个不同点</p>\n<p>我印象中，Java是子类有多个，父类越来越少的一种情况，</p>\n<img src=\"/.io//image-20211110100356010.png\" alt=\"image-20211110100356010\" style=\"zoom:67%;\">\n\n<p>​        一开始，我是这样思考的，构造函数和实例是对应的，而构造函数的原型应该是属于上层的一个实例了。</p>\n<p>​        但是你仔细观察，发现，一个构造函数的原型是和构造函数进行了对应。思想应该是每个实例都有一个原型，但是其原型默认是没有constructor的（这里可以使用 hasOwnProperty 进行证明）。我们所使用的constructor属性其实都是我们的实例的原型  __proto__ 中的constructor，但是实例的原型为什么会带有constructor，这里我的认为是，一个函数默认在词法编译阶段，会默认指向一个prototype，而这个行为就是 </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Fn.protorype = new Object();</span><br><span class=\"line\">Fn.prototype.constructor = Fn;</span><br></pre></td></tr></table></figure>\n\n<p>​    简单来说，就是在没有指定的情况下，默认先创建一个顶级的对象实例，里面只有最原始的方法，然后再对这个实例创建一个本函数的构造行为。</p>\n<img src=\"/.io//image-20211110101346723.png\" alt=\"image-20211110101346723\" style=\"zoom:67%;\">\n\n<p>​        而这个JavaScript是每个子类，都会将父类进行一次实例的操作，所以造成了每个父类的实例和子类的构造函数一一对应了。</p>\n<h3 id=\"new-方法实现\"><a href=\"#new-方法实现\" class=\"headerlink\" title=\"new 方法实现\"></a>new 方法实现</h3><h4 id=\"new-关键字会进行如下的操作：\"><a href=\"#new-关键字会进行如下的操作：\" class=\"headerlink\" title=\"new 关键字会进行如下的操作：\"></a><strong><code>new</code> 关键字会进行如下的操作：</strong></h4><ol>\n<li>创建一个空的简单JavaScript对象（即<code>&#123;&#125;</code>）；</li>\n<li>为步骤1新创建的对象添加属性**<strong>proto</strong>**，将该属性链接至构造函数的原型对象 ；</li>\n<li>将步骤1新创建的对象作为<code>this</code>的上下文 ；</li>\n<li>如果该函数没有返回对象，则返回<code>this</code>。</li>\n</ol>\n<h4 id=\"当代码-new-Foo-执行时，会发生以下事情：\"><a href=\"#当代码-new-Foo-执行时，会发生以下事情：\" class=\"headerlink\" title=\"当代码 new Foo(...) 执行时，会发生以下事情：\"></a><strong>当代码 <code>new Foo(...)</code> 执行时，会发生以下事情：</strong></h4><ol>\n<li>一个继承自 <code>Foo.prototype</code> 的新对象被创建。</li>\n<li>使用指定的参数调用构造函数 <em><code>Foo</code><em>，并将 <code>this</code> 绑定到新创建的对象。<code>new Foo</code> 等同于 <em><code>new Foo</code></em><code>()</code>，也就是没有指定参数列表，</em><code>Foo</code></em> 不带任何参数调用的情况。</li>\n<li>由构造函数返回的对象就是 <code>new</code> 表达式的结果。如果构造函数没有显式返回一个对象，则使用步骤1创建的对象。（一般情况下，构造函数不返回值，但是用户可以选择主动返回对象，来覆盖正常的对象创建步骤）</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function create(Fn, ...args) &#123;</span><br><span class=\"line\">  let _this = &#123;&#125;;</span><br><span class=\"line\">  let result = Fn.apply(_this, args);</span><br><span class=\"line\">  _this.__proto__ = Fn.prototype;</span><br><span class=\"line\">  return typeof result === &#x27;object&#x27; ? result : _this;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"继承的方式\"><a href=\"#继承的方式\" class=\"headerlink\" title=\"继承的方式\"></a>继承的方式</h3><h4 id=\"原型链继承\"><a href=\"#原型链继承\" class=\"headerlink\" title=\"原型链继承\"></a>原型链继承</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Children.prototype = new Father();</span><br><span class=\"line\">Children.prototype.constructor = Children;</span><br></pre></td></tr></table></figure>\n\n<p>​        很简单的理解，就是直接将子类的原型修改为了父类的实例，然后再对实例的constructor进行一个校准，修改为子类的构造。</p>\n<p>​        执行new方法的行为的步骤：</p>\n<ul>\n<li>产生一个this指向，__proto__  的添加，指向为children.prototype。就是 Father的实例。</li>\n<li>执行children的构造函数，this指向的调用。</li>\n<li>返回。</li>\n</ul>\n<p><strong>缺点</strong>：</p>\n<ul>\n<li>对于要在原型上添加修改的方法，需要在 new Father 之后，因为这个是直接将一个地址进行了转换。</li>\n<li>其次就是不会将参数传递到父类。只适合不带参数的。</li>\n<li>因为实例是在直接对原型的创建，所以，所有的实例都是共有的。当然，因为这个创建本就无法带参数，共有实例其实并没有什么问题。</li>\n</ul>\n<h4 id=\"组合继承\"><a href=\"#组合继承\" class=\"headerlink\" title=\"组合继承\"></a>组合继承</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Children() &#123;</span><br><span class=\"line\">\tFather.call(this);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Children.prototype = new Father();</span><br><span class=\"line\">Children.prototype.constructor = Children;</span><br></pre></td></tr></table></figure>\n\n<p>​        这个和原型链继承大同小异，就是多了一个在构造函数内部使用call方法调用父类。使用call方法调用时是不会产生 __proto__  和 constructor 的。但是你可能会发现自己测试还是有啊，但是你仔细观察，其实你自己测试所生成的 __proto__  和 constructor 是在创建对象的时候生成的。所以，其实并没有真正的生成。</p>\n<p><strong>缺点</strong>：</p>\n<ul>\n<li>new 方法 和 call 方法都生成了一份实例。</li>\n</ul>\n<h4 id=\"寄生组合继承\"><a href=\"#寄生组合继承\" class=\"headerlink\" title=\"寄生组合继承\"></a>寄生组合继承</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Children() &#123;</span><br><span class=\"line\">\tFather.call(this);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">(function () &#123;</span><br><span class=\"line\">\tlet Super = function() &#123;&#125;;</span><br><span class=\"line\">\tSuper.prototype = Father.prototype;</span><br><span class=\"line\">\tChildren.prototype = new Super();</span><br><span class=\"line\">\tChildren.prototype.constructor = Children;</span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure>\n\n<p>​        我们可以查看这个和 组合继承的区别，使用了一个空方法将Father的原型复制了过来，所以new所生成的方法就只生成了一个空对象，和一个原型。Father的方法实则已经在call方法里面进行了调用。</p>\n<h5 id=\"寄生组合继承的思考\"><a href=\"#寄生组合继承的思考\" class=\"headerlink\" title=\"寄生组合继承的思考\"></a>寄生组合继承的思考</h5><p>为什么我们会这样使用寄生组合继承</p>\n<p>我们可以从各个方面进行思考，</p>\n<p>首先继承无非就是子类想要使用上父类的元素，然后这里就需要调用父类的方法</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Children() &#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Children.prototype = new Father();</span><br><span class=\"line\"></span><br><span class=\"line\">这个方法的问题是无法传参。</span><br><span class=\"line\">这里修改了原型指向，所以需要进行构造函数的指向转变</span><br><span class=\"line\">Children.prototype.constructor = Children;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Children() &#123;</span><br><span class=\"line\">\tlet instance = new Father(xxx);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\treturn instance;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">这个方法是可以传递参数了，但是这个方法就不是父类的实例了，因为是在子类被创建，所以我们要不就是对子类也同用这个instance对象进行操作。但是这样有点不符合一种规范</span><br><span class=\"line\">这里是使用了instance方式，而instance实则是父类的实例，所以如果需要进行子类实例的操作。需要在new Fahter的后面，然后将this转换成instance，然后对于proto和构造 函数都是父函数的。很有问题的感觉</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Children() &#123;</span><br><span class=\"line\">\tFather.call(this);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">在这里，我是将父元素的方法进行了执行，当然，如果是对于父元素返回的是一个对象的，那么将会是一个不同的操作，但是在正常的情况下，通过这个可以获取到父元素的构造函数执行方法，但是，问题在于没有原型指向的改变。所以我们需要进行原型指向的改变。</span><br><span class=\"line\">简单来说，这里已经获取到了父函数的实例对象，只需要将原型指向进行改变即可</span><br><span class=\"line\">Children.prototype = new Father();</span><br><span class=\"line\">Children.prototype.constructor = Children;</span><br><span class=\"line\">通过上面这个方法，我们获取到了原型的指向，修改为了父元素的实例。唯一的问题就是进行了两次Father的使用，可以考虑对于父函数的实例进行一个处理</span><br><span class=\"line\"></span><br><span class=\"line\">let Super = funtion() &#123;&#125;;</span><br><span class=\"line\">Super.prototype = Father.prototype;</span><br><span class=\"line\">Children.prototype = new Super();</span><br><span class=\"line\">Children.prototype.constructor = Children;</span><br><span class=\"line\">区别，new的是Super，Super里面没有实例，所以里面只有一个原型的指向。</span><br><span class=\"line\">而Super的原型的指向已经被修改为了Father的原型。</span><br><span class=\"line\">此时我们只需要在对构造函数进行一个修改即可。</span><br></pre></td></tr></table></figure>\n\n\n\n<p>所以最后我们使用了寄生组合继承，方式就是在内部使用call方法调用了父函数，获取了父函数的实例方法，然后在外部创建一个空函数，原型指向了父函数的原型，然后再对其实例赋值给了子类的原型，此时因为空函数的实例内部是没有的，所以其实内部的共有属性就只有proto，和 constructor。然后在修改原型的构造。</p>\n<p>​        所以整的来说，这个方式，只生成了相同的父类的实例的方法，并且放在了子类的实例中，所以不会出现共有属性，其次就是原型是在外部进行的实现，所以原型又是共有的。其次就是对原型的构造函数进行了指向。</p>\n<p>​        所以很完美。</p>\n","site":{"data":{}},"excerpt":"","more":"<p> <strong>注意：</strong></p>\n<p><strong>这里的内容为本人的理解，不敢保正。</strong></p>\n<h1 id=\"JavaScript原型链\"><a href=\"#JavaScript原型链\" class=\"headerlink\" title=\"JavaScript原型链\"></a>JavaScript原型链</h1><p>先看一张图，简单来说</p>\n<p>​        原型其实就是一个方法的实例，然后每一个方法的实例有一个__proto__ 的指向。这个指向会直到指到null为止。这样所生产的就是一个原型链，对于在本层找不到的方法，会通过原型链逐层向上查找。</p>\n<p>​        一个方法是和一个原型对应的，而一个原型又是一个另一个方法的实例，所以这里的对应关系在于，一个方法的实例默认是没有constructor构造函数，此时这个实例就是一个单纯的底层实例，但是如果我们将一个构造函数的原型指向了这个实例，并且将这个实例的构造器指向了原型， 那么这个实例就已经算是一个原型了，此时就已经不是一个单纯的底层实例了。</p>\n<p>​        顶层的方法就是 Function，顶层的原型就是Object.prototype，而Object方法确实使用了Function的原型。</p>\n<img src=\"/.io//290701352241158.jpg\" alt=\"290701352241158\" style=\"zoom:67%;\">\n\n\n\n<h1 id=\"JavaScript-继承\"><a href=\"#JavaScript-继承\" class=\"headerlink\" title=\"JavaScript 继承\"></a>JavaScript 继承</h1><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Fn() &#123;</span><br><span class=\"line\">  this.name = 1;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">let a = new Fn();</span><br><span class=\"line\"></span><br><span class=\"line\">此时的</span><br><span class=\"line\">a.__proto__ = Fn.prototype</span><br><span class=\"line\">a.__proto__.constructor = Fn;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"new-方法的行为\"><a href=\"#new-方法的行为\" class=\"headerlink\" title=\"new 方法的行为\"></a>new 方法的行为</h2><p>​        我们要这样思考，这个new方法。</p>\n<ul>\n<li>new 一个方法，会创建的一个this的指向。</li>\n<li>然后会执行这个方法，执行结束之后。</li>\n<li>创建一个 __proto__  指向了 方法的 prototype 的指向。</li>\n<li>然后就进行返回。</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let _this = &#123;&#125;;</span><br><span class=\"line\">let result = Fn.apply(_this, args);</span><br><span class=\"line\">_this.__proto__ = Fn.prototype;</span><br><span class=\"line\">return typeof result === &#x27;object&#x27; ? result : __this__;</span><br></pre></td></tr></table></figure>\n\n<p>​        同时这里，在进行 new 方法的调用时，我们知道，如果返回的是一个引用类型，那么便会直接返回这个引用类型，如果返回的是一个值类型，那么返回的便是自己所创建的this指向。我们可以知道一个引用类型，无论你是使用的new方法，还是直接进行的创建的引用类型。其结果都会创建原型。</p>\n<p><strong>注意</strong>：</p>\n<p>​        对于一个值类型，进行了new 方法，也会变成引用类型的。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let x = new Number(1);</span><br><span class=\"line\">let y = new Number(1);</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(x === y); //false</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"JavaScript-继承：\"><a href=\"#JavaScript-继承：\" class=\"headerlink\" title=\"JavaScript 继承：\"></a><strong>JavaScript 继承</strong>：</h2><h3 id=\"继承的思路\"><a href=\"#继承的思路\" class=\"headerlink\" title=\"继承的思路\"></a>继承的思路</h3><p>继承，简单的理解就是，子类的实例可以访问父类的方法</p>\n<p>同时我们可以知道，父类的方法，创建的实例才能进行调用。</p>\n<p>而父类的prototype，已经可以算作为父类的父类的方法了。</p>\n<p>所以，我们在不考虑上级的方法之前，需要将父类的方法进行传递，</p>\n<p>这里，可以考虑使用一个新的对象进行指定。如果我一个新对象</p>\n<h3 id=\"原型和构造器\"><a href=\"#原型和构造器\" class=\"headerlink\" title=\"原型和构造器\"></a>原型和构造器</h3><p>这里和Java的一个不同点</p>\n<p>我印象中，Java是子类有多个，父类越来越少的一种情况，</p>\n<img src=\"/.io//image-20211110100356010.png\" alt=\"image-20211110100356010\" style=\"zoom:67%;\">\n\n<p>​        一开始，我是这样思考的，构造函数和实例是对应的，而构造函数的原型应该是属于上层的一个实例了。</p>\n<p>​        但是你仔细观察，发现，一个构造函数的原型是和构造函数进行了对应。思想应该是每个实例都有一个原型，但是其原型默认是没有constructor的（这里可以使用 hasOwnProperty 进行证明）。我们所使用的constructor属性其实都是我们的实例的原型  __proto__ 中的constructor，但是实例的原型为什么会带有constructor，这里我的认为是，一个函数默认在词法编译阶段，会默认指向一个prototype，而这个行为就是 </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Fn.protorype = new Object();</span><br><span class=\"line\">Fn.prototype.constructor = Fn;</span><br></pre></td></tr></table></figure>\n\n<p>​    简单来说，就是在没有指定的情况下，默认先创建一个顶级的对象实例，里面只有最原始的方法，然后再对这个实例创建一个本函数的构造行为。</p>\n<img src=\"/.io//image-20211110101346723.png\" alt=\"image-20211110101346723\" style=\"zoom:67%;\">\n\n<p>​        而这个JavaScript是每个子类，都会将父类进行一次实例的操作，所以造成了每个父类的实例和子类的构造函数一一对应了。</p>\n<h3 id=\"new-方法实现\"><a href=\"#new-方法实现\" class=\"headerlink\" title=\"new 方法实现\"></a>new 方法实现</h3><h4 id=\"new-关键字会进行如下的操作：\"><a href=\"#new-关键字会进行如下的操作：\" class=\"headerlink\" title=\"new 关键字会进行如下的操作：\"></a><strong><code>new</code> 关键字会进行如下的操作：</strong></h4><ol>\n<li>创建一个空的简单JavaScript对象（即<code>&#123;&#125;</code>）；</li>\n<li>为步骤1新创建的对象添加属性**<strong>proto</strong>**，将该属性链接至构造函数的原型对象 ；</li>\n<li>将步骤1新创建的对象作为<code>this</code>的上下文 ；</li>\n<li>如果该函数没有返回对象，则返回<code>this</code>。</li>\n</ol>\n<h4 id=\"当代码-new-Foo-执行时，会发生以下事情：\"><a href=\"#当代码-new-Foo-执行时，会发生以下事情：\" class=\"headerlink\" title=\"当代码 new Foo(...) 执行时，会发生以下事情：\"></a><strong>当代码 <code>new Foo(...)</code> 执行时，会发生以下事情：</strong></h4><ol>\n<li>一个继承自 <code>Foo.prototype</code> 的新对象被创建。</li>\n<li>使用指定的参数调用构造函数 <em><code>Foo</code><em>，并将 <code>this</code> 绑定到新创建的对象。<code>new Foo</code> 等同于 <em><code>new Foo</code></em><code>()</code>，也就是没有指定参数列表，</em><code>Foo</code></em> 不带任何参数调用的情况。</li>\n<li>由构造函数返回的对象就是 <code>new</code> 表达式的结果。如果构造函数没有显式返回一个对象，则使用步骤1创建的对象。（一般情况下，构造函数不返回值，但是用户可以选择主动返回对象，来覆盖正常的对象创建步骤）</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function create(Fn, ...args) &#123;</span><br><span class=\"line\">  let _this = &#123;&#125;;</span><br><span class=\"line\">  let result = Fn.apply(_this, args);</span><br><span class=\"line\">  _this.__proto__ = Fn.prototype;</span><br><span class=\"line\">  return typeof result === &#x27;object&#x27; ? result : _this;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"继承的方式\"><a href=\"#继承的方式\" class=\"headerlink\" title=\"继承的方式\"></a>继承的方式</h3><h4 id=\"原型链继承\"><a href=\"#原型链继承\" class=\"headerlink\" title=\"原型链继承\"></a>原型链继承</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Children.prototype = new Father();</span><br><span class=\"line\">Children.prototype.constructor = Children;</span><br></pre></td></tr></table></figure>\n\n<p>​        很简单的理解，就是直接将子类的原型修改为了父类的实例，然后再对实例的constructor进行一个校准，修改为子类的构造。</p>\n<p>​        执行new方法的行为的步骤：</p>\n<ul>\n<li>产生一个this指向，__proto__  的添加，指向为children.prototype。就是 Father的实例。</li>\n<li>执行children的构造函数，this指向的调用。</li>\n<li>返回。</li>\n</ul>\n<p><strong>缺点</strong>：</p>\n<ul>\n<li>对于要在原型上添加修改的方法，需要在 new Father 之后，因为这个是直接将一个地址进行了转换。</li>\n<li>其次就是不会将参数传递到父类。只适合不带参数的。</li>\n<li>因为实例是在直接对原型的创建，所以，所有的实例都是共有的。当然，因为这个创建本就无法带参数，共有实例其实并没有什么问题。</li>\n</ul>\n<h4 id=\"组合继承\"><a href=\"#组合继承\" class=\"headerlink\" title=\"组合继承\"></a>组合继承</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Children() &#123;</span><br><span class=\"line\">\tFather.call(this);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Children.prototype = new Father();</span><br><span class=\"line\">Children.prototype.constructor = Children;</span><br></pre></td></tr></table></figure>\n\n<p>​        这个和原型链继承大同小异，就是多了一个在构造函数内部使用call方法调用父类。使用call方法调用时是不会产生 __proto__  和 constructor 的。但是你可能会发现自己测试还是有啊，但是你仔细观察，其实你自己测试所生成的 __proto__  和 constructor 是在创建对象的时候生成的。所以，其实并没有真正的生成。</p>\n<p><strong>缺点</strong>：</p>\n<ul>\n<li>new 方法 和 call 方法都生成了一份实例。</li>\n</ul>\n<h4 id=\"寄生组合继承\"><a href=\"#寄生组合继承\" class=\"headerlink\" title=\"寄生组合继承\"></a>寄生组合继承</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Children() &#123;</span><br><span class=\"line\">\tFather.call(this);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">(function () &#123;</span><br><span class=\"line\">\tlet Super = function() &#123;&#125;;</span><br><span class=\"line\">\tSuper.prototype = Father.prototype;</span><br><span class=\"line\">\tChildren.prototype = new Super();</span><br><span class=\"line\">\tChildren.prototype.constructor = Children;</span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure>\n\n<p>​        我们可以查看这个和 组合继承的区别，使用了一个空方法将Father的原型复制了过来，所以new所生成的方法就只生成了一个空对象，和一个原型。Father的方法实则已经在call方法里面进行了调用。</p>\n<h5 id=\"寄生组合继承的思考\"><a href=\"#寄生组合继承的思考\" class=\"headerlink\" title=\"寄生组合继承的思考\"></a>寄生组合继承的思考</h5><p>为什么我们会这样使用寄生组合继承</p>\n<p>我们可以从各个方面进行思考，</p>\n<p>首先继承无非就是子类想要使用上父类的元素，然后这里就需要调用父类的方法</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Children() &#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Children.prototype = new Father();</span><br><span class=\"line\"></span><br><span class=\"line\">这个方法的问题是无法传参。</span><br><span class=\"line\">这里修改了原型指向，所以需要进行构造函数的指向转变</span><br><span class=\"line\">Children.prototype.constructor = Children;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Children() &#123;</span><br><span class=\"line\">\tlet instance = new Father(xxx);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\treturn instance;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">这个方法是可以传递参数了，但是这个方法就不是父类的实例了，因为是在子类被创建，所以我们要不就是对子类也同用这个instance对象进行操作。但是这样有点不符合一种规范</span><br><span class=\"line\">这里是使用了instance方式，而instance实则是父类的实例，所以如果需要进行子类实例的操作。需要在new Fahter的后面，然后将this转换成instance，然后对于proto和构造 函数都是父函数的。很有问题的感觉</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Children() &#123;</span><br><span class=\"line\">\tFather.call(this);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">在这里，我是将父元素的方法进行了执行，当然，如果是对于父元素返回的是一个对象的，那么将会是一个不同的操作，但是在正常的情况下，通过这个可以获取到父元素的构造函数执行方法，但是，问题在于没有原型指向的改变。所以我们需要进行原型指向的改变。</span><br><span class=\"line\">简单来说，这里已经获取到了父函数的实例对象，只需要将原型指向进行改变即可</span><br><span class=\"line\">Children.prototype = new Father();</span><br><span class=\"line\">Children.prototype.constructor = Children;</span><br><span class=\"line\">通过上面这个方法，我们获取到了原型的指向，修改为了父元素的实例。唯一的问题就是进行了两次Father的使用，可以考虑对于父函数的实例进行一个处理</span><br><span class=\"line\"></span><br><span class=\"line\">let Super = funtion() &#123;&#125;;</span><br><span class=\"line\">Super.prototype = Father.prototype;</span><br><span class=\"line\">Children.prototype = new Super();</span><br><span class=\"line\">Children.prototype.constructor = Children;</span><br><span class=\"line\">区别，new的是Super，Super里面没有实例，所以里面只有一个原型的指向。</span><br><span class=\"line\">而Super的原型的指向已经被修改为了Father的原型。</span><br><span class=\"line\">此时我们只需要在对构造函数进行一个修改即可。</span><br></pre></td></tr></table></figure>\n\n\n\n<p>所以最后我们使用了寄生组合继承，方式就是在内部使用call方法调用了父函数，获取了父函数的实例方法，然后在外部创建一个空函数，原型指向了父函数的原型，然后再对其实例赋值给了子类的原型，此时因为空函数的实例内部是没有的，所以其实内部的共有属性就只有proto，和 constructor。然后在修改原型的构造。</p>\n<p>​        所以整的来说，这个方式，只生成了相同的父类的实例的方法，并且放在了子类的实例中，所以不会出现共有属性，其次就是原型是在外部进行的实现，所以原型又是共有的。其次就是对原型的构造函数进行了指向。</p>\n<p>​        所以很完美。</p>\n"},{"title":"函数柯里化","date":"2021-11-12T08:57:59.000Z","_content":"\n\n\n#  JavaScript函数柯里化 Curry\n\n​\t\t就是说一次性只传入一个参数，后续的参数要后面才进行传递，可以实现函数的一个参数的复用效果。\n\n\n\n## 实现\n\n​\t\t首先是要确认参数的个数，这里，我看到别人是使用的 fn.length，进行的获取，所以实验了一番，发现方法的length指的是参数的个数。\n\n​\t\t使用fn.length获取了方法的参数的个数，使用剩余参数将传递进来的参数存放入数组，然后再个数足够时运行方法即可。\n\n​\t\t一步一步的理解。\n\n```\n// ...args，剩余参数，将后面的参数都作为一个数组进行实现。剩余参数必须放最后一个。\nfunction curry(fn, ...args) {\n\t// 将this的指向存储下来，后续调用时会用。\n  let _this = this;\n  //\tfn.length，这个方法可以获取到方法的参数个数。\n  let len = fn.length;\n\n\t//\t同样的，返回一个方法，然后使用剩余参数法则。\n  return function (..._args) {\n    // let _args = Object.values(arguments);\n    //这里使用的是 unshift，没有使用push，是因为，为了避免修改了前面的args值，所以是修改的每一次的_args，如果使用push的话，你对这个函数重复调用也会被存储进去，因为这个是上层的参数，是公用的。\n    _args.unshift(...args);\n    // console.log(arguments.callee);\t//获取被调用的函数，这里报错了，原因没有看，因为这个方式已经不建议使用了。\n\n\t\t//\t这里是当参数的个数不够时，继续调用这个外层方法。\n    if (_args.length < len) {\n    \t//这里，只能重新调用外层的方法，如果调用内层的方法的话，参数会无法添加成功，因为内层方法的参数是基于外层的添加。\n      return curry.call(_this, fn, ..._args);\n    }\n\n\t\t//\t参数够了，调用方法。\n    return fn.apply(_this, _args);\n  }\n}\n```\n\n","source":"_posts/JavaScript/概念/函数柯里化.md","raw":"---\ntitle: 函数柯里化\ndate: 2021-11-12 16:57:59\ntags:\n - JavaScript\n - 随笔\ncategories:\n - JavaScript\n - 随笔\n---\n\n\n\n#  JavaScript函数柯里化 Curry\n\n​\t\t就是说一次性只传入一个参数，后续的参数要后面才进行传递，可以实现函数的一个参数的复用效果。\n\n\n\n## 实现\n\n​\t\t首先是要确认参数的个数，这里，我看到别人是使用的 fn.length，进行的获取，所以实验了一番，发现方法的length指的是参数的个数。\n\n​\t\t使用fn.length获取了方法的参数的个数，使用剩余参数将传递进来的参数存放入数组，然后再个数足够时运行方法即可。\n\n​\t\t一步一步的理解。\n\n```\n// ...args，剩余参数，将后面的参数都作为一个数组进行实现。剩余参数必须放最后一个。\nfunction curry(fn, ...args) {\n\t// 将this的指向存储下来，后续调用时会用。\n  let _this = this;\n  //\tfn.length，这个方法可以获取到方法的参数个数。\n  let len = fn.length;\n\n\t//\t同样的，返回一个方法，然后使用剩余参数法则。\n  return function (..._args) {\n    // let _args = Object.values(arguments);\n    //这里使用的是 unshift，没有使用push，是因为，为了避免修改了前面的args值，所以是修改的每一次的_args，如果使用push的话，你对这个函数重复调用也会被存储进去，因为这个是上层的参数，是公用的。\n    _args.unshift(...args);\n    // console.log(arguments.callee);\t//获取被调用的函数，这里报错了，原因没有看，因为这个方式已经不建议使用了。\n\n\t\t//\t这里是当参数的个数不够时，继续调用这个外层方法。\n    if (_args.length < len) {\n    \t//这里，只能重新调用外层的方法，如果调用内层的方法的话，参数会无法添加成功，因为内层方法的参数是基于外层的添加。\n      return curry.call(_this, fn, ..._args);\n    }\n\n\t\t//\t参数够了，调用方法。\n    return fn.apply(_this, _args);\n  }\n}\n```\n\n","slug":"JavaScript/概念/函数柯里化","published":1,"updated":"2021-12-09T01:56:49.404Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckznhkk8o006zikubhan2ht1q","content":"<h1 id=\"JavaScript函数柯里化-Curry\"><a href=\"#JavaScript函数柯里化-Curry\" class=\"headerlink\" title=\"JavaScript函数柯里化 Curry\"></a>JavaScript函数柯里化 Curry</h1><p>​        就是说一次性只传入一个参数，后续的参数要后面才进行传递，可以实现函数的一个参数的复用效果。</p>\n<h2 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h2><p>​        首先是要确认参数的个数，这里，我看到别人是使用的 fn.length，进行的获取，所以实验了一番，发现方法的length指的是参数的个数。</p>\n<p>​        使用fn.length获取了方法的参数的个数，使用剩余参数将传递进来的参数存放入数组，然后再个数足够时运行方法即可。</p>\n<p>​        一步一步的理解。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// ...args，剩余参数，将后面的参数都作为一个数组进行实现。剩余参数必须放最后一个。</span><br><span class=\"line\">function curry(fn, ...args) &#123;</span><br><span class=\"line\">\t// 将this的指向存储下来，后续调用时会用。</span><br><span class=\"line\">  let _this = this;</span><br><span class=\"line\">  //\tfn.length，这个方法可以获取到方法的参数个数。</span><br><span class=\"line\">  let len = fn.length;</span><br><span class=\"line\"></span><br><span class=\"line\">\t//\t同样的，返回一个方法，然后使用剩余参数法则。</span><br><span class=\"line\">  return function (..._args) &#123;</span><br><span class=\"line\">    // let _args = Object.values(arguments);</span><br><span class=\"line\">    //这里使用的是 unshift，没有使用push，是因为，为了避免修改了前面的args值，所以是修改的每一次的_args，如果使用push的话，你对这个函数重复调用也会被存储进去，因为这个是上层的参数，是公用的。</span><br><span class=\"line\">    _args.unshift(...args);</span><br><span class=\"line\">    // console.log(arguments.callee);\t//获取被调用的函数，这里报错了，原因没有看，因为这个方式已经不建议使用了。</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t//\t这里是当参数的个数不够时，继续调用这个外层方法。</span><br><span class=\"line\">    if (_args.length &lt; len) &#123;</span><br><span class=\"line\">    \t//这里，只能重新调用外层的方法，如果调用内层的方法的话，参数会无法添加成功，因为内层方法的参数是基于外层的添加。</span><br><span class=\"line\">      return curry.call(_this, fn, ..._args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t//\t参数够了，调用方法。</span><br><span class=\"line\">    return fn.apply(_this, _args);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"JavaScript函数柯里化-Curry\"><a href=\"#JavaScript函数柯里化-Curry\" class=\"headerlink\" title=\"JavaScript函数柯里化 Curry\"></a>JavaScript函数柯里化 Curry</h1><p>​        就是说一次性只传入一个参数，后续的参数要后面才进行传递，可以实现函数的一个参数的复用效果。</p>\n<h2 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h2><p>​        首先是要确认参数的个数，这里，我看到别人是使用的 fn.length，进行的获取，所以实验了一番，发现方法的length指的是参数的个数。</p>\n<p>​        使用fn.length获取了方法的参数的个数，使用剩余参数将传递进来的参数存放入数组，然后再个数足够时运行方法即可。</p>\n<p>​        一步一步的理解。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// ...args，剩余参数，将后面的参数都作为一个数组进行实现。剩余参数必须放最后一个。</span><br><span class=\"line\">function curry(fn, ...args) &#123;</span><br><span class=\"line\">\t// 将this的指向存储下来，后续调用时会用。</span><br><span class=\"line\">  let _this = this;</span><br><span class=\"line\">  //\tfn.length，这个方法可以获取到方法的参数个数。</span><br><span class=\"line\">  let len = fn.length;</span><br><span class=\"line\"></span><br><span class=\"line\">\t//\t同样的，返回一个方法，然后使用剩余参数法则。</span><br><span class=\"line\">  return function (..._args) &#123;</span><br><span class=\"line\">    // let _args = Object.values(arguments);</span><br><span class=\"line\">    //这里使用的是 unshift，没有使用push，是因为，为了避免修改了前面的args值，所以是修改的每一次的_args，如果使用push的话，你对这个函数重复调用也会被存储进去，因为这个是上层的参数，是公用的。</span><br><span class=\"line\">    _args.unshift(...args);</span><br><span class=\"line\">    // console.log(arguments.callee);\t//获取被调用的函数，这里报错了，原因没有看，因为这个方式已经不建议使用了。</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t//\t这里是当参数的个数不够时，继续调用这个外层方法。</span><br><span class=\"line\">    if (_args.length &lt; len) &#123;</span><br><span class=\"line\">    \t//这里，只能重新调用外层的方法，如果调用内层的方法的话，参数会无法添加成功，因为内层方法的参数是基于外层的添加。</span><br><span class=\"line\">      return curry.call(_this, fn, ..._args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t//\t参数够了，调用方法。</span><br><span class=\"line\">    return fn.apply(_this, _args);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n"},{"title":"数组的emptyItems","date":"2021-11-13T13:45:21.000Z","_content":"\n\n\n#  数组的empty-items\n\n## empty的产生\n\n​\t\t首先，先说一下如何产生empty\n\n* 使用 new Array函数进行创建，并没有初始化\n\n```\nlet a = new Array(10);\nconsole.log(a);\n```\n\n* 使用 length方法重新定义了长度，长度比原来的数组长，那么会导致多余的变为 empty-items。\n\n```\nlet a = [1];\na.length = 10;\n```\n\n\n\n## empty的问题\n\n​\t\t开始我也没有在意这个empty的问题，但是后来发现对于empty-items 使用一些方法是不会进行循环的。这就造成了很大的问题。\n\n* map等数组的高阶函数，\n* forin循环\n\n```\nlet a = new Array(10);\n\na.map((v) => {\n  console.log(v);\n})\n\nfor (const key in a) {\n  console.log(a[key])\n}\n```\n\n​\t\t但是forof循环是可以的，fori循环也可以，输出的值就是undefined。\n\n\n\n## 原因\n\n当然具体的原因我也不知道，我们可以这样理解，JavaScript的数组也是一个特殊的对象形式，所以对于这些empty-items，其实并没有真正的存在，就类似于一种离散的数组形式，所以为什么循环不到，因为对于不存在的是无法循环的。但是为什么forof是可以循环的呢，我们也许可以这样思考，forof是使用的迭代器循环，所以并不是循环到了，只是这是一个数组的迭代器的形式，所以这样才成功的循环了。\n\n","source":"_posts/JavaScript/概念/数组的emptyItems.md","raw":"---\ntitle: 数组的emptyItems\ndate: 2021-11-13 21:45:21\ntags:\n - JavaScript\n - Array\n - 随笔\ncategories:\n - JavaScript\n - 随笔\n---\n\n\n\n#  数组的empty-items\n\n## empty的产生\n\n​\t\t首先，先说一下如何产生empty\n\n* 使用 new Array函数进行创建，并没有初始化\n\n```\nlet a = new Array(10);\nconsole.log(a);\n```\n\n* 使用 length方法重新定义了长度，长度比原来的数组长，那么会导致多余的变为 empty-items。\n\n```\nlet a = [1];\na.length = 10;\n```\n\n\n\n## empty的问题\n\n​\t\t开始我也没有在意这个empty的问题，但是后来发现对于empty-items 使用一些方法是不会进行循环的。这就造成了很大的问题。\n\n* map等数组的高阶函数，\n* forin循环\n\n```\nlet a = new Array(10);\n\na.map((v) => {\n  console.log(v);\n})\n\nfor (const key in a) {\n  console.log(a[key])\n}\n```\n\n​\t\t但是forof循环是可以的，fori循环也可以，输出的值就是undefined。\n\n\n\n## 原因\n\n当然具体的原因我也不知道，我们可以这样理解，JavaScript的数组也是一个特殊的对象形式，所以对于这些empty-items，其实并没有真正的存在，就类似于一种离散的数组形式，所以为什么循环不到，因为对于不存在的是无法循环的。但是为什么forof是可以循环的呢，我们也许可以这样思考，forof是使用的迭代器循环，所以并不是循环到了，只是这是一个数组的迭代器的形式，所以这样才成功的循环了。\n\n","slug":"JavaScript/概念/数组的emptyItems","published":1,"updated":"2021-12-09T01:56:49.404Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckznhkk8p0071ikubb83xg2wc","content":"<h1 id=\"数组的empty-items\"><a href=\"#数组的empty-items\" class=\"headerlink\" title=\"数组的empty-items\"></a>数组的empty-items</h1><h2 id=\"empty的产生\"><a href=\"#empty的产生\" class=\"headerlink\" title=\"empty的产生\"></a>empty的产生</h2><p>​        首先，先说一下如何产生empty</p>\n<ul>\n<li>使用 new Array函数进行创建，并没有初始化</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let a = new Array(10);</span><br><span class=\"line\">console.log(a);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>使用 length方法重新定义了长度，长度比原来的数组长，那么会导致多余的变为 empty-items。</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let a = [1];</span><br><span class=\"line\">a.length = 10;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"empty的问题\"><a href=\"#empty的问题\" class=\"headerlink\" title=\"empty的问题\"></a>empty的问题</h2><p>​        开始我也没有在意这个empty的问题，但是后来发现对于empty-items 使用一些方法是不会进行循环的。这就造成了很大的问题。</p>\n<ul>\n<li>map等数组的高阶函数，</li>\n<li>forin循环</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let a = new Array(10);</span><br><span class=\"line\"></span><br><span class=\"line\">a.map((v) =&gt; &#123;</span><br><span class=\"line\">  console.log(v);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">for (const key in a) &#123;</span><br><span class=\"line\">  console.log(a[key])</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>​        但是forof循环是可以的，fori循环也可以，输出的值就是undefined。</p>\n<h2 id=\"原因\"><a href=\"#原因\" class=\"headerlink\" title=\"原因\"></a>原因</h2><p>当然具体的原因我也不知道，我们可以这样理解，JavaScript的数组也是一个特殊的对象形式，所以对于这些empty-items，其实并没有真正的存在，就类似于一种离散的数组形式，所以为什么循环不到，因为对于不存在的是无法循环的。但是为什么forof是可以循环的呢，我们也许可以这样思考，forof是使用的迭代器循环，所以并不是循环到了，只是这是一个数组的迭代器的形式，所以这样才成功的循环了。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"数组的empty-items\"><a href=\"#数组的empty-items\" class=\"headerlink\" title=\"数组的empty-items\"></a>数组的empty-items</h1><h2 id=\"empty的产生\"><a href=\"#empty的产生\" class=\"headerlink\" title=\"empty的产生\"></a>empty的产生</h2><p>​        首先，先说一下如何产生empty</p>\n<ul>\n<li>使用 new Array函数进行创建，并没有初始化</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let a = new Array(10);</span><br><span class=\"line\">console.log(a);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>使用 length方法重新定义了长度，长度比原来的数组长，那么会导致多余的变为 empty-items。</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let a = [1];</span><br><span class=\"line\">a.length = 10;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"empty的问题\"><a href=\"#empty的问题\" class=\"headerlink\" title=\"empty的问题\"></a>empty的问题</h2><p>​        开始我也没有在意这个empty的问题，但是后来发现对于empty-items 使用一些方法是不会进行循环的。这就造成了很大的问题。</p>\n<ul>\n<li>map等数组的高阶函数，</li>\n<li>forin循环</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let a = new Array(10);</span><br><span class=\"line\"></span><br><span class=\"line\">a.map((v) =&gt; &#123;</span><br><span class=\"line\">  console.log(v);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">for (const key in a) &#123;</span><br><span class=\"line\">  console.log(a[key])</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>​        但是forof循环是可以的，fori循环也可以，输出的值就是undefined。</p>\n<h2 id=\"原因\"><a href=\"#原因\" class=\"headerlink\" title=\"原因\"></a>原因</h2><p>当然具体的原因我也不知道，我们可以这样理解，JavaScript的数组也是一个特殊的对象形式，所以对于这些empty-items，其实并没有真正的存在，就类似于一种离散的数组形式，所以为什么循环不到，因为对于不存在的是无法循环的。但是为什么forof是可以循环的呢，我们也许可以这样思考，forof是使用的迭代器循环，所以并不是循环到了，只是这是一个数组的迭代器的形式，所以这样才成功的循环了。</p>\n"},{"title":"数据类型判断","date":"2021-10-17T07:08:23.000Z","_content":"\n\n\n\n# JavaScript判断数据的类型的方法\n\n\n\n```\nlet obj = {\n  a: 1,\n  h: new Number(3),\n\n  b: 'a',\n  i: new String('12'),\n  q: `sdcard`,\n\n  c: true,\n  j: new Boolean(false),\n\n  f: [1, 2, 3],\n  g: ['1', '3'],\n\n  k: new Object({ a: 3} ),\n  l: { b: 4 },\n\n  o: new RegExp('sss'),\n  p: /sss/,\n\n  d: undefined,\n  e: null,\n  n: new Date(),\n  m: function () {},\n  r: new Set([2, '1', 'aaa']),\n  s: new Map([['a', 1], [2, 'aa'], ['xxx', 123]]),\n  t: Symbol(1),\n}\n```\n\n## typeof\n\n```\nhttps://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/typeof\n```\n\n```\nfor (const k in obj) {\n  console.log(' --  ');\n  console.log(obj[k]);\n  console.log(typeof obj[k]);\n}\n```\n\n```\n --\n1\nnumber\n --\n[Number: 3]\nobject\n --\na\nstring\n --\n[String: '12']\nobject\n --\nsdcard\nstring\n --\ntrue\nboolean\n --\n[Boolean: false]\nobject\n --\n[ 1, 2, 3 ]\nobject\n --\n[ '1', '3' ]\nobject\n --\n{ a: 3 }\nobject\n --\n{ b: 4 }\nobject\n --\n/sss/\nobject\n --\n/sss/\nobject\n --\nundefined\nundefined\n --\nnull\nobject\n --\n2021-10-20T01:55:29.835Z\nobject\n --\n[Function: m]\nfunction\n --\nSet(3) { 2, '1', 'aaa' }\nobject\n --\nMap(3) { 'a' => 1, 2 => 'aa', 'xxx' => 123 }\nobject\n --\nSymbol(1)\nsymbol\n```\n\n这里的话，主要问题是在于\n\n​\t一个是,只能把数据分为基本数据类型和对象,并且使用new方法调用的就为对象.\n\n​\t一个是 null  的 typeof 的值为 object，至于原因的话\n\n```\nhttps://2ality.com/2013/10/typeof-null.html\n```\n\n通过这篇文章我们可以知道原理，我这里就简单的说一下\n\n```\n首先，早期的JavaScript是通过值的低1位或3位来辨别类型的。\n又下面所示\n```\n\n```\n000：对象。数据是对对象的引用。\n1：整数。数据是一个 31 位有符号整数。\n010：双倍。数据是对双浮点数的引用。\n100：字符串。数据是对字符串的引用。\n110：布尔值。数据是一个布尔值。\n\nundefined，用整数−2^30（负2的30次方，不在整型的范围内）\nnull，机器码空指针（C/C++ 宏定义），低三位也是000\n```\n\n```\n所以就出现了这种 typeof null = 'object';\n```\n\n\n\n## instanceof\n\n```\nhttps://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/instanceof\n```\n\n`instanceof` 运算符用于检测构造函数的 `prototype` 属性是否出现在某个实例对象的原型链上。\n\n```\nconsole.log('a ----     ' + a instanceof Number);\n```\n\n```\n对于基本数据类型会直接返回false。而不会再内部构建对应的引用类型.\n\n否则的话，就会先通过 Object.getPrototypeOf 获得参数的原型对象。然后判断这个和你要判断的对象是否相等，不想等则会继续向上，直到相等或者为 null 时。\n```\n\n\n\n## constructor\n\n```\nhttps://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Classes/constructor\n```\n\n**`constructor `**是一种用于创建和初始化`class`创建的对象的特殊方法。\n\n你可以这样理解，一个对象的constructor的指向的是他所 new 而指向的方法。\n\n```\nfunction O() {}\nlet o = new O();\n\no.constructor === O; //true\n```\n\n```\nconsole.log('a ----     ' + (a.constructor === Number));\ntrue\n```\n\n```\n这里，在a调用constructor的时候，会在内部创建一个值为a的对象，然后再调用这个constructor方法，然后再将这个对象删除，所以这个是基本数据类型也可以进行判断的。\n```\n\n```\n这个输出的值是 a的构造器所指向的一个函数。在这里就是指向的Number，\n问题：这个因为是通过判断其构造器函数来进行的判断，所以如果我们将对其进行过修改则会判断错误。\n```\n\n```\nfunction Fn() {}\nlet x = new Fn();\nFn.prototype = new Array();\nconsole.log(x.constructor === Fn)\t\t//true\nconsole.log(x.constructor === Array)\t//false\n```\n\n```\nfunction Fn() {}\nFn.prototype = new Array();\nlet x = new Fn();\nconsole.log(x.constructor === Fn)\t\t//false\nconsole.log(x.constructor === Array)\t//ture\n```\n\n```\n第一个是先new，然后在修改的原型。\n而第二个是先修改原型，然后再进行new方法的调用。\n然后结果就不一样了，所以说明了这个new方法会调用的是原型。\n所以其构造器会被修改。\n```\n\n通过上面这个代码我们可以知道，\n\n你可以这样想,一个new方法和其结果是平级的\n\n```\nlet a = new Fn();\na,和fn是平级的.\n```\n\n一个new方法，会将他的原型作为一个构造器,并将他自己进行一次`this`指向的调用.并创建一个 `__proto__` 指向了构造器的原型.\n\n```\nfunction Fn() {}\nlet x = new Fn();\nconsole.log(x.constructor === Fn)\t\t//true\nconsole.log(x.__proto__ === Fn.prototype)\t//true\n```\n\n\n\n## Object.prototype.toString.call()\n\n```\nhttps://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/toString\n```\n\n使用方法\n\n```\nObject.prototype.toString.call(a);\n这里通过调用了call方法，转换了this的指向。\n```\n\n```\nlet obj = {\n  a: 1,\n  h: new Number(3),\n\n  b: 'a',\n  i: new String('12'),\n  q: `sdcard`,\n\n  c: true,\n  j: new Boolean(false),\n\n  f: [1, 2, 3],\n  g: ['1', '3'],\n\n  k: new Object({ a: 3} ),\n  l: { b: 4 },\n\n  o: new RegExp('sss'),\n  p: /sss/,\n\n  d: undefined,\n  e: null,\n  n: new Date(),\n  m: function () {},\n  r: new Set([2, '1', 'aaa']),\n  s: new Map([['a', 1], [2, 'aa'], ['xxx', 123]]),\n}\n```\n\n```\nfor (const k in obj) {\n  console.log(' --  ');\n  console.log(obj[k]);\n  console.log(Object.prototype.toString.call(obj[k]));\n}\n```\n\n通过下面的结果我们可以看到,使用这个对象原型的方法可以说是没有任何问题啊.\n\n```\n --\n1\n[object Number]\n --\n[Number: 3]\n[object Number]\n --\na\n[object String]\n --\n[String: '12']\n[object String]\n --\nsdcard\n[object String]\n --\ntrue\n[object Boolean]\n --\n[Boolean: false]\n[object Boolean]\n --\n[ 1, 2, 3 ]\n[object Array]\n --\n[ '1', '3' ]\n[object Array]\n --\n{ a: 3 }\n[object Object]\n --\n{ b: 4 }\n[object Object]\n --\n/sss/\n[object RegExp]\n --\n/sss/\n[object RegExp]\n --\nundefined\n[object Undefined]\n --\nnull\n[object Null]\n --\n2021-10-20T01:55:45.116Z\n[object Date]\n --\n[Function: m]\n[object Function]\n --\nSet(3) { 2, '1', 'aaa' }\n[object Set]\n --\nMap(3) { 'a' => 1, 2 => 'aa', 'xxx' => 123 }\n[object Map]\n --\nSymbol(1)\n[object Symbol]\n```\n\n","source":"_posts/JavaScript/概念/数据类型判断.md","raw":"---\ntitle: 数据类型判断\ndate: 2021-10-17 15:08:23\ntags:\n  - JavaScript\n  - 数据类型判断\ncategories:\n - JavaScript\n---\n\n\n\n\n# JavaScript判断数据的类型的方法\n\n\n\n```\nlet obj = {\n  a: 1,\n  h: new Number(3),\n\n  b: 'a',\n  i: new String('12'),\n  q: `sdcard`,\n\n  c: true,\n  j: new Boolean(false),\n\n  f: [1, 2, 3],\n  g: ['1', '3'],\n\n  k: new Object({ a: 3} ),\n  l: { b: 4 },\n\n  o: new RegExp('sss'),\n  p: /sss/,\n\n  d: undefined,\n  e: null,\n  n: new Date(),\n  m: function () {},\n  r: new Set([2, '1', 'aaa']),\n  s: new Map([['a', 1], [2, 'aa'], ['xxx', 123]]),\n  t: Symbol(1),\n}\n```\n\n## typeof\n\n```\nhttps://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/typeof\n```\n\n```\nfor (const k in obj) {\n  console.log(' --  ');\n  console.log(obj[k]);\n  console.log(typeof obj[k]);\n}\n```\n\n```\n --\n1\nnumber\n --\n[Number: 3]\nobject\n --\na\nstring\n --\n[String: '12']\nobject\n --\nsdcard\nstring\n --\ntrue\nboolean\n --\n[Boolean: false]\nobject\n --\n[ 1, 2, 3 ]\nobject\n --\n[ '1', '3' ]\nobject\n --\n{ a: 3 }\nobject\n --\n{ b: 4 }\nobject\n --\n/sss/\nobject\n --\n/sss/\nobject\n --\nundefined\nundefined\n --\nnull\nobject\n --\n2021-10-20T01:55:29.835Z\nobject\n --\n[Function: m]\nfunction\n --\nSet(3) { 2, '1', 'aaa' }\nobject\n --\nMap(3) { 'a' => 1, 2 => 'aa', 'xxx' => 123 }\nobject\n --\nSymbol(1)\nsymbol\n```\n\n这里的话，主要问题是在于\n\n​\t一个是,只能把数据分为基本数据类型和对象,并且使用new方法调用的就为对象.\n\n​\t一个是 null  的 typeof 的值为 object，至于原因的话\n\n```\nhttps://2ality.com/2013/10/typeof-null.html\n```\n\n通过这篇文章我们可以知道原理，我这里就简单的说一下\n\n```\n首先，早期的JavaScript是通过值的低1位或3位来辨别类型的。\n又下面所示\n```\n\n```\n000：对象。数据是对对象的引用。\n1：整数。数据是一个 31 位有符号整数。\n010：双倍。数据是对双浮点数的引用。\n100：字符串。数据是对字符串的引用。\n110：布尔值。数据是一个布尔值。\n\nundefined，用整数−2^30（负2的30次方，不在整型的范围内）\nnull，机器码空指针（C/C++ 宏定义），低三位也是000\n```\n\n```\n所以就出现了这种 typeof null = 'object';\n```\n\n\n\n## instanceof\n\n```\nhttps://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/instanceof\n```\n\n`instanceof` 运算符用于检测构造函数的 `prototype` 属性是否出现在某个实例对象的原型链上。\n\n```\nconsole.log('a ----     ' + a instanceof Number);\n```\n\n```\n对于基本数据类型会直接返回false。而不会再内部构建对应的引用类型.\n\n否则的话，就会先通过 Object.getPrototypeOf 获得参数的原型对象。然后判断这个和你要判断的对象是否相等，不想等则会继续向上，直到相等或者为 null 时。\n```\n\n\n\n## constructor\n\n```\nhttps://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Classes/constructor\n```\n\n**`constructor `**是一种用于创建和初始化`class`创建的对象的特殊方法。\n\n你可以这样理解，一个对象的constructor的指向的是他所 new 而指向的方法。\n\n```\nfunction O() {}\nlet o = new O();\n\no.constructor === O; //true\n```\n\n```\nconsole.log('a ----     ' + (a.constructor === Number));\ntrue\n```\n\n```\n这里，在a调用constructor的时候，会在内部创建一个值为a的对象，然后再调用这个constructor方法，然后再将这个对象删除，所以这个是基本数据类型也可以进行判断的。\n```\n\n```\n这个输出的值是 a的构造器所指向的一个函数。在这里就是指向的Number，\n问题：这个因为是通过判断其构造器函数来进行的判断，所以如果我们将对其进行过修改则会判断错误。\n```\n\n```\nfunction Fn() {}\nlet x = new Fn();\nFn.prototype = new Array();\nconsole.log(x.constructor === Fn)\t\t//true\nconsole.log(x.constructor === Array)\t//false\n```\n\n```\nfunction Fn() {}\nFn.prototype = new Array();\nlet x = new Fn();\nconsole.log(x.constructor === Fn)\t\t//false\nconsole.log(x.constructor === Array)\t//ture\n```\n\n```\n第一个是先new，然后在修改的原型。\n而第二个是先修改原型，然后再进行new方法的调用。\n然后结果就不一样了，所以说明了这个new方法会调用的是原型。\n所以其构造器会被修改。\n```\n\n通过上面这个代码我们可以知道，\n\n你可以这样想,一个new方法和其结果是平级的\n\n```\nlet a = new Fn();\na,和fn是平级的.\n```\n\n一个new方法，会将他的原型作为一个构造器,并将他自己进行一次`this`指向的调用.并创建一个 `__proto__` 指向了构造器的原型.\n\n```\nfunction Fn() {}\nlet x = new Fn();\nconsole.log(x.constructor === Fn)\t\t//true\nconsole.log(x.__proto__ === Fn.prototype)\t//true\n```\n\n\n\n## Object.prototype.toString.call()\n\n```\nhttps://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/toString\n```\n\n使用方法\n\n```\nObject.prototype.toString.call(a);\n这里通过调用了call方法，转换了this的指向。\n```\n\n```\nlet obj = {\n  a: 1,\n  h: new Number(3),\n\n  b: 'a',\n  i: new String('12'),\n  q: `sdcard`,\n\n  c: true,\n  j: new Boolean(false),\n\n  f: [1, 2, 3],\n  g: ['1', '3'],\n\n  k: new Object({ a: 3} ),\n  l: { b: 4 },\n\n  o: new RegExp('sss'),\n  p: /sss/,\n\n  d: undefined,\n  e: null,\n  n: new Date(),\n  m: function () {},\n  r: new Set([2, '1', 'aaa']),\n  s: new Map([['a', 1], [2, 'aa'], ['xxx', 123]]),\n}\n```\n\n```\nfor (const k in obj) {\n  console.log(' --  ');\n  console.log(obj[k]);\n  console.log(Object.prototype.toString.call(obj[k]));\n}\n```\n\n通过下面的结果我们可以看到,使用这个对象原型的方法可以说是没有任何问题啊.\n\n```\n --\n1\n[object Number]\n --\n[Number: 3]\n[object Number]\n --\na\n[object String]\n --\n[String: '12']\n[object String]\n --\nsdcard\n[object String]\n --\ntrue\n[object Boolean]\n --\n[Boolean: false]\n[object Boolean]\n --\n[ 1, 2, 3 ]\n[object Array]\n --\n[ '1', '3' ]\n[object Array]\n --\n{ a: 3 }\n[object Object]\n --\n{ b: 4 }\n[object Object]\n --\n/sss/\n[object RegExp]\n --\n/sss/\n[object RegExp]\n --\nundefined\n[object Undefined]\n --\nnull\n[object Null]\n --\n2021-10-20T01:55:45.116Z\n[object Date]\n --\n[Function: m]\n[object Function]\n --\nSet(3) { 2, '1', 'aaa' }\n[object Set]\n --\nMap(3) { 'a' => 1, 2 => 'aa', 'xxx' => 123 }\n[object Map]\n --\nSymbol(1)\n[object Symbol]\n```\n\n","slug":"JavaScript/概念/数据类型判断","published":1,"updated":"2021-12-09T01:56:49.404Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckznhkk8q0076ikub1xl7djma","content":"<h1 id=\"JavaScript判断数据的类型的方法\"><a href=\"#JavaScript判断数据的类型的方法\" class=\"headerlink\" title=\"JavaScript判断数据的类型的方法\"></a>JavaScript判断数据的类型的方法</h1><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let obj = &#123;</span><br><span class=\"line\">  a: 1,</span><br><span class=\"line\">  h: new Number(3),</span><br><span class=\"line\"></span><br><span class=\"line\">  b: &#x27;a&#x27;,</span><br><span class=\"line\">  i: new String(&#x27;12&#x27;),</span><br><span class=\"line\">  q: `sdcard`,</span><br><span class=\"line\"></span><br><span class=\"line\">  c: true,</span><br><span class=\"line\">  j: new Boolean(false),</span><br><span class=\"line\"></span><br><span class=\"line\">  f: [1, 2, 3],</span><br><span class=\"line\">  g: [&#x27;1&#x27;, &#x27;3&#x27;],</span><br><span class=\"line\"></span><br><span class=\"line\">  k: new Object(&#123; a: 3&#125; ),</span><br><span class=\"line\">  l: &#123; b: 4 &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  o: new RegExp(&#x27;sss&#x27;),</span><br><span class=\"line\">  p: /sss/,</span><br><span class=\"line\"></span><br><span class=\"line\">  d: undefined,</span><br><span class=\"line\">  e: null,</span><br><span class=\"line\">  n: new Date(),</span><br><span class=\"line\">  m: function () &#123;&#125;,</span><br><span class=\"line\">  r: new Set([2, &#x27;1&#x27;, &#x27;aaa&#x27;]),</span><br><span class=\"line\">  s: new Map([[&#x27;a&#x27;, 1], [2, &#x27;aa&#x27;], [&#x27;xxx&#x27;, 123]]),</span><br><span class=\"line\">  t: Symbol(1),</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"typeof\"><a href=\"#typeof\" class=\"headerlink\" title=\"typeof\"></a>typeof</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/typeof</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for (const k in obj) &#123;</span><br><span class=\"line\">  console.log(&#x27; --  &#x27;);</span><br><span class=\"line\">  console.log(obj[k]);</span><br><span class=\"line\">  console.log(typeof obj[k]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> --</span><br><span class=\"line\">1</span><br><span class=\"line\">number</span><br><span class=\"line\"> --</span><br><span class=\"line\">[Number: 3]</span><br><span class=\"line\">object</span><br><span class=\"line\"> --</span><br><span class=\"line\">a</span><br><span class=\"line\">string</span><br><span class=\"line\"> --</span><br><span class=\"line\">[String: &#x27;12&#x27;]</span><br><span class=\"line\">object</span><br><span class=\"line\"> --</span><br><span class=\"line\">sdcard</span><br><span class=\"line\">string</span><br><span class=\"line\"> --</span><br><span class=\"line\">true</span><br><span class=\"line\">boolean</span><br><span class=\"line\"> --</span><br><span class=\"line\">[Boolean: false]</span><br><span class=\"line\">object</span><br><span class=\"line\"> --</span><br><span class=\"line\">[ 1, 2, 3 ]</span><br><span class=\"line\">object</span><br><span class=\"line\"> --</span><br><span class=\"line\">[ &#x27;1&#x27;, &#x27;3&#x27; ]</span><br><span class=\"line\">object</span><br><span class=\"line\"> --</span><br><span class=\"line\">&#123; a: 3 &#125;</span><br><span class=\"line\">object</span><br><span class=\"line\"> --</span><br><span class=\"line\">&#123; b: 4 &#125;</span><br><span class=\"line\">object</span><br><span class=\"line\"> --</span><br><span class=\"line\">/sss/</span><br><span class=\"line\">object</span><br><span class=\"line\"> --</span><br><span class=\"line\">/sss/</span><br><span class=\"line\">object</span><br><span class=\"line\"> --</span><br><span class=\"line\">undefined</span><br><span class=\"line\">undefined</span><br><span class=\"line\"> --</span><br><span class=\"line\">null</span><br><span class=\"line\">object</span><br><span class=\"line\"> --</span><br><span class=\"line\">2021-10-20T01:55:29.835Z</span><br><span class=\"line\">object</span><br><span class=\"line\"> --</span><br><span class=\"line\">[Function: m]</span><br><span class=\"line\">function</span><br><span class=\"line\"> --</span><br><span class=\"line\">Set(3) &#123; 2, &#x27;1&#x27;, &#x27;aaa&#x27; &#125;</span><br><span class=\"line\">object</span><br><span class=\"line\"> --</span><br><span class=\"line\">Map(3) &#123; &#x27;a&#x27; =&gt; 1, 2 =&gt; &#x27;aa&#x27;, &#x27;xxx&#x27; =&gt; 123 &#125;</span><br><span class=\"line\">object</span><br><span class=\"line\"> --</span><br><span class=\"line\">Symbol(1)</span><br><span class=\"line\">symbol</span><br></pre></td></tr></table></figure>\n\n<p>这里的话，主要问题是在于</p>\n<p>​    一个是,只能把数据分为基本数据类型和对象,并且使用new方法调用的就为对象.</p>\n<p>​    一个是 null  的 typeof 的值为 object，至于原因的话</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://2ality.com/2013/10/typeof-null.html</span><br></pre></td></tr></table></figure>\n\n<p>通过这篇文章我们可以知道原理，我这里就简单的说一下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">首先，早期的JavaScript是通过值的低1位或3位来辨别类型的。</span><br><span class=\"line\">又下面所示</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">000：对象。数据是对对象的引用。</span><br><span class=\"line\">1：整数。数据是一个 31 位有符号整数。</span><br><span class=\"line\">010：双倍。数据是对双浮点数的引用。</span><br><span class=\"line\">100：字符串。数据是对字符串的引用。</span><br><span class=\"line\">110：布尔值。数据是一个布尔值。</span><br><span class=\"line\"></span><br><span class=\"line\">undefined，用整数−2^30（负2的30次方，不在整型的范围内）</span><br><span class=\"line\">null，机器码空指针（C/C++ 宏定义），低三位也是000</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">所以就出现了这种 typeof null = &#x27;object&#x27;;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"instanceof\"><a href=\"#instanceof\" class=\"headerlink\" title=\"instanceof\"></a>instanceof</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/instanceof</span><br></pre></td></tr></table></figure>\n\n<p><code>instanceof</code> 运算符用于检测构造函数的 <code>prototype</code> 属性是否出现在某个实例对象的原型链上。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(&#x27;a ----     &#x27; + a instanceof Number);</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">对于基本数据类型会直接返回false。而不会再内部构建对应的引用类型.</span><br><span class=\"line\"></span><br><span class=\"line\">否则的话，就会先通过 Object.getPrototypeOf 获得参数的原型对象。然后判断这个和你要判断的对象是否相等，不想等则会继续向上，直到相等或者为 null 时。</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"constructor-NaN\"><a href=\"#constructor-NaN\" class=\"headerlink\" title=\"constructor\"></a>constructor</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Classes/constructor</span><br></pre></td></tr></table></figure>\n\n<p>**<code>constructor </code>**是一种用于创建和初始化<code>class</code>创建的对象的特殊方法。</p>\n<p>你可以这样理解，一个对象的constructor的指向的是他所 new 而指向的方法。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function O() &#123;&#125;</span><br><span class=\"line\">let o = new O();</span><br><span class=\"line\"></span><br><span class=\"line\">o.constructor === O; //true</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(&#x27;a ----     &#x27; + (a.constructor === Number));</span><br><span class=\"line\">true</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">这里，在a调用constructor的时候，会在内部创建一个值为a的对象，然后再调用这个constructor方法，然后再将这个对象删除，所以这个是基本数据类型也可以进行判断的。</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">这个输出的值是 a的构造器所指向的一个函数。在这里就是指向的Number，</span><br><span class=\"line\">问题：这个因为是通过判断其构造器函数来进行的判断，所以如果我们将对其进行过修改则会判断错误。</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Fn() &#123;&#125;</span><br><span class=\"line\">let x = new Fn();</span><br><span class=\"line\">Fn.prototype = new Array();</span><br><span class=\"line\">console.log(x.constructor === Fn)\t\t//true</span><br><span class=\"line\">console.log(x.constructor === Array)\t//false</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Fn() &#123;&#125;</span><br><span class=\"line\">Fn.prototype = new Array();</span><br><span class=\"line\">let x = new Fn();</span><br><span class=\"line\">console.log(x.constructor === Fn)\t\t//false</span><br><span class=\"line\">console.log(x.constructor === Array)\t//ture</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">第一个是先new，然后在修改的原型。</span><br><span class=\"line\">而第二个是先修改原型，然后再进行new方法的调用。</span><br><span class=\"line\">然后结果就不一样了，所以说明了这个new方法会调用的是原型。</span><br><span class=\"line\">所以其构造器会被修改。</span><br></pre></td></tr></table></figure>\n\n<p>通过上面这个代码我们可以知道，</p>\n<p>你可以这样想,一个new方法和其结果是平级的</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let a = new Fn();</span><br><span class=\"line\">a,和fn是平级的.</span><br></pre></td></tr></table></figure>\n\n<p>一个new方法，会将他的原型作为一个构造器,并将他自己进行一次<code>this</code>指向的调用.并创建一个 <code>__proto__</code> 指向了构造器的原型.</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Fn() &#123;&#125;</span><br><span class=\"line\">let x = new Fn();</span><br><span class=\"line\">console.log(x.constructor === Fn)\t\t//true</span><br><span class=\"line\">console.log(x.__proto__ === Fn.prototype)\t//true</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"Object-prototype-toString-call\"><a href=\"#Object-prototype-toString-call\" class=\"headerlink\" title=\"Object.prototype.toString.call()\"></a>Object.prototype.toString.call()</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/toString</span><br></pre></td></tr></table></figure>\n\n<p>使用方法</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Object.prototype.toString.call(a);</span><br><span class=\"line\">这里通过调用了call方法，转换了this的指向。</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let obj = &#123;</span><br><span class=\"line\">  a: 1,</span><br><span class=\"line\">  h: new Number(3),</span><br><span class=\"line\"></span><br><span class=\"line\">  b: &#x27;a&#x27;,</span><br><span class=\"line\">  i: new String(&#x27;12&#x27;),</span><br><span class=\"line\">  q: `sdcard`,</span><br><span class=\"line\"></span><br><span class=\"line\">  c: true,</span><br><span class=\"line\">  j: new Boolean(false),</span><br><span class=\"line\"></span><br><span class=\"line\">  f: [1, 2, 3],</span><br><span class=\"line\">  g: [&#x27;1&#x27;, &#x27;3&#x27;],</span><br><span class=\"line\"></span><br><span class=\"line\">  k: new Object(&#123; a: 3&#125; ),</span><br><span class=\"line\">  l: &#123; b: 4 &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  o: new RegExp(&#x27;sss&#x27;),</span><br><span class=\"line\">  p: /sss/,</span><br><span class=\"line\"></span><br><span class=\"line\">  d: undefined,</span><br><span class=\"line\">  e: null,</span><br><span class=\"line\">  n: new Date(),</span><br><span class=\"line\">  m: function () &#123;&#125;,</span><br><span class=\"line\">  r: new Set([2, &#x27;1&#x27;, &#x27;aaa&#x27;]),</span><br><span class=\"line\">  s: new Map([[&#x27;a&#x27;, 1], [2, &#x27;aa&#x27;], [&#x27;xxx&#x27;, 123]]),</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for (const k in obj) &#123;</span><br><span class=\"line\">  console.log(&#x27; --  &#x27;);</span><br><span class=\"line\">  console.log(obj[k]);</span><br><span class=\"line\">  console.log(Object.prototype.toString.call(obj[k]));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过下面的结果我们可以看到,使用这个对象原型的方法可以说是没有任何问题啊.</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> --</span><br><span class=\"line\">1</span><br><span class=\"line\">[object Number]</span><br><span class=\"line\"> --</span><br><span class=\"line\">[Number: 3]</span><br><span class=\"line\">[object Number]</span><br><span class=\"line\"> --</span><br><span class=\"line\">a</span><br><span class=\"line\">[object String]</span><br><span class=\"line\"> --</span><br><span class=\"line\">[String: &#x27;12&#x27;]</span><br><span class=\"line\">[object String]</span><br><span class=\"line\"> --</span><br><span class=\"line\">sdcard</span><br><span class=\"line\">[object String]</span><br><span class=\"line\"> --</span><br><span class=\"line\">true</span><br><span class=\"line\">[object Boolean]</span><br><span class=\"line\"> --</span><br><span class=\"line\">[Boolean: false]</span><br><span class=\"line\">[object Boolean]</span><br><span class=\"line\"> --</span><br><span class=\"line\">[ 1, 2, 3 ]</span><br><span class=\"line\">[object Array]</span><br><span class=\"line\"> --</span><br><span class=\"line\">[ &#x27;1&#x27;, &#x27;3&#x27; ]</span><br><span class=\"line\">[object Array]</span><br><span class=\"line\"> --</span><br><span class=\"line\">&#123; a: 3 &#125;</span><br><span class=\"line\">[object Object]</span><br><span class=\"line\"> --</span><br><span class=\"line\">&#123; b: 4 &#125;</span><br><span class=\"line\">[object Object]</span><br><span class=\"line\"> --</span><br><span class=\"line\">/sss/</span><br><span class=\"line\">[object RegExp]</span><br><span class=\"line\"> --</span><br><span class=\"line\">/sss/</span><br><span class=\"line\">[object RegExp]</span><br><span class=\"line\"> --</span><br><span class=\"line\">undefined</span><br><span class=\"line\">[object Undefined]</span><br><span class=\"line\"> --</span><br><span class=\"line\">null</span><br><span class=\"line\">[object Null]</span><br><span class=\"line\"> --</span><br><span class=\"line\">2021-10-20T01:55:45.116Z</span><br><span class=\"line\">[object Date]</span><br><span class=\"line\"> --</span><br><span class=\"line\">[Function: m]</span><br><span class=\"line\">[object Function]</span><br><span class=\"line\"> --</span><br><span class=\"line\">Set(3) &#123; 2, &#x27;1&#x27;, &#x27;aaa&#x27; &#125;</span><br><span class=\"line\">[object Set]</span><br><span class=\"line\"> --</span><br><span class=\"line\">Map(3) &#123; &#x27;a&#x27; =&gt; 1, 2 =&gt; &#x27;aa&#x27;, &#x27;xxx&#x27; =&gt; 123 &#125;</span><br><span class=\"line\">[object Map]</span><br><span class=\"line\"> --</span><br><span class=\"line\">Symbol(1)</span><br><span class=\"line\">[object Symbol]</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"JavaScript判断数据的类型的方法\"><a href=\"#JavaScript判断数据的类型的方法\" class=\"headerlink\" title=\"JavaScript判断数据的类型的方法\"></a>JavaScript判断数据的类型的方法</h1><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let obj = &#123;</span><br><span class=\"line\">  a: 1,</span><br><span class=\"line\">  h: new Number(3),</span><br><span class=\"line\"></span><br><span class=\"line\">  b: &#x27;a&#x27;,</span><br><span class=\"line\">  i: new String(&#x27;12&#x27;),</span><br><span class=\"line\">  q: `sdcard`,</span><br><span class=\"line\"></span><br><span class=\"line\">  c: true,</span><br><span class=\"line\">  j: new Boolean(false),</span><br><span class=\"line\"></span><br><span class=\"line\">  f: [1, 2, 3],</span><br><span class=\"line\">  g: [&#x27;1&#x27;, &#x27;3&#x27;],</span><br><span class=\"line\"></span><br><span class=\"line\">  k: new Object(&#123; a: 3&#125; ),</span><br><span class=\"line\">  l: &#123; b: 4 &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  o: new RegExp(&#x27;sss&#x27;),</span><br><span class=\"line\">  p: /sss/,</span><br><span class=\"line\"></span><br><span class=\"line\">  d: undefined,</span><br><span class=\"line\">  e: null,</span><br><span class=\"line\">  n: new Date(),</span><br><span class=\"line\">  m: function () &#123;&#125;,</span><br><span class=\"line\">  r: new Set([2, &#x27;1&#x27;, &#x27;aaa&#x27;]),</span><br><span class=\"line\">  s: new Map([[&#x27;a&#x27;, 1], [2, &#x27;aa&#x27;], [&#x27;xxx&#x27;, 123]]),</span><br><span class=\"line\">  t: Symbol(1),</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"typeof\"><a href=\"#typeof\" class=\"headerlink\" title=\"typeof\"></a>typeof</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/typeof</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for (const k in obj) &#123;</span><br><span class=\"line\">  console.log(&#x27; --  &#x27;);</span><br><span class=\"line\">  console.log(obj[k]);</span><br><span class=\"line\">  console.log(typeof obj[k]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> --</span><br><span class=\"line\">1</span><br><span class=\"line\">number</span><br><span class=\"line\"> --</span><br><span class=\"line\">[Number: 3]</span><br><span class=\"line\">object</span><br><span class=\"line\"> --</span><br><span class=\"line\">a</span><br><span class=\"line\">string</span><br><span class=\"line\"> --</span><br><span class=\"line\">[String: &#x27;12&#x27;]</span><br><span class=\"line\">object</span><br><span class=\"line\"> --</span><br><span class=\"line\">sdcard</span><br><span class=\"line\">string</span><br><span class=\"line\"> --</span><br><span class=\"line\">true</span><br><span class=\"line\">boolean</span><br><span class=\"line\"> --</span><br><span class=\"line\">[Boolean: false]</span><br><span class=\"line\">object</span><br><span class=\"line\"> --</span><br><span class=\"line\">[ 1, 2, 3 ]</span><br><span class=\"line\">object</span><br><span class=\"line\"> --</span><br><span class=\"line\">[ &#x27;1&#x27;, &#x27;3&#x27; ]</span><br><span class=\"line\">object</span><br><span class=\"line\"> --</span><br><span class=\"line\">&#123; a: 3 &#125;</span><br><span class=\"line\">object</span><br><span class=\"line\"> --</span><br><span class=\"line\">&#123; b: 4 &#125;</span><br><span class=\"line\">object</span><br><span class=\"line\"> --</span><br><span class=\"line\">/sss/</span><br><span class=\"line\">object</span><br><span class=\"line\"> --</span><br><span class=\"line\">/sss/</span><br><span class=\"line\">object</span><br><span class=\"line\"> --</span><br><span class=\"line\">undefined</span><br><span class=\"line\">undefined</span><br><span class=\"line\"> --</span><br><span class=\"line\">null</span><br><span class=\"line\">object</span><br><span class=\"line\"> --</span><br><span class=\"line\">2021-10-20T01:55:29.835Z</span><br><span class=\"line\">object</span><br><span class=\"line\"> --</span><br><span class=\"line\">[Function: m]</span><br><span class=\"line\">function</span><br><span class=\"line\"> --</span><br><span class=\"line\">Set(3) &#123; 2, &#x27;1&#x27;, &#x27;aaa&#x27; &#125;</span><br><span class=\"line\">object</span><br><span class=\"line\"> --</span><br><span class=\"line\">Map(3) &#123; &#x27;a&#x27; =&gt; 1, 2 =&gt; &#x27;aa&#x27;, &#x27;xxx&#x27; =&gt; 123 &#125;</span><br><span class=\"line\">object</span><br><span class=\"line\"> --</span><br><span class=\"line\">Symbol(1)</span><br><span class=\"line\">symbol</span><br></pre></td></tr></table></figure>\n\n<p>这里的话，主要问题是在于</p>\n<p>​    一个是,只能把数据分为基本数据类型和对象,并且使用new方法调用的就为对象.</p>\n<p>​    一个是 null  的 typeof 的值为 object，至于原因的话</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://2ality.com/2013/10/typeof-null.html</span><br></pre></td></tr></table></figure>\n\n<p>通过这篇文章我们可以知道原理，我这里就简单的说一下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">首先，早期的JavaScript是通过值的低1位或3位来辨别类型的。</span><br><span class=\"line\">又下面所示</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">000：对象。数据是对对象的引用。</span><br><span class=\"line\">1：整数。数据是一个 31 位有符号整数。</span><br><span class=\"line\">010：双倍。数据是对双浮点数的引用。</span><br><span class=\"line\">100：字符串。数据是对字符串的引用。</span><br><span class=\"line\">110：布尔值。数据是一个布尔值。</span><br><span class=\"line\"></span><br><span class=\"line\">undefined，用整数−2^30（负2的30次方，不在整型的范围内）</span><br><span class=\"line\">null，机器码空指针（C/C++ 宏定义），低三位也是000</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">所以就出现了这种 typeof null = &#x27;object&#x27;;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"instanceof\"><a href=\"#instanceof\" class=\"headerlink\" title=\"instanceof\"></a>instanceof</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/instanceof</span><br></pre></td></tr></table></figure>\n\n<p><code>instanceof</code> 运算符用于检测构造函数的 <code>prototype</code> 属性是否出现在某个实例对象的原型链上。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(&#x27;a ----     &#x27; + a instanceof Number);</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">对于基本数据类型会直接返回false。而不会再内部构建对应的引用类型.</span><br><span class=\"line\"></span><br><span class=\"line\">否则的话，就会先通过 Object.getPrototypeOf 获得参数的原型对象。然后判断这个和你要判断的对象是否相等，不想等则会继续向上，直到相等或者为 null 时。</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"constructor-NaN\"><a href=\"#constructor-NaN\" class=\"headerlink\" title=\"constructor\"></a>constructor</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Classes/constructor</span><br></pre></td></tr></table></figure>\n\n<p>**<code>constructor </code>**是一种用于创建和初始化<code>class</code>创建的对象的特殊方法。</p>\n<p>你可以这样理解，一个对象的constructor的指向的是他所 new 而指向的方法。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function O() &#123;&#125;</span><br><span class=\"line\">let o = new O();</span><br><span class=\"line\"></span><br><span class=\"line\">o.constructor === O; //true</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(&#x27;a ----     &#x27; + (a.constructor === Number));</span><br><span class=\"line\">true</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">这里，在a调用constructor的时候，会在内部创建一个值为a的对象，然后再调用这个constructor方法，然后再将这个对象删除，所以这个是基本数据类型也可以进行判断的。</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">这个输出的值是 a的构造器所指向的一个函数。在这里就是指向的Number，</span><br><span class=\"line\">问题：这个因为是通过判断其构造器函数来进行的判断，所以如果我们将对其进行过修改则会判断错误。</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Fn() &#123;&#125;</span><br><span class=\"line\">let x = new Fn();</span><br><span class=\"line\">Fn.prototype = new Array();</span><br><span class=\"line\">console.log(x.constructor === Fn)\t\t//true</span><br><span class=\"line\">console.log(x.constructor === Array)\t//false</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Fn() &#123;&#125;</span><br><span class=\"line\">Fn.prototype = new Array();</span><br><span class=\"line\">let x = new Fn();</span><br><span class=\"line\">console.log(x.constructor === Fn)\t\t//false</span><br><span class=\"line\">console.log(x.constructor === Array)\t//ture</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">第一个是先new，然后在修改的原型。</span><br><span class=\"line\">而第二个是先修改原型，然后再进行new方法的调用。</span><br><span class=\"line\">然后结果就不一样了，所以说明了这个new方法会调用的是原型。</span><br><span class=\"line\">所以其构造器会被修改。</span><br></pre></td></tr></table></figure>\n\n<p>通过上面这个代码我们可以知道，</p>\n<p>你可以这样想,一个new方法和其结果是平级的</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let a = new Fn();</span><br><span class=\"line\">a,和fn是平级的.</span><br></pre></td></tr></table></figure>\n\n<p>一个new方法，会将他的原型作为一个构造器,并将他自己进行一次<code>this</code>指向的调用.并创建一个 <code>__proto__</code> 指向了构造器的原型.</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Fn() &#123;&#125;</span><br><span class=\"line\">let x = new Fn();</span><br><span class=\"line\">console.log(x.constructor === Fn)\t\t//true</span><br><span class=\"line\">console.log(x.__proto__ === Fn.prototype)\t//true</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"Object-prototype-toString-call\"><a href=\"#Object-prototype-toString-call\" class=\"headerlink\" title=\"Object.prototype.toString.call()\"></a>Object.prototype.toString.call()</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/toString</span><br></pre></td></tr></table></figure>\n\n<p>使用方法</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Object.prototype.toString.call(a);</span><br><span class=\"line\">这里通过调用了call方法，转换了this的指向。</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let obj = &#123;</span><br><span class=\"line\">  a: 1,</span><br><span class=\"line\">  h: new Number(3),</span><br><span class=\"line\"></span><br><span class=\"line\">  b: &#x27;a&#x27;,</span><br><span class=\"line\">  i: new String(&#x27;12&#x27;),</span><br><span class=\"line\">  q: `sdcard`,</span><br><span class=\"line\"></span><br><span class=\"line\">  c: true,</span><br><span class=\"line\">  j: new Boolean(false),</span><br><span class=\"line\"></span><br><span class=\"line\">  f: [1, 2, 3],</span><br><span class=\"line\">  g: [&#x27;1&#x27;, &#x27;3&#x27;],</span><br><span class=\"line\"></span><br><span class=\"line\">  k: new Object(&#123; a: 3&#125; ),</span><br><span class=\"line\">  l: &#123; b: 4 &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  o: new RegExp(&#x27;sss&#x27;),</span><br><span class=\"line\">  p: /sss/,</span><br><span class=\"line\"></span><br><span class=\"line\">  d: undefined,</span><br><span class=\"line\">  e: null,</span><br><span class=\"line\">  n: new Date(),</span><br><span class=\"line\">  m: function () &#123;&#125;,</span><br><span class=\"line\">  r: new Set([2, &#x27;1&#x27;, &#x27;aaa&#x27;]),</span><br><span class=\"line\">  s: new Map([[&#x27;a&#x27;, 1], [2, &#x27;aa&#x27;], [&#x27;xxx&#x27;, 123]]),</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for (const k in obj) &#123;</span><br><span class=\"line\">  console.log(&#x27; --  &#x27;);</span><br><span class=\"line\">  console.log(obj[k]);</span><br><span class=\"line\">  console.log(Object.prototype.toString.call(obj[k]));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过下面的结果我们可以看到,使用这个对象原型的方法可以说是没有任何问题啊.</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> --</span><br><span class=\"line\">1</span><br><span class=\"line\">[object Number]</span><br><span class=\"line\"> --</span><br><span class=\"line\">[Number: 3]</span><br><span class=\"line\">[object Number]</span><br><span class=\"line\"> --</span><br><span class=\"line\">a</span><br><span class=\"line\">[object String]</span><br><span class=\"line\"> --</span><br><span class=\"line\">[String: &#x27;12&#x27;]</span><br><span class=\"line\">[object String]</span><br><span class=\"line\"> --</span><br><span class=\"line\">sdcard</span><br><span class=\"line\">[object String]</span><br><span class=\"line\"> --</span><br><span class=\"line\">true</span><br><span class=\"line\">[object Boolean]</span><br><span class=\"line\"> --</span><br><span class=\"line\">[Boolean: false]</span><br><span class=\"line\">[object Boolean]</span><br><span class=\"line\"> --</span><br><span class=\"line\">[ 1, 2, 3 ]</span><br><span class=\"line\">[object Array]</span><br><span class=\"line\"> --</span><br><span class=\"line\">[ &#x27;1&#x27;, &#x27;3&#x27; ]</span><br><span class=\"line\">[object Array]</span><br><span class=\"line\"> --</span><br><span class=\"line\">&#123; a: 3 &#125;</span><br><span class=\"line\">[object Object]</span><br><span class=\"line\"> --</span><br><span class=\"line\">&#123; b: 4 &#125;</span><br><span class=\"line\">[object Object]</span><br><span class=\"line\"> --</span><br><span class=\"line\">/sss/</span><br><span class=\"line\">[object RegExp]</span><br><span class=\"line\"> --</span><br><span class=\"line\">/sss/</span><br><span class=\"line\">[object RegExp]</span><br><span class=\"line\"> --</span><br><span class=\"line\">undefined</span><br><span class=\"line\">[object Undefined]</span><br><span class=\"line\"> --</span><br><span class=\"line\">null</span><br><span class=\"line\">[object Null]</span><br><span class=\"line\"> --</span><br><span class=\"line\">2021-10-20T01:55:45.116Z</span><br><span class=\"line\">[object Date]</span><br><span class=\"line\"> --</span><br><span class=\"line\">[Function: m]</span><br><span class=\"line\">[object Function]</span><br><span class=\"line\"> --</span><br><span class=\"line\">Set(3) &#123; 2, &#x27;1&#x27;, &#x27;aaa&#x27; &#125;</span><br><span class=\"line\">[object Set]</span><br><span class=\"line\"> --</span><br><span class=\"line\">Map(3) &#123; &#x27;a&#x27; =&gt; 1, 2 =&gt; &#x27;aa&#x27;, &#x27;xxx&#x27; =&gt; 123 &#125;</span><br><span class=\"line\">[object Map]</span><br><span class=\"line\"> --</span><br><span class=\"line\">Symbol(1)</span><br><span class=\"line\">[object Symbol]</span><br></pre></td></tr></table></figure>\n\n"},{"title":"迭代器","date":"2021-11-14T10:30:37.000Z","_content":"\n\n\n#  JavaScript 迭代器\n\n```\nhttps://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Iterators_and_Generators\n```\n\n\n\n​\t\t首先JavaScript里面的数组我们可以知道其实也是一个对象。但是为什么我们可以通过一些方法进行循环，这里就运用到了一个迭代器的方法。iterator\n\n\n\n## 可迭代协议\n\n​\t\t**可迭代协议**允许 JavaScript 对象定义或定制它们的迭代行为，例如，在一个 [`for..of`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/for...of) 结构中，哪些值可以被遍历到。一些内置类型同时是[内置可迭代对象](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Iteration_protocols#内置可迭代对象)，并且有默认的迭代行为，比如 [`Array`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array) 或者 [`Map`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map)，而其他内置类型则不是（比如 [`Object`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object))）。\n\n​\t\t要成为**可迭代**对象， 一个对象必须实现 `**@@iterator**` 方法。这意味着对象（或者它[原型链](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain)上的某个对象）必须有一个键为 `@@iterator` 的属性，可通过常量 [`Symbol.iterator`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol/iterator) 访问该属性\n\n\n\n​\t\t简单来说就是forof进行循环的操作，会先调用一个 `@@iterator` 方法，然后使用这个方法返回的迭代器获得迭代的值。\n\n​\t\t通过这里我们就可以知道几个问题\n\n* 默认对象为什么不可以进行迭代，是因为对于默认是没有实现这个迭代器的。而Array和Map是默认就存在一个迭代器。\n* 为什么对于数组存在empty-items，但是 forof 和 forin 为什么会不同的效果呢。就是因为forof是使用的迭代器的形式进行迭代，而forin是使用的键值对的形式进行的迭代。所以对于存在空值的数组，但是forof是通过数组的迭代器，所以还是使用的长度，而forin是使用的键值对，所以对于空值，实际上并没有迭代出来。\n\n\n\n### 可迭代对象\n\n​\t\t要成为**可迭代**对象， 一个对象必须实现 `**@@iterator**` 方法。这意味着对象（或者它[原型链](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain)上的某个对象）必须有一个键为 `@@iterator` 的属性，可通过常量 [`Symbol.iterator`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol/iterator) 访问该属性。\n\n| 属性                | 值                                                           |\n| :------------------ | :----------------------------------------------------------- |\n| `[Symbol.iterator]` | 一个无参数的函数，其返回值为一个符合[迭代器协议](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Iteration_protocols#迭代器协议)的对象。 |\n\n\n\n​\t\t此函数可以是普通函数，也可以是生成器函数，以便在调用时返回迭代器对象。 在此生成器函数的内部，可以使用`yield`提供每个条目。\n\n\n\n## 迭代器协议\n\n​\t\t**迭代器协议**定义了产生一系列值（无论是有限个还是无限个）的标准方式。当值为有限个时，所有的值都被迭代完毕后，则会返回一个默认返回值。\n\n​\t\t只有实现了一个拥有以下语义（semantic）的 `**next()**` 方法，一个对象才能成为迭代器：\n\n| 属性   | 值                                                           |\n| :----- | :----------------------------------------------------------- |\n| `next` | 一个无参数或者一个参数的函数，返回一个应当拥有以下两个属性的对象：`done`（boolean）如果迭代器可以产生序列中的下一个值，则为 `false`。（这等价于没有指定 `done` 这个属性。）如果迭代器已将序列迭代完毕，则为 `true`。这种情况下，`value` 是可选的，如果它依然存在，即为迭代结束之后的默认返回值。`value`迭代器返回的任何 JavaScript 值。done 为 true 时可省略。`next()` 方法必须返回一个对象，该对象应当有两个属性： `done` 和 `value`，如果返回了一个非对象值（比如 `false` 或 `undefined`），则会抛出一个 [`TypeError`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/TypeError) 异常（`\"iterator.next() returned a non-object value\"`）。 |\n\n\n\n​\t\t查看一个内置的可迭代对象\n\n```\nlet someString = \"hi\";\ntypeof someString[Symbol.iterator];          // \"function\"\n\nlet iterator = someString[Symbol.iterator]();\niterator + \"\";                   // \"[object String Iterator]\"\n\niterator.next();                         // { value: \"h\", done: false }\niterator.next();                         // { value: \"i\", done: false }\niterator.next();                 // { value: undefined, done: true }\n```\n\n\n\n​\t\t自己提供一个@@iterator 方法，方法需要能够使用next方法。\n\n```\n// 必须构造 String 对象以避免字符串字面量 auto-boxing\nvar someString = new String(\"hi\");\nsomeString[Symbol.iterator] = function() {\n  return { // 只返回一次元素，字符串 \"bye\"，的迭代器对象\n    next: function() {\t\n      if (this._first) {\n        this._first = false;\n        return { value: \"bye\", done: false };\n      } else {\n        return { done: true };\n      }\n    },\n    _first: true\n  };\n};\n```\n\n​\t\t通过***生成器函数\\*** 也可以生成这个效果。\n\n```\nvar myIterable = {};\nmyIterable[Symbol.iterator] = function* () {\n    yield 1;\n    yield 2;\n    yield 3;\n};\n[...myIterable]; // [1, 2, 3]\n```\n\n\n\n​\t\t一个简单的示例。\n\n```\nlet o = {\n  a: 1,\n  b: 2,\n  x: 3\n}\n\n这个是使用的生成器语法进行的操作。\n个人建议使用生成器函数进行操作，生成器的语法非常合适这个迭代器。如果不使用生成器的语法，会比较复杂。\no[Symbol.iterator] = function* () {\n  let keys = Object.keys(this);\n  for (const keysKey in keys) {\n    yield this[keys[keysKey]];\n  }\n};\n\n这里是一个没有使用生成器的语法，所以对于返回值，需要有一个next函数进行调用。然后，调用之后会返回一个值，然后如何解决是否返回结束，行为就是一个index进行存储，但是如果先进行了index的修改，那么return的时候也要进行一次修改，所以会比较麻烦。\no[Symbol.iterator] = function () {\n  let keys = Object.keys(this);\n  let obj = this;\n\n  return {\n    next: function () {\n      if (keys[this.index]) {\n        //最终方式\n        return { value: obj[keys[this.index++]], done: false };\n        \n        //++this.index;\n        //return { value: obj[keys[this.index-1]], done: false };\n        \n        //\t\n        //return { value: obj[keys[this.index]], done: false };\n        \n        //\t通过这里我们也 知道了，++会先于 &&||逻辑运算符。\n        //return this.index++ || console.log(this.index) && { value: obj[keys[this.index]], done: false };\n      } else {\n        return { done: true };\n      }\n    },\n    index: 0\n  }\n}\n```\n\n​\t\t通过这个方法可以取出迭代器对象并且使用next()获取下一个迭代的值。\n\n```\nlet oo = o[Symbol.iterator]();\nconsole.log(oo.next());\n```\n\n\n\n生成器对象既是一个迭代器，也是一个可迭代的对象。\n\n```\nlet generator = function* (){\n  yield 1;\n  yield 2;\n  yield 3;\n}();\n\nconsole.log(typeof generator.next);\n// 返回\"function\", 因为有一个next方法，所以这是一个迭代器\n迭代器就是存在了next方法的一个对象，next方法的返回值为value和done\n\nconsole.log(typeof generator[Symbol.iterator]);\n// 返回\"function\", 因为有一个@@iterator方法，所以这是一个可迭代对象\n可迭代对象，意思就是说这个是可以使用迭代器的，可以使用forof方法。简单来说就是这个方法内部实现了 [Symbol.iterator] 函数。\n\nconsole.log(generator[Symbol.iterator]() === generator);\n// 返回true, 因为@@iterator方法返回自身（即迭代器），所以这是一个格式良好的可迭代对象\n首先，我们知道这是一个可迭代对象，也是一个迭代器，意思就是说，这个迭代器的内部也存在一个迭代器。一个是它本身的任务就是一个迭代器，另一个是它作为一个可迭代对象，它存在一个内部的迭代器，然后这里的意思就是说可迭代对象的迭代器方法和它自身是相等的。\n感觉就像是一个普通函数返回的对象里面有一个next方法和一个[Symbol.iterator]方法，然后这个Symbol.iterator方法是直接返回自身。所以就是迭代器的迭代器方法返回为自身。\n\nconsole.log([...generator]);\n// 返回[1, 2, 3]\n\nconsole.log(Symbol.iterator in generator)\n// 返回true, 因为@@iterator方法是generator的一个属性\n```\n\n```\nlet o = {\n  a: 1,\n  b: 2,\n  x: 3\n}\n\n// o[Symbol.iterator] = function* () {\n//   let keys = Object.keys(this);\n//\n//   for (const keysKey in keys) {\n//     yield this[keys[keysKey]];\n//   }\n// };\n\no[Symbol.iterator] = function () {\n  let keys = Object.keys(this);\n  let obj = this;\n  return {\n    next: function () {\n      if (keys[this.index]) {\n        return { value: obj[keys[this.index++]], done: false };\n      } else {\n        return { done: true };\n      }\n    },\n    [Symbol.iterator]: function () {\n      return this;\n    },\n    index: 0\n  }\n}\n\nlet generator = function* (){\n  yield 1;\n  yield 2;\n  yield 3;\n}();\n\nconsole.log(typeof generator.next);\n\nlet g = o[Symbol.iterator]();\nconsole.log(typeof g.next);\n// 返回\"function\", 因为有一个next方法，所以这是一个迭代器\n\nconsole.log(typeof generator[Symbol.iterator]);\nconsole.log(typeof g[Symbol.iterator])\n// 返回\"function\", 因为有一个@@iterator方法，所以这是一个可迭代对象\n\nconsole.log(generator[Symbol.iterator]() === generator);\nconsole.log(g[Symbol.iterator]() === g);\n// 返回true, 因为@@iterator方法返回自身（即迭代器），所以这是一个格式良好的可迭代对象\n\nconsole.log([...generator]);\n// 返回[1, 2, 3]\n\nconsole.log(Symbol.iterator in generator)\nconsole.log(Symbol.iterator in g)\n// 返回true, 因为@@iterator方法是generator的一个属性\n```\n\n","source":"_posts/JavaScript/概念/迭代器.md","raw":"---\ntitle: 迭代器\ndate: 2021-11-14 18:30:37\ntags:\n - JavaScript\n - 迭代器\ncategories:\n - JavaScript\n - 概念\n---\n\n\n\n#  JavaScript 迭代器\n\n```\nhttps://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Iterators_and_Generators\n```\n\n\n\n​\t\t首先JavaScript里面的数组我们可以知道其实也是一个对象。但是为什么我们可以通过一些方法进行循环，这里就运用到了一个迭代器的方法。iterator\n\n\n\n## 可迭代协议\n\n​\t\t**可迭代协议**允许 JavaScript 对象定义或定制它们的迭代行为，例如，在一个 [`for..of`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/for...of) 结构中，哪些值可以被遍历到。一些内置类型同时是[内置可迭代对象](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Iteration_protocols#内置可迭代对象)，并且有默认的迭代行为，比如 [`Array`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array) 或者 [`Map`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map)，而其他内置类型则不是（比如 [`Object`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object))）。\n\n​\t\t要成为**可迭代**对象， 一个对象必须实现 `**@@iterator**` 方法。这意味着对象（或者它[原型链](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain)上的某个对象）必须有一个键为 `@@iterator` 的属性，可通过常量 [`Symbol.iterator`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol/iterator) 访问该属性\n\n\n\n​\t\t简单来说就是forof进行循环的操作，会先调用一个 `@@iterator` 方法，然后使用这个方法返回的迭代器获得迭代的值。\n\n​\t\t通过这里我们就可以知道几个问题\n\n* 默认对象为什么不可以进行迭代，是因为对于默认是没有实现这个迭代器的。而Array和Map是默认就存在一个迭代器。\n* 为什么对于数组存在empty-items，但是 forof 和 forin 为什么会不同的效果呢。就是因为forof是使用的迭代器的形式进行迭代，而forin是使用的键值对的形式进行的迭代。所以对于存在空值的数组，但是forof是通过数组的迭代器，所以还是使用的长度，而forin是使用的键值对，所以对于空值，实际上并没有迭代出来。\n\n\n\n### 可迭代对象\n\n​\t\t要成为**可迭代**对象， 一个对象必须实现 `**@@iterator**` 方法。这意味着对象（或者它[原型链](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain)上的某个对象）必须有一个键为 `@@iterator` 的属性，可通过常量 [`Symbol.iterator`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol/iterator) 访问该属性。\n\n| 属性                | 值                                                           |\n| :------------------ | :----------------------------------------------------------- |\n| `[Symbol.iterator]` | 一个无参数的函数，其返回值为一个符合[迭代器协议](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Iteration_protocols#迭代器协议)的对象。 |\n\n\n\n​\t\t此函数可以是普通函数，也可以是生成器函数，以便在调用时返回迭代器对象。 在此生成器函数的内部，可以使用`yield`提供每个条目。\n\n\n\n## 迭代器协议\n\n​\t\t**迭代器协议**定义了产生一系列值（无论是有限个还是无限个）的标准方式。当值为有限个时，所有的值都被迭代完毕后，则会返回一个默认返回值。\n\n​\t\t只有实现了一个拥有以下语义（semantic）的 `**next()**` 方法，一个对象才能成为迭代器：\n\n| 属性   | 值                                                           |\n| :----- | :----------------------------------------------------------- |\n| `next` | 一个无参数或者一个参数的函数，返回一个应当拥有以下两个属性的对象：`done`（boolean）如果迭代器可以产生序列中的下一个值，则为 `false`。（这等价于没有指定 `done` 这个属性。）如果迭代器已将序列迭代完毕，则为 `true`。这种情况下，`value` 是可选的，如果它依然存在，即为迭代结束之后的默认返回值。`value`迭代器返回的任何 JavaScript 值。done 为 true 时可省略。`next()` 方法必须返回一个对象，该对象应当有两个属性： `done` 和 `value`，如果返回了一个非对象值（比如 `false` 或 `undefined`），则会抛出一个 [`TypeError`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/TypeError) 异常（`\"iterator.next() returned a non-object value\"`）。 |\n\n\n\n​\t\t查看一个内置的可迭代对象\n\n```\nlet someString = \"hi\";\ntypeof someString[Symbol.iterator];          // \"function\"\n\nlet iterator = someString[Symbol.iterator]();\niterator + \"\";                   // \"[object String Iterator]\"\n\niterator.next();                         // { value: \"h\", done: false }\niterator.next();                         // { value: \"i\", done: false }\niterator.next();                 // { value: undefined, done: true }\n```\n\n\n\n​\t\t自己提供一个@@iterator 方法，方法需要能够使用next方法。\n\n```\n// 必须构造 String 对象以避免字符串字面量 auto-boxing\nvar someString = new String(\"hi\");\nsomeString[Symbol.iterator] = function() {\n  return { // 只返回一次元素，字符串 \"bye\"，的迭代器对象\n    next: function() {\t\n      if (this._first) {\n        this._first = false;\n        return { value: \"bye\", done: false };\n      } else {\n        return { done: true };\n      }\n    },\n    _first: true\n  };\n};\n```\n\n​\t\t通过***生成器函数\\*** 也可以生成这个效果。\n\n```\nvar myIterable = {};\nmyIterable[Symbol.iterator] = function* () {\n    yield 1;\n    yield 2;\n    yield 3;\n};\n[...myIterable]; // [1, 2, 3]\n```\n\n\n\n​\t\t一个简单的示例。\n\n```\nlet o = {\n  a: 1,\n  b: 2,\n  x: 3\n}\n\n这个是使用的生成器语法进行的操作。\n个人建议使用生成器函数进行操作，生成器的语法非常合适这个迭代器。如果不使用生成器的语法，会比较复杂。\no[Symbol.iterator] = function* () {\n  let keys = Object.keys(this);\n  for (const keysKey in keys) {\n    yield this[keys[keysKey]];\n  }\n};\n\n这里是一个没有使用生成器的语法，所以对于返回值，需要有一个next函数进行调用。然后，调用之后会返回一个值，然后如何解决是否返回结束，行为就是一个index进行存储，但是如果先进行了index的修改，那么return的时候也要进行一次修改，所以会比较麻烦。\no[Symbol.iterator] = function () {\n  let keys = Object.keys(this);\n  let obj = this;\n\n  return {\n    next: function () {\n      if (keys[this.index]) {\n        //最终方式\n        return { value: obj[keys[this.index++]], done: false };\n        \n        //++this.index;\n        //return { value: obj[keys[this.index-1]], done: false };\n        \n        //\t\n        //return { value: obj[keys[this.index]], done: false };\n        \n        //\t通过这里我们也 知道了，++会先于 &&||逻辑运算符。\n        //return this.index++ || console.log(this.index) && { value: obj[keys[this.index]], done: false };\n      } else {\n        return { done: true };\n      }\n    },\n    index: 0\n  }\n}\n```\n\n​\t\t通过这个方法可以取出迭代器对象并且使用next()获取下一个迭代的值。\n\n```\nlet oo = o[Symbol.iterator]();\nconsole.log(oo.next());\n```\n\n\n\n生成器对象既是一个迭代器，也是一个可迭代的对象。\n\n```\nlet generator = function* (){\n  yield 1;\n  yield 2;\n  yield 3;\n}();\n\nconsole.log(typeof generator.next);\n// 返回\"function\", 因为有一个next方法，所以这是一个迭代器\n迭代器就是存在了next方法的一个对象，next方法的返回值为value和done\n\nconsole.log(typeof generator[Symbol.iterator]);\n// 返回\"function\", 因为有一个@@iterator方法，所以这是一个可迭代对象\n可迭代对象，意思就是说这个是可以使用迭代器的，可以使用forof方法。简单来说就是这个方法内部实现了 [Symbol.iterator] 函数。\n\nconsole.log(generator[Symbol.iterator]() === generator);\n// 返回true, 因为@@iterator方法返回自身（即迭代器），所以这是一个格式良好的可迭代对象\n首先，我们知道这是一个可迭代对象，也是一个迭代器，意思就是说，这个迭代器的内部也存在一个迭代器。一个是它本身的任务就是一个迭代器，另一个是它作为一个可迭代对象，它存在一个内部的迭代器，然后这里的意思就是说可迭代对象的迭代器方法和它自身是相等的。\n感觉就像是一个普通函数返回的对象里面有一个next方法和一个[Symbol.iterator]方法，然后这个Symbol.iterator方法是直接返回自身。所以就是迭代器的迭代器方法返回为自身。\n\nconsole.log([...generator]);\n// 返回[1, 2, 3]\n\nconsole.log(Symbol.iterator in generator)\n// 返回true, 因为@@iterator方法是generator的一个属性\n```\n\n```\nlet o = {\n  a: 1,\n  b: 2,\n  x: 3\n}\n\n// o[Symbol.iterator] = function* () {\n//   let keys = Object.keys(this);\n//\n//   for (const keysKey in keys) {\n//     yield this[keys[keysKey]];\n//   }\n// };\n\no[Symbol.iterator] = function () {\n  let keys = Object.keys(this);\n  let obj = this;\n  return {\n    next: function () {\n      if (keys[this.index]) {\n        return { value: obj[keys[this.index++]], done: false };\n      } else {\n        return { done: true };\n      }\n    },\n    [Symbol.iterator]: function () {\n      return this;\n    },\n    index: 0\n  }\n}\n\nlet generator = function* (){\n  yield 1;\n  yield 2;\n  yield 3;\n}();\n\nconsole.log(typeof generator.next);\n\nlet g = o[Symbol.iterator]();\nconsole.log(typeof g.next);\n// 返回\"function\", 因为有一个next方法，所以这是一个迭代器\n\nconsole.log(typeof generator[Symbol.iterator]);\nconsole.log(typeof g[Symbol.iterator])\n// 返回\"function\", 因为有一个@@iterator方法，所以这是一个可迭代对象\n\nconsole.log(generator[Symbol.iterator]() === generator);\nconsole.log(g[Symbol.iterator]() === g);\n// 返回true, 因为@@iterator方法返回自身（即迭代器），所以这是一个格式良好的可迭代对象\n\nconsole.log([...generator]);\n// 返回[1, 2, 3]\n\nconsole.log(Symbol.iterator in generator)\nconsole.log(Symbol.iterator in g)\n// 返回true, 因为@@iterator方法是generator的一个属性\n```\n\n","slug":"JavaScript/概念/迭代器","published":1,"updated":"2022-01-21T07:46:01.580Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckznhkk8q0079ikub9abgdj7f","content":"<h1 id=\"JavaScript-迭代器\"><a href=\"#JavaScript-迭代器\" class=\"headerlink\" title=\"JavaScript 迭代器\"></a>JavaScript 迭代器</h1><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Iterators_and_Generators</span><br></pre></td></tr></table></figure>\n\n\n\n<p>​        首先JavaScript里面的数组我们可以知道其实也是一个对象。但是为什么我们可以通过一些方法进行循环，这里就运用到了一个迭代器的方法。iterator</p>\n<h2 id=\"可迭代协议\"><a href=\"#可迭代协议\" class=\"headerlink\" title=\"可迭代协议\"></a>可迭代协议</h2><p>​        <strong>可迭代协议</strong>允许 JavaScript 对象定义或定制它们的迭代行为，例如，在一个 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/for...of\"><code>for..of</code></a> 结构中，哪些值可以被遍历到。一些内置类型同时是<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Iteration_protocols#%E5%86%85%E7%BD%AE%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1\">内置可迭代对象</a>，并且有默认的迭代行为，比如 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array\"><code>Array</code></a> 或者 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map\"><code>Map</code></a>，而其他内置类型则不是（比如 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object\"><code>Object</code></a>)）。</p>\n<p>​        要成为<strong>可迭代</strong>对象， 一个对象必须实现 <code>**@@iterator**</code> 方法。这意味着对象（或者它<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain\">原型链</a>上的某个对象）必须有一个键为 <code>@@iterator</code> 的属性，可通过常量 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol/iterator\"><code>Symbol.iterator</code></a> 访问该属性</p>\n<p>​        简单来说就是forof进行循环的操作，会先调用一个 <code>@@iterator</code> 方法，然后使用这个方法返回的迭代器获得迭代的值。</p>\n<p>​        通过这里我们就可以知道几个问题</p>\n<ul>\n<li>默认对象为什么不可以进行迭代，是因为对于默认是没有实现这个迭代器的。而Array和Map是默认就存在一个迭代器。</li>\n<li>为什么对于数组存在empty-items，但是 forof 和 forin 为什么会不同的效果呢。就是因为forof是使用的迭代器的形式进行迭代，而forin是使用的键值对的形式进行的迭代。所以对于存在空值的数组，但是forof是通过数组的迭代器，所以还是使用的长度，而forin是使用的键值对，所以对于空值，实际上并没有迭代出来。</li>\n</ul>\n<h3 id=\"可迭代对象\"><a href=\"#可迭代对象\" class=\"headerlink\" title=\"可迭代对象\"></a>可迭代对象</h3><p>​        要成为<strong>可迭代</strong>对象， 一个对象必须实现 <code>**@@iterator**</code> 方法。这意味着对象（或者它<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain\">原型链</a>上的某个对象）必须有一个键为 <code>@@iterator</code> 的属性，可通过常量 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol/iterator\"><code>Symbol.iterator</code></a> 访问该属性。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">属性</th>\n<th align=\"left\">值</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>[Symbol.iterator]</code></td>\n<td align=\"left\">一个无参数的函数，其返回值为一个符合<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Iteration_protocols#%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%8D%8F%E8%AE%AE\">迭代器协议</a>的对象。</td>\n</tr>\n</tbody></table>\n<p>​        此函数可以是普通函数，也可以是生成器函数，以便在调用时返回迭代器对象。 在此生成器函数的内部，可以使用<code>yield</code>提供每个条目。</p>\n<h2 id=\"迭代器协议\"><a href=\"#迭代器协议\" class=\"headerlink\" title=\"迭代器协议\"></a>迭代器协议</h2><p>​        <strong>迭代器协议</strong>定义了产生一系列值（无论是有限个还是无限个）的标准方式。当值为有限个时，所有的值都被迭代完毕后，则会返回一个默认返回值。</p>\n<p>​        只有实现了一个拥有以下语义（semantic）的 <code>**next()**</code> 方法，一个对象才能成为迭代器：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">属性</th>\n<th align=\"left\">值</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>next</code></td>\n<td align=\"left\">一个无参数或者一个参数的函数，返回一个应当拥有以下两个属性的对象：<code>done</code>（boolean）如果迭代器可以产生序列中的下一个值，则为 <code>false</code>。（这等价于没有指定 <code>done</code> 这个属性。）如果迭代器已将序列迭代完毕，则为 <code>true</code>。这种情况下，<code>value</code> 是可选的，如果它依然存在，即为迭代结束之后的默认返回值。<code>value</code>迭代器返回的任何 JavaScript 值。done 为 true 时可省略。<code>next()</code> 方法必须返回一个对象，该对象应当有两个属性： <code>done</code> 和 <code>value</code>，如果返回了一个非对象值（比如 <code>false</code> 或 <code>undefined</code>），则会抛出一个 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/TypeError\"><code>TypeError</code></a> 异常（<code>&quot;iterator.next() returned a non-object value&quot;</code>）。</td>\n</tr>\n</tbody></table>\n<p>​        查看一个内置的可迭代对象</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let someString = &quot;hi&quot;;</span><br><span class=\"line\">typeof someString[Symbol.iterator];          // &quot;function&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">let iterator = someString[Symbol.iterator]();</span><br><span class=\"line\">iterator + &quot;&quot;;                   // &quot;[object String Iterator]&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">iterator.next();                         // &#123; value: &quot;h&quot;, done: false &#125;</span><br><span class=\"line\">iterator.next();                         // &#123; value: &quot;i&quot;, done: false &#125;</span><br><span class=\"line\">iterator.next();                 // &#123; value: undefined, done: true &#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>​        自己提供一个@@iterator 方法，方法需要能够使用next方法。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 必须构造 String 对象以避免字符串字面量 auto-boxing</span><br><span class=\"line\">var someString = new String(&quot;hi&quot;);</span><br><span class=\"line\">someString[Symbol.iterator] = function() &#123;</span><br><span class=\"line\">  return &#123; // 只返回一次元素，字符串 &quot;bye&quot;，的迭代器对象</span><br><span class=\"line\">    next: function() &#123;\t</span><br><span class=\"line\">      if (this._first) &#123;</span><br><span class=\"line\">        this._first = false;</span><br><span class=\"line\">        return &#123; value: &quot;bye&quot;, done: false &#125;;</span><br><span class=\"line\">      &#125; else &#123;</span><br><span class=\"line\">        return &#123; done: true &#125;;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    _first: true</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>​        通过*<strong>生成器函数*</strong> 也可以生成这个效果。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var myIterable = &#123;&#125;;</span><br><span class=\"line\">myIterable[Symbol.iterator] = function* () &#123;</span><br><span class=\"line\">    yield 1;</span><br><span class=\"line\">    yield 2;</span><br><span class=\"line\">    yield 3;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">[...myIterable]; // [1, 2, 3]</span><br></pre></td></tr></table></figure>\n\n\n\n<p>​        一个简单的示例。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let o = &#123;</span><br><span class=\"line\">  a: 1,</span><br><span class=\"line\">  b: 2,</span><br><span class=\"line\">  x: 3</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">这个是使用的生成器语法进行的操作。</span><br><span class=\"line\">个人建议使用生成器函数进行操作，生成器的语法非常合适这个迭代器。如果不使用生成器的语法，会比较复杂。</span><br><span class=\"line\">o[Symbol.iterator] = function* () &#123;</span><br><span class=\"line\">  let keys = Object.keys(this);</span><br><span class=\"line\">  for (const keysKey in keys) &#123;</span><br><span class=\"line\">    yield this[keys[keysKey]];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">这里是一个没有使用生成器的语法，所以对于返回值，需要有一个next函数进行调用。然后，调用之后会返回一个值，然后如何解决是否返回结束，行为就是一个index进行存储，但是如果先进行了index的修改，那么return的时候也要进行一次修改，所以会比较麻烦。</span><br><span class=\"line\">o[Symbol.iterator] = function () &#123;</span><br><span class=\"line\">  let keys = Object.keys(this);</span><br><span class=\"line\">  let obj = this;</span><br><span class=\"line\"></span><br><span class=\"line\">  return &#123;</span><br><span class=\"line\">    next: function () &#123;</span><br><span class=\"line\">      if (keys[this.index]) &#123;</span><br><span class=\"line\">        //最终方式</span><br><span class=\"line\">        return &#123; value: obj[keys[this.index++]], done: false &#125;;</span><br><span class=\"line\">        </span><br><span class=\"line\">        //++this.index;</span><br><span class=\"line\">        //return &#123; value: obj[keys[this.index-1]], done: false &#125;;</span><br><span class=\"line\">        </span><br><span class=\"line\">        //\t</span><br><span class=\"line\">        //return &#123; value: obj[keys[this.index]], done: false &#125;;</span><br><span class=\"line\">        </span><br><span class=\"line\">        //\t通过这里我们也 知道了，++会先于 &amp;&amp;||逻辑运算符。</span><br><span class=\"line\">        //return this.index++ || console.log(this.index) &amp;&amp; &#123; value: obj[keys[this.index]], done: false &#125;;</span><br><span class=\"line\">      &#125; else &#123;</span><br><span class=\"line\">        return &#123; done: true &#125;;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    index: 0</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>​        通过这个方法可以取出迭代器对象并且使用next()获取下一个迭代的值。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let oo = o[Symbol.iterator]();</span><br><span class=\"line\">console.log(oo.next());</span><br></pre></td></tr></table></figure>\n\n\n\n<p>生成器对象既是一个迭代器，也是一个可迭代的对象。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let generator = function* ()&#123;</span><br><span class=\"line\">  yield 1;</span><br><span class=\"line\">  yield 2;</span><br><span class=\"line\">  yield 3;</span><br><span class=\"line\">&#125;();</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(typeof generator.next);</span><br><span class=\"line\">// 返回&quot;function&quot;, 因为有一个next方法，所以这是一个迭代器</span><br><span class=\"line\">迭代器就是存在了next方法的一个对象，next方法的返回值为value和done</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(typeof generator[Symbol.iterator]);</span><br><span class=\"line\">// 返回&quot;function&quot;, 因为有一个@@iterator方法，所以这是一个可迭代对象</span><br><span class=\"line\">可迭代对象，意思就是说这个是可以使用迭代器的，可以使用forof方法。简单来说就是这个方法内部实现了 [Symbol.iterator] 函数。</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(generator[Symbol.iterator]() === generator);</span><br><span class=\"line\">// 返回true, 因为@@iterator方法返回自身（即迭代器），所以这是一个格式良好的可迭代对象</span><br><span class=\"line\">首先，我们知道这是一个可迭代对象，也是一个迭代器，意思就是说，这个迭代器的内部也存在一个迭代器。一个是它本身的任务就是一个迭代器，另一个是它作为一个可迭代对象，它存在一个内部的迭代器，然后这里的意思就是说可迭代对象的迭代器方法和它自身是相等的。</span><br><span class=\"line\">感觉就像是一个普通函数返回的对象里面有一个next方法和一个[Symbol.iterator]方法，然后这个Symbol.iterator方法是直接返回自身。所以就是迭代器的迭代器方法返回为自身。</span><br><span class=\"line\"></span><br><span class=\"line\">console.log([...generator]);</span><br><span class=\"line\">// 返回[1, 2, 3]</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(Symbol.iterator in generator)</span><br><span class=\"line\">// 返回true, 因为@@iterator方法是generator的一个属性</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let o = &#123;</span><br><span class=\"line\">  a: 1,</span><br><span class=\"line\">  b: 2,</span><br><span class=\"line\">  x: 3</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// o[Symbol.iterator] = function* () &#123;</span><br><span class=\"line\">//   let keys = Object.keys(this);</span><br><span class=\"line\">//</span><br><span class=\"line\">//   for (const keysKey in keys) &#123;</span><br><span class=\"line\">//     yield this[keys[keysKey]];</span><br><span class=\"line\">//   &#125;</span><br><span class=\"line\">// &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">o[Symbol.iterator] = function () &#123;</span><br><span class=\"line\">  let keys = Object.keys(this);</span><br><span class=\"line\">  let obj = this;</span><br><span class=\"line\">  return &#123;</span><br><span class=\"line\">    next: function () &#123;</span><br><span class=\"line\">      if (keys[this.index]) &#123;</span><br><span class=\"line\">        return &#123; value: obj[keys[this.index++]], done: false &#125;;</span><br><span class=\"line\">      &#125; else &#123;</span><br><span class=\"line\">        return &#123; done: true &#125;;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    [Symbol.iterator]: function () &#123;</span><br><span class=\"line\">      return this;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    index: 0</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">let generator = function* ()&#123;</span><br><span class=\"line\">  yield 1;</span><br><span class=\"line\">  yield 2;</span><br><span class=\"line\">  yield 3;</span><br><span class=\"line\">&#125;();</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(typeof generator.next);</span><br><span class=\"line\"></span><br><span class=\"line\">let g = o[Symbol.iterator]();</span><br><span class=\"line\">console.log(typeof g.next);</span><br><span class=\"line\">// 返回&quot;function&quot;, 因为有一个next方法，所以这是一个迭代器</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(typeof generator[Symbol.iterator]);</span><br><span class=\"line\">console.log(typeof g[Symbol.iterator])</span><br><span class=\"line\">// 返回&quot;function&quot;, 因为有一个@@iterator方法，所以这是一个可迭代对象</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(generator[Symbol.iterator]() === generator);</span><br><span class=\"line\">console.log(g[Symbol.iterator]() === g);</span><br><span class=\"line\">// 返回true, 因为@@iterator方法返回自身（即迭代器），所以这是一个格式良好的可迭代对象</span><br><span class=\"line\"></span><br><span class=\"line\">console.log([...generator]);</span><br><span class=\"line\">// 返回[1, 2, 3]</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(Symbol.iterator in generator)</span><br><span class=\"line\">console.log(Symbol.iterator in g)</span><br><span class=\"line\">// 返回true, 因为@@iterator方法是generator的一个属性</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"JavaScript-迭代器\"><a href=\"#JavaScript-迭代器\" class=\"headerlink\" title=\"JavaScript 迭代器\"></a>JavaScript 迭代器</h1><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Iterators_and_Generators</span><br></pre></td></tr></table></figure>\n\n\n\n<p>​        首先JavaScript里面的数组我们可以知道其实也是一个对象。但是为什么我们可以通过一些方法进行循环，这里就运用到了一个迭代器的方法。iterator</p>\n<h2 id=\"可迭代协议\"><a href=\"#可迭代协议\" class=\"headerlink\" title=\"可迭代协议\"></a>可迭代协议</h2><p>​        <strong>可迭代协议</strong>允许 JavaScript 对象定义或定制它们的迭代行为，例如，在一个 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/for...of\"><code>for..of</code></a> 结构中，哪些值可以被遍历到。一些内置类型同时是<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Iteration_protocols#%E5%86%85%E7%BD%AE%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1\">内置可迭代对象</a>，并且有默认的迭代行为，比如 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array\"><code>Array</code></a> 或者 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map\"><code>Map</code></a>，而其他内置类型则不是（比如 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object\"><code>Object</code></a>)）。</p>\n<p>​        要成为<strong>可迭代</strong>对象， 一个对象必须实现 <code>**@@iterator**</code> 方法。这意味着对象（或者它<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain\">原型链</a>上的某个对象）必须有一个键为 <code>@@iterator</code> 的属性，可通过常量 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol/iterator\"><code>Symbol.iterator</code></a> 访问该属性</p>\n<p>​        简单来说就是forof进行循环的操作，会先调用一个 <code>@@iterator</code> 方法，然后使用这个方法返回的迭代器获得迭代的值。</p>\n<p>​        通过这里我们就可以知道几个问题</p>\n<ul>\n<li>默认对象为什么不可以进行迭代，是因为对于默认是没有实现这个迭代器的。而Array和Map是默认就存在一个迭代器。</li>\n<li>为什么对于数组存在empty-items，但是 forof 和 forin 为什么会不同的效果呢。就是因为forof是使用的迭代器的形式进行迭代，而forin是使用的键值对的形式进行的迭代。所以对于存在空值的数组，但是forof是通过数组的迭代器，所以还是使用的长度，而forin是使用的键值对，所以对于空值，实际上并没有迭代出来。</li>\n</ul>\n<h3 id=\"可迭代对象\"><a href=\"#可迭代对象\" class=\"headerlink\" title=\"可迭代对象\"></a>可迭代对象</h3><p>​        要成为<strong>可迭代</strong>对象， 一个对象必须实现 <code>**@@iterator**</code> 方法。这意味着对象（或者它<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain\">原型链</a>上的某个对象）必须有一个键为 <code>@@iterator</code> 的属性，可通过常量 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol/iterator\"><code>Symbol.iterator</code></a> 访问该属性。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">属性</th>\n<th align=\"left\">值</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>[Symbol.iterator]</code></td>\n<td align=\"left\">一个无参数的函数，其返回值为一个符合<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Iteration_protocols#%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%8D%8F%E8%AE%AE\">迭代器协议</a>的对象。</td>\n</tr>\n</tbody></table>\n<p>​        此函数可以是普通函数，也可以是生成器函数，以便在调用时返回迭代器对象。 在此生成器函数的内部，可以使用<code>yield</code>提供每个条目。</p>\n<h2 id=\"迭代器协议\"><a href=\"#迭代器协议\" class=\"headerlink\" title=\"迭代器协议\"></a>迭代器协议</h2><p>​        <strong>迭代器协议</strong>定义了产生一系列值（无论是有限个还是无限个）的标准方式。当值为有限个时，所有的值都被迭代完毕后，则会返回一个默认返回值。</p>\n<p>​        只有实现了一个拥有以下语义（semantic）的 <code>**next()**</code> 方法，一个对象才能成为迭代器：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">属性</th>\n<th align=\"left\">值</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>next</code></td>\n<td align=\"left\">一个无参数或者一个参数的函数，返回一个应当拥有以下两个属性的对象：<code>done</code>（boolean）如果迭代器可以产生序列中的下一个值，则为 <code>false</code>。（这等价于没有指定 <code>done</code> 这个属性。）如果迭代器已将序列迭代完毕，则为 <code>true</code>。这种情况下，<code>value</code> 是可选的，如果它依然存在，即为迭代结束之后的默认返回值。<code>value</code>迭代器返回的任何 JavaScript 值。done 为 true 时可省略。<code>next()</code> 方法必须返回一个对象，该对象应当有两个属性： <code>done</code> 和 <code>value</code>，如果返回了一个非对象值（比如 <code>false</code> 或 <code>undefined</code>），则会抛出一个 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/TypeError\"><code>TypeError</code></a> 异常（<code>&quot;iterator.next() returned a non-object value&quot;</code>）。</td>\n</tr>\n</tbody></table>\n<p>​        查看一个内置的可迭代对象</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let someString = &quot;hi&quot;;</span><br><span class=\"line\">typeof someString[Symbol.iterator];          // &quot;function&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">let iterator = someString[Symbol.iterator]();</span><br><span class=\"line\">iterator + &quot;&quot;;                   // &quot;[object String Iterator]&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">iterator.next();                         // &#123; value: &quot;h&quot;, done: false &#125;</span><br><span class=\"line\">iterator.next();                         // &#123; value: &quot;i&quot;, done: false &#125;</span><br><span class=\"line\">iterator.next();                 // &#123; value: undefined, done: true &#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>​        自己提供一个@@iterator 方法，方法需要能够使用next方法。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 必须构造 String 对象以避免字符串字面量 auto-boxing</span><br><span class=\"line\">var someString = new String(&quot;hi&quot;);</span><br><span class=\"line\">someString[Symbol.iterator] = function() &#123;</span><br><span class=\"line\">  return &#123; // 只返回一次元素，字符串 &quot;bye&quot;，的迭代器对象</span><br><span class=\"line\">    next: function() &#123;\t</span><br><span class=\"line\">      if (this._first) &#123;</span><br><span class=\"line\">        this._first = false;</span><br><span class=\"line\">        return &#123; value: &quot;bye&quot;, done: false &#125;;</span><br><span class=\"line\">      &#125; else &#123;</span><br><span class=\"line\">        return &#123; done: true &#125;;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    _first: true</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>​        通过*<strong>生成器函数*</strong> 也可以生成这个效果。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var myIterable = &#123;&#125;;</span><br><span class=\"line\">myIterable[Symbol.iterator] = function* () &#123;</span><br><span class=\"line\">    yield 1;</span><br><span class=\"line\">    yield 2;</span><br><span class=\"line\">    yield 3;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">[...myIterable]; // [1, 2, 3]</span><br></pre></td></tr></table></figure>\n\n\n\n<p>​        一个简单的示例。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let o = &#123;</span><br><span class=\"line\">  a: 1,</span><br><span class=\"line\">  b: 2,</span><br><span class=\"line\">  x: 3</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">这个是使用的生成器语法进行的操作。</span><br><span class=\"line\">个人建议使用生成器函数进行操作，生成器的语法非常合适这个迭代器。如果不使用生成器的语法，会比较复杂。</span><br><span class=\"line\">o[Symbol.iterator] = function* () &#123;</span><br><span class=\"line\">  let keys = Object.keys(this);</span><br><span class=\"line\">  for (const keysKey in keys) &#123;</span><br><span class=\"line\">    yield this[keys[keysKey]];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">这里是一个没有使用生成器的语法，所以对于返回值，需要有一个next函数进行调用。然后，调用之后会返回一个值，然后如何解决是否返回结束，行为就是一个index进行存储，但是如果先进行了index的修改，那么return的时候也要进行一次修改，所以会比较麻烦。</span><br><span class=\"line\">o[Symbol.iterator] = function () &#123;</span><br><span class=\"line\">  let keys = Object.keys(this);</span><br><span class=\"line\">  let obj = this;</span><br><span class=\"line\"></span><br><span class=\"line\">  return &#123;</span><br><span class=\"line\">    next: function () &#123;</span><br><span class=\"line\">      if (keys[this.index]) &#123;</span><br><span class=\"line\">        //最终方式</span><br><span class=\"line\">        return &#123; value: obj[keys[this.index++]], done: false &#125;;</span><br><span class=\"line\">        </span><br><span class=\"line\">        //++this.index;</span><br><span class=\"line\">        //return &#123; value: obj[keys[this.index-1]], done: false &#125;;</span><br><span class=\"line\">        </span><br><span class=\"line\">        //\t</span><br><span class=\"line\">        //return &#123; value: obj[keys[this.index]], done: false &#125;;</span><br><span class=\"line\">        </span><br><span class=\"line\">        //\t通过这里我们也 知道了，++会先于 &amp;&amp;||逻辑运算符。</span><br><span class=\"line\">        //return this.index++ || console.log(this.index) &amp;&amp; &#123; value: obj[keys[this.index]], done: false &#125;;</span><br><span class=\"line\">      &#125; else &#123;</span><br><span class=\"line\">        return &#123; done: true &#125;;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    index: 0</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>​        通过这个方法可以取出迭代器对象并且使用next()获取下一个迭代的值。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let oo = o[Symbol.iterator]();</span><br><span class=\"line\">console.log(oo.next());</span><br></pre></td></tr></table></figure>\n\n\n\n<p>生成器对象既是一个迭代器，也是一个可迭代的对象。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let generator = function* ()&#123;</span><br><span class=\"line\">  yield 1;</span><br><span class=\"line\">  yield 2;</span><br><span class=\"line\">  yield 3;</span><br><span class=\"line\">&#125;();</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(typeof generator.next);</span><br><span class=\"line\">// 返回&quot;function&quot;, 因为有一个next方法，所以这是一个迭代器</span><br><span class=\"line\">迭代器就是存在了next方法的一个对象，next方法的返回值为value和done</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(typeof generator[Symbol.iterator]);</span><br><span class=\"line\">// 返回&quot;function&quot;, 因为有一个@@iterator方法，所以这是一个可迭代对象</span><br><span class=\"line\">可迭代对象，意思就是说这个是可以使用迭代器的，可以使用forof方法。简单来说就是这个方法内部实现了 [Symbol.iterator] 函数。</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(generator[Symbol.iterator]() === generator);</span><br><span class=\"line\">// 返回true, 因为@@iterator方法返回自身（即迭代器），所以这是一个格式良好的可迭代对象</span><br><span class=\"line\">首先，我们知道这是一个可迭代对象，也是一个迭代器，意思就是说，这个迭代器的内部也存在一个迭代器。一个是它本身的任务就是一个迭代器，另一个是它作为一个可迭代对象，它存在一个内部的迭代器，然后这里的意思就是说可迭代对象的迭代器方法和它自身是相等的。</span><br><span class=\"line\">感觉就像是一个普通函数返回的对象里面有一个next方法和一个[Symbol.iterator]方法，然后这个Symbol.iterator方法是直接返回自身。所以就是迭代器的迭代器方法返回为自身。</span><br><span class=\"line\"></span><br><span class=\"line\">console.log([...generator]);</span><br><span class=\"line\">// 返回[1, 2, 3]</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(Symbol.iterator in generator)</span><br><span class=\"line\">// 返回true, 因为@@iterator方法是generator的一个属性</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let o = &#123;</span><br><span class=\"line\">  a: 1,</span><br><span class=\"line\">  b: 2,</span><br><span class=\"line\">  x: 3</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// o[Symbol.iterator] = function* () &#123;</span><br><span class=\"line\">//   let keys = Object.keys(this);</span><br><span class=\"line\">//</span><br><span class=\"line\">//   for (const keysKey in keys) &#123;</span><br><span class=\"line\">//     yield this[keys[keysKey]];</span><br><span class=\"line\">//   &#125;</span><br><span class=\"line\">// &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">o[Symbol.iterator] = function () &#123;</span><br><span class=\"line\">  let keys = Object.keys(this);</span><br><span class=\"line\">  let obj = this;</span><br><span class=\"line\">  return &#123;</span><br><span class=\"line\">    next: function () &#123;</span><br><span class=\"line\">      if (keys[this.index]) &#123;</span><br><span class=\"line\">        return &#123; value: obj[keys[this.index++]], done: false &#125;;</span><br><span class=\"line\">      &#125; else &#123;</span><br><span class=\"line\">        return &#123; done: true &#125;;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    [Symbol.iterator]: function () &#123;</span><br><span class=\"line\">      return this;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    index: 0</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">let generator = function* ()&#123;</span><br><span class=\"line\">  yield 1;</span><br><span class=\"line\">  yield 2;</span><br><span class=\"line\">  yield 3;</span><br><span class=\"line\">&#125;();</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(typeof generator.next);</span><br><span class=\"line\"></span><br><span class=\"line\">let g = o[Symbol.iterator]();</span><br><span class=\"line\">console.log(typeof g.next);</span><br><span class=\"line\">// 返回&quot;function&quot;, 因为有一个next方法，所以这是一个迭代器</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(typeof generator[Symbol.iterator]);</span><br><span class=\"line\">console.log(typeof g[Symbol.iterator])</span><br><span class=\"line\">// 返回&quot;function&quot;, 因为有一个@@iterator方法，所以这是一个可迭代对象</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(generator[Symbol.iterator]() === generator);</span><br><span class=\"line\">console.log(g[Symbol.iterator]() === g);</span><br><span class=\"line\">// 返回true, 因为@@iterator方法返回自身（即迭代器），所以这是一个格式良好的可迭代对象</span><br><span class=\"line\"></span><br><span class=\"line\">console.log([...generator]);</span><br><span class=\"line\">// 返回[1, 2, 3]</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(Symbol.iterator in generator)</span><br><span class=\"line\">console.log(Symbol.iterator in g)</span><br><span class=\"line\">// 返回true, 因为@@iterator方法是generator的一个属性</span><br></pre></td></tr></table></figure>\n\n"},{"title":"高阶函数","date":"2021-11-13T03:17:08.000Z","_content":"\n\n\n#  JavaScript 高阶函数\n\n​\t\t面试的时候我被问到了什么是高阶函数，当时就蒙了，现在去了解了一下。\n\n​\t\t其实这个东西很简单，你也经常使用。只是听起来高大上罢了\n\n\n\n## 函数是什么\n\n​\t\t说到高阶函数，我们需要知道函数的一些形式，我们也需要思考函数可以和变量一样进行传递吗\n\n​\t\t在JavaScript中，函数实际上也是一个对象。每一个函数都是Function类型的一个实例。它既有 \\_\\_proto\\_\\_，也有 prototype。但是prototype才是它自身的，而 proto 是它原型的一个指向。\n\n\n\n## 什么是高阶函数\n\n​\t\t在这里我们知道了函数其实就是一个特殊的对象，所以其实可以进行传递，因此。\n\n​\t\t高阶函数由此而来，高阶函数就是进行了函数的传递，不是将函数当成一个函数，而是当成一个对象进行传递。\n\n\n\n## 常用的高阶函数的一些方法\n\n```\nmap， reduce， sort 等等。\n```\n\n​\t\t这里就不详细进行介绍。\n\n```\nmap(Number);\n\nmap是一个会将一个数组的值调用回调函数生成的值作为一个新的数组\nNumber就是转数字，\n\n所以这两个的结合就是，会将数组的值挨个使用一次Number方法，将生成的结果进行返回。\n```\n\n","source":"_posts/JavaScript/概念/高阶函数.md","raw":"---\ntitle: 高阶函数\ndate: 2021-11-13 11:17:08\ntags:\n - JavaScript\n - 随笔\ncategories:\n - JavaScript\n - 随笔\n---\n\n\n\n#  JavaScript 高阶函数\n\n​\t\t面试的时候我被问到了什么是高阶函数，当时就蒙了，现在去了解了一下。\n\n​\t\t其实这个东西很简单，你也经常使用。只是听起来高大上罢了\n\n\n\n## 函数是什么\n\n​\t\t说到高阶函数，我们需要知道函数的一些形式，我们也需要思考函数可以和变量一样进行传递吗\n\n​\t\t在JavaScript中，函数实际上也是一个对象。每一个函数都是Function类型的一个实例。它既有 \\_\\_proto\\_\\_，也有 prototype。但是prototype才是它自身的，而 proto 是它原型的一个指向。\n\n\n\n## 什么是高阶函数\n\n​\t\t在这里我们知道了函数其实就是一个特殊的对象，所以其实可以进行传递，因此。\n\n​\t\t高阶函数由此而来，高阶函数就是进行了函数的传递，不是将函数当成一个函数，而是当成一个对象进行传递。\n\n\n\n## 常用的高阶函数的一些方法\n\n```\nmap， reduce， sort 等等。\n```\n\n​\t\t这里就不详细进行介绍。\n\n```\nmap(Number);\n\nmap是一个会将一个数组的值调用回调函数生成的值作为一个新的数组\nNumber就是转数字，\n\n所以这两个的结合就是，会将数组的值挨个使用一次Number方法，将生成的结果进行返回。\n```\n\n","slug":"JavaScript/概念/高阶函数","published":1,"updated":"2021-12-09T01:56:49.404Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckznhkk8r007eikubg26r4pi0","content":"<h1 id=\"JavaScript-高阶函数\"><a href=\"#JavaScript-高阶函数\" class=\"headerlink\" title=\"JavaScript 高阶函数\"></a>JavaScript 高阶函数</h1><p>​        面试的时候我被问到了什么是高阶函数，当时就蒙了，现在去了解了一下。</p>\n<p>​        其实这个东西很简单，你也经常使用。只是听起来高大上罢了</p>\n<h2 id=\"函数是什么\"><a href=\"#函数是什么\" class=\"headerlink\" title=\"函数是什么\"></a>函数是什么</h2><p>​        说到高阶函数，我们需要知道函数的一些形式，我们也需要思考函数可以和变量一样进行传递吗</p>\n<p>​        在JavaScript中，函数实际上也是一个对象。每一个函数都是Function类型的一个实例。它既有 __proto__，也有 prototype。但是prototype才是它自身的，而 proto 是它原型的一个指向。</p>\n<h2 id=\"什么是高阶函数\"><a href=\"#什么是高阶函数\" class=\"headerlink\" title=\"什么是高阶函数\"></a>什么是高阶函数</h2><p>​        在这里我们知道了函数其实就是一个特殊的对象，所以其实可以进行传递，因此。</p>\n<p>​        高阶函数由此而来，高阶函数就是进行了函数的传递，不是将函数当成一个函数，而是当成一个对象进行传递。</p>\n<h2 id=\"常用的高阶函数的一些方法\"><a href=\"#常用的高阶函数的一些方法\" class=\"headerlink\" title=\"常用的高阶函数的一些方法\"></a>常用的高阶函数的一些方法</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">map， reduce， sort 等等。</span><br></pre></td></tr></table></figure>\n\n<p>​        这里就不详细进行介绍。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">map(Number);</span><br><span class=\"line\"></span><br><span class=\"line\">map是一个会将一个数组的值调用回调函数生成的值作为一个新的数组</span><br><span class=\"line\">Number就是转数字，</span><br><span class=\"line\"></span><br><span class=\"line\">所以这两个的结合就是，会将数组的值挨个使用一次Number方法，将生成的结果进行返回。</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"JavaScript-高阶函数\"><a href=\"#JavaScript-高阶函数\" class=\"headerlink\" title=\"JavaScript 高阶函数\"></a>JavaScript 高阶函数</h1><p>​        面试的时候我被问到了什么是高阶函数，当时就蒙了，现在去了解了一下。</p>\n<p>​        其实这个东西很简单，你也经常使用。只是听起来高大上罢了</p>\n<h2 id=\"函数是什么\"><a href=\"#函数是什么\" class=\"headerlink\" title=\"函数是什么\"></a>函数是什么</h2><p>​        说到高阶函数，我们需要知道函数的一些形式，我们也需要思考函数可以和变量一样进行传递吗</p>\n<p>​        在JavaScript中，函数实际上也是一个对象。每一个函数都是Function类型的一个实例。它既有 __proto__，也有 prototype。但是prototype才是它自身的，而 proto 是它原型的一个指向。</p>\n<h2 id=\"什么是高阶函数\"><a href=\"#什么是高阶函数\" class=\"headerlink\" title=\"什么是高阶函数\"></a>什么是高阶函数</h2><p>​        在这里我们知道了函数其实就是一个特殊的对象，所以其实可以进行传递，因此。</p>\n<p>​        高阶函数由此而来，高阶函数就是进行了函数的传递，不是将函数当成一个函数，而是当成一个对象进行传递。</p>\n<h2 id=\"常用的高阶函数的一些方法\"><a href=\"#常用的高阶函数的一些方法\" class=\"headerlink\" title=\"常用的高阶函数的一些方法\"></a>常用的高阶函数的一些方法</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">map， reduce， sort 等等。</span><br></pre></td></tr></table></figure>\n\n<p>​        这里就不详细进行介绍。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">map(Number);</span><br><span class=\"line\"></span><br><span class=\"line\">map是一个会将一个数组的值调用回调函数生成的值作为一个新的数组</span><br><span class=\"line\">Number就是转数字，</span><br><span class=\"line\"></span><br><span class=\"line\">所以这两个的结合就是，会将数组的值挨个使用一次Number方法，将生成的结果进行返回。</span><br></pre></td></tr></table></figure>\n\n"},{"title":"JavaScript类型转换","date":"2021-10-19T02:07:37.000Z","_content":"\n\n\n#  JavaScript类型转换\n\n参考的文章\n\n```\nhttps://www.cnblogs.com/shikaka/p/10463293.html\nhttps://www.cnblogs.com/shikaka/p/10473462.html\n```\n\n\n\n## 基本数据类型\n\n```\nstring， number， Boolean， null， undefined， symbol\n```\n\n基本数据类型是没有方法可以调用的。\n\n但是我们却发现，\n\n```\n'aaa'.indexOf('a');\n```\n\n这个明明是基本数据类型，但是却可以调用方法，这个是为什么呢。\n\n这个是因为`JavaScript`在底层进行了一个操作，当发现调用方法的是一个基本数据类型的话，会根据这个类型来创建一个对应的引用数据类型对象。然后再调用这个方法，调用之后将返回值进行返回并将这个对象进行删除。\n\n\n\n在 `JavaScript` 中，类型转换主要的两个方法是\n\n`valueOf` ， `toString`\n\n我们下面分别对这两个进行一个判断使用操作。\n\n\n\n```\nlet a = 1,\n    b = 'a',\n    c = true,\n    d = undefined,\n    e = null,\n    f = [1, 2, 3],\n    g = ['1', '3'],\n    h = new Number(3),\n    i = new String('12'),\n    j = new Boolean(false),\n    k = new Object({ a: 3} ),\n    l = { b: 4 },\n    m = function () {},\n    n = new Date(),\n    o = new RegExp('sss'),\n    p = /sss/,\n    q = `sdcard`,\n    r = new Array([1,2,3]);\n```\n\n\n\n## valueOf\n\n```\nconsole.log(a.valueOf());\nconsole.log(b.valueOf());\nconsole.log(c.valueOf());\n// console.log(d.valueOf());\n// console.log(e.valueOf());\nconsole.log(f.valueOf());\nconsole.log(h.valueOf());\nconsole.log(i.valueOf());\nconsole.log(j.valueOf());\nconsole.log(k.valueOf());\nconsole.log(n.valueOf());\nconsole.log(o.valueOf());\n```\n\n#### 这就是执行的结果。\n\n```\n1\na\ntrue\n[ 1, 2, 3 ]\n3\n12\nfalse\n{ a: 3 }\n1634610286344\n/sss/\n```\n\n#### 我们可以从结果里面看到\n\n| 类型                                         | 结果                                                     |\n| -------------------------------------------- | -------------------------------------------------------- |\n| null，undefined                              | 没有valueOf方法，会报错                                  |\n| 基本数据类型，包括Symbol类型                 | valueOf方法为其本身，可以使用 === 来判断，Symbol为true。 |\n| 对象，数组，方法，正则                       | 也为其本身                                               |\n| 使用new方法创建的基本数据类型，new number(1) | 为其值，与原来不等。                                     |\n| date类型                                     | 当前时间距 1970.01.01 午夜的毫秒数                       |\n\n\n\n所以我们可以看到，\n\n基本除了对象，其他的类型使用valueOf方法都可以转换成基本数据类型。\n\n对于使用new方法创建的基本数据类型的引用数据类型，也会被转换成基本数据类型。\n\n这里的原因，是因为 `number `对象对 `valueOf` 进行了一次重写，所以在调用的时候就会调用自己所重写的方法，于是返回的结果会不同。其他也同理。\n\n但是`JavaScript`内部是如何进行操作，取出值的，我还是不了解。\n\n\n\n## toString\n\n```\nconsole.log(a.toString());\nconsole.log(b.toString());\nconsole.log(c.toString());\n// console.log(d.toString());\n// console.log(e.toString());\nconsole.log(f.toString());\nconsole.log(h.toString());\nconsole.log(i.toString());\nconsole.log(j.toString());\nconsole.log(k.toString());\nconsole.log(n.toString());\nconsole.log(o.toString());\n```\n\n```\n1\na\ntrue\n1,2,3\n3\n12\nfalse\n[object Object]\nTue Oct 19 2021 10:50:07 GMT+0800 (中国标准时间)\n/sss/\n```\n\n\n\n| 类型             | 结果                           |\n| ---------------- | ------------------------------ |\n| null， undefined | 没有toString方法               |\n| 基本数据类型     | 直接转为字符串                 |\n| 普通对象         | 直接转为字符串 [object Object] |\n| 日期，正则对象   | 转为对应值的字符串             |\n\n\n\n# 隐式类型转换\n\n\n\n我这里主要讲解一下隐式类型转换\n\n### 对于一个对象转为基本数据类型的方法\n\n对于一个不是基本数据类型的。会先通过 `valueOf` 转换，看是否能转为基本数据类型\n\n如果还不可以，然后就会使用 `toString `方法转为字符串。然后再来进行判断。\n\n对于 `Date` 对象的话，使用顺序会反过来\n\n\n\n### 转字符串。\n\n就直接toString方法就行了。\n\n\n\n### 转数字\n\n就类似于 `Number(undefined); ` 的情况\n\n```\nnull， false\t\t-> 0\nundefined\t\t-> NaN\n```\n\n#### 对于字符串\n\n```\n字符串含有字符的。没有特殊含义的都为 NaN\n\n'1.111111111111111e+50' 这个就会转为数字，还有进制表示和小数点会转，其他带有字符会被转成 NaN\n```\n\n#### 对于对象\n\n```\n先使用前面我说过的规则转为基本类型，然后再进行转换。\n```\n\n\n\n### 转布尔值\n\n几个特殊值为 `false`\n\n```\nNaN, undefined， null， 0， +0， -0， ''\n```\n\n其他为true\n\n\n\n## 基本上涉及运算和比较就会出现隐式类型转换\n\n\n\n### 加号 + \n\n存在字符串则转为字符串的拼接操作\n\n非字符串就会转数字操作。\n\n```\nconsole.log(1+2+'')\n1+2 先为3，\n然后3+'' 为3\n```\n\n这个就涉及到了上面的转换规则\n\n\n\n这里有个小问题\n\n```\nlet x = Symbol(1);\nconsole.log(x + '1')\n这样会抛出异常，虽然Symbol可以使用toString，\n但是不能进行隐式转换。\n```\n\n\n\n### 减号 - 乘号 * 除号 /\n\n会转为数字进行运算。\n\n```\n特殊的，对于 NaN运算得NaN\n对于 0/0 等于 NaN\n对于 1/0 等于 Infinity\n```\n\n\n\n|| 和 && 这里这个返回值不是`true`和`false`而是返回两边操作数的执行结果。\n\n\n\n### 比较运算\n\n**转换规则**\n\n<img src=\"JavaScript类型转换/image-20211019105728109.png\" alt=\"image-20211019105728109\" style=\"zoom:67%;\" />\n\n\n\n#### == 和 ===\n\n非严格相等等号 可以允许强制类型转换，\n\n而严格相等等号 不允许强制类型的转换。\n\n\n\n其他的就如上，使用上面的转换规则进行转换。\n\n\n\n这里有个小问题点\n\n```\nif ([]) {\n  console.log(1)\n} else {\n  console.log(2)\n}\n此时会输出为1，所以说明了[]在if判断里面为真，但是 [] == true 为false，\n这里可以看上面 转布尔值 那个地方，说明了，布尔在进行判断时 除了 undefined，null，NaN，0， ''，其他都为true\n因此也可以说明，if判断是使用的 Boolean 来进行的判断为真还是为假。而不是与true进行的比较。\n```\n\n\n\n#### null和undefined的比较\n\nnull和undefined进行比较时\n\n​\t使用非严格等号为 true\n\n​\t使用严格等号为 false\n\n```\nnull == undefined\n```\n\n\n\n#### NaN 不与任何值相等，包括自己\n\n```\nNaN == NaN\tfalse\n```\n\n```\n并且 NaN > 0 和 NaN <= 0 都为 false\n```\n\n\n\n\n\n","source":"_posts/JavaScript/概念/JavaScript类型转换.md","raw":"---\ntitle: JavaScript类型转换\ndate: 2021-10-19 10:07:37\ntags:\n - JavaScript\n - 类型转换\ncategories:\n - JavaScript\n - Global_Objects\n---\n\n\n\n#  JavaScript类型转换\n\n参考的文章\n\n```\nhttps://www.cnblogs.com/shikaka/p/10463293.html\nhttps://www.cnblogs.com/shikaka/p/10473462.html\n```\n\n\n\n## 基本数据类型\n\n```\nstring， number， Boolean， null， undefined， symbol\n```\n\n基本数据类型是没有方法可以调用的。\n\n但是我们却发现，\n\n```\n'aaa'.indexOf('a');\n```\n\n这个明明是基本数据类型，但是却可以调用方法，这个是为什么呢。\n\n这个是因为`JavaScript`在底层进行了一个操作，当发现调用方法的是一个基本数据类型的话，会根据这个类型来创建一个对应的引用数据类型对象。然后再调用这个方法，调用之后将返回值进行返回并将这个对象进行删除。\n\n\n\n在 `JavaScript` 中，类型转换主要的两个方法是\n\n`valueOf` ， `toString`\n\n我们下面分别对这两个进行一个判断使用操作。\n\n\n\n```\nlet a = 1,\n    b = 'a',\n    c = true,\n    d = undefined,\n    e = null,\n    f = [1, 2, 3],\n    g = ['1', '3'],\n    h = new Number(3),\n    i = new String('12'),\n    j = new Boolean(false),\n    k = new Object({ a: 3} ),\n    l = { b: 4 },\n    m = function () {},\n    n = new Date(),\n    o = new RegExp('sss'),\n    p = /sss/,\n    q = `sdcard`,\n    r = new Array([1,2,3]);\n```\n\n\n\n## valueOf\n\n```\nconsole.log(a.valueOf());\nconsole.log(b.valueOf());\nconsole.log(c.valueOf());\n// console.log(d.valueOf());\n// console.log(e.valueOf());\nconsole.log(f.valueOf());\nconsole.log(h.valueOf());\nconsole.log(i.valueOf());\nconsole.log(j.valueOf());\nconsole.log(k.valueOf());\nconsole.log(n.valueOf());\nconsole.log(o.valueOf());\n```\n\n#### 这就是执行的结果。\n\n```\n1\na\ntrue\n[ 1, 2, 3 ]\n3\n12\nfalse\n{ a: 3 }\n1634610286344\n/sss/\n```\n\n#### 我们可以从结果里面看到\n\n| 类型                                         | 结果                                                     |\n| -------------------------------------------- | -------------------------------------------------------- |\n| null，undefined                              | 没有valueOf方法，会报错                                  |\n| 基本数据类型，包括Symbol类型                 | valueOf方法为其本身，可以使用 === 来判断，Symbol为true。 |\n| 对象，数组，方法，正则                       | 也为其本身                                               |\n| 使用new方法创建的基本数据类型，new number(1) | 为其值，与原来不等。                                     |\n| date类型                                     | 当前时间距 1970.01.01 午夜的毫秒数                       |\n\n\n\n所以我们可以看到，\n\n基本除了对象，其他的类型使用valueOf方法都可以转换成基本数据类型。\n\n对于使用new方法创建的基本数据类型的引用数据类型，也会被转换成基本数据类型。\n\n这里的原因，是因为 `number `对象对 `valueOf` 进行了一次重写，所以在调用的时候就会调用自己所重写的方法，于是返回的结果会不同。其他也同理。\n\n但是`JavaScript`内部是如何进行操作，取出值的，我还是不了解。\n\n\n\n## toString\n\n```\nconsole.log(a.toString());\nconsole.log(b.toString());\nconsole.log(c.toString());\n// console.log(d.toString());\n// console.log(e.toString());\nconsole.log(f.toString());\nconsole.log(h.toString());\nconsole.log(i.toString());\nconsole.log(j.toString());\nconsole.log(k.toString());\nconsole.log(n.toString());\nconsole.log(o.toString());\n```\n\n```\n1\na\ntrue\n1,2,3\n3\n12\nfalse\n[object Object]\nTue Oct 19 2021 10:50:07 GMT+0800 (中国标准时间)\n/sss/\n```\n\n\n\n| 类型             | 结果                           |\n| ---------------- | ------------------------------ |\n| null， undefined | 没有toString方法               |\n| 基本数据类型     | 直接转为字符串                 |\n| 普通对象         | 直接转为字符串 [object Object] |\n| 日期，正则对象   | 转为对应值的字符串             |\n\n\n\n# 隐式类型转换\n\n\n\n我这里主要讲解一下隐式类型转换\n\n### 对于一个对象转为基本数据类型的方法\n\n对于一个不是基本数据类型的。会先通过 `valueOf` 转换，看是否能转为基本数据类型\n\n如果还不可以，然后就会使用 `toString `方法转为字符串。然后再来进行判断。\n\n对于 `Date` 对象的话，使用顺序会反过来\n\n\n\n### 转字符串。\n\n就直接toString方法就行了。\n\n\n\n### 转数字\n\n就类似于 `Number(undefined); ` 的情况\n\n```\nnull， false\t\t-> 0\nundefined\t\t-> NaN\n```\n\n#### 对于字符串\n\n```\n字符串含有字符的。没有特殊含义的都为 NaN\n\n'1.111111111111111e+50' 这个就会转为数字，还有进制表示和小数点会转，其他带有字符会被转成 NaN\n```\n\n#### 对于对象\n\n```\n先使用前面我说过的规则转为基本类型，然后再进行转换。\n```\n\n\n\n### 转布尔值\n\n几个特殊值为 `false`\n\n```\nNaN, undefined， null， 0， +0， -0， ''\n```\n\n其他为true\n\n\n\n## 基本上涉及运算和比较就会出现隐式类型转换\n\n\n\n### 加号 + \n\n存在字符串则转为字符串的拼接操作\n\n非字符串就会转数字操作。\n\n```\nconsole.log(1+2+'')\n1+2 先为3，\n然后3+'' 为3\n```\n\n这个就涉及到了上面的转换规则\n\n\n\n这里有个小问题\n\n```\nlet x = Symbol(1);\nconsole.log(x + '1')\n这样会抛出异常，虽然Symbol可以使用toString，\n但是不能进行隐式转换。\n```\n\n\n\n### 减号 - 乘号 * 除号 /\n\n会转为数字进行运算。\n\n```\n特殊的，对于 NaN运算得NaN\n对于 0/0 等于 NaN\n对于 1/0 等于 Infinity\n```\n\n\n\n|| 和 && 这里这个返回值不是`true`和`false`而是返回两边操作数的执行结果。\n\n\n\n### 比较运算\n\n**转换规则**\n\n<img src=\"JavaScript类型转换/image-20211019105728109.png\" alt=\"image-20211019105728109\" style=\"zoom:67%;\" />\n\n\n\n#### == 和 ===\n\n非严格相等等号 可以允许强制类型转换，\n\n而严格相等等号 不允许强制类型的转换。\n\n\n\n其他的就如上，使用上面的转换规则进行转换。\n\n\n\n这里有个小问题点\n\n```\nif ([]) {\n  console.log(1)\n} else {\n  console.log(2)\n}\n此时会输出为1，所以说明了[]在if判断里面为真，但是 [] == true 为false，\n这里可以看上面 转布尔值 那个地方，说明了，布尔在进行判断时 除了 undefined，null，NaN，0， ''，其他都为true\n因此也可以说明，if判断是使用的 Boolean 来进行的判断为真还是为假。而不是与true进行的比较。\n```\n\n\n\n#### null和undefined的比较\n\nnull和undefined进行比较时\n\n​\t使用非严格等号为 true\n\n​\t使用严格等号为 false\n\n```\nnull == undefined\n```\n\n\n\n#### NaN 不与任何值相等，包括自己\n\n```\nNaN == NaN\tfalse\n```\n\n```\n并且 NaN > 0 和 NaN <= 0 都为 false\n```\n\n\n\n\n\n","slug":"JavaScript/概念/JavaScript类型转换","published":1,"updated":"2021-12-09T01:56:49.404Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckznhkk8r007hikubdyaj5rct","content":"<h1 id=\"JavaScript类型转换\"><a href=\"#JavaScript类型转换\" class=\"headerlink\" title=\"JavaScript类型转换\"></a>JavaScript类型转换</h1><p>参考的文章</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://www.cnblogs.com/shikaka/p/10463293.html</span><br><span class=\"line\">https://www.cnblogs.com/shikaka/p/10473462.html</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"基本数据类型\"><a href=\"#基本数据类型\" class=\"headerlink\" title=\"基本数据类型\"></a>基本数据类型</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">string， number， Boolean， null， undefined， symbol</span><br></pre></td></tr></table></figure>\n\n<p>基本数据类型是没有方法可以调用的。</p>\n<p>但是我们却发现，</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x27;aaa&#x27;.indexOf(&#x27;a&#x27;);</span><br></pre></td></tr></table></figure>\n\n<p>这个明明是基本数据类型，但是却可以调用方法，这个是为什么呢。</p>\n<p>这个是因为<code>JavaScript</code>在底层进行了一个操作，当发现调用方法的是一个基本数据类型的话，会根据这个类型来创建一个对应的引用数据类型对象。然后再调用这个方法，调用之后将返回值进行返回并将这个对象进行删除。</p>\n<p>在 <code>JavaScript</code> 中，类型转换主要的两个方法是</p>\n<p><code>valueOf</code> ， <code>toString</code></p>\n<p>我们下面分别对这两个进行一个判断使用操作。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let a = 1,</span><br><span class=\"line\">    b = &#x27;a&#x27;,</span><br><span class=\"line\">    c = true,</span><br><span class=\"line\">    d = undefined,</span><br><span class=\"line\">    e = null,</span><br><span class=\"line\">    f = [1, 2, 3],</span><br><span class=\"line\">    g = [&#x27;1&#x27;, &#x27;3&#x27;],</span><br><span class=\"line\">    h = new Number(3),</span><br><span class=\"line\">    i = new String(&#x27;12&#x27;),</span><br><span class=\"line\">    j = new Boolean(false),</span><br><span class=\"line\">    k = new Object(&#123; a: 3&#125; ),</span><br><span class=\"line\">    l = &#123; b: 4 &#125;,</span><br><span class=\"line\">    m = function () &#123;&#125;,</span><br><span class=\"line\">    n = new Date(),</span><br><span class=\"line\">    o = new RegExp(&#x27;sss&#x27;),</span><br><span class=\"line\">    p = /sss/,</span><br><span class=\"line\">    q = `sdcard`,</span><br><span class=\"line\">    r = new Array([1,2,3]);</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"valueOf-NaN\"><a href=\"#valueOf-NaN\" class=\"headerlink\" title=\"valueOf\"></a>valueOf</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(a.valueOf());</span><br><span class=\"line\">console.log(b.valueOf());</span><br><span class=\"line\">console.log(c.valueOf());</span><br><span class=\"line\">// console.log(d.valueOf());</span><br><span class=\"line\">// console.log(e.valueOf());</span><br><span class=\"line\">console.log(f.valueOf());</span><br><span class=\"line\">console.log(h.valueOf());</span><br><span class=\"line\">console.log(i.valueOf());</span><br><span class=\"line\">console.log(j.valueOf());</span><br><span class=\"line\">console.log(k.valueOf());</span><br><span class=\"line\">console.log(n.valueOf());</span><br><span class=\"line\">console.log(o.valueOf());</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"这就是执行的结果。\"><a href=\"#这就是执行的结果。\" class=\"headerlink\" title=\"这就是执行的结果。\"></a>这就是执行的结果。</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1</span><br><span class=\"line\">a</span><br><span class=\"line\">true</span><br><span class=\"line\">[ 1, 2, 3 ]</span><br><span class=\"line\">3</span><br><span class=\"line\">12</span><br><span class=\"line\">false</span><br><span class=\"line\">&#123; a: 3 &#125;</span><br><span class=\"line\">1634610286344</span><br><span class=\"line\">/sss/</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"我们可以从结果里面看到\"><a href=\"#我们可以从结果里面看到\" class=\"headerlink\" title=\"我们可以从结果里面看到\"></a>我们可以从结果里面看到</h4><table>\n<thead>\n<tr>\n<th>类型</th>\n<th>结果</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>null，undefined</td>\n<td>没有valueOf方法，会报错</td>\n</tr>\n<tr>\n<td>基本数据类型，包括Symbol类型</td>\n<td>valueOf方法为其本身，可以使用 === 来判断，Symbol为true。</td>\n</tr>\n<tr>\n<td>对象，数组，方法，正则</td>\n<td>也为其本身</td>\n</tr>\n<tr>\n<td>使用new方法创建的基本数据类型，new number(1)</td>\n<td>为其值，与原来不等。</td>\n</tr>\n<tr>\n<td>date类型</td>\n<td>当前时间距 1970.01.01 午夜的毫秒数</td>\n</tr>\n</tbody></table>\n<p>所以我们可以看到，</p>\n<p>基本除了对象，其他的类型使用valueOf方法都可以转换成基本数据类型。</p>\n<p>对于使用new方法创建的基本数据类型的引用数据类型，也会被转换成基本数据类型。</p>\n<p>这里的原因，是因为 <code>number </code>对象对 <code>valueOf</code> 进行了一次重写，所以在调用的时候就会调用自己所重写的方法，于是返回的结果会不同。其他也同理。</p>\n<p>但是<code>JavaScript</code>内部是如何进行操作，取出值的，我还是不了解。</p>\n<h2 id=\"toString-NaN\"><a href=\"#toString-NaN\" class=\"headerlink\" title=\"toString\"></a>toString</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(a.toString());</span><br><span class=\"line\">console.log(b.toString());</span><br><span class=\"line\">console.log(c.toString());</span><br><span class=\"line\">// console.log(d.toString());</span><br><span class=\"line\">// console.log(e.toString());</span><br><span class=\"line\">console.log(f.toString());</span><br><span class=\"line\">console.log(h.toString());</span><br><span class=\"line\">console.log(i.toString());</span><br><span class=\"line\">console.log(j.toString());</span><br><span class=\"line\">console.log(k.toString());</span><br><span class=\"line\">console.log(n.toString());</span><br><span class=\"line\">console.log(o.toString());</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1</span><br><span class=\"line\">a</span><br><span class=\"line\">true</span><br><span class=\"line\">1,2,3</span><br><span class=\"line\">3</span><br><span class=\"line\">12</span><br><span class=\"line\">false</span><br><span class=\"line\">[object Object]</span><br><span class=\"line\">Tue Oct 19 2021 10:50:07 GMT+0800 (中国标准时间)</span><br><span class=\"line\">/sss/</span><br></pre></td></tr></table></figure>\n\n\n\n<table>\n<thead>\n<tr>\n<th>类型</th>\n<th>结果</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>null， undefined</td>\n<td>没有toString方法</td>\n</tr>\n<tr>\n<td>基本数据类型</td>\n<td>直接转为字符串</td>\n</tr>\n<tr>\n<td>普通对象</td>\n<td>直接转为字符串 [object Object]</td>\n</tr>\n<tr>\n<td>日期，正则对象</td>\n<td>转为对应值的字符串</td>\n</tr>\n</tbody></table>\n<h1 id=\"隐式类型转换\"><a href=\"#隐式类型转换\" class=\"headerlink\" title=\"隐式类型转换\"></a>隐式类型转换</h1><p>我这里主要讲解一下隐式类型转换</p>\n<h3 id=\"对于一个对象转为基本数据类型的方法\"><a href=\"#对于一个对象转为基本数据类型的方法\" class=\"headerlink\" title=\"对于一个对象转为基本数据类型的方法\"></a>对于一个对象转为基本数据类型的方法</h3><p>对于一个不是基本数据类型的。会先通过 <code>valueOf</code> 转换，看是否能转为基本数据类型</p>\n<p>如果还不可以，然后就会使用 <code>toString </code>方法转为字符串。然后再来进行判断。</p>\n<p>对于 <code>Date</code> 对象的话，使用顺序会反过来</p>\n<h3 id=\"转字符串。\"><a href=\"#转字符串。\" class=\"headerlink\" title=\"转字符串。\"></a>转字符串。</h3><p>就直接toString方法就行了。</p>\n<h3 id=\"转数字\"><a href=\"#转数字\" class=\"headerlink\" title=\"转数字\"></a>转数字</h3><p>就类似于 <code>Number(undefined); </code> 的情况</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">null， false\t\t-&gt; 0</span><br><span class=\"line\">undefined\t\t-&gt; NaN</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"对于字符串\"><a href=\"#对于字符串\" class=\"headerlink\" title=\"对于字符串\"></a>对于字符串</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">字符串含有字符的。没有特殊含义的都为 NaN</span><br><span class=\"line\"></span><br><span class=\"line\">&#x27;1.111111111111111e+50&#x27; 这个就会转为数字，还有进制表示和小数点会转，其他带有字符会被转成 NaN</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"对于对象\"><a href=\"#对于对象\" class=\"headerlink\" title=\"对于对象\"></a>对于对象</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">先使用前面我说过的规则转为基本类型，然后再进行转换。</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"转布尔值\"><a href=\"#转布尔值\" class=\"headerlink\" title=\"转布尔值\"></a>转布尔值</h3><p>几个特殊值为 <code>false</code></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NaN, undefined， null， 0， +0， -0， &#x27;&#x27;</span><br></pre></td></tr></table></figure>\n\n<p>其他为true</p>\n<h2 id=\"基本上涉及运算和比较就会出现隐式类型转换\"><a href=\"#基本上涉及运算和比较就会出现隐式类型转换\" class=\"headerlink\" title=\"基本上涉及运算和比较就会出现隐式类型转换\"></a>基本上涉及运算和比较就会出现隐式类型转换</h2><h3 id=\"加号\"><a href=\"#加号\" class=\"headerlink\" title=\"加号 +\"></a>加号 +</h3><p>存在字符串则转为字符串的拼接操作</p>\n<p>非字符串就会转数字操作。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(1+2+&#x27;&#x27;)</span><br><span class=\"line\">1+2 先为3，</span><br><span class=\"line\">然后3+&#x27;&#x27; 为3</span><br></pre></td></tr></table></figure>\n\n<p>这个就涉及到了上面的转换规则</p>\n<p>这里有个小问题</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let x = Symbol(1);</span><br><span class=\"line\">console.log(x + &#x27;1&#x27;)</span><br><span class=\"line\">这样会抛出异常，虽然Symbol可以使用toString，</span><br><span class=\"line\">但是不能进行隐式转换。</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"减号-乘号-除号\"><a href=\"#减号-乘号-除号\" class=\"headerlink\" title=\"减号 - 乘号 * 除号 /\"></a>减号 - 乘号 * 除号 /</h3><p>会转为数字进行运算。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">特殊的，对于 NaN运算得NaN</span><br><span class=\"line\">对于 0/0 等于 NaN</span><br><span class=\"line\">对于 1/0 等于 Infinity</span><br></pre></td></tr></table></figure>\n\n\n\n<p>|| 和 &amp;&amp; 这里这个返回值不是<code>true</code>和<code>false</code>而是返回两边操作数的执行结果。</p>\n<h3 id=\"比较运算\"><a href=\"#比较运算\" class=\"headerlink\" title=\"比较运算\"></a>比较运算</h3><p><strong>转换规则</strong></p>\n<img src=\"/.io//image-20211019105728109.png\" alt=\"image-20211019105728109\" style=\"zoom:67%;\">\n\n\n\n<h4 id=\"和\"><a href=\"#和\" class=\"headerlink\" title=\"== 和 ===\"></a>== 和 ===</h4><p>非严格相等等号 可以允许强制类型转换，</p>\n<p>而严格相等等号 不允许强制类型的转换。</p>\n<p>其他的就如上，使用上面的转换规则进行转换。</p>\n<p>这里有个小问题点</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if ([]) &#123;</span><br><span class=\"line\">  console.log(1)</span><br><span class=\"line\">&#125; else &#123;</span><br><span class=\"line\">  console.log(2)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">此时会输出为1，所以说明了[]在if判断里面为真，但是 [] == true 为false，</span><br><span class=\"line\">这里可以看上面 转布尔值 那个地方，说明了，布尔在进行判断时 除了 undefined，null，NaN，0， &#x27;&#x27;，其他都为true</span><br><span class=\"line\">因此也可以说明，if判断是使用的 Boolean 来进行的判断为真还是为假。而不是与true进行的比较。</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"null和undefined的比较\"><a href=\"#null和undefined的比较\" class=\"headerlink\" title=\"null和undefined的比较\"></a>null和undefined的比较</h4><p>null和undefined进行比较时</p>\n<p>​    使用非严格等号为 true</p>\n<p>​    使用严格等号为 false</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">null == undefined</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"NaN-不与任何值相等，包括自己\"><a href=\"#NaN-不与任何值相等，包括自己\" class=\"headerlink\" title=\"NaN 不与任何值相等，包括自己\"></a>NaN 不与任何值相等，包括自己</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NaN == NaN\tfalse</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">并且 NaN &gt; 0 和 NaN &lt;= 0 都为 false</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"JavaScript类型转换\"><a href=\"#JavaScript类型转换\" class=\"headerlink\" title=\"JavaScript类型转换\"></a>JavaScript类型转换</h1><p>参考的文章</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://www.cnblogs.com/shikaka/p/10463293.html</span><br><span class=\"line\">https://www.cnblogs.com/shikaka/p/10473462.html</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"基本数据类型\"><a href=\"#基本数据类型\" class=\"headerlink\" title=\"基本数据类型\"></a>基本数据类型</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">string， number， Boolean， null， undefined， symbol</span><br></pre></td></tr></table></figure>\n\n<p>基本数据类型是没有方法可以调用的。</p>\n<p>但是我们却发现，</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x27;aaa&#x27;.indexOf(&#x27;a&#x27;);</span><br></pre></td></tr></table></figure>\n\n<p>这个明明是基本数据类型，但是却可以调用方法，这个是为什么呢。</p>\n<p>这个是因为<code>JavaScript</code>在底层进行了一个操作，当发现调用方法的是一个基本数据类型的话，会根据这个类型来创建一个对应的引用数据类型对象。然后再调用这个方法，调用之后将返回值进行返回并将这个对象进行删除。</p>\n<p>在 <code>JavaScript</code> 中，类型转换主要的两个方法是</p>\n<p><code>valueOf</code> ， <code>toString</code></p>\n<p>我们下面分别对这两个进行一个判断使用操作。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let a = 1,</span><br><span class=\"line\">    b = &#x27;a&#x27;,</span><br><span class=\"line\">    c = true,</span><br><span class=\"line\">    d = undefined,</span><br><span class=\"line\">    e = null,</span><br><span class=\"line\">    f = [1, 2, 3],</span><br><span class=\"line\">    g = [&#x27;1&#x27;, &#x27;3&#x27;],</span><br><span class=\"line\">    h = new Number(3),</span><br><span class=\"line\">    i = new String(&#x27;12&#x27;),</span><br><span class=\"line\">    j = new Boolean(false),</span><br><span class=\"line\">    k = new Object(&#123; a: 3&#125; ),</span><br><span class=\"line\">    l = &#123; b: 4 &#125;,</span><br><span class=\"line\">    m = function () &#123;&#125;,</span><br><span class=\"line\">    n = new Date(),</span><br><span class=\"line\">    o = new RegExp(&#x27;sss&#x27;),</span><br><span class=\"line\">    p = /sss/,</span><br><span class=\"line\">    q = `sdcard`,</span><br><span class=\"line\">    r = new Array([1,2,3]);</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"valueOf-NaN\"><a href=\"#valueOf-NaN\" class=\"headerlink\" title=\"valueOf\"></a>valueOf</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(a.valueOf());</span><br><span class=\"line\">console.log(b.valueOf());</span><br><span class=\"line\">console.log(c.valueOf());</span><br><span class=\"line\">// console.log(d.valueOf());</span><br><span class=\"line\">// console.log(e.valueOf());</span><br><span class=\"line\">console.log(f.valueOf());</span><br><span class=\"line\">console.log(h.valueOf());</span><br><span class=\"line\">console.log(i.valueOf());</span><br><span class=\"line\">console.log(j.valueOf());</span><br><span class=\"line\">console.log(k.valueOf());</span><br><span class=\"line\">console.log(n.valueOf());</span><br><span class=\"line\">console.log(o.valueOf());</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"这就是执行的结果。\"><a href=\"#这就是执行的结果。\" class=\"headerlink\" title=\"这就是执行的结果。\"></a>这就是执行的结果。</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1</span><br><span class=\"line\">a</span><br><span class=\"line\">true</span><br><span class=\"line\">[ 1, 2, 3 ]</span><br><span class=\"line\">3</span><br><span class=\"line\">12</span><br><span class=\"line\">false</span><br><span class=\"line\">&#123; a: 3 &#125;</span><br><span class=\"line\">1634610286344</span><br><span class=\"line\">/sss/</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"我们可以从结果里面看到\"><a href=\"#我们可以从结果里面看到\" class=\"headerlink\" title=\"我们可以从结果里面看到\"></a>我们可以从结果里面看到</h4><table>\n<thead>\n<tr>\n<th>类型</th>\n<th>结果</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>null，undefined</td>\n<td>没有valueOf方法，会报错</td>\n</tr>\n<tr>\n<td>基本数据类型，包括Symbol类型</td>\n<td>valueOf方法为其本身，可以使用 === 来判断，Symbol为true。</td>\n</tr>\n<tr>\n<td>对象，数组，方法，正则</td>\n<td>也为其本身</td>\n</tr>\n<tr>\n<td>使用new方法创建的基本数据类型，new number(1)</td>\n<td>为其值，与原来不等。</td>\n</tr>\n<tr>\n<td>date类型</td>\n<td>当前时间距 1970.01.01 午夜的毫秒数</td>\n</tr>\n</tbody></table>\n<p>所以我们可以看到，</p>\n<p>基本除了对象，其他的类型使用valueOf方法都可以转换成基本数据类型。</p>\n<p>对于使用new方法创建的基本数据类型的引用数据类型，也会被转换成基本数据类型。</p>\n<p>这里的原因，是因为 <code>number </code>对象对 <code>valueOf</code> 进行了一次重写，所以在调用的时候就会调用自己所重写的方法，于是返回的结果会不同。其他也同理。</p>\n<p>但是<code>JavaScript</code>内部是如何进行操作，取出值的，我还是不了解。</p>\n<h2 id=\"toString-NaN\"><a href=\"#toString-NaN\" class=\"headerlink\" title=\"toString\"></a>toString</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(a.toString());</span><br><span class=\"line\">console.log(b.toString());</span><br><span class=\"line\">console.log(c.toString());</span><br><span class=\"line\">// console.log(d.toString());</span><br><span class=\"line\">// console.log(e.toString());</span><br><span class=\"line\">console.log(f.toString());</span><br><span class=\"line\">console.log(h.toString());</span><br><span class=\"line\">console.log(i.toString());</span><br><span class=\"line\">console.log(j.toString());</span><br><span class=\"line\">console.log(k.toString());</span><br><span class=\"line\">console.log(n.toString());</span><br><span class=\"line\">console.log(o.toString());</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1</span><br><span class=\"line\">a</span><br><span class=\"line\">true</span><br><span class=\"line\">1,2,3</span><br><span class=\"line\">3</span><br><span class=\"line\">12</span><br><span class=\"line\">false</span><br><span class=\"line\">[object Object]</span><br><span class=\"line\">Tue Oct 19 2021 10:50:07 GMT+0800 (中国标准时间)</span><br><span class=\"line\">/sss/</span><br></pre></td></tr></table></figure>\n\n\n\n<table>\n<thead>\n<tr>\n<th>类型</th>\n<th>结果</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>null， undefined</td>\n<td>没有toString方法</td>\n</tr>\n<tr>\n<td>基本数据类型</td>\n<td>直接转为字符串</td>\n</tr>\n<tr>\n<td>普通对象</td>\n<td>直接转为字符串 [object Object]</td>\n</tr>\n<tr>\n<td>日期，正则对象</td>\n<td>转为对应值的字符串</td>\n</tr>\n</tbody></table>\n<h1 id=\"隐式类型转换\"><a href=\"#隐式类型转换\" class=\"headerlink\" title=\"隐式类型转换\"></a>隐式类型转换</h1><p>我这里主要讲解一下隐式类型转换</p>\n<h3 id=\"对于一个对象转为基本数据类型的方法\"><a href=\"#对于一个对象转为基本数据类型的方法\" class=\"headerlink\" title=\"对于一个对象转为基本数据类型的方法\"></a>对于一个对象转为基本数据类型的方法</h3><p>对于一个不是基本数据类型的。会先通过 <code>valueOf</code> 转换，看是否能转为基本数据类型</p>\n<p>如果还不可以，然后就会使用 <code>toString </code>方法转为字符串。然后再来进行判断。</p>\n<p>对于 <code>Date</code> 对象的话，使用顺序会反过来</p>\n<h3 id=\"转字符串。\"><a href=\"#转字符串。\" class=\"headerlink\" title=\"转字符串。\"></a>转字符串。</h3><p>就直接toString方法就行了。</p>\n<h3 id=\"转数字\"><a href=\"#转数字\" class=\"headerlink\" title=\"转数字\"></a>转数字</h3><p>就类似于 <code>Number(undefined); </code> 的情况</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">null， false\t\t-&gt; 0</span><br><span class=\"line\">undefined\t\t-&gt; NaN</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"对于字符串\"><a href=\"#对于字符串\" class=\"headerlink\" title=\"对于字符串\"></a>对于字符串</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">字符串含有字符的。没有特殊含义的都为 NaN</span><br><span class=\"line\"></span><br><span class=\"line\">&#x27;1.111111111111111e+50&#x27; 这个就会转为数字，还有进制表示和小数点会转，其他带有字符会被转成 NaN</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"对于对象\"><a href=\"#对于对象\" class=\"headerlink\" title=\"对于对象\"></a>对于对象</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">先使用前面我说过的规则转为基本类型，然后再进行转换。</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"转布尔值\"><a href=\"#转布尔值\" class=\"headerlink\" title=\"转布尔值\"></a>转布尔值</h3><p>几个特殊值为 <code>false</code></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NaN, undefined， null， 0， +0， -0， &#x27;&#x27;</span><br></pre></td></tr></table></figure>\n\n<p>其他为true</p>\n<h2 id=\"基本上涉及运算和比较就会出现隐式类型转换\"><a href=\"#基本上涉及运算和比较就会出现隐式类型转换\" class=\"headerlink\" title=\"基本上涉及运算和比较就会出现隐式类型转换\"></a>基本上涉及运算和比较就会出现隐式类型转换</h2><h3 id=\"加号\"><a href=\"#加号\" class=\"headerlink\" title=\"加号 +\"></a>加号 +</h3><p>存在字符串则转为字符串的拼接操作</p>\n<p>非字符串就会转数字操作。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(1+2+&#x27;&#x27;)</span><br><span class=\"line\">1+2 先为3，</span><br><span class=\"line\">然后3+&#x27;&#x27; 为3</span><br></pre></td></tr></table></figure>\n\n<p>这个就涉及到了上面的转换规则</p>\n<p>这里有个小问题</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let x = Symbol(1);</span><br><span class=\"line\">console.log(x + &#x27;1&#x27;)</span><br><span class=\"line\">这样会抛出异常，虽然Symbol可以使用toString，</span><br><span class=\"line\">但是不能进行隐式转换。</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"减号-乘号-除号\"><a href=\"#减号-乘号-除号\" class=\"headerlink\" title=\"减号 - 乘号 * 除号 /\"></a>减号 - 乘号 * 除号 /</h3><p>会转为数字进行运算。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">特殊的，对于 NaN运算得NaN</span><br><span class=\"line\">对于 0/0 等于 NaN</span><br><span class=\"line\">对于 1/0 等于 Infinity</span><br></pre></td></tr></table></figure>\n\n\n\n<p>|| 和 &amp;&amp; 这里这个返回值不是<code>true</code>和<code>false</code>而是返回两边操作数的执行结果。</p>\n<h3 id=\"比较运算\"><a href=\"#比较运算\" class=\"headerlink\" title=\"比较运算\"></a>比较运算</h3><p><strong>转换规则</strong></p>\n<img src=\"/.io//image-20211019105728109.png\" alt=\"image-20211019105728109\" style=\"zoom:67%;\">\n\n\n\n<h4 id=\"和\"><a href=\"#和\" class=\"headerlink\" title=\"== 和 ===\"></a>== 和 ===</h4><p>非严格相等等号 可以允许强制类型转换，</p>\n<p>而严格相等等号 不允许强制类型的转换。</p>\n<p>其他的就如上，使用上面的转换规则进行转换。</p>\n<p>这里有个小问题点</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if ([]) &#123;</span><br><span class=\"line\">  console.log(1)</span><br><span class=\"line\">&#125; else &#123;</span><br><span class=\"line\">  console.log(2)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">此时会输出为1，所以说明了[]在if判断里面为真，但是 [] == true 为false，</span><br><span class=\"line\">这里可以看上面 转布尔值 那个地方，说明了，布尔在进行判断时 除了 undefined，null，NaN，0， &#x27;&#x27;，其他都为true</span><br><span class=\"line\">因此也可以说明，if判断是使用的 Boolean 来进行的判断为真还是为假。而不是与true进行的比较。</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"null和undefined的比较\"><a href=\"#null和undefined的比较\" class=\"headerlink\" title=\"null和undefined的比较\"></a>null和undefined的比较</h4><p>null和undefined进行比较时</p>\n<p>​    使用非严格等号为 true</p>\n<p>​    使用严格等号为 false</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">null == undefined</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"NaN-不与任何值相等，包括自己\"><a href=\"#NaN-不与任何值相等，包括自己\" class=\"headerlink\" title=\"NaN 不与任何值相等，包括自己\"></a>NaN 不与任何值相等，包括自己</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NaN == NaN\tfalse</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">并且 NaN &gt; 0 和 NaN &lt;= 0 都为 false</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n"},{"title":"if in 用法","date":"2022-02-12T08:09:34.000Z","_content":"\n\n\n#  if in 的用法\n\n```\nconst obj = {\n  a: 1,\n  b: 2,\n}\n\nobj.__proto__.c = 3\n\nObject.defineProperty(obj, 'd', {\n  value: 123,\n  enumerable: false\n})\n\nif ('a' in obj) {\n  console.log('a')\n}\nif ('c' in obj) {\n  console.log('c')\n}\nif ('d' in obj) {\n  console.log('d')\n}\n```\n\n```\na\nc\nd\n```\n\n\n\n所以我们可以知道，if ( in )\n\n会把 自身的，原型链上的。以及不可枚举的都会显示。","source":"_posts/JavaScript/随笔/if in 用法.md","raw":"---\ntitle: if in 用法\ndate: 2022-02-12 16:09:34\ntags:\n - 随笔\n - JavaScript\ncategories:\n - JavaScript\n - 随笔\n---\n\n\n\n#  if in 的用法\n\n```\nconst obj = {\n  a: 1,\n  b: 2,\n}\n\nobj.__proto__.c = 3\n\nObject.defineProperty(obj, 'd', {\n  value: 123,\n  enumerable: false\n})\n\nif ('a' in obj) {\n  console.log('a')\n}\nif ('c' in obj) {\n  console.log('c')\n}\nif ('d' in obj) {\n  console.log('d')\n}\n```\n\n```\na\nc\nd\n```\n\n\n\n所以我们可以知道，if ( in )\n\n会把 自身的，原型链上的。以及不可枚举的都会显示。","slug":"JavaScript/随笔/if in 用法","published":1,"updated":"2022-02-14T07:11:00.610Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckznhkk8s007mikubb0xtfsbq","content":"<h1 id=\"if-in-的用法\"><a href=\"#if-in-的用法\" class=\"headerlink\" title=\"if in 的用法\"></a>if in 的用法</h1><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const obj = &#123;</span><br><span class=\"line\">  a: 1,</span><br><span class=\"line\">  b: 2,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">obj.__proto__.c = 3</span><br><span class=\"line\"></span><br><span class=\"line\">Object.defineProperty(obj, &#x27;d&#x27;, &#123;</span><br><span class=\"line\">  value: 123,</span><br><span class=\"line\">  enumerable: false</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">if (&#x27;a&#x27; in obj) &#123;</span><br><span class=\"line\">  console.log(&#x27;a&#x27;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">if (&#x27;c&#x27; in obj) &#123;</span><br><span class=\"line\">  console.log(&#x27;c&#x27;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">if (&#x27;d&#x27; in obj) &#123;</span><br><span class=\"line\">  console.log(&#x27;d&#x27;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a</span><br><span class=\"line\">c</span><br><span class=\"line\">d</span><br></pre></td></tr></table></figure>\n\n\n\n<p>所以我们可以知道，if ( in )</p>\n<p>会把 自身的，原型链上的。以及不可枚举的都会显示。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"if-in-的用法\"><a href=\"#if-in-的用法\" class=\"headerlink\" title=\"if in 的用法\"></a>if in 的用法</h1><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const obj = &#123;</span><br><span class=\"line\">  a: 1,</span><br><span class=\"line\">  b: 2,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">obj.__proto__.c = 3</span><br><span class=\"line\"></span><br><span class=\"line\">Object.defineProperty(obj, &#x27;d&#x27;, &#123;</span><br><span class=\"line\">  value: 123,</span><br><span class=\"line\">  enumerable: false</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">if (&#x27;a&#x27; in obj) &#123;</span><br><span class=\"line\">  console.log(&#x27;a&#x27;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">if (&#x27;c&#x27; in obj) &#123;</span><br><span class=\"line\">  console.log(&#x27;c&#x27;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">if (&#x27;d&#x27; in obj) &#123;</span><br><span class=\"line\">  console.log(&#x27;d&#x27;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a</span><br><span class=\"line\">c</span><br><span class=\"line\">d</span><br></pre></td></tr></table></figure>\n\n\n\n<p>所以我们可以知道，if ( in )</p>\n<p>会把 自身的，原型链上的。以及不可枚举的都会显示。</p>\n"},{"layout":"draft","title":"js遍历对象的方法","date":"2022-01-19T09:32:25.000Z","_content":"\n\n\n#  JavaScript 遍历对象的方法\n\n```\nObject.keys\nforin\nObject.getOwnPropertyNames\n```\n\n\n\n## Object.keys\n\n使用 Object.keys，会返回一个数组，数组是一个由键构成的\n\n元素均为对象自身的，可枚举的属性\n\n​\t代表了，不会查找原型链，以及需要可枚举\n\n```\nconst obj = {\n\ta: 1\n}\nconst pro = {\n\tb: 2\n}\nobj.__proto__ = pro\n\nObject.keys(obj).log\n\ta\n```\n\n\n\n## forin\n\nforin循环，获取的是key值，会向原型链进行获取。但是不会查找不可枚举的属性\n\n​\t可以使用 hasOwnProperty 来判断该属性是否是属于自身的。同时对于不可枚举的也是可以进行判断的。\n\n```\nconst obj = {\n\ta: 1\n}\nconst pro = {\n\tb: 2\n}\nobj.__proto__ = pro\nObject.defineProperty(obj, 'c', {value: 3, enumerable: false}) // 不可枚举属性\n\nfor key in obj\n\tlog.key\n\tlog.obj[key]\n\tlog.obj.hasOwnProperty(key)\n  a, b\n```\n\n\n\n## Object.getOwnPropertyNames\n\n返回自身的属性数组，不包括原型链\n\n但是包括不可枚举属性\n\n同时对于一个数组，他的 getOwnPropertyNames 有length，说明了这个length是存在于自身的\n\n```\nconst obj = {\n\ta: 1\n}\nconst pro = {\n\tb: 2\n}\nobj.__proto__ = pro\nObject.defineProperty(obj, 'c', {value: 3, eumerable: false})\t// 添加一个不可枚举属性\n\nObject.getOwPropertyNames(obj)\n\ta, c\n```\n\n\n\n## 题外话：forof\n\nforof 其实在前面就已经说过了，这个是一个根据迭代器进行的循环\n\n面试也问过，为什么forin可以遍历数组，当时我的理解是 forin 实际上并不是遍历数组，他是遍历一个对象，现在我也是这样认为的，我认为forin 不是遍历数组，他内部的遍历实际是对象，只是因为js的任何都是对象的原因，所以 forin 遍历数组获取到的下标，这样一看，他不是很像是对象的键吗，数组只是存在了一个length方法。而对象没有而已。\n\n我认为forof才是JavaScript对于遍历数组而创建一个方式，因为forof使用的迭代器，是数组才有的，创建的对象是没有的，当然这个我们也能进行自己编写，具体的可以看看前面写的 迭代器部分。\n\n","source":"_posts/JavaScript/随笔/js遍历对象的方法.md","raw":"---\nlayout: draft\ntitle: js遍历对象的方法\ndate: 2022-01-19 17:32:25\ntags:\n - JavaScript\n - 随笔\ncategories:\n - JavaScript\n - 随笔\n---\n\n\n\n#  JavaScript 遍历对象的方法\n\n```\nObject.keys\nforin\nObject.getOwnPropertyNames\n```\n\n\n\n## Object.keys\n\n使用 Object.keys，会返回一个数组，数组是一个由键构成的\n\n元素均为对象自身的，可枚举的属性\n\n​\t代表了，不会查找原型链，以及需要可枚举\n\n```\nconst obj = {\n\ta: 1\n}\nconst pro = {\n\tb: 2\n}\nobj.__proto__ = pro\n\nObject.keys(obj).log\n\ta\n```\n\n\n\n## forin\n\nforin循环，获取的是key值，会向原型链进行获取。但是不会查找不可枚举的属性\n\n​\t可以使用 hasOwnProperty 来判断该属性是否是属于自身的。同时对于不可枚举的也是可以进行判断的。\n\n```\nconst obj = {\n\ta: 1\n}\nconst pro = {\n\tb: 2\n}\nobj.__proto__ = pro\nObject.defineProperty(obj, 'c', {value: 3, enumerable: false}) // 不可枚举属性\n\nfor key in obj\n\tlog.key\n\tlog.obj[key]\n\tlog.obj.hasOwnProperty(key)\n  a, b\n```\n\n\n\n## Object.getOwnPropertyNames\n\n返回自身的属性数组，不包括原型链\n\n但是包括不可枚举属性\n\n同时对于一个数组，他的 getOwnPropertyNames 有length，说明了这个length是存在于自身的\n\n```\nconst obj = {\n\ta: 1\n}\nconst pro = {\n\tb: 2\n}\nobj.__proto__ = pro\nObject.defineProperty(obj, 'c', {value: 3, eumerable: false})\t// 添加一个不可枚举属性\n\nObject.getOwPropertyNames(obj)\n\ta, c\n```\n\n\n\n## 题外话：forof\n\nforof 其实在前面就已经说过了，这个是一个根据迭代器进行的循环\n\n面试也问过，为什么forin可以遍历数组，当时我的理解是 forin 实际上并不是遍历数组，他是遍历一个对象，现在我也是这样认为的，我认为forin 不是遍历数组，他内部的遍历实际是对象，只是因为js的任何都是对象的原因，所以 forin 遍历数组获取到的下标，这样一看，他不是很像是对象的键吗，数组只是存在了一个length方法。而对象没有而已。\n\n我认为forof才是JavaScript对于遍历数组而创建一个方式，因为forof使用的迭代器，是数组才有的，创建的对象是没有的，当然这个我们也能进行自己编写，具体的可以看看前面写的 迭代器部分。\n\n","slug":"JavaScript/随笔/js遍历对象的方法","published":1,"updated":"2022-02-14T07:11:00.610Z","comments":1,"photos":[],"link":"","_id":"ckznhkk8s007pikubbjrh3968","content":"<h1 id=\"JavaScript-遍历对象的方法\"><a href=\"#JavaScript-遍历对象的方法\" class=\"headerlink\" title=\"JavaScript 遍历对象的方法\"></a>JavaScript 遍历对象的方法</h1><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Object.keys</span><br><span class=\"line\">forin</span><br><span class=\"line\">Object.getOwnPropertyNames</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"Object-keys\"><a href=\"#Object-keys\" class=\"headerlink\" title=\"Object.keys\"></a>Object.keys</h2><p>使用 Object.keys，会返回一个数组，数组是一个由键构成的</p>\n<p>元素均为对象自身的，可枚举的属性</p>\n<p>​    代表了，不会查找原型链，以及需要可枚举</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const obj = &#123;</span><br><span class=\"line\">\ta: 1</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">const pro = &#123;</span><br><span class=\"line\">\tb: 2</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">obj.__proto__ = pro</span><br><span class=\"line\"></span><br><span class=\"line\">Object.keys(obj).log</span><br><span class=\"line\">\ta</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"forin\"><a href=\"#forin\" class=\"headerlink\" title=\"forin\"></a>forin</h2><p>forin循环，获取的是key值，会向原型链进行获取。但是不会查找不可枚举的属性</p>\n<p>​    可以使用 hasOwnProperty 来判断该属性是否是属于自身的。同时对于不可枚举的也是可以进行判断的。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const obj = &#123;</span><br><span class=\"line\">\ta: 1</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">const pro = &#123;</span><br><span class=\"line\">\tb: 2</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">obj.__proto__ = pro</span><br><span class=\"line\">Object.defineProperty(obj, &#x27;c&#x27;, &#123;value: 3, enumerable: false&#125;) // 不可枚举属性</span><br><span class=\"line\"></span><br><span class=\"line\">for key in obj</span><br><span class=\"line\">\tlog.key</span><br><span class=\"line\">\tlog.obj[key]</span><br><span class=\"line\">\tlog.obj.hasOwnProperty(key)</span><br><span class=\"line\">  a, b</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"Object-getOwnPropertyNames\"><a href=\"#Object-getOwnPropertyNames\" class=\"headerlink\" title=\"Object.getOwnPropertyNames\"></a>Object.getOwnPropertyNames</h2><p>返回自身的属性数组，不包括原型链</p>\n<p>但是包括不可枚举属性</p>\n<p>同时对于一个数组，他的 getOwnPropertyNames 有length，说明了这个length是存在于自身的</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const obj = &#123;</span><br><span class=\"line\">\ta: 1</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">const pro = &#123;</span><br><span class=\"line\">\tb: 2</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">obj.__proto__ = pro</span><br><span class=\"line\">Object.defineProperty(obj, &#x27;c&#x27;, &#123;value: 3, eumerable: false&#125;)\t// 添加一个不可枚举属性</span><br><span class=\"line\"></span><br><span class=\"line\">Object.getOwPropertyNames(obj)</span><br><span class=\"line\">\ta, c</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"题外话：forof\"><a href=\"#题外话：forof\" class=\"headerlink\" title=\"题外话：forof\"></a>题外话：forof</h2><p>forof 其实在前面就已经说过了，这个是一个根据迭代器进行的循环</p>\n<p>面试也问过，为什么forin可以遍历数组，当时我的理解是 forin 实际上并不是遍历数组，他是遍历一个对象，现在我也是这样认为的，我认为forin 不是遍历数组，他内部的遍历实际是对象，只是因为js的任何都是对象的原因，所以 forin 遍历数组获取到的下标，这样一看，他不是很像是对象的键吗，数组只是存在了一个length方法。而对象没有而已。</p>\n<p>我认为forof才是JavaScript对于遍历数组而创建一个方式，因为forof使用的迭代器，是数组才有的，创建的对象是没有的，当然这个我们也能进行自己编写，具体的可以看看前面写的 迭代器部分。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"JavaScript-遍历对象的方法\"><a href=\"#JavaScript-遍历对象的方法\" class=\"headerlink\" title=\"JavaScript 遍历对象的方法\"></a>JavaScript 遍历对象的方法</h1><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Object.keys</span><br><span class=\"line\">forin</span><br><span class=\"line\">Object.getOwnPropertyNames</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"Object-keys\"><a href=\"#Object-keys\" class=\"headerlink\" title=\"Object.keys\"></a>Object.keys</h2><p>使用 Object.keys，会返回一个数组，数组是一个由键构成的</p>\n<p>元素均为对象自身的，可枚举的属性</p>\n<p>​    代表了，不会查找原型链，以及需要可枚举</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const obj = &#123;</span><br><span class=\"line\">\ta: 1</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">const pro = &#123;</span><br><span class=\"line\">\tb: 2</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">obj.__proto__ = pro</span><br><span class=\"line\"></span><br><span class=\"line\">Object.keys(obj).log</span><br><span class=\"line\">\ta</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"forin\"><a href=\"#forin\" class=\"headerlink\" title=\"forin\"></a>forin</h2><p>forin循环，获取的是key值，会向原型链进行获取。但是不会查找不可枚举的属性</p>\n<p>​    可以使用 hasOwnProperty 来判断该属性是否是属于自身的。同时对于不可枚举的也是可以进行判断的。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const obj = &#123;</span><br><span class=\"line\">\ta: 1</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">const pro = &#123;</span><br><span class=\"line\">\tb: 2</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">obj.__proto__ = pro</span><br><span class=\"line\">Object.defineProperty(obj, &#x27;c&#x27;, &#123;value: 3, enumerable: false&#125;) // 不可枚举属性</span><br><span class=\"line\"></span><br><span class=\"line\">for key in obj</span><br><span class=\"line\">\tlog.key</span><br><span class=\"line\">\tlog.obj[key]</span><br><span class=\"line\">\tlog.obj.hasOwnProperty(key)</span><br><span class=\"line\">  a, b</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"Object-getOwnPropertyNames\"><a href=\"#Object-getOwnPropertyNames\" class=\"headerlink\" title=\"Object.getOwnPropertyNames\"></a>Object.getOwnPropertyNames</h2><p>返回自身的属性数组，不包括原型链</p>\n<p>但是包括不可枚举属性</p>\n<p>同时对于一个数组，他的 getOwnPropertyNames 有length，说明了这个length是存在于自身的</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const obj = &#123;</span><br><span class=\"line\">\ta: 1</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">const pro = &#123;</span><br><span class=\"line\">\tb: 2</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">obj.__proto__ = pro</span><br><span class=\"line\">Object.defineProperty(obj, &#x27;c&#x27;, &#123;value: 3, eumerable: false&#125;)\t// 添加一个不可枚举属性</span><br><span class=\"line\"></span><br><span class=\"line\">Object.getOwPropertyNames(obj)</span><br><span class=\"line\">\ta, c</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"题外话：forof\"><a href=\"#题外话：forof\" class=\"headerlink\" title=\"题外话：forof\"></a>题外话：forof</h2><p>forof 其实在前面就已经说过了，这个是一个根据迭代器进行的循环</p>\n<p>面试也问过，为什么forin可以遍历数组，当时我的理解是 forin 实际上并不是遍历数组，他是遍历一个对象，现在我也是这样认为的，我认为forin 不是遍历数组，他内部的遍历实际是对象，只是因为js的任何都是对象的原因，所以 forin 遍历数组获取到的下标，这样一看，他不是很像是对象的键吗，数组只是存在了一个length方法。而对象没有而已。</p>\n<p>我认为forof才是JavaScript对于遍历数组而创建一个方式，因为forof使用的迭代器，是数组才有的，创建的对象是没有的，当然这个我们也能进行自己编写，具体的可以看看前面写的 迭代器部分。</p>\n"},{"title":"Vue-使用-深入了解组件","date":"2021-10-29T15:15:14.000Z","_content":"\n\n\n#  组件注册\n\n```\nhttps://cn.vuejs.org/v2/guide/components-registration.html\n```\n\n\n\n## 组件名\n\n### 组件名大小写\n\n​\t\t对于大小写的组件名，在使用的时候大写会变成 -+小写的形式。\n\n```\nmyComPonent\n\nmy-com-ponent\n```\n\n\n\n## 全局注册\n\n```\nVue.component('component-a', { /* ... */ })\n```\n\n​\t\t这样创建就是全局注册的，只要注册了之后，后面的Vue实例都可以直接使用。\n\n\n\n## 局部注册\n\n​\t\t全局注册会不可避免的增加性能的消耗，浪费了很多时间。所以可以使用局部注册的方式进行注册，将组件注册在实例的内部，因此在实例被销毁时也会被销毁。\n\n```\nconst ComponentA = { /* ... */ };\n\nnew Vue({\n  el: '#app',\n  components: {\n    'component-a': ComponentA,\n    'component-b': ComponentB\n  }\n})\n```\n\n​\t\t简单来说就是 ComponentsA 里面的对象就是 new一个Vue实例的对象。然后再在components里面进行new的创建，所以将作用域限制到了一定的范围。\n\n```\nconst C = {\n  template: `<div>22</div>`,\n}\nconst ComponentA = {\n  el: '#ap',\n  //这里是局部组件创建再加上了一个组件的创建，否则一个父组件，两个局部组件内部是不能相互调用的。\n  components: {\n    'com': C,\n  }\n}\n\nconst app = new Vue({\n  el: '#app',\n  data: {\n    a: 1\n  },\n  components: {\n    'comA': ComponentA,\n    'com': C,\n  }\n})\n```\n\n\n\n## 模块系统\n\n​\t\t简单来说就是可以使用 import / require 来使用一个模块系统。\n\n\n\n### 在模块系统中局部注册\n\n​\t\t简单来说，下面这个是取出了一个对象。这个是一个ES6的模块化导出的默认导出的写法。\n\n​\t\t所以简单来说就是将对象进行导出。\n\n```\nimport ComponentA from './Component';\n```\n\n```\nexport default {\n\t\n}\n```\n\n​\t\t我们先理清一下思路\n\n* 首先，Vue的components里面使用的是一个对象，这个对象是那个实例对象。其次对于这个命名的思路是因为是es6的对象赋值的方式\n* 然后就是导入 import 和 export default 这里导入和导出对象。\n* 所以其实还是有思路的。\n\n\n\n### 基础组件的自动化全局注册\n\n​\t\trequire.context 可以全局注册组件。但是需要使用webpack或者使用了VueCLI3+（因为内部使用了webpack）\n\n​\t\t**什么是 require.context ：**\n\n* 首先，是一个webpack的api。\n* 其次，这个api用于实现自动化导入模块。就是对于一个文件引入很多模块的情况，可以使用这个api，会遍历指定的文件，然后进行自动导入，不需要每次显式的调用import导入模块。\n* 进行一个更细粒度的模块引入。\n\n\n\n​\t\t**一个使用时机**：\n\n* 首先就是需要引入很多模块\n* 其次就是这个模块的处于同一父文件位置，所以对于基础组件来说是非常合适的。\n\n\n\n​\t\trequire.context 的参数：\n\n* directory，String类型\n\n  * 文件目录位置，\n\n* includeSubdirs，Boolean类型\n\n  * 表示是否包含文件的子目录，可选参数，默认是 true\n\n* filter，RegExp正则表达式类型\n\n  * 表示过滤某些文件。可选参数，默认是 `/^\\.\\/.*$/` 指的是所有文件。（这里是webpack写的，但是我没有理解这个正则）。\n\n* mode，String类型\n\n  * 表示加载的方式， sync，eager，weak，lazy，lazy-once。默认值是sync。\n\n  * ```\n    sync\n    eager\n    \t不会生成额外的chunk，所有模块当成当前chunk引入。没有额外的网络请求，但是会返回一个resolved的Promise。\n    weak\n    \t这个没有看懂，大概可能是尝试加载，不可用返回一个reject的Promise。\n    lazy\n    \t为每一个导入的模块生成一个可延迟加载的chunk。简单来说就是将以异步方式加载。\n    lazy-once\n    \t生成一个可以满足所有的可延迟加载的chunk。这个chunk将第一次调用时获取，随后使用相同的网络响应。\n    ```\n\n\n\n大概看懂了之后，我们再看一下组件的自动化全局注册\n\n```\nimport Vue from 'vue'\nimport upperFirst from 'lodash/upperFirst'\nimport camelCase from 'lodash/camelCase'\n\nconst requireComponent = require.context(\n  // 其组件目录的相对路径\n  './components',\n  // 是否查询其子目录\n  false,\n  // 匹配基础组件文件名的正则表达式\n  /Base[A-Z]\\w+\\.(vue|js)$/\n)\n\nrequireComponent.keys().forEach(fileName => {\n  // 获取组件配置\n  const componentConfig = requireComponent(fileName)\n\n  // 获取组件的 PascalCase 命名\n  const componentName = upperFirst(\n    camelCase(\n      // 获取和目录深度无关的文件名\n      fileName\n        .split('/')\n        .pop()\n        .replace(/\\.\\w+$/, '')\n    )\n  )\n\n  // 全局注册组件\n  Vue.component(\n    componentName,\n    // 如果这个组件选项是通过 `export default` 导出的，\n    // 那么就会优先使用 `.default`，\n    // 否则回退到使用模块的根。\n    componentConfig.default || componentConfig\n  )\n})\n```\n\n​\t\t**其中这一部分的作用是将每个文件的模块给取了出来**\n\n```\nconst requireComponent = require.context(\n  // 其组件目录的相对路径\n  './components',\n  // 是否查询其子目录\n  false,\n  // 匹配基础组件文件名的正则表达式\n  /Base[A-Z]\\w+\\.(vue|js)$/\n)\n\n目录是 ./components\n不查询子目录\n匹配文件的形式，Basexxxx.(vue|js)\n```\n\n* requireComponent 通过typeof 判断是一个，function，里面存在了方法，可以使用keys方法进行获取\n\n\n\n​\t\t**这里是将requireComponent存储的组件给进行了注册。**\n\n```\nrequireComponent.keys().forEach(fileName => {\n  // 获取组件配置\n  const componentConfig = requireComponent(fileName)\n\n  // 获取组件的 PascalCase 命名\n  const componentName = upperFirst(\n    camelCase(\n      // 获取和目录深度无关的文件名\n      fileName\n        .split('/')\n        .pop()\n        .replace(/\\.\\w+$/, '')\n    )\n  )\n\n  // 全局注册组件\n  Vue.component(\n    componentName,\n    // 如果这个组件选项是通过 `export default` 导出的，\n    // 那么就会优先使用 `.default`，\n    // 否则回退到使用模块的根。\n    componentConfig.default || componentConfig\n  )\n})\n```\n\n* keys方法获取到的是文件的相对路径。使用foreach进行循环操作。foreach内部也是和forin一个意思。forin和forof的区别在于迭代器问题。\n\n  * ```\n    ./App.vue\n    ./components/App.vue\n    ```\n\n* 然后使用 requireComponent 方法，参数为文件位置，便会获取到内容。\n\n  * 使用 requireComponent(filename)，进行获取，就可以获取到内容。\n\n* 当然这里的一个特点是，这个requireComponent 既是一个方法，也是一个对象，因为它既能像方法一样传递参数进行操作，也可以调用keys这个方法。\n\n* 这里使用的 upperFirst 和 camelCase 是 lodash里面的方法，其中 upperFirst的作用是首字母大写，而camelCase是将字符串转为驼峰命名法，比如空格，-，_将会被划分。\n\n* 在这里，首先fileName是一个文件的路径和名字，所以使用split进行划分/， 然后取出最后一个，然后将后面的文件后缀改为空，然后给camelCase变为驼峰，然后返回的字符串给了upperFirst变为了首字母大写的驼峰。赋值给了componentName。\n\n  * ```\n    const componentName = upperFirst(\n      camelCase(\n        // 获取和目录深度无关的文件名\n        fileName\n          .split('/')\n          .pop()\n          .replace(/\\.\\w+$/, '')\n      )\n    )\n    ```\n\n* 然后就是注册组件了，使用了 Vue.component 方法。进行注册，Vue.component 第一个参数是名字，第二个参数是需要被Vue实例的对象。\n\n  * 这里的唯一的问题就是，对于如果没有使用 export default 导出的方法，貌似不会存在 default 这个对象。但是具体的我们需要在后面才会知道。\n\n  * ```\n    Vue.component(\n      componentName,\n      // 如果这个组件选项是通过 `export default` 导出的，\n      // 那么就会优先使用 `.default`，\n      // 否则回退到使用模块的根。\n      componentConfig.default || componentConfig\n    )\n    ```\n\n\n\n​\t\t**如何实现一个方法带有对象的使用。**\n\n​\t\t这里我的一个想法就是修改原型链了，因为JavaScript任何都是存在原型链的，对于方法来说，也是有一个原型链的。简单来理解，方法既可以使用，又可以当作一个构造器来创建对象。\n\n* 作为一个构造器来说，方法需要记住的是prototype的指向\n* 而对于方法的执行来说，需要记住的是 \\_\\_proto\\_\\_ 的指向。所以这里对 \\_\\_proto\\_\\_ 里面创建了一个方法，然后通过调用这个方法来获取了keys，并且这个本身也是一个方法。\n\n```\nfunction T() {\n  return 1;\n}\n\nT.__proto__.keys = function () {\n  console.log(2);\n}\n```\n\n\n\n# Prop\n\n## Prop的大小写\n\n​\t\t简单来说就是驼峰命名法(camelCase)会在HTML上进行使用时需要转换为短横线分割命名(kebab-case)。因为HTML文档解析是大小写不敏感的，所以 postTitle 会被解析成 posttitle\n\n```\n<blog-post :post-title=\"a\"></blog-post>\n\nVue.component('blog-post', {\n  // 在 JavaScript 中是 camelCase 的\n  props: ['postTitle'],\n  template: '<h3>{{ postTitle }}</h3>'\n});\n```\n\n​\t\t但是如果是使用的字符串模板，那么就不会有这个限制。\n\n​\t\t意思就是说，使用template这种，模板是字符串的，应该是中间有个步骤在解析的时候会将驼峰自动转换为短横线。所以没有问题。\n\n\n\n## Prop类型\n\n* 正常prop在使用的时候是使用的数组，加上字符串进行存储。此时的prop是一个数组的形式。\n\n  * ```\n    props: ['title', 'author']\n    ```\n\n* 当然我们可以设置prop的值的类型。此时的prop是一个对象的形式。\n\n  * ```\n    props: {\n      title: String,\n      likes: Number,\n    }\n    ```\n\n  * 对于设置了类型，但是类型对不上的，会报错，但是还是会正常显示，并不会进行类型转换。\n\n* 后面还会将一个写法，props里面的prop也是一个对象，我们后续再进行一个讲解。\n\n  * ```\n    props: {\n    \tpropA: {\n    \t\ttype: String,\n    \t\tdefault: '111',\n    \t\trequired: true\n    \t}\n    }\n    ```\n\n\n\n## 传递静态或动态Prop\n\n​\t\t简单来说，prop的传递是通过在使用组件时，添加上了attribute属性在DOM树上，然后再进行的传递，所以这个是可以使用 v-bind 进行绑定的。\n\n​\t\t当然通过这里我也学会一个小case，就是在这样使用的时候，会把42作为一个数字传递过去，而不是字符串，对于布尔值也是一样，如果要传递一个字符串，需要再使用 '' 进行划分。\n\n```\n<blog-post :likes=\"42\"></blog-post>\n42， false， [12, 41]， {}\n```\n\n​\t\t对于要传入一个对象的所有property，我们可以使用 v-bind，进行直接传入。\n\n```\n<blog-post v-bind=\"post\"></blog-post>\n\n就等于将 post 里面的对象进行传递\n\n<blog-post\n  v-bind:id=\"post.id\"\n  v-bind:title=\"post.title\"\n></blog-post>\n```\n\n​\t\t当然这里的优先级来说，首先对于子组件没有的prop，是不会进行赋值的，其次对于对象里面存在，同时在外面也进行过一个操作的。比如下面这个情况，是以单独的为重点。\n\n```\n<blog-post :post-title=\"a\" v-bind=\"post\"></blog-post>\n\npost: {\n  id: 1,\n  'post-title': 'xxxx',\n}\n```\n\n​\t\t其次，就是对于对象里面的属性，在子组件的props里没有，但是确实这个标签的属性的，会被挂载为一个属性。\n\n​\t\t比如：下面这个title就是子组件不存在的，但是属于标签上的属性，我们就可以看到DOM解构上就存在了，同时，我们也发现，id属性应该也是DOM树上的，但是却没有，应该是对于props里面存在的属性会被拦截，只有不在的才会跳出拦截。\n\n```\npost: {\n  id: 1,\n  title: 'xxxx',\n}\n```\n\n\n\n## 单向数据流\n\n​\t\t简单来说，对于这个父子组件的值的传递，所以为了保证子组件意外变更父级组件的状态，我们让子组件不能进行更新，更新会报出警告。并且不能进行更改。\n\n​\t\t然而记住，这个只是对栈进行了一个锁定，并没有对堆进行锁定，所以简单来说就是值类型是会被警告，但是对于引用类型来说，还是可以直接进行修改，并不会爆出警告。\n\n​\t\t这是一个需要记住的问题。\n\n\n\n​\t\t对于会进行修改数据，但是又不想污染了父组件的data的，我们这里，有两个方式\n\n* 第一种就是使用了data将props的值重新进行赋值了 **这个子组件接下来希望将其作为一个本地的 prop 数据来使用** 。\n  * ```\n    props: ['initialCounter'],\n    data: function () {\n      return {\n        counter: this.initialCounter\n      }\n    }\n    ```\n\n* 第二种就是使用计算属性，简单来说就是并没有修改原数据，仅仅只是使用了原数据。常用于 **以一种原始的值传入且需要进行转换** 。\n\n\n\n## Prop 验证\n\n​\t\t验证类型是否满足需求，以及是否是必填项。\n\n### 类型检查\n\n* 类型的限制\n\n```\nprops: {\n\tA: Number,\n\tB: [Number, String],\n\tC: {\n\t\ttype: String,\n\t}\n}\n```\n\n* 是否为必填项和默认值\n\n```\nprops: {\n\tA: {\n\t\trequired: true,\n\t\tdefault: 'AA',\n\t}\n}\n```\n\n**注意：**\n\n对象和数组的默认值必须从一个工厂函数获取。简单来说就是需要是一个函数，函数返回一个对象或者数组。\n\n```\ndefault: () => {\n\treturn {\n\t\ta: 1\n\t};\n}\n```\n\n\n\n* 自定义一个验证函数\n\n```\nA: {\n\tvalidator: function(value) {\n\t\t//返回值是 true 和 false\n\t\treturn true;\n\t}\n}\n```\n\n\n\n> ​\t\t注意那些 prop 会在一个组件实例创建**之前**进行验证，所以实例的 property (如 `data`、`computed` 等) 在 `default` 或 `validator` 函数中是不可用的。\n\n\n\n## 非 Prop 的 Attribute\n\n​\t\t一个非 prop 的 attribute 是指传向一个组件，但是该组件并没有相应 prop 定义的 attribute。\n\n​\t\t这个在前面也有说过，因为prop的传递是在标签上进行的传递，那么怎么区别这个属性是prop的值还是我是要给标签上的值呢。这里就是非Prop的属性\n\n​\t\t简单来理解，就是对于声明的属性，但是却没有prop属性进行接收，那么就会被添加到组件的根元素上。\n\n\n\n### 替换/合并已有的 Attribute\n\n​\t\t简单来说就是我在组件的根元素上已经存在了这个属性，但是我在外面使用的使用对这个属性进行了重新的赋值，但是我的需求不是进行覆盖，而是进行合并，此时就是这个 替换/合并 属性\n\n​\t\t但是这里从官网上看出，并没有什么方法，但是对于 class 和 style 这两个属性，我们会进行合并操作，但是对于其他属性，比如 type 等，我们就会出现替换掉的操作。\n\n```\n子组件，c-c\ndiv.A[type='AA']\n\n父组件的使用\nc-c.B[type='BB']\n```\n\n\n\n### 禁用 Attribute 继承\n\n​\t\t简单来说就是因为在使用这个组件时，一些没有被prop的属性会被加入根标签，但是有的时候是不想这样的，所以我们可以使用 inheritAttrs: false，代表了继承属性为false。\n\n```\nVue.component('my-component', {\n\t//这个属性，为false，代表了多余的属性不会被记录在dom树上。（多余是指没有在props定义的），默认为true。\n  inheritAttrs: false,\n  // ...\n})\n```\n\n​\t\t当然对于需要被继承的属性，我们可以使用 $attrs 进行获取。这个属性包含了一个属性名和一个属性值。\n\n​\t\t通过 inheritAttrs 和 $attrs 这两个属性，就可以自己决定属性应该被赋予哪个元素。通常用于编写基础组件。\n\n​\t\t下面这个例子，首先，使用了 inheritAttrs 进行了拦截。对于props不存在的属性将不会出现在根元素上。然后再对input标签上添加了一个 v-bind=\"$attrs\" 因为$attrs 属性是一个键值对。然后将其赋值给了input标签上。\n\n```\nVue.component('base-input', {\n  inheritAttrs: false,\n  props: ['label', 'value'],\n  template: `\n    <label>\n      {{ label }}\n      <input\n        v-bind=\"$attrs\"\n        v-bind:value=\"value\"\n        v-on:input=\"$emit('input', $event.target.value)\"\n      >\n    </label>\n  `\n})\n\n<base-input\n  label=\"Username:\"\n  v-model=\"username\"\n  required\n  placeholder=\"Enter your username\"\n></base-input>\n```\n\n```\n$attrs 的值。\n{\n\trequired: \"\"\n\tplaceholder: \"Enter your username\"\n}\n```\n\n> 注意 `inheritAttrs: false` 选项**不会**影响 `style` 和 `class` 的绑定。\n\n​\t\t通过这个方式来进行操作的话，不用担心哪个是真正的根元素。\n\n\n\n# 自定义事件\n\n## 事件名\n\n​\t\t首先要注意一个地方，那就是，对于 vue 的 v-on 监听来说，（语法糖是@）。这个是不会将短横线转为驼峰的。\n\n​\t\t我们从前面可以知道，对于 props 来说，传递的属性如果是短横线，那么在props里面可以使用驼峰来进行处理，但是对于事件来说不行。\n\n​\t\t这里就会好奇为什么prop可以短横线转驼峰，但是事件不能呢。有的说是JavaScript的命名规范里面不能使用短横线命名。\n\n```\nthis.$emit('myEvent')\n<!-- 没有效果 -->\n因为 短横线不能转换为驼峰。所以没有效果。\n<my-component v-on:my-event=\"doSomething\"></my-component>\n```\n\n​\t\t所以对于 @myEvent 将会被转化为 @myevent。\n\n​\t\t所以最好的建议就是全部都是用 kebab-case。这里不但有HTML大小写不敏感的原因，还有对于模板字符串来说。大小写是规定的。\n\n\n\n## 自定义组件的v-model 2.2.0+\n\n​\t\tv-model 这个默认是利用名为 value 的prop 和 input 的事件。当然对于input的单选框和其他的会将value属性用于不同的prop。但是我们可以使用 model 选项来解决 v-model的冲突。\n\n​\t\t简单的理解一下下面的内容，prop：checked，这个默认是value，代表了使用props的checked作为v-model的绑定。event：change，默认是input，代表监听的事件名称是change，这些都是可以进行修改的。\n\n```\nVue.component('base-checkbox', {\n  model: {\n    prop: 'checked',\n    event: 'change'\n  },\n  props: {\n    checked: Boolean\n  },\n  template: `\n    <input\n      type=\"checkbox\"\n      v-bind:checked=\"checked\"\n      v-on:change=\"$emit('change', $event.target.checked)\"\n    >\n  `\n})\n```\n\n​\t\t比如我这里进行一个修改。就是将 prop 的checked改成了XXX，于是相对应的。props的名字也要有一个XXX的存在。同理。我可以将event改成一个AAA，那么就会将emit提交的事件名称修改为AAA。\n\n```\nmodel: {\n  prop: 'XXX',\n  event: 'AA'\n},\nprops: {\n  XXX: String\n},\ntemplate: `\n  <input\n  :value=\"XXX\"\n  @change=\"$emit('AA', $event.target.value)\"\n  >\n`\n```\n\n> 注意你仍然需要在组件的 props 选项里声明 checked 这个 prop。\n\n\n\n## 将原生事件绑定到组件\n\n​\t\t简单来说就是我想对一个标签进行监听，比如input监听，方法在本身，但是组件的input标签是在子组件的。那么此时我们就可以发现。子组件的输入并不会调用这个方法。\n\n```\n<base-input @input=\"onInput\"></base-input>\n```\n\n​\t\t我们可以先做一个原生的示例。通过下面这个示例我们可以发现。在输入input的时候会输出1，2 。因为这个是冒泡的原因。所以先进行的子组件的执行，再进行的父组件的执行。\n\n```\n<div oninput=\"console.log(2);\">\n  <input oninput=\"console.log(1);\"/>\n</div>\n```\n\n​\t\t那么我们做一个vue组件的示例。并且我们也可以发现。此时就不会执行 myInput 方法了。只会执行组件内部的input的方法。不会执行外部的。原因的话。我们可以知道对于没有props接收的属性一般会被加入根元素，但是我们可以发现对于 监听属性来说，并没有加入到根元素。\n\n```\n<div id=\"app\">\n  <base-input @input=\"myInput\"></base-input>\n</div>\n\nVue.component('base-input', {\n  template: `<input @input=\"CInput\">`,\n  methods: {\n    CInput() {\n      console.log('c');\n    }\n  }\n})\n```\n\n​\t\t具体的原因还不清楚。但是要记住就是直接使用监听是不会被监听成功的。有可能是监听要通过JavaScript进行操作，但是组件的元素会被替换，所以监听会失效。\n\n​\t\t因此我们可以使用 .native 修饰符 那么此时就可以将监听放入根元素了。当然，这个的效果简单来说就是会将事件绑定给根元素。但是如果本来根元素不支持这个事件，那么就会静默失败，比如 div的根元素绑定一个focus，就会失败。\n\n```\n<base-input @input.native=\"myInput\"></base-input>\n```\n\n\n\n​\t\t此时，对于根元素并不是我想要绑定的元素，这个时候，我们知道，对于props，有一个叫做。$attrs，和 inheritAttrs 进行搭配，可以使父组件传递的props在子组件能够有一个自己规定的位置出现。那么同时事件也有一个 $listeners 属性，他是一个对象，里面包含了作用在这个组件上的监听器。\n\n```\n<div><input v-on=\"$listeners\" @input=\"CInput\"></div>\n```\n\n​\t\t但是注意，如果使用了 .native 那么将不会出现在 $listeners 里面。不管 .native 是否会绑定成功。\n\n​\t\t下面这个是使用computed，这里记住一个问题，那就是 下面这个写法是会将 input 的监听进行覆盖的一个操作。但是又通过了 $emit 向上通知了父组件的 input。同理 使用 this.$listeners['input'] 也会覆盖input。\n\n```\ncomputed: {\n  inputListeners: function () {\n    var vm = this\n    // `Object.assign` 将所有的对象合并为一个新对象\n    return Object.assign({},\n      // 我们从父级添加所有的监听器\n      this.$listeners,\n      // 然后我们添加自定义监听器，\n      // 或覆写一些监听器的行为\n      {\n        // 这里确保组件配合 `v-model` 的工作\n        input: function (event) {\n        \tvm.$emit('input', event.target.value)\n        }\n      }\n    )\n  }\n},\n```\n\n\n\n## .sync修饰符 2.3.0+\n\n​\t\t因为双向绑定会带来维护上的问题。因为对于data的变更不清楚来源。\n\n​\t\t所以我们推荐 update:myPropName 来代替。在一个包含 title 的假设的组件。\n\n```\nthis.$emit('update:title', newTitle)\n```\n\n​\t\t因此就引出了sync修饰符，这算是一个语法糖。\n\n* 对于父组件来说，变化就是将 :title 和 :update:title 进行了合并，简单来说就像是进行了 v-model 的操作一样。\n\n  * ```\n    <base-input\n      v-bind:title=\"a\"\n      v-on:update:title=\"a\"\n    ></base-input>\n    \n    <base-input :title.sync=\"a\"></base-input>\n    ```\n\n* 对于子组件来说，没有什么变化， 这里的 :title.sync 就是 @update:title 加上了 :title，所以对于 $emit 也是使用原来的 update:title 进行的提交。\n\n  * ```\n    this.$emit('update:title', Math.random());\n    ```\n\n\n\n在这里，还有一个问题就是。我们可以发现对于 emit提交时带的参数，父组件如果要将方法写在那个标签上进行表达式的执行，那么 $event 就是第一个参数。\n\n```\nthis.$emit('update:title', 1);\n\n//这里的 $event 就是 子元素在 $emit 提交时的第二个参数，从第二个参数开始的提交就是会传递给父元素的参数。这里只是第二个，如果没有参数的话，就会为undefined\n<base-input @update:title=\"a = $event\"></base-input>\n```\n\n\n\n> 注意带有 `.sync` 修饰符的 `v-bind` **不能**和表达式一起使用 (例如 `v-bind:title.sync=”doc.title + ‘!’”` 是无效的)。取而代之的是，你只能提供你想要绑定的 property 名，类似 `v-model`。\n\n\n\n​\t\t当然，这里的 sync修饰符 也可以和 v-bind 进行搭配\n\n```\n<text-document v-bind.sync=\"doc\"></text-document>\n\nthis.$emit('update:title', 1111);\n```\n\n\n\n> 将 `v-bind.sync` 用在一个字面量的对象上，例如 `v-bind.sync=”{ title: doc.title }”`，是无法正常工作的，因为在解析一个像这样的复杂表达式的时候，有很多边缘情况需要考虑。\n\n\n\n# 插槽\n\n​\t\t简单来说就是，因为Vue的组件化思路，所以很多都是以组件进行的开发。但是为了降低组件和组件的解耦性，就可以使用插槽，将组件之间的联系进一步的降低。\n\n​\t\t在 2.6.0中，提供了新的语法 v-slot 来代替了 slot 和 slot-scope\n\n## 插槽内容\n\n​\t\t\n\n**一个简单的示例**\n\n​\t\t下面的示例就代表了 Your Profile 将会代替 slot这个标签进行显示。当然 插槽的内部可以包含任何模板代码，包括HTML和其他组件，这也是我们常会使用的方法。\n\n```\n<navigation-link url=\"/profile\">\n  Your Profile\n</navigation-link>\n\n\n<a>\n  <slot></slot>\n</a>\n```\n\n\n\n## 编译作用域\n\n​\t\t简单来说，看下面这个代码，这个 a 应该是 父级组件上的 a呢，还是子组件上的a呢。\n\n​\t\t最终的结果就是这个是 父级组件上的a。\n\n```\n<div>\n\t<base-input>{{ a }}</base-input>\n</div>\n```\n\n这里有条规则\n\n> 父级模板里的所有内容都是在父级作用域中编译的；子模板里的所有内容都是在子作用域中编译的。\n\n\n\n## 后背内容\n\n​\t\t简单来说就是一个插槽的默认值。简单来说就是写在 slot 里面的内容就是 插槽的默认值。\n\n​\t\t如果你在使用组件的时候没有使用插槽，那么就会使用这个默认的内容，并且这个默认的内容的作用域是在子组件的。\n\n​\t\t如果提供有内容，那么便会渲染来取代内容。\n\n```\n<div><slot>{{ x }}</slot></div>\n```\n\n\n\n## 具名插槽\n\n​\t\t简单来说就是使用name将插槽能够指定的使用在某个位置。对于没有使用name的，会有一个默认的name default。 \n\n```\n<slot name=\"header\"></slot>\n```\n\n​\t\t那么在使用这个具名插槽的时候，我们就可以使用一个 template 进行包裹，然后在里面使用 v-slot指令，并以 v-slot 的参数的形式提供名称。\n\n​\t\t从下面的代码可以看出，对于使用了 template加上v-slot的，就是寻找name相对应的。对于没有使用的就会被作为一个默认，就算中间隔了一个template v-slot 也一样。\n\n```\n<base-layout>\n  <template v-slot:header>\n    <h1>Here might be a page title</h1>\n  </template>\n\n  <p>A paragraph for the main content.</p>\n  <p>And another one.</p>\n\n  <template v-slot:footer>\n    <p>Here's some contact info</p>\n  </template>\n</base-layout>\n```\n\n​\t\t当然，为了语义的方便，我们建议还是可以将默认的放入一个 template v-slot:default，当然，这个default不要也可以，但是如果加了default，那么就不会将其他外层标签也加入默认，但是如果没有加上default的话，那么就会加入默认。\n\n​\t\t比如：\n\n```\n<template v-slot:default>\n  <p>A paragraph for the main content.</p>\n  <p>And another one.</p>\n</template>\n//下面这个不会显示。\n<p>And another one.</p>\n```\n\n```\n<template>\n  <p>A paragraph for the main content.</p>\n  <p>And another one.</p>\n</template>\n//上面的template没有使用default，下面这个会显示出来，因为都被算在了插槽里面\n<p>And another one.</p>\n```\n\n\n\n## 作用域插槽\n\n​\t\t2.6.0 废弃了 slot-scope\n\n​\t\t因为我们可以知道，插槽的默认的作用域是编译时的环境，所以一般常常是父级作用域，那么此时我们要如何将作用域作用域子级。\n\n​\t\t这个时候就是要使用作用域插槽的时候了。\n\n* 简单来说就是子组件在进行slot创建时，通过 v-bind 绑定一个属性，然后属性的值是data的值。\n* 然后在使用的时候，通过 v-slot:xx=\"xxx\" 进行了属性的获取，这里 xxx就是子组件传递过来的一系列的属性而形成的对象。\n* 此时我们就可以在父组件里面使用到子组件的data了，当然，建议这个还是少使用吧，因为这个造成了组件的透明度降低。\n\n```\n<slot :x=\"x1\"></slot>\n\n<template v-slot:default=\"a\">\na.x\n</template>\n```\n\n\n\n### 独占默认插槽的缩写语法\n\n​\t\t就是说，只有被提供的内容只存在默认插槽的存在时，组件的标签才可以被当作插槽的模板来使用。此时我们就可以直接把 v-slot 用在组件上。\n\n​\t\t这里我们首先知道 v-slot 可以使用在组件上，并且插槽是可以接收一个组件的。但是我们后面可以发现，如果直接使用组件，会出现插槽的位置无法正确的定位。\n\n​\t\t然后我么可以发现，其实对组件是不能进行插槽的定位的。意思就是说，对于组件来说，使用插槽的 v-slot 不能定位到对应的具名插槽。\n\n​\t\t比如下面这个情况，我开始以为 v-slot:footer 和 v-slot:header，都会按照正确的位置进行拜访，因为这个就是具名插槽的作用，只能用于template，对于下面这个test组件，虽然我们也使用了 v-slot:header 但是他并没有去header，而是就为普通的标签的行为。v-slot不会在除了template上起作用。\n\n```\n<base-input>\n  <template v-slot:footer>\n  \t<ttt></ttt>\n  </template>\n\n  <p>123</p>\n  <p>111</p>\n\n  <test v-slot:header></test>\n</base-input>\n```\n\n\n\n```\n<current-user v-slot:default=\"slotProps\">\n  {{ slotProps.user.firstName }}\n</current-user>\n```\n\n​\t\t缩写语法\n\n```\n<current-user v-slot=\"slotProps\">\n  {{ slotProps.user.firstName }}\n</current-user>\n```\n\n​\t\t案例形式。简单来说就是，如果base-input内部只有一个默认插槽，那么我们可以将这个 base-input 内部的整体都作为一个 slot的代替，如果是以前， base-input>template[v-slot=\"slotProps\"] 但是我们可以将template进行省略，所以变成了 base-input[v-slot=\"slotProps\"]\n\n​\t\t当然，上面这个也是进行了缩写了的。完整的话，需要加上 v-slot:default。\n\n```\n<base-input v-slot=\"slotProps\">\n</base-input>\n```\n\n\n\n### 解构插槽Prop\n\n​\t\t简单来说就是说，作用域插槽的内部原理就是将插槽的内容包裹在一个参数的函数内部。\n\n```\nfunction (slotProps) {\n  // 插槽内容\n}\n```\n\n​\t\t在下面这个标签的使用里。使用了解构赋值的形式， { user } = slotProps，在这里，解构赋值的效果就是，取出了 slotProps的user给了 user。当然我们也可以使用其他的解构赋值的行为。\n\n```\n<current-user v-slot=\"{ user }\">\n  {{ user.firstName }}\n</current-user>\n```\n\n\n\n## 动态插槽名\n\n​\t\t2.6.0 新增\n\n```\n<template v-slot:[dynamicSlotName]>\n  ...\n</template\t>\n```\n\n\n\n## 具名插槽的缩写\n\n​\t\t2.6.0 新增\n\n​\t\t简单来说，就是插槽的语法糖，v-slot => #，但是对于没有参数的话是无效的。\n\n```\n<current #header=\"{ user }\"></current>\n//下面这个是无效的。\n<current #=\"{ user }\"></current>\n```\n\n\n\n# 动态组件&异步组件\n\n## 在动态组件上使用 keep-alive\n\n​\t\t之前，我们使用 is 属性来对组件进行切换。\n\n```\n<component v-bind:is=\"currentTabComponent\"></component>\n```\n\n​\t\t现在，我们在组件进行切换的时候，想要保存组件的状态。以避免重复的渲染。\n\n```\n<!-- 失活的组件将会被缓存！-->\n<keep-alive>\n  <component v-bind:is=\"currentTabComponent\"></component>\n</keep-alive>\n```\n\n\n\n## 异步组件\n\n​\t\t将应用分割成小一些的代码块，并且只在需要的时候才从服务器进行加载。对此Vue允许使用一个工厂函数的方式进行定义组件。Vue只有在这个组件需要被渲染，并把结果缓存起来供未来重渲染。\n\n​\t\t下面这个简单的例子，表示了第二个参数是一个函数，函数需要使用resolve和reject，表示会以promise进行调用，通过resolve返回渲染对象，荣国reject表示加载失败。\n\n```\nVue.component('async-example', function (resolve, reject) {\n  setTimeout(function () {\n    // 向 `resolve` 回调传递组件定义\n    resolve({\n      template: '<div>I am async!</div>'\n    })\n  }, 1000)\n})\n```\n\n​\t\t一个推荐的做法是将异步组件和 [webpack 的 code-splitting 功能](https://webpack.js.org/guides/code-splitting/)一起配合使用\n\n```\nVue.component('async-webpack-example', function (resolve) {\n  // 这个特殊的 `require` 语法将会告诉 webpack\n  // 自动将你的构建代码切割成多个包，这些包\n  // 会通过 Ajax 请求加载\n  require(['./my-async-component'], resolve)\n})\n```\n\n​\t\t但是因为我这个异步组件和搭配webpack这个用的比较少，所以在这里就没有进行详细的讲述，就直接贴上Vue的官网链接了。\n\n```\nhttps://cn.vuejs.org/v2/guide/components-dynamic-async.html#异步组件\n```\n\n\n\n### 处理加载状态\n\n​\t\t2.3.0 新增\n\n```\nconst AsyncComponent = () => ({\n  // 需要加载的组件 (应该是一个 `Promise` 对象)\n  component: import('./MyComponent.vue'),\n  // 异步组件加载时使用的组件\n  loading: LoadingComponent,\n  // 加载失败时使用的组件\n  error: ErrorComponent,\n  // 展示加载时组件的延时时间。默认值是 200 (毫秒)\n  delay: 200,\n  // 如果提供了超时时间且组件加载也超时了，\n  // 则使用加载失败时使用的组件。默认值是：`Infinity`\n  timeout: 3000\n})\n```\n\n\n\n> 注意如果你希望在 [Vue Router](https://github.com/vuejs/vue-router) 的路由组件中使用上述语法的话，你必须使用 Vue Router 2.4.0+ 版本。\n\n\n\n# 处理边界情况\n\n\n\n## 访问元素 & 组件\n\n\n\n### 访问根实例 this.$root\n\n​\t\t这个可以通过 `this.$root`，进行访问。如果是methods里面的方法aa，那么就可以通过 `this.$root.aa` 进行访问。\n\n​\t\t所有的子组件都可以将这个实例作为一个全局 store 来访问或者使用。\n\n> 对于 demo 或非常小型的有少量组件的应用来说这是很方便的。不过这个模式扩展到中大型应用来说就不然了。因此在绝大多数情况下，我们强烈推荐使用 [Vuex](https://github.com/vuejs/vuex) 来管理应用的状态。\n\n\n\n### 访问父级组件实例\n​\t\t可以通过 $parent 属性来访问一个父组件的实例。\n​\t\t但是请注意，这样写虽然是可以直接对父组件进行了操作，可以代替props来进行数据的访问，但是却会造成数据的修改时不清楚修改的源头。\n\n### 访问子组件实例或子元素\n​\t\t可以通过 ref 属性，为子组件赋予一个ID引用。\n\n```\n<base-input ref=\"usernameInput\"></base-input>\n\n那么父组件就可以通过 this.$refs.usernameInput 来访问子组件了。\n```\n\n​\t\t但是记住，this.$refs，里面存放的只会有属于自己的子组件，以及有可能会有自己的子孙级组件。这个我们一会儿就说。\n\n​\t\tref同时也可以写在原生的HTML标签上面，for example `<input type=\"text\" ref=\"inpu\">` 如果写在了原生的HTML上面，我们通过$refs获取时也是一个原生的标签，并且也可以使用方法，比如 `focus` 等。\n\n```\n<div id=\"app\">\n    <input type=\"text\" ref=\"input\">\n</div>\n\n//在父组件的方法里面使用这个便可以调用input的原生focus进行聚焦。\nthis.$refs.inpu.focus()\n```\n\n\n\n关于父组件的 refs 是否会含有子组件，这个应该是在哪个组件被编译就会存在于哪个组件。\n\n​\t\t比如看看下面这个文件的内容。template存在一个插槽和input，然后在使用组件的时候，插槽又是插入了一个input，但是如果我们查看结果，就会发现，插槽所写的ref会存在与父组件，而在template里面所写的，便会存在于子组件。\n\n```\ntemplate: `<div><slot></slot><input type=\"text\" ref=\"input\"></div>`,\n\n<aaaa ref=\"ssss\">\n    <input type=\"text\" ref=\"inpu\">\n</aaaa>\n```\n\n​\t\t当 ref 和 v-for 一起使用的时候，ref会包含整个数组。一般来说，refs是一个对象，但是对于使用了v-for的来说，就会变成一个数组，就算是ref使用了v-bind 进行了绑定，也会变为存在不同ref的对象，内部含有数组。\n\n```\n<li :ref=\"i\" v-for=\"i in 10\"></li>\n\n1: [li]\n2: [li]\n3: [li]\n4: [li]\n\n形成的还是数组，虽然数组的长度只有1。\n```\n\n\n\n### 依赖注入\n\n​\t\t简单来说，就是父子组件可以通过 $parent 来进行访问，但是对于嵌套的情况，会造成 $parent.$parent 那么此时就是依赖注入的时候。\n\n​\t\t这里用到了两个新的实例的选项。 provide & inject\n\n**provide** 选项允许我们指定我们想要提供给后代组件的数据/方法。\n\n```\nprovide: function() {\n\treturn {\n\t\tget: this.get\n\t}\n}\n```\n\n**inject** 在任何后代组件里，我们都可以使用 inject 选项来接收指定的属性进行注入。\n\n**例子**：\n\n```\nfather\n\tchildren\n\t\tgrandson\n\n那么此时 grandson要使用 father组件的方法就需要 this.$parent.$parent 来进行调用，但是对于有多层的调用会出现意想不到的问题。\n```\n\n​\t\t使用 provide 和 inject 进行处理，需要记住，这个的调用创建应该是先于data，所以如果当data和inject进行了重合，那么便会出现data覆盖了inject，但是他们都是属于 init injected & reacted 周期。在使用 beforeCreate 之后， 以及 created 之前。\n\n```\n先使用 provide 进行提供需要给后代的方法和数据。\nconst app = new Vue({\n\tprovide() {\n\t\treturn {\n\t\t\tname: this.output,\n\t\t}\n\t}\n})\n\n然后在后代使用 inject 进行注入，注入之后就可以使用 this.name进行使用。\nVue.component('xx', {\n\tinject: ['name'],\n})\n```\n\n\n\n## 程序化的事件侦听器\n\n通过 $on(eventName, eventHandler) 来侦听一个事件。\n\n通过 $once(eventName, eventHandler) 来一次性的侦听一个事件。\n\n通过 $off(eventName, eventHandler)  来停止侦听一个事件。\n\n一般来说是很少进行使用的，但是当你需要在一个组件的实例上手动的侦听事件时，它们便派上了用场。\n\n```\nmounted() {\n\tthis.pi = new Pi({});\n},\nbeforeDestroy() {\n\tthis.pi.destroy();\n}\n```\n\n如果使用程序化的侦听器来解决这个问题：\n\n```\nmounted() {\n\tconst pi = new Pi({});\n\tthis.$once('hook:beforeDestroy', function() {\n\t\tpi.destroy();\n\t})\n},\n```\n\n**注意**：\n\n> ​\t\tVue 的事件系统不同于浏览器的 [EventTarget API](https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget)。尽管它们工作起来是相似的，但是 `$emit`、`$on`, 和 `$off` 并不是 `dispatchEvent`、`addEventListener` 和 `removeEventListener` 的别名。\n\n\n\n## 循环引用\n\n### 递归组件\n\n​\t\t组件是可以在他们自己的模板中调用自身的，但是只能通过name选项来做这件事。\n\n```\nname: 'stack',\ntempalte: `<div><stack></stack></div>`,\n```\n\n​\t\t简单来说就是可以进行递归的循环，所以需要注意，并且发现对于全局注册组件，也可以使用组件名称进行递归组件。\n\n\n\n### 组件之间的循环引用\n\n​\t\t对于组件之间的相互调用，组件在渲染树中互相为对方的后代和祖先。当通过 Vue.component 全局注册组件的时候，这个悖论将会被解开。\n\n```\ntree-father\n\ttree-other\n\t\ntree-other\n\ttree-father\n```\n\n​\t\t然而，如果你使用一个模块系统依赖/导入组件，则会遇到一个错误。\n\n​\t\t所以此时的解决办法就是：\n\n* 将注册事件放入 beforeCreate 进行注册。\n\n  * ```\n    beforeCreate() {\n    \tthis.$options.components.ComponentA = require('./component-a.vue');\n    }\n    ```\n\n* 或者，在本地进行注册组件的时候，可以使用 webpack 异步 import\n\n  * ```\n    components: {\n    \tComponentA: () => import('./component-a.vue');\n    }\n    ```\n\n\n\n## 模板定义的代替品\n\n### 内联模板\n\n​\t\t简单来说就是，组件内部的内容将会作为模板，而不是将其视为分布式内容(或者插槽？)。\n\n```\n<my-component inline-template>\n    <div>\n        <p>These are compiled as the component's own template.</p>\n        <p>Not parent's transclusion content.</p>\n    </div>\n</my-component>\n\nVue.component('my-component', {\n})\n```\n\n**注意点**：\n\n* 使用的模板名需要是存在的\n* 如果要使用内联模板，那么对于全局注册的组件时需要的信息可以不需要，比如(template，data，methods等)。\n* 个人感觉这个和 template 的效果很相似。但是注意，使用内联模板也是可以使用data和methods的。所以这个的作用应该是很像 .vue 文件的使用。\n\n\n\n### X-Template\n\n​\t\t使用 script 脚本，并且将type设置为 text/x-template，然后通过使用 id 来引用模板。\n\n```\n<script type=\"text/x-template\" id=\"hello-world-template\">\n  <p>Hello hello hello</p>\n</script>\n\nVue.component('hello-world', {\n  template: '#hello-world-template'\n})\n```\n\n​\t\t这些替代模板都是将 模板内部的标签 和 数据 以及操作等进行了分割。\n\n\n\n## 控制更新\n\n### 强制更新\n\n​\t\t使用 $forceUpdate\n\n```\ndata() {\n\treturn {\n\t\tx: [1, 3],\n\t}\n}\n\nthis.x[1] = 10;\n//此时，虽然数据发生了改变，但是因为vue2的数据响应式无法对数组的直接操作进行通知，所以不会发生更新，那么此时就需要使用 this.$forceUpdate(); 来进行强制更新了。\nthis.$forceUpdate();\n```\n\n\n\n### 使用 v-once 的廉价静态组件\n\n​\t\tVue 渲染纯HTML非常快，但是有时你的组件包含了大量的静态内容。在这些情况下，可以确保只被评估一次。\n\n```\nVue.component('terms-of-service', {\n  template: `\n    <div v-once>\n      <h1>Terms of Service</h1>\n      ... a lot of static content ...\n    </div>\n  `\n})\n```\n\n**注意**：\n\n尽量不要过度的使用这种模式。除非真的渲染缓慢。\n\n","source":"_posts/Vue/Vue2教程/Vue2-教程-深入了解组件.md","raw":"---\ntitle: Vue-使用-深入了解组件\ndate: 2021-10-29 23:15:14\ntags:\n - Vue\n - Vue2\n - 文档\ncategories:\n - Vue\n - Vue2文档\n---\n\n\n\n#  组件注册\n\n```\nhttps://cn.vuejs.org/v2/guide/components-registration.html\n```\n\n\n\n## 组件名\n\n### 组件名大小写\n\n​\t\t对于大小写的组件名，在使用的时候大写会变成 -+小写的形式。\n\n```\nmyComPonent\n\nmy-com-ponent\n```\n\n\n\n## 全局注册\n\n```\nVue.component('component-a', { /* ... */ })\n```\n\n​\t\t这样创建就是全局注册的，只要注册了之后，后面的Vue实例都可以直接使用。\n\n\n\n## 局部注册\n\n​\t\t全局注册会不可避免的增加性能的消耗，浪费了很多时间。所以可以使用局部注册的方式进行注册，将组件注册在实例的内部，因此在实例被销毁时也会被销毁。\n\n```\nconst ComponentA = { /* ... */ };\n\nnew Vue({\n  el: '#app',\n  components: {\n    'component-a': ComponentA,\n    'component-b': ComponentB\n  }\n})\n```\n\n​\t\t简单来说就是 ComponentsA 里面的对象就是 new一个Vue实例的对象。然后再在components里面进行new的创建，所以将作用域限制到了一定的范围。\n\n```\nconst C = {\n  template: `<div>22</div>`,\n}\nconst ComponentA = {\n  el: '#ap',\n  //这里是局部组件创建再加上了一个组件的创建，否则一个父组件，两个局部组件内部是不能相互调用的。\n  components: {\n    'com': C,\n  }\n}\n\nconst app = new Vue({\n  el: '#app',\n  data: {\n    a: 1\n  },\n  components: {\n    'comA': ComponentA,\n    'com': C,\n  }\n})\n```\n\n\n\n## 模块系统\n\n​\t\t简单来说就是可以使用 import / require 来使用一个模块系统。\n\n\n\n### 在模块系统中局部注册\n\n​\t\t简单来说，下面这个是取出了一个对象。这个是一个ES6的模块化导出的默认导出的写法。\n\n​\t\t所以简单来说就是将对象进行导出。\n\n```\nimport ComponentA from './Component';\n```\n\n```\nexport default {\n\t\n}\n```\n\n​\t\t我们先理清一下思路\n\n* 首先，Vue的components里面使用的是一个对象，这个对象是那个实例对象。其次对于这个命名的思路是因为是es6的对象赋值的方式\n* 然后就是导入 import 和 export default 这里导入和导出对象。\n* 所以其实还是有思路的。\n\n\n\n### 基础组件的自动化全局注册\n\n​\t\trequire.context 可以全局注册组件。但是需要使用webpack或者使用了VueCLI3+（因为内部使用了webpack）\n\n​\t\t**什么是 require.context ：**\n\n* 首先，是一个webpack的api。\n* 其次，这个api用于实现自动化导入模块。就是对于一个文件引入很多模块的情况，可以使用这个api，会遍历指定的文件，然后进行自动导入，不需要每次显式的调用import导入模块。\n* 进行一个更细粒度的模块引入。\n\n\n\n​\t\t**一个使用时机**：\n\n* 首先就是需要引入很多模块\n* 其次就是这个模块的处于同一父文件位置，所以对于基础组件来说是非常合适的。\n\n\n\n​\t\trequire.context 的参数：\n\n* directory，String类型\n\n  * 文件目录位置，\n\n* includeSubdirs，Boolean类型\n\n  * 表示是否包含文件的子目录，可选参数，默认是 true\n\n* filter，RegExp正则表达式类型\n\n  * 表示过滤某些文件。可选参数，默认是 `/^\\.\\/.*$/` 指的是所有文件。（这里是webpack写的，但是我没有理解这个正则）。\n\n* mode，String类型\n\n  * 表示加载的方式， sync，eager，weak，lazy，lazy-once。默认值是sync。\n\n  * ```\n    sync\n    eager\n    \t不会生成额外的chunk，所有模块当成当前chunk引入。没有额外的网络请求，但是会返回一个resolved的Promise。\n    weak\n    \t这个没有看懂，大概可能是尝试加载，不可用返回一个reject的Promise。\n    lazy\n    \t为每一个导入的模块生成一个可延迟加载的chunk。简单来说就是将以异步方式加载。\n    lazy-once\n    \t生成一个可以满足所有的可延迟加载的chunk。这个chunk将第一次调用时获取，随后使用相同的网络响应。\n    ```\n\n\n\n大概看懂了之后，我们再看一下组件的自动化全局注册\n\n```\nimport Vue from 'vue'\nimport upperFirst from 'lodash/upperFirst'\nimport camelCase from 'lodash/camelCase'\n\nconst requireComponent = require.context(\n  // 其组件目录的相对路径\n  './components',\n  // 是否查询其子目录\n  false,\n  // 匹配基础组件文件名的正则表达式\n  /Base[A-Z]\\w+\\.(vue|js)$/\n)\n\nrequireComponent.keys().forEach(fileName => {\n  // 获取组件配置\n  const componentConfig = requireComponent(fileName)\n\n  // 获取组件的 PascalCase 命名\n  const componentName = upperFirst(\n    camelCase(\n      // 获取和目录深度无关的文件名\n      fileName\n        .split('/')\n        .pop()\n        .replace(/\\.\\w+$/, '')\n    )\n  )\n\n  // 全局注册组件\n  Vue.component(\n    componentName,\n    // 如果这个组件选项是通过 `export default` 导出的，\n    // 那么就会优先使用 `.default`，\n    // 否则回退到使用模块的根。\n    componentConfig.default || componentConfig\n  )\n})\n```\n\n​\t\t**其中这一部分的作用是将每个文件的模块给取了出来**\n\n```\nconst requireComponent = require.context(\n  // 其组件目录的相对路径\n  './components',\n  // 是否查询其子目录\n  false,\n  // 匹配基础组件文件名的正则表达式\n  /Base[A-Z]\\w+\\.(vue|js)$/\n)\n\n目录是 ./components\n不查询子目录\n匹配文件的形式，Basexxxx.(vue|js)\n```\n\n* requireComponent 通过typeof 判断是一个，function，里面存在了方法，可以使用keys方法进行获取\n\n\n\n​\t\t**这里是将requireComponent存储的组件给进行了注册。**\n\n```\nrequireComponent.keys().forEach(fileName => {\n  // 获取组件配置\n  const componentConfig = requireComponent(fileName)\n\n  // 获取组件的 PascalCase 命名\n  const componentName = upperFirst(\n    camelCase(\n      // 获取和目录深度无关的文件名\n      fileName\n        .split('/')\n        .pop()\n        .replace(/\\.\\w+$/, '')\n    )\n  )\n\n  // 全局注册组件\n  Vue.component(\n    componentName,\n    // 如果这个组件选项是通过 `export default` 导出的，\n    // 那么就会优先使用 `.default`，\n    // 否则回退到使用模块的根。\n    componentConfig.default || componentConfig\n  )\n})\n```\n\n* keys方法获取到的是文件的相对路径。使用foreach进行循环操作。foreach内部也是和forin一个意思。forin和forof的区别在于迭代器问题。\n\n  * ```\n    ./App.vue\n    ./components/App.vue\n    ```\n\n* 然后使用 requireComponent 方法，参数为文件位置，便会获取到内容。\n\n  * 使用 requireComponent(filename)，进行获取，就可以获取到内容。\n\n* 当然这里的一个特点是，这个requireComponent 既是一个方法，也是一个对象，因为它既能像方法一样传递参数进行操作，也可以调用keys这个方法。\n\n* 这里使用的 upperFirst 和 camelCase 是 lodash里面的方法，其中 upperFirst的作用是首字母大写，而camelCase是将字符串转为驼峰命名法，比如空格，-，_将会被划分。\n\n* 在这里，首先fileName是一个文件的路径和名字，所以使用split进行划分/， 然后取出最后一个，然后将后面的文件后缀改为空，然后给camelCase变为驼峰，然后返回的字符串给了upperFirst变为了首字母大写的驼峰。赋值给了componentName。\n\n  * ```\n    const componentName = upperFirst(\n      camelCase(\n        // 获取和目录深度无关的文件名\n        fileName\n          .split('/')\n          .pop()\n          .replace(/\\.\\w+$/, '')\n      )\n    )\n    ```\n\n* 然后就是注册组件了，使用了 Vue.component 方法。进行注册，Vue.component 第一个参数是名字，第二个参数是需要被Vue实例的对象。\n\n  * 这里的唯一的问题就是，对于如果没有使用 export default 导出的方法，貌似不会存在 default 这个对象。但是具体的我们需要在后面才会知道。\n\n  * ```\n    Vue.component(\n      componentName,\n      // 如果这个组件选项是通过 `export default` 导出的，\n      // 那么就会优先使用 `.default`，\n      // 否则回退到使用模块的根。\n      componentConfig.default || componentConfig\n    )\n    ```\n\n\n\n​\t\t**如何实现一个方法带有对象的使用。**\n\n​\t\t这里我的一个想法就是修改原型链了，因为JavaScript任何都是存在原型链的，对于方法来说，也是有一个原型链的。简单来理解，方法既可以使用，又可以当作一个构造器来创建对象。\n\n* 作为一个构造器来说，方法需要记住的是prototype的指向\n* 而对于方法的执行来说，需要记住的是 \\_\\_proto\\_\\_ 的指向。所以这里对 \\_\\_proto\\_\\_ 里面创建了一个方法，然后通过调用这个方法来获取了keys，并且这个本身也是一个方法。\n\n```\nfunction T() {\n  return 1;\n}\n\nT.__proto__.keys = function () {\n  console.log(2);\n}\n```\n\n\n\n# Prop\n\n## Prop的大小写\n\n​\t\t简单来说就是驼峰命名法(camelCase)会在HTML上进行使用时需要转换为短横线分割命名(kebab-case)。因为HTML文档解析是大小写不敏感的，所以 postTitle 会被解析成 posttitle\n\n```\n<blog-post :post-title=\"a\"></blog-post>\n\nVue.component('blog-post', {\n  // 在 JavaScript 中是 camelCase 的\n  props: ['postTitle'],\n  template: '<h3>{{ postTitle }}</h3>'\n});\n```\n\n​\t\t但是如果是使用的字符串模板，那么就不会有这个限制。\n\n​\t\t意思就是说，使用template这种，模板是字符串的，应该是中间有个步骤在解析的时候会将驼峰自动转换为短横线。所以没有问题。\n\n\n\n## Prop类型\n\n* 正常prop在使用的时候是使用的数组，加上字符串进行存储。此时的prop是一个数组的形式。\n\n  * ```\n    props: ['title', 'author']\n    ```\n\n* 当然我们可以设置prop的值的类型。此时的prop是一个对象的形式。\n\n  * ```\n    props: {\n      title: String,\n      likes: Number,\n    }\n    ```\n\n  * 对于设置了类型，但是类型对不上的，会报错，但是还是会正常显示，并不会进行类型转换。\n\n* 后面还会将一个写法，props里面的prop也是一个对象，我们后续再进行一个讲解。\n\n  * ```\n    props: {\n    \tpropA: {\n    \t\ttype: String,\n    \t\tdefault: '111',\n    \t\trequired: true\n    \t}\n    }\n    ```\n\n\n\n## 传递静态或动态Prop\n\n​\t\t简单来说，prop的传递是通过在使用组件时，添加上了attribute属性在DOM树上，然后再进行的传递，所以这个是可以使用 v-bind 进行绑定的。\n\n​\t\t当然通过这里我也学会一个小case，就是在这样使用的时候，会把42作为一个数字传递过去，而不是字符串，对于布尔值也是一样，如果要传递一个字符串，需要再使用 '' 进行划分。\n\n```\n<blog-post :likes=\"42\"></blog-post>\n42， false， [12, 41]， {}\n```\n\n​\t\t对于要传入一个对象的所有property，我们可以使用 v-bind，进行直接传入。\n\n```\n<blog-post v-bind=\"post\"></blog-post>\n\n就等于将 post 里面的对象进行传递\n\n<blog-post\n  v-bind:id=\"post.id\"\n  v-bind:title=\"post.title\"\n></blog-post>\n```\n\n​\t\t当然这里的优先级来说，首先对于子组件没有的prop，是不会进行赋值的，其次对于对象里面存在，同时在外面也进行过一个操作的。比如下面这个情况，是以单独的为重点。\n\n```\n<blog-post :post-title=\"a\" v-bind=\"post\"></blog-post>\n\npost: {\n  id: 1,\n  'post-title': 'xxxx',\n}\n```\n\n​\t\t其次，就是对于对象里面的属性，在子组件的props里没有，但是确实这个标签的属性的，会被挂载为一个属性。\n\n​\t\t比如：下面这个title就是子组件不存在的，但是属于标签上的属性，我们就可以看到DOM解构上就存在了，同时，我们也发现，id属性应该也是DOM树上的，但是却没有，应该是对于props里面存在的属性会被拦截，只有不在的才会跳出拦截。\n\n```\npost: {\n  id: 1,\n  title: 'xxxx',\n}\n```\n\n\n\n## 单向数据流\n\n​\t\t简单来说，对于这个父子组件的值的传递，所以为了保证子组件意外变更父级组件的状态，我们让子组件不能进行更新，更新会报出警告。并且不能进行更改。\n\n​\t\t然而记住，这个只是对栈进行了一个锁定，并没有对堆进行锁定，所以简单来说就是值类型是会被警告，但是对于引用类型来说，还是可以直接进行修改，并不会爆出警告。\n\n​\t\t这是一个需要记住的问题。\n\n\n\n​\t\t对于会进行修改数据，但是又不想污染了父组件的data的，我们这里，有两个方式\n\n* 第一种就是使用了data将props的值重新进行赋值了 **这个子组件接下来希望将其作为一个本地的 prop 数据来使用** 。\n  * ```\n    props: ['initialCounter'],\n    data: function () {\n      return {\n        counter: this.initialCounter\n      }\n    }\n    ```\n\n* 第二种就是使用计算属性，简单来说就是并没有修改原数据，仅仅只是使用了原数据。常用于 **以一种原始的值传入且需要进行转换** 。\n\n\n\n## Prop 验证\n\n​\t\t验证类型是否满足需求，以及是否是必填项。\n\n### 类型检查\n\n* 类型的限制\n\n```\nprops: {\n\tA: Number,\n\tB: [Number, String],\n\tC: {\n\t\ttype: String,\n\t}\n}\n```\n\n* 是否为必填项和默认值\n\n```\nprops: {\n\tA: {\n\t\trequired: true,\n\t\tdefault: 'AA',\n\t}\n}\n```\n\n**注意：**\n\n对象和数组的默认值必须从一个工厂函数获取。简单来说就是需要是一个函数，函数返回一个对象或者数组。\n\n```\ndefault: () => {\n\treturn {\n\t\ta: 1\n\t};\n}\n```\n\n\n\n* 自定义一个验证函数\n\n```\nA: {\n\tvalidator: function(value) {\n\t\t//返回值是 true 和 false\n\t\treturn true;\n\t}\n}\n```\n\n\n\n> ​\t\t注意那些 prop 会在一个组件实例创建**之前**进行验证，所以实例的 property (如 `data`、`computed` 等) 在 `default` 或 `validator` 函数中是不可用的。\n\n\n\n## 非 Prop 的 Attribute\n\n​\t\t一个非 prop 的 attribute 是指传向一个组件，但是该组件并没有相应 prop 定义的 attribute。\n\n​\t\t这个在前面也有说过，因为prop的传递是在标签上进行的传递，那么怎么区别这个属性是prop的值还是我是要给标签上的值呢。这里就是非Prop的属性\n\n​\t\t简单来理解，就是对于声明的属性，但是却没有prop属性进行接收，那么就会被添加到组件的根元素上。\n\n\n\n### 替换/合并已有的 Attribute\n\n​\t\t简单来说就是我在组件的根元素上已经存在了这个属性，但是我在外面使用的使用对这个属性进行了重新的赋值，但是我的需求不是进行覆盖，而是进行合并，此时就是这个 替换/合并 属性\n\n​\t\t但是这里从官网上看出，并没有什么方法，但是对于 class 和 style 这两个属性，我们会进行合并操作，但是对于其他属性，比如 type 等，我们就会出现替换掉的操作。\n\n```\n子组件，c-c\ndiv.A[type='AA']\n\n父组件的使用\nc-c.B[type='BB']\n```\n\n\n\n### 禁用 Attribute 继承\n\n​\t\t简单来说就是因为在使用这个组件时，一些没有被prop的属性会被加入根标签，但是有的时候是不想这样的，所以我们可以使用 inheritAttrs: false，代表了继承属性为false。\n\n```\nVue.component('my-component', {\n\t//这个属性，为false，代表了多余的属性不会被记录在dom树上。（多余是指没有在props定义的），默认为true。\n  inheritAttrs: false,\n  // ...\n})\n```\n\n​\t\t当然对于需要被继承的属性，我们可以使用 $attrs 进行获取。这个属性包含了一个属性名和一个属性值。\n\n​\t\t通过 inheritAttrs 和 $attrs 这两个属性，就可以自己决定属性应该被赋予哪个元素。通常用于编写基础组件。\n\n​\t\t下面这个例子，首先，使用了 inheritAttrs 进行了拦截。对于props不存在的属性将不会出现在根元素上。然后再对input标签上添加了一个 v-bind=\"$attrs\" 因为$attrs 属性是一个键值对。然后将其赋值给了input标签上。\n\n```\nVue.component('base-input', {\n  inheritAttrs: false,\n  props: ['label', 'value'],\n  template: `\n    <label>\n      {{ label }}\n      <input\n        v-bind=\"$attrs\"\n        v-bind:value=\"value\"\n        v-on:input=\"$emit('input', $event.target.value)\"\n      >\n    </label>\n  `\n})\n\n<base-input\n  label=\"Username:\"\n  v-model=\"username\"\n  required\n  placeholder=\"Enter your username\"\n></base-input>\n```\n\n```\n$attrs 的值。\n{\n\trequired: \"\"\n\tplaceholder: \"Enter your username\"\n}\n```\n\n> 注意 `inheritAttrs: false` 选项**不会**影响 `style` 和 `class` 的绑定。\n\n​\t\t通过这个方式来进行操作的话，不用担心哪个是真正的根元素。\n\n\n\n# 自定义事件\n\n## 事件名\n\n​\t\t首先要注意一个地方，那就是，对于 vue 的 v-on 监听来说，（语法糖是@）。这个是不会将短横线转为驼峰的。\n\n​\t\t我们从前面可以知道，对于 props 来说，传递的属性如果是短横线，那么在props里面可以使用驼峰来进行处理，但是对于事件来说不行。\n\n​\t\t这里就会好奇为什么prop可以短横线转驼峰，但是事件不能呢。有的说是JavaScript的命名规范里面不能使用短横线命名。\n\n```\nthis.$emit('myEvent')\n<!-- 没有效果 -->\n因为 短横线不能转换为驼峰。所以没有效果。\n<my-component v-on:my-event=\"doSomething\"></my-component>\n```\n\n​\t\t所以对于 @myEvent 将会被转化为 @myevent。\n\n​\t\t所以最好的建议就是全部都是用 kebab-case。这里不但有HTML大小写不敏感的原因，还有对于模板字符串来说。大小写是规定的。\n\n\n\n## 自定义组件的v-model 2.2.0+\n\n​\t\tv-model 这个默认是利用名为 value 的prop 和 input 的事件。当然对于input的单选框和其他的会将value属性用于不同的prop。但是我们可以使用 model 选项来解决 v-model的冲突。\n\n​\t\t简单的理解一下下面的内容，prop：checked，这个默认是value，代表了使用props的checked作为v-model的绑定。event：change，默认是input，代表监听的事件名称是change，这些都是可以进行修改的。\n\n```\nVue.component('base-checkbox', {\n  model: {\n    prop: 'checked',\n    event: 'change'\n  },\n  props: {\n    checked: Boolean\n  },\n  template: `\n    <input\n      type=\"checkbox\"\n      v-bind:checked=\"checked\"\n      v-on:change=\"$emit('change', $event.target.checked)\"\n    >\n  `\n})\n```\n\n​\t\t比如我这里进行一个修改。就是将 prop 的checked改成了XXX，于是相对应的。props的名字也要有一个XXX的存在。同理。我可以将event改成一个AAA，那么就会将emit提交的事件名称修改为AAA。\n\n```\nmodel: {\n  prop: 'XXX',\n  event: 'AA'\n},\nprops: {\n  XXX: String\n},\ntemplate: `\n  <input\n  :value=\"XXX\"\n  @change=\"$emit('AA', $event.target.value)\"\n  >\n`\n```\n\n> 注意你仍然需要在组件的 props 选项里声明 checked 这个 prop。\n\n\n\n## 将原生事件绑定到组件\n\n​\t\t简单来说就是我想对一个标签进行监听，比如input监听，方法在本身，但是组件的input标签是在子组件的。那么此时我们就可以发现。子组件的输入并不会调用这个方法。\n\n```\n<base-input @input=\"onInput\"></base-input>\n```\n\n​\t\t我们可以先做一个原生的示例。通过下面这个示例我们可以发现。在输入input的时候会输出1，2 。因为这个是冒泡的原因。所以先进行的子组件的执行，再进行的父组件的执行。\n\n```\n<div oninput=\"console.log(2);\">\n  <input oninput=\"console.log(1);\"/>\n</div>\n```\n\n​\t\t那么我们做一个vue组件的示例。并且我们也可以发现。此时就不会执行 myInput 方法了。只会执行组件内部的input的方法。不会执行外部的。原因的话。我们可以知道对于没有props接收的属性一般会被加入根元素，但是我们可以发现对于 监听属性来说，并没有加入到根元素。\n\n```\n<div id=\"app\">\n  <base-input @input=\"myInput\"></base-input>\n</div>\n\nVue.component('base-input', {\n  template: `<input @input=\"CInput\">`,\n  methods: {\n    CInput() {\n      console.log('c');\n    }\n  }\n})\n```\n\n​\t\t具体的原因还不清楚。但是要记住就是直接使用监听是不会被监听成功的。有可能是监听要通过JavaScript进行操作，但是组件的元素会被替换，所以监听会失效。\n\n​\t\t因此我们可以使用 .native 修饰符 那么此时就可以将监听放入根元素了。当然，这个的效果简单来说就是会将事件绑定给根元素。但是如果本来根元素不支持这个事件，那么就会静默失败，比如 div的根元素绑定一个focus，就会失败。\n\n```\n<base-input @input.native=\"myInput\"></base-input>\n```\n\n\n\n​\t\t此时，对于根元素并不是我想要绑定的元素，这个时候，我们知道，对于props，有一个叫做。$attrs，和 inheritAttrs 进行搭配，可以使父组件传递的props在子组件能够有一个自己规定的位置出现。那么同时事件也有一个 $listeners 属性，他是一个对象，里面包含了作用在这个组件上的监听器。\n\n```\n<div><input v-on=\"$listeners\" @input=\"CInput\"></div>\n```\n\n​\t\t但是注意，如果使用了 .native 那么将不会出现在 $listeners 里面。不管 .native 是否会绑定成功。\n\n​\t\t下面这个是使用computed，这里记住一个问题，那就是 下面这个写法是会将 input 的监听进行覆盖的一个操作。但是又通过了 $emit 向上通知了父组件的 input。同理 使用 this.$listeners['input'] 也会覆盖input。\n\n```\ncomputed: {\n  inputListeners: function () {\n    var vm = this\n    // `Object.assign` 将所有的对象合并为一个新对象\n    return Object.assign({},\n      // 我们从父级添加所有的监听器\n      this.$listeners,\n      // 然后我们添加自定义监听器，\n      // 或覆写一些监听器的行为\n      {\n        // 这里确保组件配合 `v-model` 的工作\n        input: function (event) {\n        \tvm.$emit('input', event.target.value)\n        }\n      }\n    )\n  }\n},\n```\n\n\n\n## .sync修饰符 2.3.0+\n\n​\t\t因为双向绑定会带来维护上的问题。因为对于data的变更不清楚来源。\n\n​\t\t所以我们推荐 update:myPropName 来代替。在一个包含 title 的假设的组件。\n\n```\nthis.$emit('update:title', newTitle)\n```\n\n​\t\t因此就引出了sync修饰符，这算是一个语法糖。\n\n* 对于父组件来说，变化就是将 :title 和 :update:title 进行了合并，简单来说就像是进行了 v-model 的操作一样。\n\n  * ```\n    <base-input\n      v-bind:title=\"a\"\n      v-on:update:title=\"a\"\n    ></base-input>\n    \n    <base-input :title.sync=\"a\"></base-input>\n    ```\n\n* 对于子组件来说，没有什么变化， 这里的 :title.sync 就是 @update:title 加上了 :title，所以对于 $emit 也是使用原来的 update:title 进行的提交。\n\n  * ```\n    this.$emit('update:title', Math.random());\n    ```\n\n\n\n在这里，还有一个问题就是。我们可以发现对于 emit提交时带的参数，父组件如果要将方法写在那个标签上进行表达式的执行，那么 $event 就是第一个参数。\n\n```\nthis.$emit('update:title', 1);\n\n//这里的 $event 就是 子元素在 $emit 提交时的第二个参数，从第二个参数开始的提交就是会传递给父元素的参数。这里只是第二个，如果没有参数的话，就会为undefined\n<base-input @update:title=\"a = $event\"></base-input>\n```\n\n\n\n> 注意带有 `.sync` 修饰符的 `v-bind` **不能**和表达式一起使用 (例如 `v-bind:title.sync=”doc.title + ‘!’”` 是无效的)。取而代之的是，你只能提供你想要绑定的 property 名，类似 `v-model`。\n\n\n\n​\t\t当然，这里的 sync修饰符 也可以和 v-bind 进行搭配\n\n```\n<text-document v-bind.sync=\"doc\"></text-document>\n\nthis.$emit('update:title', 1111);\n```\n\n\n\n> 将 `v-bind.sync` 用在一个字面量的对象上，例如 `v-bind.sync=”{ title: doc.title }”`，是无法正常工作的，因为在解析一个像这样的复杂表达式的时候，有很多边缘情况需要考虑。\n\n\n\n# 插槽\n\n​\t\t简单来说就是，因为Vue的组件化思路，所以很多都是以组件进行的开发。但是为了降低组件和组件的解耦性，就可以使用插槽，将组件之间的联系进一步的降低。\n\n​\t\t在 2.6.0中，提供了新的语法 v-slot 来代替了 slot 和 slot-scope\n\n## 插槽内容\n\n​\t\t\n\n**一个简单的示例**\n\n​\t\t下面的示例就代表了 Your Profile 将会代替 slot这个标签进行显示。当然 插槽的内部可以包含任何模板代码，包括HTML和其他组件，这也是我们常会使用的方法。\n\n```\n<navigation-link url=\"/profile\">\n  Your Profile\n</navigation-link>\n\n\n<a>\n  <slot></slot>\n</a>\n```\n\n\n\n## 编译作用域\n\n​\t\t简单来说，看下面这个代码，这个 a 应该是 父级组件上的 a呢，还是子组件上的a呢。\n\n​\t\t最终的结果就是这个是 父级组件上的a。\n\n```\n<div>\n\t<base-input>{{ a }}</base-input>\n</div>\n```\n\n这里有条规则\n\n> 父级模板里的所有内容都是在父级作用域中编译的；子模板里的所有内容都是在子作用域中编译的。\n\n\n\n## 后背内容\n\n​\t\t简单来说就是一个插槽的默认值。简单来说就是写在 slot 里面的内容就是 插槽的默认值。\n\n​\t\t如果你在使用组件的时候没有使用插槽，那么就会使用这个默认的内容，并且这个默认的内容的作用域是在子组件的。\n\n​\t\t如果提供有内容，那么便会渲染来取代内容。\n\n```\n<div><slot>{{ x }}</slot></div>\n```\n\n\n\n## 具名插槽\n\n​\t\t简单来说就是使用name将插槽能够指定的使用在某个位置。对于没有使用name的，会有一个默认的name default。 \n\n```\n<slot name=\"header\"></slot>\n```\n\n​\t\t那么在使用这个具名插槽的时候，我们就可以使用一个 template 进行包裹，然后在里面使用 v-slot指令，并以 v-slot 的参数的形式提供名称。\n\n​\t\t从下面的代码可以看出，对于使用了 template加上v-slot的，就是寻找name相对应的。对于没有使用的就会被作为一个默认，就算中间隔了一个template v-slot 也一样。\n\n```\n<base-layout>\n  <template v-slot:header>\n    <h1>Here might be a page title</h1>\n  </template>\n\n  <p>A paragraph for the main content.</p>\n  <p>And another one.</p>\n\n  <template v-slot:footer>\n    <p>Here's some contact info</p>\n  </template>\n</base-layout>\n```\n\n​\t\t当然，为了语义的方便，我们建议还是可以将默认的放入一个 template v-slot:default，当然，这个default不要也可以，但是如果加了default，那么就不会将其他外层标签也加入默认，但是如果没有加上default的话，那么就会加入默认。\n\n​\t\t比如：\n\n```\n<template v-slot:default>\n  <p>A paragraph for the main content.</p>\n  <p>And another one.</p>\n</template>\n//下面这个不会显示。\n<p>And another one.</p>\n```\n\n```\n<template>\n  <p>A paragraph for the main content.</p>\n  <p>And another one.</p>\n</template>\n//上面的template没有使用default，下面这个会显示出来，因为都被算在了插槽里面\n<p>And another one.</p>\n```\n\n\n\n## 作用域插槽\n\n​\t\t2.6.0 废弃了 slot-scope\n\n​\t\t因为我们可以知道，插槽的默认的作用域是编译时的环境，所以一般常常是父级作用域，那么此时我们要如何将作用域作用域子级。\n\n​\t\t这个时候就是要使用作用域插槽的时候了。\n\n* 简单来说就是子组件在进行slot创建时，通过 v-bind 绑定一个属性，然后属性的值是data的值。\n* 然后在使用的时候，通过 v-slot:xx=\"xxx\" 进行了属性的获取，这里 xxx就是子组件传递过来的一系列的属性而形成的对象。\n* 此时我们就可以在父组件里面使用到子组件的data了，当然，建议这个还是少使用吧，因为这个造成了组件的透明度降低。\n\n```\n<slot :x=\"x1\"></slot>\n\n<template v-slot:default=\"a\">\na.x\n</template>\n```\n\n\n\n### 独占默认插槽的缩写语法\n\n​\t\t就是说，只有被提供的内容只存在默认插槽的存在时，组件的标签才可以被当作插槽的模板来使用。此时我们就可以直接把 v-slot 用在组件上。\n\n​\t\t这里我们首先知道 v-slot 可以使用在组件上，并且插槽是可以接收一个组件的。但是我们后面可以发现，如果直接使用组件，会出现插槽的位置无法正确的定位。\n\n​\t\t然后我么可以发现，其实对组件是不能进行插槽的定位的。意思就是说，对于组件来说，使用插槽的 v-slot 不能定位到对应的具名插槽。\n\n​\t\t比如下面这个情况，我开始以为 v-slot:footer 和 v-slot:header，都会按照正确的位置进行拜访，因为这个就是具名插槽的作用，只能用于template，对于下面这个test组件，虽然我们也使用了 v-slot:header 但是他并没有去header，而是就为普通的标签的行为。v-slot不会在除了template上起作用。\n\n```\n<base-input>\n  <template v-slot:footer>\n  \t<ttt></ttt>\n  </template>\n\n  <p>123</p>\n  <p>111</p>\n\n  <test v-slot:header></test>\n</base-input>\n```\n\n\n\n```\n<current-user v-slot:default=\"slotProps\">\n  {{ slotProps.user.firstName }}\n</current-user>\n```\n\n​\t\t缩写语法\n\n```\n<current-user v-slot=\"slotProps\">\n  {{ slotProps.user.firstName }}\n</current-user>\n```\n\n​\t\t案例形式。简单来说就是，如果base-input内部只有一个默认插槽，那么我们可以将这个 base-input 内部的整体都作为一个 slot的代替，如果是以前， base-input>template[v-slot=\"slotProps\"] 但是我们可以将template进行省略，所以变成了 base-input[v-slot=\"slotProps\"]\n\n​\t\t当然，上面这个也是进行了缩写了的。完整的话，需要加上 v-slot:default。\n\n```\n<base-input v-slot=\"slotProps\">\n</base-input>\n```\n\n\n\n### 解构插槽Prop\n\n​\t\t简单来说就是说，作用域插槽的内部原理就是将插槽的内容包裹在一个参数的函数内部。\n\n```\nfunction (slotProps) {\n  // 插槽内容\n}\n```\n\n​\t\t在下面这个标签的使用里。使用了解构赋值的形式， { user } = slotProps，在这里，解构赋值的效果就是，取出了 slotProps的user给了 user。当然我们也可以使用其他的解构赋值的行为。\n\n```\n<current-user v-slot=\"{ user }\">\n  {{ user.firstName }}\n</current-user>\n```\n\n\n\n## 动态插槽名\n\n​\t\t2.6.0 新增\n\n```\n<template v-slot:[dynamicSlotName]>\n  ...\n</template\t>\n```\n\n\n\n## 具名插槽的缩写\n\n​\t\t2.6.0 新增\n\n​\t\t简单来说，就是插槽的语法糖，v-slot => #，但是对于没有参数的话是无效的。\n\n```\n<current #header=\"{ user }\"></current>\n//下面这个是无效的。\n<current #=\"{ user }\"></current>\n```\n\n\n\n# 动态组件&异步组件\n\n## 在动态组件上使用 keep-alive\n\n​\t\t之前，我们使用 is 属性来对组件进行切换。\n\n```\n<component v-bind:is=\"currentTabComponent\"></component>\n```\n\n​\t\t现在，我们在组件进行切换的时候，想要保存组件的状态。以避免重复的渲染。\n\n```\n<!-- 失活的组件将会被缓存！-->\n<keep-alive>\n  <component v-bind:is=\"currentTabComponent\"></component>\n</keep-alive>\n```\n\n\n\n## 异步组件\n\n​\t\t将应用分割成小一些的代码块，并且只在需要的时候才从服务器进行加载。对此Vue允许使用一个工厂函数的方式进行定义组件。Vue只有在这个组件需要被渲染，并把结果缓存起来供未来重渲染。\n\n​\t\t下面这个简单的例子，表示了第二个参数是一个函数，函数需要使用resolve和reject，表示会以promise进行调用，通过resolve返回渲染对象，荣国reject表示加载失败。\n\n```\nVue.component('async-example', function (resolve, reject) {\n  setTimeout(function () {\n    // 向 `resolve` 回调传递组件定义\n    resolve({\n      template: '<div>I am async!</div>'\n    })\n  }, 1000)\n})\n```\n\n​\t\t一个推荐的做法是将异步组件和 [webpack 的 code-splitting 功能](https://webpack.js.org/guides/code-splitting/)一起配合使用\n\n```\nVue.component('async-webpack-example', function (resolve) {\n  // 这个特殊的 `require` 语法将会告诉 webpack\n  // 自动将你的构建代码切割成多个包，这些包\n  // 会通过 Ajax 请求加载\n  require(['./my-async-component'], resolve)\n})\n```\n\n​\t\t但是因为我这个异步组件和搭配webpack这个用的比较少，所以在这里就没有进行详细的讲述，就直接贴上Vue的官网链接了。\n\n```\nhttps://cn.vuejs.org/v2/guide/components-dynamic-async.html#异步组件\n```\n\n\n\n### 处理加载状态\n\n​\t\t2.3.0 新增\n\n```\nconst AsyncComponent = () => ({\n  // 需要加载的组件 (应该是一个 `Promise` 对象)\n  component: import('./MyComponent.vue'),\n  // 异步组件加载时使用的组件\n  loading: LoadingComponent,\n  // 加载失败时使用的组件\n  error: ErrorComponent,\n  // 展示加载时组件的延时时间。默认值是 200 (毫秒)\n  delay: 200,\n  // 如果提供了超时时间且组件加载也超时了，\n  // 则使用加载失败时使用的组件。默认值是：`Infinity`\n  timeout: 3000\n})\n```\n\n\n\n> 注意如果你希望在 [Vue Router](https://github.com/vuejs/vue-router) 的路由组件中使用上述语法的话，你必须使用 Vue Router 2.4.0+ 版本。\n\n\n\n# 处理边界情况\n\n\n\n## 访问元素 & 组件\n\n\n\n### 访问根实例 this.$root\n\n​\t\t这个可以通过 `this.$root`，进行访问。如果是methods里面的方法aa，那么就可以通过 `this.$root.aa` 进行访问。\n\n​\t\t所有的子组件都可以将这个实例作为一个全局 store 来访问或者使用。\n\n> 对于 demo 或非常小型的有少量组件的应用来说这是很方便的。不过这个模式扩展到中大型应用来说就不然了。因此在绝大多数情况下，我们强烈推荐使用 [Vuex](https://github.com/vuejs/vuex) 来管理应用的状态。\n\n\n\n### 访问父级组件实例\n​\t\t可以通过 $parent 属性来访问一个父组件的实例。\n​\t\t但是请注意，这样写虽然是可以直接对父组件进行了操作，可以代替props来进行数据的访问，但是却会造成数据的修改时不清楚修改的源头。\n\n### 访问子组件实例或子元素\n​\t\t可以通过 ref 属性，为子组件赋予一个ID引用。\n\n```\n<base-input ref=\"usernameInput\"></base-input>\n\n那么父组件就可以通过 this.$refs.usernameInput 来访问子组件了。\n```\n\n​\t\t但是记住，this.$refs，里面存放的只会有属于自己的子组件，以及有可能会有自己的子孙级组件。这个我们一会儿就说。\n\n​\t\tref同时也可以写在原生的HTML标签上面，for example `<input type=\"text\" ref=\"inpu\">` 如果写在了原生的HTML上面，我们通过$refs获取时也是一个原生的标签，并且也可以使用方法，比如 `focus` 等。\n\n```\n<div id=\"app\">\n    <input type=\"text\" ref=\"input\">\n</div>\n\n//在父组件的方法里面使用这个便可以调用input的原生focus进行聚焦。\nthis.$refs.inpu.focus()\n```\n\n\n\n关于父组件的 refs 是否会含有子组件，这个应该是在哪个组件被编译就会存在于哪个组件。\n\n​\t\t比如看看下面这个文件的内容。template存在一个插槽和input，然后在使用组件的时候，插槽又是插入了一个input，但是如果我们查看结果，就会发现，插槽所写的ref会存在与父组件，而在template里面所写的，便会存在于子组件。\n\n```\ntemplate: `<div><slot></slot><input type=\"text\" ref=\"input\"></div>`,\n\n<aaaa ref=\"ssss\">\n    <input type=\"text\" ref=\"inpu\">\n</aaaa>\n```\n\n​\t\t当 ref 和 v-for 一起使用的时候，ref会包含整个数组。一般来说，refs是一个对象，但是对于使用了v-for的来说，就会变成一个数组，就算是ref使用了v-bind 进行了绑定，也会变为存在不同ref的对象，内部含有数组。\n\n```\n<li :ref=\"i\" v-for=\"i in 10\"></li>\n\n1: [li]\n2: [li]\n3: [li]\n4: [li]\n\n形成的还是数组，虽然数组的长度只有1。\n```\n\n\n\n### 依赖注入\n\n​\t\t简单来说，就是父子组件可以通过 $parent 来进行访问，但是对于嵌套的情况，会造成 $parent.$parent 那么此时就是依赖注入的时候。\n\n​\t\t这里用到了两个新的实例的选项。 provide & inject\n\n**provide** 选项允许我们指定我们想要提供给后代组件的数据/方法。\n\n```\nprovide: function() {\n\treturn {\n\t\tget: this.get\n\t}\n}\n```\n\n**inject** 在任何后代组件里，我们都可以使用 inject 选项来接收指定的属性进行注入。\n\n**例子**：\n\n```\nfather\n\tchildren\n\t\tgrandson\n\n那么此时 grandson要使用 father组件的方法就需要 this.$parent.$parent 来进行调用，但是对于有多层的调用会出现意想不到的问题。\n```\n\n​\t\t使用 provide 和 inject 进行处理，需要记住，这个的调用创建应该是先于data，所以如果当data和inject进行了重合，那么便会出现data覆盖了inject，但是他们都是属于 init injected & reacted 周期。在使用 beforeCreate 之后， 以及 created 之前。\n\n```\n先使用 provide 进行提供需要给后代的方法和数据。\nconst app = new Vue({\n\tprovide() {\n\t\treturn {\n\t\t\tname: this.output,\n\t\t}\n\t}\n})\n\n然后在后代使用 inject 进行注入，注入之后就可以使用 this.name进行使用。\nVue.component('xx', {\n\tinject: ['name'],\n})\n```\n\n\n\n## 程序化的事件侦听器\n\n通过 $on(eventName, eventHandler) 来侦听一个事件。\n\n通过 $once(eventName, eventHandler) 来一次性的侦听一个事件。\n\n通过 $off(eventName, eventHandler)  来停止侦听一个事件。\n\n一般来说是很少进行使用的，但是当你需要在一个组件的实例上手动的侦听事件时，它们便派上了用场。\n\n```\nmounted() {\n\tthis.pi = new Pi({});\n},\nbeforeDestroy() {\n\tthis.pi.destroy();\n}\n```\n\n如果使用程序化的侦听器来解决这个问题：\n\n```\nmounted() {\n\tconst pi = new Pi({});\n\tthis.$once('hook:beforeDestroy', function() {\n\t\tpi.destroy();\n\t})\n},\n```\n\n**注意**：\n\n> ​\t\tVue 的事件系统不同于浏览器的 [EventTarget API](https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget)。尽管它们工作起来是相似的，但是 `$emit`、`$on`, 和 `$off` 并不是 `dispatchEvent`、`addEventListener` 和 `removeEventListener` 的别名。\n\n\n\n## 循环引用\n\n### 递归组件\n\n​\t\t组件是可以在他们自己的模板中调用自身的，但是只能通过name选项来做这件事。\n\n```\nname: 'stack',\ntempalte: `<div><stack></stack></div>`,\n```\n\n​\t\t简单来说就是可以进行递归的循环，所以需要注意，并且发现对于全局注册组件，也可以使用组件名称进行递归组件。\n\n\n\n### 组件之间的循环引用\n\n​\t\t对于组件之间的相互调用，组件在渲染树中互相为对方的后代和祖先。当通过 Vue.component 全局注册组件的时候，这个悖论将会被解开。\n\n```\ntree-father\n\ttree-other\n\t\ntree-other\n\ttree-father\n```\n\n​\t\t然而，如果你使用一个模块系统依赖/导入组件，则会遇到一个错误。\n\n​\t\t所以此时的解决办法就是：\n\n* 将注册事件放入 beforeCreate 进行注册。\n\n  * ```\n    beforeCreate() {\n    \tthis.$options.components.ComponentA = require('./component-a.vue');\n    }\n    ```\n\n* 或者，在本地进行注册组件的时候，可以使用 webpack 异步 import\n\n  * ```\n    components: {\n    \tComponentA: () => import('./component-a.vue');\n    }\n    ```\n\n\n\n## 模板定义的代替品\n\n### 内联模板\n\n​\t\t简单来说就是，组件内部的内容将会作为模板，而不是将其视为分布式内容(或者插槽？)。\n\n```\n<my-component inline-template>\n    <div>\n        <p>These are compiled as the component's own template.</p>\n        <p>Not parent's transclusion content.</p>\n    </div>\n</my-component>\n\nVue.component('my-component', {\n})\n```\n\n**注意点**：\n\n* 使用的模板名需要是存在的\n* 如果要使用内联模板，那么对于全局注册的组件时需要的信息可以不需要，比如(template，data，methods等)。\n* 个人感觉这个和 template 的效果很相似。但是注意，使用内联模板也是可以使用data和methods的。所以这个的作用应该是很像 .vue 文件的使用。\n\n\n\n### X-Template\n\n​\t\t使用 script 脚本，并且将type设置为 text/x-template，然后通过使用 id 来引用模板。\n\n```\n<script type=\"text/x-template\" id=\"hello-world-template\">\n  <p>Hello hello hello</p>\n</script>\n\nVue.component('hello-world', {\n  template: '#hello-world-template'\n})\n```\n\n​\t\t这些替代模板都是将 模板内部的标签 和 数据 以及操作等进行了分割。\n\n\n\n## 控制更新\n\n### 强制更新\n\n​\t\t使用 $forceUpdate\n\n```\ndata() {\n\treturn {\n\t\tx: [1, 3],\n\t}\n}\n\nthis.x[1] = 10;\n//此时，虽然数据发生了改变，但是因为vue2的数据响应式无法对数组的直接操作进行通知，所以不会发生更新，那么此时就需要使用 this.$forceUpdate(); 来进行强制更新了。\nthis.$forceUpdate();\n```\n\n\n\n### 使用 v-once 的廉价静态组件\n\n​\t\tVue 渲染纯HTML非常快，但是有时你的组件包含了大量的静态内容。在这些情况下，可以确保只被评估一次。\n\n```\nVue.component('terms-of-service', {\n  template: `\n    <div v-once>\n      <h1>Terms of Service</h1>\n      ... a lot of static content ...\n    </div>\n  `\n})\n```\n\n**注意**：\n\n尽量不要过度的使用这种模式。除非真的渲染缓慢。\n\n","slug":"Vue/Vue2教程/Vue2-教程-深入了解组件","published":1,"updated":"2021-12-03T02:38:06.179Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckznhkk8t007tikub5qwi8q23","content":"<h1 id=\"组件注册\"><a href=\"#组件注册\" class=\"headerlink\" title=\"组件注册\"></a>组件注册</h1><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://cn.vuejs.org/v2/guide/components-registration.html</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"组件名\"><a href=\"#组件名\" class=\"headerlink\" title=\"组件名\"></a>组件名</h2><h3 id=\"组件名大小写\"><a href=\"#组件名大小写\" class=\"headerlink\" title=\"组件名大小写\"></a>组件名大小写</h3><p>​        对于大小写的组件名，在使用的时候大写会变成 -+小写的形式。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">myComPonent</span><br><span class=\"line\"></span><br><span class=\"line\">my-com-ponent</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"全局注册\"><a href=\"#全局注册\" class=\"headerlink\" title=\"全局注册\"></a>全局注册</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Vue.component(&#x27;component-a&#x27;, &#123; /* ... */ &#125;)</span><br></pre></td></tr></table></figure>\n\n<p>​        这样创建就是全局注册的，只要注册了之后，后面的Vue实例都可以直接使用。</p>\n<h2 id=\"局部注册\"><a href=\"#局部注册\" class=\"headerlink\" title=\"局部注册\"></a>局部注册</h2><p>​        全局注册会不可避免的增加性能的消耗，浪费了很多时间。所以可以使用局部注册的方式进行注册，将组件注册在实例的内部，因此在实例被销毁时也会被销毁。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const ComponentA = &#123; /* ... */ &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">new Vue(&#123;</span><br><span class=\"line\">  el: &#x27;#app&#x27;,</span><br><span class=\"line\">  components: &#123;</span><br><span class=\"line\">    &#x27;component-a&#x27;: ComponentA,</span><br><span class=\"line\">    &#x27;component-b&#x27;: ComponentB</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>​        简单来说就是 ComponentsA 里面的对象就是 new一个Vue实例的对象。然后再在components里面进行new的创建，所以将作用域限制到了一定的范围。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const C = &#123;</span><br><span class=\"line\">  template: `&lt;div&gt;22&lt;/div&gt;`,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">const ComponentA = &#123;</span><br><span class=\"line\">  el: &#x27;#ap&#x27;,</span><br><span class=\"line\">  //这里是局部组件创建再加上了一个组件的创建，否则一个父组件，两个局部组件内部是不能相互调用的。</span><br><span class=\"line\">  components: &#123;</span><br><span class=\"line\">    &#x27;com&#x27;: C,</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const app = new Vue(&#123;</span><br><span class=\"line\">  el: &#x27;#app&#x27;,</span><br><span class=\"line\">  data: &#123;</span><br><span class=\"line\">    a: 1</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  components: &#123;</span><br><span class=\"line\">    &#x27;comA&#x27;: ComponentA,</span><br><span class=\"line\">    &#x27;com&#x27;: C,</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"模块系统\"><a href=\"#模块系统\" class=\"headerlink\" title=\"模块系统\"></a>模块系统</h2><p>​        简单来说就是可以使用 import / require 来使用一个模块系统。</p>\n<h3 id=\"在模块系统中局部注册\"><a href=\"#在模块系统中局部注册\" class=\"headerlink\" title=\"在模块系统中局部注册\"></a>在模块系统中局部注册</h3><p>​        简单来说，下面这个是取出了一个对象。这个是一个ES6的模块化导出的默认导出的写法。</p>\n<p>​        所以简单来说就是将对象进行导出。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import ComponentA from &#x27;./Component&#x27;;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export default &#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>​        我们先理清一下思路</p>\n<ul>\n<li>首先，Vue的components里面使用的是一个对象，这个对象是那个实例对象。其次对于这个命名的思路是因为是es6的对象赋值的方式</li>\n<li>然后就是导入 import 和 export default 这里导入和导出对象。</li>\n<li>所以其实还是有思路的。</li>\n</ul>\n<h3 id=\"基础组件的自动化全局注册\"><a href=\"#基础组件的自动化全局注册\" class=\"headerlink\" title=\"基础组件的自动化全局注册\"></a>基础组件的自动化全局注册</h3><p>​        require.context 可以全局注册组件。但是需要使用webpack或者使用了VueCLI3+（因为内部使用了webpack）</p>\n<p>​        <strong>什么是 require.context ：</strong></p>\n<ul>\n<li>首先，是一个webpack的api。</li>\n<li>其次，这个api用于实现自动化导入模块。就是对于一个文件引入很多模块的情况，可以使用这个api，会遍历指定的文件，然后进行自动导入，不需要每次显式的调用import导入模块。</li>\n<li>进行一个更细粒度的模块引入。</li>\n</ul>\n<p>​        <strong>一个使用时机</strong>：</p>\n<ul>\n<li>首先就是需要引入很多模块</li>\n<li>其次就是这个模块的处于同一父文件位置，所以对于基础组件来说是非常合适的。</li>\n</ul>\n<p>​        require.context 的参数：</p>\n<ul>\n<li><p>directory，String类型</p>\n<ul>\n<li>文件目录位置，</li>\n</ul>\n</li>\n<li><p>includeSubdirs，Boolean类型</p>\n<ul>\n<li>表示是否包含文件的子目录，可选参数，默认是 true</li>\n</ul>\n</li>\n<li><p>filter，RegExp正则表达式类型</p>\n<ul>\n<li>表示过滤某些文件。可选参数，默认是 <code>/^\\.\\/.*$/</code> 指的是所有文件。（这里是webpack写的，但是我没有理解这个正则）。</li>\n</ul>\n</li>\n<li><p>mode，String类型</p>\n<ul>\n<li><p>表示加载的方式， sync，eager，weak，lazy，lazy-once。默认值是sync。</p>\n</li>\n<li><p>```<br>sync<br>eager</p>\n<pre><code>不会生成额外的chunk，所有模块当成当前chunk引入。没有额外的网络请求，但是会返回一个resolved的Promise。\n</code></pre>\n<p>weak</p>\n<pre><code>这个没有看懂，大概可能是尝试加载，不可用返回一个reject的Promise。\n</code></pre>\n<p>lazy</p>\n<pre><code>为每一个导入的模块生成一个可延迟加载的chunk。简单来说就是将以异步方式加载。\n</code></pre>\n<p>lazy-once</p>\n<pre><code>生成一个可以满足所有的可延迟加载的chunk。这个chunk将第一次调用时获取，随后使用相同的网络响应。\n</code></pre>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">大概看懂了之后，我们再看一下组件的自动化全局注册</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>import Vue from ‘vue’<br>import upperFirst from ‘lodash/upperFirst’<br>import camelCase from ‘lodash/camelCase’</p>\n</li>\n</ul>\n</li>\n</ul>\n<p>const requireComponent = require.context(<br>  // 其组件目录的相对路径<br>  ‘./components’,<br>  // 是否查询其子目录<br>  false,<br>  // 匹配基础组件文件名的正则表达式<br>  /Base[A-Z]\\w+.(vue|js)$/<br>)</p>\n<p>requireComponent.keys().forEach(fileName =&gt; {<br>  // 获取组件配置<br>  const componentConfig = requireComponent(fileName)</p>\n<p>  // 获取组件的 PascalCase 命名<br>  const componentName = upperFirst(<br>    camelCase(<br>      // 获取和目录深度无关的文件名<br>      fileName<br>        .split(‘/‘)<br>        .pop()<br>        .replace(/.\\w+$/, ‘’)<br>    )<br>  )</p>\n<p>  // 全局注册组件<br>  Vue.component(<br>    componentName,<br>    // 如果这个组件选项是通过 <code>export default</code> 导出的，<br>    // 那么就会优先使用 <code>.default</code>，<br>    // 否则回退到使用模块的根。<br>    componentConfig.default || componentConfig<br>  )<br>})</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">​\t\t**其中这一部分的作用是将每个文件的模块给取了出来**</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>const requireComponent = require.context(<br>  // 其组件目录的相对路径<br>  ‘./components’,<br>  // 是否查询其子目录<br>  false,<br>  // 匹配基础组件文件名的正则表达式<br>  /Base[A-Z]\\w+.(vue|js)$/<br>)</p>\n<p>目录是 ./components<br>不查询子目录<br>匹配文件的形式，Basexxxx.(vue|js)</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">* requireComponent 通过typeof 判断是一个，function，里面存在了方法，可以使用keys方法进行获取</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t**这里是将requireComponent存储的组件给进行了注册。**</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>requireComponent.keys().forEach(fileName =&gt; {<br>  // 获取组件配置<br>  const componentConfig = requireComponent(fileName)</p>\n<p>  // 获取组件的 PascalCase 命名<br>  const componentName = upperFirst(<br>    camelCase(<br>      // 获取和目录深度无关的文件名<br>      fileName<br>        .split(‘/‘)<br>        .pop()<br>        .replace(/.\\w+$/, ‘’)<br>    )<br>  )</p>\n<p>  // 全局注册组件<br>  Vue.component(<br>    componentName,<br>    // 如果这个组件选项是通过 <code>export default</code> 导出的，<br>    // 那么就会优先使用 <code>.default</code>，<br>    // 否则回退到使用模块的根。<br>    componentConfig.default || componentConfig<br>  )<br>})</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">* keys方法获取到的是文件的相对路径。使用foreach进行循环操作。foreach内部也是和forin一个意思。forin和forof的区别在于迭代器问题。</span><br><span class=\"line\"></span><br><span class=\"line\">  * ```</span><br><span class=\"line\">    ./App.vue</span><br><span class=\"line\">    ./components/App.vue</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>然后使用 requireComponent 方法，参数为文件位置，便会获取到内容。</p>\n<ul>\n<li>使用 requireComponent(filename)，进行获取，就可以获取到内容。</li>\n</ul>\n</li>\n<li><p>当然这里的一个特点是，这个requireComponent 既是一个方法，也是一个对象，因为它既能像方法一样传递参数进行操作，也可以调用keys这个方法。</p>\n</li>\n<li><p>这里使用的 upperFirst 和 camelCase 是 lodash里面的方法，其中 upperFirst的作用是首字母大写，而camelCase是将字符串转为驼峰命名法，比如空格，-，_将会被划分。</p>\n</li>\n<li><p>在这里，首先fileName是一个文件的路径和名字，所以使用split进行划分/， 然后取出最后一个，然后将后面的文件后缀改为空，然后给camelCase变为驼峰，然后返回的字符串给了upperFirst变为了首字母大写的驼峰。赋值给了componentName。</p>\n<ul>\n<li>```<br>const componentName = upperFirst(<br>  camelCase(<pre><code>// 获取和目录深度无关的文件名\nfileName\n  .split(&#39;/&#39;)\n  .pop()\n  .replace(/\\.\\w+$/, &#39;&#39;)\n</code></pre>\n  )<br>)<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">* 然后就是注册组件了，使用了 Vue.component 方法。进行注册，Vue.component 第一个参数是名字，第二个参数是需要被Vue实例的对象。</span><br><span class=\"line\"></span><br><span class=\"line\">  * 这里的唯一的问题就是，对于如果没有使用 export default 导出的方法，貌似不会存在 default 这个对象。但是具体的我们需要在后面才会知道。</span><br><span class=\"line\"></span><br><span class=\"line\">  * ```</span><br><span class=\"line\">    Vue.component(</span><br><span class=\"line\">      componentName,</span><br><span class=\"line\">      // 如果这个组件选项是通过 `export default` 导出的，</span><br><span class=\"line\">      // 那么就会优先使用 `.default`，</span><br><span class=\"line\">      // 否则回退到使用模块的根。</span><br><span class=\"line\">      componentConfig.default || componentConfig</span><br><span class=\"line\">    )</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ul>\n<p>​        <strong>如何实现一个方法带有对象的使用。</strong></p>\n<p>​        这里我的一个想法就是修改原型链了，因为JavaScript任何都是存在原型链的，对于方法来说，也是有一个原型链的。简单来理解，方法既可以使用，又可以当作一个构造器来创建对象。</p>\n<ul>\n<li>作为一个构造器来说，方法需要记住的是prototype的指向</li>\n<li>而对于方法的执行来说，需要记住的是 __proto__ 的指向。所以这里对 __proto__ 里面创建了一个方法，然后通过调用这个方法来获取了keys，并且这个本身也是一个方法。</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function T() &#123;</span><br><span class=\"line\">  return 1;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">T.__proto__.keys = function () &#123;</span><br><span class=\"line\">  console.log(2);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"Prop\"><a href=\"#Prop\" class=\"headerlink\" title=\"Prop\"></a>Prop</h1><h2 id=\"Prop的大小写\"><a href=\"#Prop的大小写\" class=\"headerlink\" title=\"Prop的大小写\"></a>Prop的大小写</h2><p>​        简单来说就是驼峰命名法(camelCase)会在HTML上进行使用时需要转换为短横线分割命名(kebab-case)。因为HTML文档解析是大小写不敏感的，所以 postTitle 会被解析成 posttitle</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;blog-post :post-title=&quot;a&quot;&gt;&lt;/blog-post&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">Vue.component(&#x27;blog-post&#x27;, &#123;</span><br><span class=\"line\">  // 在 JavaScript 中是 camelCase 的</span><br><span class=\"line\">  props: [&#x27;postTitle&#x27;],</span><br><span class=\"line\">  template: &#x27;&lt;h3&gt;&#123;&#123; postTitle &#125;&#125;&lt;/h3&gt;&#x27;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>​        但是如果是使用的字符串模板，那么就不会有这个限制。</p>\n<p>​        意思就是说，使用template这种，模板是字符串的，应该是中间有个步骤在解析的时候会将驼峰自动转换为短横线。所以没有问题。</p>\n<h2 id=\"Prop类型\"><a href=\"#Prop类型\" class=\"headerlink\" title=\"Prop类型\"></a>Prop类型</h2><ul>\n<li><p>正常prop在使用的时候是使用的数组，加上字符串进行存储。此时的prop是一个数组的形式。</p>\n<ul>\n<li><p>```<br>props: [‘title’, ‘author’]</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">* 当然我们可以设置prop的值的类型。此时的prop是一个对象的形式。</span><br><span class=\"line\"></span><br><span class=\"line\">  * ```</span><br><span class=\"line\">    props: &#123;</span><br><span class=\"line\">      title: String,</span><br><span class=\"line\">      likes: Number,</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>对于设置了类型，但是类型对不上的，会报错，但是还是会正常显示，并不会进行类型转换。</p>\n</li>\n</ul>\n</li>\n<li><p>后面还会将一个写法，props里面的prop也是一个对象，我们后续再进行一个讲解。</p>\n<ul>\n<li>```<br>props: {<pre><code>propA: &#123;\n    type: String,\n    default: &#39;111&#39;,\n    required: true\n&#125;\n</code></pre>\n}<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">## 传递静态或动态Prop</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t简单来说，prop的传递是通过在使用组件时，添加上了attribute属性在DOM树上，然后再进行的传递，所以这个是可以使用 v-bind 进行绑定的。</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t当然通过这里我也学会一个小case，就是在这样使用的时候，会把42作为一个数字传递过去，而不是字符串，对于布尔值也是一样，如果要传递一个字符串，需要再使用 &#x27;&#x27; 进行划分。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<blog-post :likes=\"42\"></blog-post><br>42， false， [12, 41]， {}<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">​\t\t对于要传入一个对象的所有property，我们可以使用 v-bind，进行直接传入。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<blog-post v-bind=\"post\"></blog-post></li>\n</ul>\n</li>\n</ul>\n<p>就等于将 post 里面的对象进行传递</p>\n<p>&lt;blog-post<br>  v-bind:id=”post.id”<br>  v-bind:title=”post.title”</p>\n<blockquote>\n\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">​\t\t当然这里的优先级来说，首先对于子组件没有的prop，是不会进行赋值的，其次对于对象里面存在，同时在外面也进行过一个操作的。比如下面这个情况，是以单独的为重点。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p><blog-post :post-title=\"a\" v-bind=\"post\"></blog-post></p>\n<p>post: {<br>  id: 1,<br>  ‘post-title’: ‘xxxx’,<br>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">​\t\t其次，就是对于对象里面的属性，在子组件的props里没有，但是确实这个标签的属性的，会被挂载为一个属性。</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t比如：下面这个title就是子组件不存在的，但是属于标签上的属性，我们就可以看到DOM解构上就存在了，同时，我们也发现，id属性应该也是DOM树上的，但是却没有，应该是对于props里面存在的属性会被拦截，只有不在的才会跳出拦截。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>post: {<br>  id: 1,<br>  title: ‘xxxx’,<br>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">## 单向数据流</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t简单来说，对于这个父子组件的值的传递，所以为了保证子组件意外变更父级组件的状态，我们让子组件不能进行更新，更新会报出警告。并且不能进行更改。</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t然而记住，这个只是对栈进行了一个锁定，并没有对堆进行锁定，所以简单来说就是值类型是会被警告，但是对于引用类型来说，还是可以直接进行修改，并不会爆出警告。</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t这是一个需要记住的问题。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t对于会进行修改数据，但是又不想污染了父组件的data的，我们这里，有两个方式</span><br><span class=\"line\"></span><br><span class=\"line\">* 第一种就是使用了data将props的值重新进行赋值了 **这个子组件接下来希望将其作为一个本地的 prop 数据来使用** 。</span><br><span class=\"line\">  * ```</span><br><span class=\"line\">    props: [&#x27;initialCounter&#x27;],</span><br><span class=\"line\">    data: function () &#123;</span><br><span class=\"line\">      return &#123;</span><br><span class=\"line\">        counter: this.initialCounter</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>第二种就是使用计算属性，简单来说就是并没有修改原数据，仅仅只是使用了原数据。常用于 <strong>以一种原始的值传入且需要进行转换</strong> 。</li>\n</ul>\n<h2 id=\"Prop-验证\"><a href=\"#Prop-验证\" class=\"headerlink\" title=\"Prop 验证\"></a>Prop 验证</h2><p>​        验证类型是否满足需求，以及是否是必填项。</p>\n<h3 id=\"类型检查\"><a href=\"#类型检查\" class=\"headerlink\" title=\"类型检查\"></a>类型检查</h3><ul>\n<li>类型的限制</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">props: &#123;</span><br><span class=\"line\">\tA: Number,</span><br><span class=\"line\">\tB: [Number, String],</span><br><span class=\"line\">\tC: &#123;</span><br><span class=\"line\">\t\ttype: String,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>是否为必填项和默认值</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">props: &#123;</span><br><span class=\"line\">\tA: &#123;</span><br><span class=\"line\">\t\trequired: true,</span><br><span class=\"line\">\t\tdefault: &#x27;AA&#x27;,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>注意：</strong></p>\n<p>对象和数组的默认值必须从一个工厂函数获取。简单来说就是需要是一个函数，函数返回一个对象或者数组。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">default: () =&gt; &#123;</span><br><span class=\"line\">\treturn &#123;</span><br><span class=\"line\">\t\ta: 1</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<ul>\n<li>自定义一个验证函数</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A: &#123;</span><br><span class=\"line\">\tvalidator: function(value) &#123;</span><br><span class=\"line\">\t\t//返回值是 true 和 false</span><br><span class=\"line\">\t\treturn true;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<blockquote>\n<p>​        注意那些 prop 会在一个组件实例创建<strong>之前</strong>进行验证，所以实例的 property (如 <code>data</code>、<code>computed</code> 等) 在 <code>default</code> 或 <code>validator</code> 函数中是不可用的。</p>\n</blockquote>\n<h2 id=\"非-Prop-的-Attribute\"><a href=\"#非-Prop-的-Attribute\" class=\"headerlink\" title=\"非 Prop 的 Attribute\"></a>非 Prop 的 Attribute</h2><p>​        一个非 prop 的 attribute 是指传向一个组件，但是该组件并没有相应 prop 定义的 attribute。</p>\n<p>​        这个在前面也有说过，因为prop的传递是在标签上进行的传递，那么怎么区别这个属性是prop的值还是我是要给标签上的值呢。这里就是非Prop的属性</p>\n<p>​        简单来理解，就是对于声明的属性，但是却没有prop属性进行接收，那么就会被添加到组件的根元素上。</p>\n<h3 id=\"替换-合并已有的-Attribute\"><a href=\"#替换-合并已有的-Attribute\" class=\"headerlink\" title=\"替换/合并已有的 Attribute\"></a>替换/合并已有的 Attribute</h3><p>​        简单来说就是我在组件的根元素上已经存在了这个属性，但是我在外面使用的使用对这个属性进行了重新的赋值，但是我的需求不是进行覆盖，而是进行合并，此时就是这个 替换/合并 属性</p>\n<p>​        但是这里从官网上看出，并没有什么方法，但是对于 class 和 style 这两个属性，我们会进行合并操作，但是对于其他属性，比如 type 等，我们就会出现替换掉的操作。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">子组件，c-c</span><br><span class=\"line\">div.A[type=&#x27;AA&#x27;]</span><br><span class=\"line\"></span><br><span class=\"line\">父组件的使用</span><br><span class=\"line\">c-c.B[type=&#x27;BB&#x27;]</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"禁用-Attribute-继承\"><a href=\"#禁用-Attribute-继承\" class=\"headerlink\" title=\"禁用 Attribute 继承\"></a>禁用 Attribute 继承</h3><p>​        简单来说就是因为在使用这个组件时，一些没有被prop的属性会被加入根标签，但是有的时候是不想这样的，所以我们可以使用 inheritAttrs: false，代表了继承属性为false。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Vue.component(&#x27;my-component&#x27;, &#123;</span><br><span class=\"line\">\t//这个属性，为false，代表了多余的属性不会被记录在dom树上。（多余是指没有在props定义的），默认为true。</span><br><span class=\"line\">  inheritAttrs: false,</span><br><span class=\"line\">  // ...</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>​        当然对于需要被继承的属性，我们可以使用 $attrs 进行获取。这个属性包含了一个属性名和一个属性值。</p>\n<p>​        通过 inheritAttrs 和 $attrs 这两个属性，就可以自己决定属性应该被赋予哪个元素。通常用于编写基础组件。</p>\n<p>​        下面这个例子，首先，使用了 inheritAttrs 进行了拦截。对于props不存在的属性将不会出现在根元素上。然后再对input标签上添加了一个 v-bind=”$attrs” 因为$attrs 属性是一个键值对。然后将其赋值给了input标签上。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Vue.component(&#x27;base-input&#x27;, &#123;</span><br><span class=\"line\">  inheritAttrs: false,</span><br><span class=\"line\">  props: [&#x27;label&#x27;, &#x27;value&#x27;],</span><br><span class=\"line\">  template: `</span><br><span class=\"line\">    &lt;label&gt;</span><br><span class=\"line\">      &#123;&#123; label &#125;&#125;</span><br><span class=\"line\">      &lt;input</span><br><span class=\"line\">        v-bind=&quot;$attrs&quot;</span><br><span class=\"line\">        v-bind:value=&quot;value&quot;</span><br><span class=\"line\">        v-on:input=&quot;$emit(&#x27;input&#x27;, $event.target.value)&quot;</span><br><span class=\"line\">      &gt;</span><br><span class=\"line\">    &lt;/label&gt;</span><br><span class=\"line\">  `</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;base-input</span><br><span class=\"line\">  label=&quot;Username:&quot;</span><br><span class=\"line\">  v-model=&quot;username&quot;</span><br><span class=\"line\">  required</span><br><span class=\"line\">  placeholder=&quot;Enter your username&quot;</span><br><span class=\"line\">&gt;&lt;/base-input&gt;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$attrs 的值。</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\trequired: &quot;&quot;</span><br><span class=\"line\">\tplaceholder: &quot;Enter your username&quot;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意 <code>inheritAttrs: false</code> 选项<strong>不会</strong>影响 <code>style</code> 和 <code>class</code> 的绑定。</p>\n</blockquote>\n<p>​        通过这个方式来进行操作的话，不用担心哪个是真正的根元素。</p>\n<h1 id=\"自定义事件\"><a href=\"#自定义事件\" class=\"headerlink\" title=\"自定义事件\"></a>自定义事件</h1><h2 id=\"事件名\"><a href=\"#事件名\" class=\"headerlink\" title=\"事件名\"></a>事件名</h2><p>​        首先要注意一个地方，那就是，对于 vue 的 v-on 监听来说，（语法糖是@）。这个是不会将短横线转为驼峰的。</p>\n<p>​        我们从前面可以知道，对于 props 来说，传递的属性如果是短横线，那么在props里面可以使用驼峰来进行处理，但是对于事件来说不行。</p>\n<p>​        这里就会好奇为什么prop可以短横线转驼峰，但是事件不能呢。有的说是JavaScript的命名规范里面不能使用短横线命名。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">this.$emit(&#x27;myEvent&#x27;)</span><br><span class=\"line\">&lt;!-- 没有效果 --&gt;</span><br><span class=\"line\">因为 短横线不能转换为驼峰。所以没有效果。</span><br><span class=\"line\">&lt;my-component v-on:my-event=&quot;doSomething&quot;&gt;&lt;/my-component&gt;</span><br></pre></td></tr></table></figure>\n\n<p>​        所以对于 @myEvent 将会被转化为 @myevent。</p>\n<p>​        所以最好的建议就是全部都是用 kebab-case。这里不但有HTML大小写不敏感的原因，还有对于模板字符串来说。大小写是规定的。</p>\n<h2 id=\"自定义组件的v-model-2-2-0\"><a href=\"#自定义组件的v-model-2-2-0\" class=\"headerlink\" title=\"自定义组件的v-model 2.2.0+\"></a>自定义组件的v-model 2.2.0+</h2><p>​        v-model 这个默认是利用名为 value 的prop 和 input 的事件。当然对于input的单选框和其他的会将value属性用于不同的prop。但是我们可以使用 model 选项来解决 v-model的冲突。</p>\n<p>​        简单的理解一下下面的内容，prop：checked，这个默认是value，代表了使用props的checked作为v-model的绑定。event：change，默认是input，代表监听的事件名称是change，这些都是可以进行修改的。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Vue.component(&#x27;base-checkbox&#x27;, &#123;</span><br><span class=\"line\">  model: &#123;</span><br><span class=\"line\">    prop: &#x27;checked&#x27;,</span><br><span class=\"line\">    event: &#x27;change&#x27;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  props: &#123;</span><br><span class=\"line\">    checked: Boolean</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  template: `</span><br><span class=\"line\">    &lt;input</span><br><span class=\"line\">      type=&quot;checkbox&quot;</span><br><span class=\"line\">      v-bind:checked=&quot;checked&quot;</span><br><span class=\"line\">      v-on:change=&quot;$emit(&#x27;change&#x27;, $event.target.checked)&quot;</span><br><span class=\"line\">    &gt;</span><br><span class=\"line\">  `</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>​        比如我这里进行一个修改。就是将 prop 的checked改成了XXX，于是相对应的。props的名字也要有一个XXX的存在。同理。我可以将event改成一个AAA，那么就会将emit提交的事件名称修改为AAA。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">model: &#123;</span><br><span class=\"line\">  prop: &#x27;XXX&#x27;,</span><br><span class=\"line\">  event: &#x27;AA&#x27;</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">props: &#123;</span><br><span class=\"line\">  XXX: String</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">template: `</span><br><span class=\"line\">  &lt;input</span><br><span class=\"line\">  :value=&quot;XXX&quot;</span><br><span class=\"line\">  @change=&quot;$emit(&#x27;AA&#x27;, $event.target.value)&quot;</span><br><span class=\"line\">  &gt;</span><br><span class=\"line\">`</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意你仍然需要在组件的 props 选项里声明 checked 这个 prop。</p>\n</blockquote>\n<h2 id=\"将原生事件绑定到组件\"><a href=\"#将原生事件绑定到组件\" class=\"headerlink\" title=\"将原生事件绑定到组件\"></a>将原生事件绑定到组件</h2><p>​        简单来说就是我想对一个标签进行监听，比如input监听，方法在本身，但是组件的input标签是在子组件的。那么此时我们就可以发现。子组件的输入并不会调用这个方法。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;base-input @input=&quot;onInput&quot;&gt;&lt;/base-input&gt;</span><br></pre></td></tr></table></figure>\n\n<p>​        我们可以先做一个原生的示例。通过下面这个示例我们可以发现。在输入input的时候会输出1，2 。因为这个是冒泡的原因。所以先进行的子组件的执行，再进行的父组件的执行。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div oninput=&quot;console.log(2);&quot;&gt;</span><br><span class=\"line\">  &lt;input oninput=&quot;console.log(1);&quot;/&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n\n<p>​        那么我们做一个vue组件的示例。并且我们也可以发现。此时就不会执行 myInput 方法了。只会执行组件内部的input的方法。不会执行外部的。原因的话。我们可以知道对于没有props接收的属性一般会被加入根元素，但是我们可以发现对于 监听属性来说，并没有加入到根元素。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=&quot;app&quot;&gt;</span><br><span class=\"line\">  &lt;base-input @input=&quot;myInput&quot;&gt;&lt;/base-input&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">Vue.component(&#x27;base-input&#x27;, &#123;</span><br><span class=\"line\">  template: `&lt;input @input=&quot;CInput&quot;&gt;`,</span><br><span class=\"line\">  methods: &#123;</span><br><span class=\"line\">    CInput() &#123;</span><br><span class=\"line\">      console.log(&#x27;c&#x27;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>​        具体的原因还不清楚。但是要记住就是直接使用监听是不会被监听成功的。有可能是监听要通过JavaScript进行操作，但是组件的元素会被替换，所以监听会失效。</p>\n<p>​        因此我们可以使用 .native 修饰符 那么此时就可以将监听放入根元素了。当然，这个的效果简单来说就是会将事件绑定给根元素。但是如果本来根元素不支持这个事件，那么就会静默失败，比如 div的根元素绑定一个focus，就会失败。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;base-input @input.native=&quot;myInput&quot;&gt;&lt;/base-input&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>​        此时，对于根元素并不是我想要绑定的元素，这个时候，我们知道，对于props，有一个叫做。$attrs，和 inheritAttrs 进行搭配，可以使父组件传递的props在子组件能够有一个自己规定的位置出现。那么同时事件也有一个 $listeners 属性，他是一个对象，里面包含了作用在这个组件上的监听器。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div&gt;&lt;input v-on=&quot;$listeners&quot; @input=&quot;CInput&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n\n<p>​        但是注意，如果使用了 .native 那么将不会出现在 $listeners 里面。不管 .native 是否会绑定成功。</p>\n<p>​        下面这个是使用computed，这里记住一个问题，那就是 下面这个写法是会将 input 的监听进行覆盖的一个操作。但是又通过了 $emit 向上通知了父组件的 input。同理 使用 this.$listeners[‘input’] 也会覆盖input。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">computed: &#123;</span><br><span class=\"line\">  inputListeners: function () &#123;</span><br><span class=\"line\">    var vm = this</span><br><span class=\"line\">    // `Object.assign` 将所有的对象合并为一个新对象</span><br><span class=\"line\">    return Object.assign(&#123;&#125;,</span><br><span class=\"line\">      // 我们从父级添加所有的监听器</span><br><span class=\"line\">      this.$listeners,</span><br><span class=\"line\">      // 然后我们添加自定义监听器，</span><br><span class=\"line\">      // 或覆写一些监听器的行为</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        // 这里确保组件配合 `v-model` 的工作</span><br><span class=\"line\">        input: function (event) &#123;</span><br><span class=\"line\">        \tvm.$emit(&#x27;input&#x27;, event.target.value)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"sync修饰符-2-3-0\"><a href=\"#sync修饰符-2-3-0\" class=\"headerlink\" title=\".sync修饰符 2.3.0+\"></a>.sync修饰符 2.3.0+</h2><p>​        因为双向绑定会带来维护上的问题。因为对于data的变更不清楚来源。</p>\n<p>​        所以我们推荐 update:myPropName 来代替。在一个包含 title 的假设的组件。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">this.$emit(&#x27;update:title&#x27;, newTitle)</span><br></pre></td></tr></table></figure>\n\n<p>​        因此就引出了sync修饰符，这算是一个语法糖。</p>\n<ul>\n<li><p>对于父组件来说，变化就是将 :title 和 :update:title 进行了合并，简单来说就像是进行了 v-model 的操作一样。</p>\n<ul>\n<li>```<br>&lt;base-input<br>  v-bind:title=”a”<br>  v-on:update:title=”a”<blockquote>\n\n</blockquote>\n<base-input :title.sync=\"a\"></base-input><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">* 对于子组件来说，没有什么变化， 这里的 :title.sync 就是 @update:title 加上了 :title，所以对于 $emit 也是使用原来的 update:title 进行的提交。</span><br><span class=\"line\"></span><br><span class=\"line\">  * ```</span><br><span class=\"line\">    this.$emit(&#x27;update:title&#x27;, Math.random());</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ul>\n<p>在这里，还有一个问题就是。我们可以发现对于 emit提交时带的参数，父组件如果要将方法写在那个标签上进行表达式的执行，那么 $event 就是第一个参数。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">this.$emit(&#x27;update:title&#x27;, 1);</span><br><span class=\"line\"></span><br><span class=\"line\">//这里的 $event 就是 子元素在 $emit 提交时的第二个参数，从第二个参数开始的提交就是会传递给父元素的参数。这里只是第二个，如果没有参数的话，就会为undefined</span><br><span class=\"line\">&lt;base-input @update:title=&quot;a = $event&quot;&gt;&lt;/base-input&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n<blockquote>\n<p>注意带有 <code>.sync</code> 修饰符的 <code>v-bind</code> <strong>不能</strong>和表达式一起使用 (例如 <code>v-bind:title.sync=”doc.title + ‘!’”</code> 是无效的)。取而代之的是，你只能提供你想要绑定的 property 名，类似 <code>v-model</code>。</p>\n</blockquote>\n<p>​        当然，这里的 sync修饰符 也可以和 v-bind 进行搭配</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;text-document v-bind.sync=&quot;doc&quot;&gt;&lt;/text-document&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">this.$emit(&#x27;update:title&#x27;, 1111);</span><br></pre></td></tr></table></figure>\n\n\n\n<blockquote>\n<p>将 <code>v-bind.sync</code> 用在一个字面量的对象上，例如 <code>v-bind.sync=”&#123; title: doc.title &#125;”</code>，是无法正常工作的，因为在解析一个像这样的复杂表达式的时候，有很多边缘情况需要考虑。</p>\n</blockquote>\n<h1 id=\"插槽\"><a href=\"#插槽\" class=\"headerlink\" title=\"插槽\"></a>插槽</h1><p>​        简单来说就是，因为Vue的组件化思路，所以很多都是以组件进行的开发。但是为了降低组件和组件的解耦性，就可以使用插槽，将组件之间的联系进一步的降低。</p>\n<p>​        在 2.6.0中，提供了新的语法 v-slot 来代替了 slot 和 slot-scope</p>\n<h2 id=\"插槽内容\"><a href=\"#插槽内容\" class=\"headerlink\" title=\"插槽内容\"></a>插槽内容</h2><p>​        </p>\n<p><strong>一个简单的示例</strong></p>\n<p>​        下面的示例就代表了 Your Profile 将会代替 slot这个标签进行显示。当然 插槽的内部可以包含任何模板代码，包括HTML和其他组件，这也是我们常会使用的方法。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;navigation-link url=&quot;/profile&quot;&gt;</span><br><span class=\"line\">  Your Profile</span><br><span class=\"line\">&lt;/navigation-link&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&lt;a&gt;</span><br><span class=\"line\">  &lt;slot&gt;&lt;/slot&gt;</span><br><span class=\"line\">&lt;/a&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"编译作用域\"><a href=\"#编译作用域\" class=\"headerlink\" title=\"编译作用域\"></a>编译作用域</h2><p>​        简单来说，看下面这个代码，这个 a 应该是 父级组件上的 a呢，还是子组件上的a呢。</p>\n<p>​        最终的结果就是这个是 父级组件上的a。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div&gt;</span><br><span class=\"line\">\t&lt;base-input&gt;&#123;&#123; a &#125;&#125;&lt;/base-input&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n\n<p>这里有条规则</p>\n<blockquote>\n<p>父级模板里的所有内容都是在父级作用域中编译的；子模板里的所有内容都是在子作用域中编译的。</p>\n</blockquote>\n<h2 id=\"后背内容\"><a href=\"#后背内容\" class=\"headerlink\" title=\"后背内容\"></a>后背内容</h2><p>​        简单来说就是一个插槽的默认值。简单来说就是写在 slot 里面的内容就是 插槽的默认值。</p>\n<p>​        如果你在使用组件的时候没有使用插槽，那么就会使用这个默认的内容，并且这个默认的内容的作用域是在子组件的。</p>\n<p>​        如果提供有内容，那么便会渲染来取代内容。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div&gt;&lt;slot&gt;&#123;&#123; x &#125;&#125;&lt;/slot&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"具名插槽\"><a href=\"#具名插槽\" class=\"headerlink\" title=\"具名插槽\"></a>具名插槽</h2><p>​        简单来说就是使用name将插槽能够指定的使用在某个位置。对于没有使用name的，会有一个默认的name default。 </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;slot name=&quot;header&quot;&gt;&lt;/slot&gt;</span><br></pre></td></tr></table></figure>\n\n<p>​        那么在使用这个具名插槽的时候，我们就可以使用一个 template 进行包裹，然后在里面使用 v-slot指令，并以 v-slot 的参数的形式提供名称。</p>\n<p>​        从下面的代码可以看出，对于使用了 template加上v-slot的，就是寻找name相对应的。对于没有使用的就会被作为一个默认，就算中间隔了一个template v-slot 也一样。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;base-layout&gt;</span><br><span class=\"line\">  &lt;template v-slot:header&gt;</span><br><span class=\"line\">    &lt;h1&gt;Here might be a page title&lt;/h1&gt;</span><br><span class=\"line\">  &lt;/template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">  &lt;p&gt;A paragraph for the main content.&lt;/p&gt;</span><br><span class=\"line\">  &lt;p&gt;And another one.&lt;/p&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">  &lt;template v-slot:footer&gt;</span><br><span class=\"line\">    &lt;p&gt;Here&#x27;s some contact info&lt;/p&gt;</span><br><span class=\"line\">  &lt;/template&gt;</span><br><span class=\"line\">&lt;/base-layout&gt;</span><br></pre></td></tr></table></figure>\n\n<p>​        当然，为了语义的方便，我们建议还是可以将默认的放入一个 template v-slot:default，当然，这个default不要也可以，但是如果加了default，那么就不会将其他外层标签也加入默认，但是如果没有加上default的话，那么就会加入默认。</p>\n<p>​        比如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;template v-slot:default&gt;</span><br><span class=\"line\">  &lt;p&gt;A paragraph for the main content.&lt;/p&gt;</span><br><span class=\"line\">  &lt;p&gt;And another one.&lt;/p&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\">//下面这个不会显示。</span><br><span class=\"line\">&lt;p&gt;And another one.&lt;/p&gt;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  &lt;p&gt;A paragraph for the main content.&lt;/p&gt;</span><br><span class=\"line\">  &lt;p&gt;And another one.&lt;/p&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\">//上面的template没有使用default，下面这个会显示出来，因为都被算在了插槽里面</span><br><span class=\"line\">&lt;p&gt;And another one.&lt;/p&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"作用域插槽\"><a href=\"#作用域插槽\" class=\"headerlink\" title=\"作用域插槽\"></a>作用域插槽</h2><p>​        2.6.0 废弃了 slot-scope</p>\n<p>​        因为我们可以知道，插槽的默认的作用域是编译时的环境，所以一般常常是父级作用域，那么此时我们要如何将作用域作用域子级。</p>\n<p>​        这个时候就是要使用作用域插槽的时候了。</p>\n<ul>\n<li>简单来说就是子组件在进行slot创建时，通过 v-bind 绑定一个属性，然后属性的值是data的值。</li>\n<li>然后在使用的时候，通过 v-slot:xx=”xxx” 进行了属性的获取，这里 xxx就是子组件传递过来的一系列的属性而形成的对象。</li>\n<li>此时我们就可以在父组件里面使用到子组件的data了，当然，建议这个还是少使用吧，因为这个造成了组件的透明度降低。</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;slot :x=&quot;x1&quot;&gt;&lt;/slot&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;template v-slot:default=&quot;a&quot;&gt;</span><br><span class=\"line\">a.x</span><br><span class=\"line\">&lt;/template&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"独占默认插槽的缩写语法\"><a href=\"#独占默认插槽的缩写语法\" class=\"headerlink\" title=\"独占默认插槽的缩写语法\"></a>独占默认插槽的缩写语法</h3><p>​        就是说，只有被提供的内容只存在默认插槽的存在时，组件的标签才可以被当作插槽的模板来使用。此时我们就可以直接把 v-slot 用在组件上。</p>\n<p>​        这里我们首先知道 v-slot 可以使用在组件上，并且插槽是可以接收一个组件的。但是我们后面可以发现，如果直接使用组件，会出现插槽的位置无法正确的定位。</p>\n<p>​        然后我么可以发现，其实对组件是不能进行插槽的定位的。意思就是说，对于组件来说，使用插槽的 v-slot 不能定位到对应的具名插槽。</p>\n<p>​        比如下面这个情况，我开始以为 v-slot:footer 和 v-slot:header，都会按照正确的位置进行拜访，因为这个就是具名插槽的作用，只能用于template，对于下面这个test组件，虽然我们也使用了 v-slot:header 但是他并没有去header，而是就为普通的标签的行为。v-slot不会在除了template上起作用。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;base-input&gt;</span><br><span class=\"line\">  &lt;template v-slot:footer&gt;</span><br><span class=\"line\">  \t&lt;ttt&gt;&lt;/ttt&gt;</span><br><span class=\"line\">  &lt;/template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">  &lt;p&gt;123&lt;/p&gt;</span><br><span class=\"line\">  &lt;p&gt;111&lt;/p&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">  &lt;test v-slot:header&gt;&lt;/test&gt;</span><br><span class=\"line\">&lt;/base-input&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;current-user v-slot:default=&quot;slotProps&quot;&gt;</span><br><span class=\"line\">  &#123;&#123; slotProps.user.firstName &#125;&#125;</span><br><span class=\"line\">&lt;/current-user&gt;</span><br></pre></td></tr></table></figure>\n\n<p>​        缩写语法</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;current-user v-slot=&quot;slotProps&quot;&gt;</span><br><span class=\"line\">  &#123;&#123; slotProps.user.firstName &#125;&#125;</span><br><span class=\"line\">&lt;/current-user&gt;</span><br></pre></td></tr></table></figure>\n\n<p>​        案例形式。简单来说就是，如果base-input内部只有一个默认插槽，那么我们可以将这个 base-input 内部的整体都作为一个 slot的代替，如果是以前， base-input&gt;template[v-slot=”slotProps”] 但是我们可以将template进行省略，所以变成了 base-input[v-slot=”slotProps”]</p>\n<p>​        当然，上面这个也是进行了缩写了的。完整的话，需要加上 v-slot:default。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;base-input v-slot=&quot;slotProps&quot;&gt;</span><br><span class=\"line\">&lt;/base-input&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"解构插槽Prop\"><a href=\"#解构插槽Prop\" class=\"headerlink\" title=\"解构插槽Prop\"></a>解构插槽Prop</h3><p>​        简单来说就是说，作用域插槽的内部原理就是将插槽的内容包裹在一个参数的函数内部。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function (slotProps) &#123;</span><br><span class=\"line\">  // 插槽内容</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>​        在下面这个标签的使用里。使用了解构赋值的形式， { user } = slotProps，在这里，解构赋值的效果就是，取出了 slotProps的user给了 user。当然我们也可以使用其他的解构赋值的行为。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;current-user v-slot=&quot;&#123; user &#125;&quot;&gt;</span><br><span class=\"line\">  &#123;&#123; user.firstName &#125;&#125;</span><br><span class=\"line\">&lt;/current-user&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"动态插槽名\"><a href=\"#动态插槽名\" class=\"headerlink\" title=\"动态插槽名\"></a>动态插槽名</h2><p>​        2.6.0 新增</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;template v-slot:[dynamicSlotName]&gt;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&lt;/template\t&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"具名插槽的缩写\"><a href=\"#具名插槽的缩写\" class=\"headerlink\" title=\"具名插槽的缩写\"></a>具名插槽的缩写</h2><p>​        2.6.0 新增</p>\n<p>​        简单来说，就是插槽的语法糖，v-slot =&gt; #，但是对于没有参数的话是无效的。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;current #header=&quot;&#123; user &#125;&quot;&gt;&lt;/current&gt;</span><br><span class=\"line\">//下面这个是无效的。</span><br><span class=\"line\">&lt;current #=&quot;&#123; user &#125;&quot;&gt;&lt;/current&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"动态组件-amp-异步组件\"><a href=\"#动态组件-amp-异步组件\" class=\"headerlink\" title=\"动态组件&amp;异步组件\"></a>动态组件&amp;异步组件</h1><h2 id=\"在动态组件上使用-keep-alive\"><a href=\"#在动态组件上使用-keep-alive\" class=\"headerlink\" title=\"在动态组件上使用 keep-alive\"></a>在动态组件上使用 keep-alive</h2><p>​        之前，我们使用 is 属性来对组件进行切换。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;component v-bind:is=&quot;currentTabComponent&quot;&gt;&lt;/component&gt;</span><br></pre></td></tr></table></figure>\n\n<p>​        现在，我们在组件进行切换的时候，想要保存组件的状态。以避免重复的渲染。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- 失活的组件将会被缓存！--&gt;</span><br><span class=\"line\">&lt;keep-alive&gt;</span><br><span class=\"line\">  &lt;component v-bind:is=&quot;currentTabComponent&quot;&gt;&lt;/component&gt;</span><br><span class=\"line\">&lt;/keep-alive&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"异步组件\"><a href=\"#异步组件\" class=\"headerlink\" title=\"异步组件\"></a>异步组件</h2><p>​        将应用分割成小一些的代码块，并且只在需要的时候才从服务器进行加载。对此Vue允许使用一个工厂函数的方式进行定义组件。Vue只有在这个组件需要被渲染，并把结果缓存起来供未来重渲染。</p>\n<p>​        下面这个简单的例子，表示了第二个参数是一个函数，函数需要使用resolve和reject，表示会以promise进行调用，通过resolve返回渲染对象，荣国reject表示加载失败。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Vue.component(&#x27;async-example&#x27;, function (resolve, reject) &#123;</span><br><span class=\"line\">  setTimeout(function () &#123;</span><br><span class=\"line\">    // 向 `resolve` 回调传递组件定义</span><br><span class=\"line\">    resolve(&#123;</span><br><span class=\"line\">      template: &#x27;&lt;div&gt;I am async!&lt;/div&gt;&#x27;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;, 1000)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>​        一个推荐的做法是将异步组件和 <a href=\"https://webpack.js.org/guides/code-splitting/\">webpack 的 code-splitting 功能</a>一起配合使用</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Vue.component(&#x27;async-webpack-example&#x27;, function (resolve) &#123;</span><br><span class=\"line\">  // 这个特殊的 `require` 语法将会告诉 webpack</span><br><span class=\"line\">  // 自动将你的构建代码切割成多个包，这些包</span><br><span class=\"line\">  // 会通过 Ajax 请求加载</span><br><span class=\"line\">  require([&#x27;./my-async-component&#x27;], resolve)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>​        但是因为我这个异步组件和搭配webpack这个用的比较少，所以在这里就没有进行详细的讲述，就直接贴上Vue的官网链接了。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://cn.vuejs.org/v2/guide/components-dynamic-async.html#异步组件</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"处理加载状态\"><a href=\"#处理加载状态\" class=\"headerlink\" title=\"处理加载状态\"></a>处理加载状态</h3><p>​        2.3.0 新增</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const AsyncComponent = () =&gt; (&#123;</span><br><span class=\"line\">  // 需要加载的组件 (应该是一个 `Promise` 对象)</span><br><span class=\"line\">  component: import(&#x27;./MyComponent.vue&#x27;),</span><br><span class=\"line\">  // 异步组件加载时使用的组件</span><br><span class=\"line\">  loading: LoadingComponent,</span><br><span class=\"line\">  // 加载失败时使用的组件</span><br><span class=\"line\">  error: ErrorComponent,</span><br><span class=\"line\">  // 展示加载时组件的延时时间。默认值是 200 (毫秒)</span><br><span class=\"line\">  delay: 200,</span><br><span class=\"line\">  // 如果提供了超时时间且组件加载也超时了，</span><br><span class=\"line\">  // 则使用加载失败时使用的组件。默认值是：`Infinity`</span><br><span class=\"line\">  timeout: 3000</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n\n\n<blockquote>\n<p>注意如果你希望在 <a href=\"https://github.com/vuejs/vue-router\">Vue Router</a> 的路由组件中使用上述语法的话，你必须使用 Vue Router 2.4.0+ 版本。</p>\n</blockquote>\n<h1 id=\"处理边界情况\"><a href=\"#处理边界情况\" class=\"headerlink\" title=\"处理边界情况\"></a>处理边界情况</h1><h2 id=\"访问元素-amp-组件\"><a href=\"#访问元素-amp-组件\" class=\"headerlink\" title=\"访问元素 &amp; 组件\"></a>访问元素 &amp; 组件</h2><h3 id=\"访问根实例-this-root\"><a href=\"#访问根实例-this-root\" class=\"headerlink\" title=\"访问根实例 this.$root\"></a>访问根实例 this.$root</h3><p>​        这个可以通过 <code>this.$root</code>，进行访问。如果是methods里面的方法aa，那么就可以通过 <code>this.$root.aa</code> 进行访问。</p>\n<p>​        所有的子组件都可以将这个实例作为一个全局 store 来访问或者使用。</p>\n<blockquote>\n<p>对于 demo 或非常小型的有少量组件的应用来说这是很方便的。不过这个模式扩展到中大型应用来说就不然了。因此在绝大多数情况下，我们强烈推荐使用 <a href=\"https://github.com/vuejs/vuex\">Vuex</a> 来管理应用的状态。</p>\n</blockquote>\n<h3 id=\"访问父级组件实例\"><a href=\"#访问父级组件实例\" class=\"headerlink\" title=\"访问父级组件实例\"></a>访问父级组件实例</h3><p>​        可以通过 $parent 属性来访问一个父组件的实例。<br>​        但是请注意，这样写虽然是可以直接对父组件进行了操作，可以代替props来进行数据的访问，但是却会造成数据的修改时不清楚修改的源头。</p>\n<h3 id=\"访问子组件实例或子元素\"><a href=\"#访问子组件实例或子元素\" class=\"headerlink\" title=\"访问子组件实例或子元素\"></a>访问子组件实例或子元素</h3><p>​        可以通过 ref 属性，为子组件赋予一个ID引用。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;base-input ref=&quot;usernameInput&quot;&gt;&lt;/base-input&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">那么父组件就可以通过 this.$refs.usernameInput 来访问子组件了。</span><br></pre></td></tr></table></figure>\n\n<p>​        但是记住，this.$refs，里面存放的只会有属于自己的子组件，以及有可能会有自己的子孙级组件。这个我们一会儿就说。</p>\n<p>​        ref同时也可以写在原生的HTML标签上面，for example <code>&lt;input type=&quot;text&quot; ref=&quot;inpu&quot;&gt;</code> 如果写在了原生的HTML上面，我们通过$refs获取时也是一个原生的标签，并且也可以使用方法，比如 <code>focus</code> 等。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=&quot;app&quot;&gt;</span><br><span class=\"line\">    &lt;input type=&quot;text&quot; ref=&quot;input&quot;&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">//在父组件的方法里面使用这个便可以调用input的原生focus进行聚焦。</span><br><span class=\"line\">this.$refs.inpu.focus()</span><br></pre></td></tr></table></figure>\n\n\n\n<p>关于父组件的 refs 是否会含有子组件，这个应该是在哪个组件被编译就会存在于哪个组件。</p>\n<p>​        比如看看下面这个文件的内容。template存在一个插槽和input，然后在使用组件的时候，插槽又是插入了一个input，但是如果我们查看结果，就会发现，插槽所写的ref会存在与父组件，而在template里面所写的，便会存在于子组件。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template: `&lt;div&gt;&lt;slot&gt;&lt;/slot&gt;&lt;input type=&quot;text&quot; ref=&quot;input&quot;&gt;&lt;/div&gt;`,</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;aaaa ref=&quot;ssss&quot;&gt;</span><br><span class=\"line\">    &lt;input type=&quot;text&quot; ref=&quot;inpu&quot;&gt;</span><br><span class=\"line\">&lt;/aaaa&gt;</span><br></pre></td></tr></table></figure>\n\n<p>​        当 ref 和 v-for 一起使用的时候，ref会包含整个数组。一般来说，refs是一个对象，但是对于使用了v-for的来说，就会变成一个数组，就算是ref使用了v-bind 进行了绑定，也会变为存在不同ref的对象，内部含有数组。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;li :ref=&quot;i&quot; v-for=&quot;i in 10&quot;&gt;&lt;/li&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">1: [li]</span><br><span class=\"line\">2: [li]</span><br><span class=\"line\">3: [li]</span><br><span class=\"line\">4: [li]</span><br><span class=\"line\"></span><br><span class=\"line\">形成的还是数组，虽然数组的长度只有1。</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"依赖注入\"><a href=\"#依赖注入\" class=\"headerlink\" title=\"依赖注入\"></a>依赖注入</h3><p>​        简单来说，就是父子组件可以通过 $parent 来进行访问，但是对于嵌套的情况，会造成 $parent.$parent 那么此时就是依赖注入的时候。</p>\n<p>​        这里用到了两个新的实例的选项。 provide &amp; inject</p>\n<p><strong>provide</strong> 选项允许我们指定我们想要提供给后代组件的数据/方法。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">provide: function() &#123;</span><br><span class=\"line\">\treturn &#123;</span><br><span class=\"line\">\t\tget: this.get</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>inject</strong> 在任何后代组件里，我们都可以使用 inject 选项来接收指定的属性进行注入。</p>\n<p><strong>例子</strong>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">father</span><br><span class=\"line\">\tchildren</span><br><span class=\"line\">\t\tgrandson</span><br><span class=\"line\"></span><br><span class=\"line\">那么此时 grandson要使用 father组件的方法就需要 this.$parent.$parent 来进行调用，但是对于有多层的调用会出现意想不到的问题。</span><br></pre></td></tr></table></figure>\n\n<p>​        使用 provide 和 inject 进行处理，需要记住，这个的调用创建应该是先于data，所以如果当data和inject进行了重合，那么便会出现data覆盖了inject，但是他们都是属于 init injected &amp; reacted 周期。在使用 beforeCreate 之后， 以及 created 之前。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">先使用 provide 进行提供需要给后代的方法和数据。</span><br><span class=\"line\">const app = new Vue(&#123;</span><br><span class=\"line\">\tprovide() &#123;</span><br><span class=\"line\">\t\treturn &#123;</span><br><span class=\"line\">\t\t\tname: this.output,</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">然后在后代使用 inject 进行注入，注入之后就可以使用 this.name进行使用。</span><br><span class=\"line\">Vue.component(&#x27;xx&#x27;, &#123;</span><br><span class=\"line\">\tinject: [&#x27;name&#x27;],</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"程序化的事件侦听器\"><a href=\"#程序化的事件侦听器\" class=\"headerlink\" title=\"程序化的事件侦听器\"></a>程序化的事件侦听器</h2><p>通过 $on(eventName, eventHandler) 来侦听一个事件。</p>\n<p>通过 $once(eventName, eventHandler) 来一次性的侦听一个事件。</p>\n<p>通过 $off(eventName, eventHandler)  来停止侦听一个事件。</p>\n<p>一般来说是很少进行使用的，但是当你需要在一个组件的实例上手动的侦听事件时，它们便派上了用场。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mounted() &#123;</span><br><span class=\"line\">\tthis.pi = new Pi(&#123;&#125;);</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">beforeDestroy() &#123;</span><br><span class=\"line\">\tthis.pi.destroy();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果使用程序化的侦听器来解决这个问题：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mounted() &#123;</span><br><span class=\"line\">\tconst pi = new Pi(&#123;&#125;);</span><br><span class=\"line\">\tthis.$once(&#x27;hook:beforeDestroy&#x27;, function() &#123;</span><br><span class=\"line\">\t\tpi.destroy();</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n\n<p><strong>注意</strong>：</p>\n<blockquote>\n<p>​        Vue 的事件系统不同于浏览器的 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget\">EventTarget API</a>。尽管它们工作起来是相似的，但是 <code>$emit</code>、<code>$on</code>, 和 <code>$off</code> 并不是 <code>dispatchEvent</code>、<code>addEventListener</code> 和 <code>removeEventListener</code> 的别名。</p>\n</blockquote>\n<h2 id=\"循环引用\"><a href=\"#循环引用\" class=\"headerlink\" title=\"循环引用\"></a>循环引用</h2><h3 id=\"递归组件\"><a href=\"#递归组件\" class=\"headerlink\" title=\"递归组件\"></a>递归组件</h3><p>​        组件是可以在他们自己的模板中调用自身的，但是只能通过name选项来做这件事。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">name: &#x27;stack&#x27;,</span><br><span class=\"line\">tempalte: `&lt;div&gt;&lt;stack&gt;&lt;/stack&gt;&lt;/div&gt;`,</span><br></pre></td></tr></table></figure>\n\n<p>​        简单来说就是可以进行递归的循环，所以需要注意，并且发现对于全局注册组件，也可以使用组件名称进行递归组件。</p>\n<h3 id=\"组件之间的循环引用\"><a href=\"#组件之间的循环引用\" class=\"headerlink\" title=\"组件之间的循环引用\"></a>组件之间的循环引用</h3><p>​        对于组件之间的相互调用，组件在渲染树中互相为对方的后代和祖先。当通过 Vue.component 全局注册组件的时候，这个悖论将会被解开。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tree-father</span><br><span class=\"line\">\ttree-other</span><br><span class=\"line\">\t</span><br><span class=\"line\">tree-other</span><br><span class=\"line\">\ttree-father</span><br></pre></td></tr></table></figure>\n\n<p>​        然而，如果你使用一个模块系统依赖/导入组件，则会遇到一个错误。</p>\n<p>​        所以此时的解决办法就是：</p>\n<ul>\n<li><p>将注册事件放入 beforeCreate 进行注册。</p>\n<ul>\n<li>```<br>beforeCreate() {<pre><code>this.$options.components.ComponentA = require(&#39;./component-a.vue&#39;);\n</code></pre>\n}<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">* 或者，在本地进行注册组件的时候，可以使用 webpack 异步 import</span><br><span class=\"line\"></span><br><span class=\"line\">  * ```</span><br><span class=\"line\">    components: &#123;</span><br><span class=\"line\">    \tComponentA: () =&gt; import(&#x27;./component-a.vue&#x27;);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"模板定义的代替品\"><a href=\"#模板定义的代替品\" class=\"headerlink\" title=\"模板定义的代替品\"></a>模板定义的代替品</h2><h3 id=\"内联模板\"><a href=\"#内联模板\" class=\"headerlink\" title=\"内联模板\"></a>内联模板</h3><p>​        简单来说就是，组件内部的内容将会作为模板，而不是将其视为分布式内容(或者插槽？)。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;my-component inline-template&gt;</span><br><span class=\"line\">    &lt;div&gt;</span><br><span class=\"line\">        &lt;p&gt;These are compiled as the component&#x27;s own template.&lt;/p&gt;</span><br><span class=\"line\">        &lt;p&gt;Not parent&#x27;s transclusion content.&lt;/p&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">&lt;/my-component&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">Vue.component(&#x27;my-component&#x27;, &#123;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p><strong>注意点</strong>：</p>\n<ul>\n<li>使用的模板名需要是存在的</li>\n<li>如果要使用内联模板，那么对于全局注册的组件时需要的信息可以不需要，比如(template，data，methods等)。</li>\n<li>个人感觉这个和 template 的效果很相似。但是注意，使用内联模板也是可以使用data和methods的。所以这个的作用应该是很像 .vue 文件的使用。</li>\n</ul>\n<h3 id=\"X-Template\"><a href=\"#X-Template\" class=\"headerlink\" title=\"X-Template\"></a>X-Template</h3><p>​        使用 script 脚本，并且将type设置为 text/x-template，然后通过使用 id 来引用模板。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script type=&quot;text/x-template&quot; id=&quot;hello-world-template&quot;&gt;</span><br><span class=\"line\">  &lt;p&gt;Hello hello hello&lt;/p&gt;</span><br><span class=\"line\">&lt;/script&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">Vue.component(&#x27;hello-world&#x27;, &#123;</span><br><span class=\"line\">  template: &#x27;#hello-world-template&#x27;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>​        这些替代模板都是将 模板内部的标签 和 数据 以及操作等进行了分割。</p>\n<h2 id=\"控制更新\"><a href=\"#控制更新\" class=\"headerlink\" title=\"控制更新\"></a>控制更新</h2><h3 id=\"强制更新\"><a href=\"#强制更新\" class=\"headerlink\" title=\"强制更新\"></a>强制更新</h3><p>​        使用 $forceUpdate</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">data() &#123;</span><br><span class=\"line\">\treturn &#123;</span><br><span class=\"line\">\t\tx: [1, 3],</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">this.x[1] = 10;</span><br><span class=\"line\">//此时，虽然数据发生了改变，但是因为vue2的数据响应式无法对数组的直接操作进行通知，所以不会发生更新，那么此时就需要使用 this.$forceUpdate(); 来进行强制更新了。</span><br><span class=\"line\">this.$forceUpdate();</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"使用-v-once-的廉价静态组件\"><a href=\"#使用-v-once-的廉价静态组件\" class=\"headerlink\" title=\"使用 v-once 的廉价静态组件\"></a>使用 v-once 的廉价静态组件</h3><p>​        Vue 渲染纯HTML非常快，但是有时你的组件包含了大量的静态内容。在这些情况下，可以确保只被评估一次。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Vue.component(&#x27;terms-of-service&#x27;, &#123;</span><br><span class=\"line\">  template: `</span><br><span class=\"line\">    &lt;div v-once&gt;</span><br><span class=\"line\">      &lt;h1&gt;Terms of Service&lt;/h1&gt;</span><br><span class=\"line\">      ... a lot of static content ...</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">  `</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p><strong>注意</strong>：</p>\n<p>尽量不要过度的使用这种模式。除非真的渲染缓慢。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"组件注册\"><a href=\"#组件注册\" class=\"headerlink\" title=\"组件注册\"></a>组件注册</h1><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://cn.vuejs.org/v2/guide/components-registration.html</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"组件名\"><a href=\"#组件名\" class=\"headerlink\" title=\"组件名\"></a>组件名</h2><h3 id=\"组件名大小写\"><a href=\"#组件名大小写\" class=\"headerlink\" title=\"组件名大小写\"></a>组件名大小写</h3><p>​        对于大小写的组件名，在使用的时候大写会变成 -+小写的形式。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">myComPonent</span><br><span class=\"line\"></span><br><span class=\"line\">my-com-ponent</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"全局注册\"><a href=\"#全局注册\" class=\"headerlink\" title=\"全局注册\"></a>全局注册</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Vue.component(&#x27;component-a&#x27;, &#123; /* ... */ &#125;)</span><br></pre></td></tr></table></figure>\n\n<p>​        这样创建就是全局注册的，只要注册了之后，后面的Vue实例都可以直接使用。</p>\n<h2 id=\"局部注册\"><a href=\"#局部注册\" class=\"headerlink\" title=\"局部注册\"></a>局部注册</h2><p>​        全局注册会不可避免的增加性能的消耗，浪费了很多时间。所以可以使用局部注册的方式进行注册，将组件注册在实例的内部，因此在实例被销毁时也会被销毁。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const ComponentA = &#123; /* ... */ &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">new Vue(&#123;</span><br><span class=\"line\">  el: &#x27;#app&#x27;,</span><br><span class=\"line\">  components: &#123;</span><br><span class=\"line\">    &#x27;component-a&#x27;: ComponentA,</span><br><span class=\"line\">    &#x27;component-b&#x27;: ComponentB</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>​        简单来说就是 ComponentsA 里面的对象就是 new一个Vue实例的对象。然后再在components里面进行new的创建，所以将作用域限制到了一定的范围。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const C = &#123;</span><br><span class=\"line\">  template: `&lt;div&gt;22&lt;/div&gt;`,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">const ComponentA = &#123;</span><br><span class=\"line\">  el: &#x27;#ap&#x27;,</span><br><span class=\"line\">  //这里是局部组件创建再加上了一个组件的创建，否则一个父组件，两个局部组件内部是不能相互调用的。</span><br><span class=\"line\">  components: &#123;</span><br><span class=\"line\">    &#x27;com&#x27;: C,</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const app = new Vue(&#123;</span><br><span class=\"line\">  el: &#x27;#app&#x27;,</span><br><span class=\"line\">  data: &#123;</span><br><span class=\"line\">    a: 1</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  components: &#123;</span><br><span class=\"line\">    &#x27;comA&#x27;: ComponentA,</span><br><span class=\"line\">    &#x27;com&#x27;: C,</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"模块系统\"><a href=\"#模块系统\" class=\"headerlink\" title=\"模块系统\"></a>模块系统</h2><p>​        简单来说就是可以使用 import / require 来使用一个模块系统。</p>\n<h3 id=\"在模块系统中局部注册\"><a href=\"#在模块系统中局部注册\" class=\"headerlink\" title=\"在模块系统中局部注册\"></a>在模块系统中局部注册</h3><p>​        简单来说，下面这个是取出了一个对象。这个是一个ES6的模块化导出的默认导出的写法。</p>\n<p>​        所以简单来说就是将对象进行导出。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import ComponentA from &#x27;./Component&#x27;;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export default &#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>​        我们先理清一下思路</p>\n<ul>\n<li>首先，Vue的components里面使用的是一个对象，这个对象是那个实例对象。其次对于这个命名的思路是因为是es6的对象赋值的方式</li>\n<li>然后就是导入 import 和 export default 这里导入和导出对象。</li>\n<li>所以其实还是有思路的。</li>\n</ul>\n<h3 id=\"基础组件的自动化全局注册\"><a href=\"#基础组件的自动化全局注册\" class=\"headerlink\" title=\"基础组件的自动化全局注册\"></a>基础组件的自动化全局注册</h3><p>​        require.context 可以全局注册组件。但是需要使用webpack或者使用了VueCLI3+（因为内部使用了webpack）</p>\n<p>​        <strong>什么是 require.context ：</strong></p>\n<ul>\n<li>首先，是一个webpack的api。</li>\n<li>其次，这个api用于实现自动化导入模块。就是对于一个文件引入很多模块的情况，可以使用这个api，会遍历指定的文件，然后进行自动导入，不需要每次显式的调用import导入模块。</li>\n<li>进行一个更细粒度的模块引入。</li>\n</ul>\n<p>​        <strong>一个使用时机</strong>：</p>\n<ul>\n<li>首先就是需要引入很多模块</li>\n<li>其次就是这个模块的处于同一父文件位置，所以对于基础组件来说是非常合适的。</li>\n</ul>\n<p>​        require.context 的参数：</p>\n<ul>\n<li><p>directory，String类型</p>\n<ul>\n<li>文件目录位置，</li>\n</ul>\n</li>\n<li><p>includeSubdirs，Boolean类型</p>\n<ul>\n<li>表示是否包含文件的子目录，可选参数，默认是 true</li>\n</ul>\n</li>\n<li><p>filter，RegExp正则表达式类型</p>\n<ul>\n<li>表示过滤某些文件。可选参数，默认是 <code>/^\\.\\/.*$/</code> 指的是所有文件。（这里是webpack写的，但是我没有理解这个正则）。</li>\n</ul>\n</li>\n<li><p>mode，String类型</p>\n<ul>\n<li><p>表示加载的方式， sync，eager，weak，lazy，lazy-once。默认值是sync。</p>\n</li>\n<li><p>```<br>sync<br>eager</p>\n<pre><code>不会生成额外的chunk，所有模块当成当前chunk引入。没有额外的网络请求，但是会返回一个resolved的Promise。\n</code></pre>\n<p>weak</p>\n<pre><code>这个没有看懂，大概可能是尝试加载，不可用返回一个reject的Promise。\n</code></pre>\n<p>lazy</p>\n<pre><code>为每一个导入的模块生成一个可延迟加载的chunk。简单来说就是将以异步方式加载。\n</code></pre>\n<p>lazy-once</p>\n<pre><code>生成一个可以满足所有的可延迟加载的chunk。这个chunk将第一次调用时获取，随后使用相同的网络响应。\n</code></pre>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">大概看懂了之后，我们再看一下组件的自动化全局注册</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>import Vue from ‘vue’<br>import upperFirst from ‘lodash/upperFirst’<br>import camelCase from ‘lodash/camelCase’</p>\n</li>\n</ul>\n</li>\n</ul>\n<p>const requireComponent = require.context(<br>  // 其组件目录的相对路径<br>  ‘./components’,<br>  // 是否查询其子目录<br>  false,<br>  // 匹配基础组件文件名的正则表达式<br>  /Base[A-Z]\\w+.(vue|js)$/<br>)</p>\n<p>requireComponent.keys().forEach(fileName =&gt; {<br>  // 获取组件配置<br>  const componentConfig = requireComponent(fileName)</p>\n<p>  // 获取组件的 PascalCase 命名<br>  const componentName = upperFirst(<br>    camelCase(<br>      // 获取和目录深度无关的文件名<br>      fileName<br>        .split(‘/‘)<br>        .pop()<br>        .replace(/.\\w+$/, ‘’)<br>    )<br>  )</p>\n<p>  // 全局注册组件<br>  Vue.component(<br>    componentName,<br>    // 如果这个组件选项是通过 <code>export default</code> 导出的，<br>    // 那么就会优先使用 <code>.default</code>，<br>    // 否则回退到使用模块的根。<br>    componentConfig.default || componentConfig<br>  )<br>})</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">​\t\t**其中这一部分的作用是将每个文件的模块给取了出来**</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>const requireComponent = require.context(<br>  // 其组件目录的相对路径<br>  ‘./components’,<br>  // 是否查询其子目录<br>  false,<br>  // 匹配基础组件文件名的正则表达式<br>  /Base[A-Z]\\w+.(vue|js)$/<br>)</p>\n<p>目录是 ./components<br>不查询子目录<br>匹配文件的形式，Basexxxx.(vue|js)</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">* requireComponent 通过typeof 判断是一个，function，里面存在了方法，可以使用keys方法进行获取</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t**这里是将requireComponent存储的组件给进行了注册。**</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>requireComponent.keys().forEach(fileName =&gt; {<br>  // 获取组件配置<br>  const componentConfig = requireComponent(fileName)</p>\n<p>  // 获取组件的 PascalCase 命名<br>  const componentName = upperFirst(<br>    camelCase(<br>      // 获取和目录深度无关的文件名<br>      fileName<br>        .split(‘/‘)<br>        .pop()<br>        .replace(/.\\w+$/, ‘’)<br>    )<br>  )</p>\n<p>  // 全局注册组件<br>  Vue.component(<br>    componentName,<br>    // 如果这个组件选项是通过 <code>export default</code> 导出的，<br>    // 那么就会优先使用 <code>.default</code>，<br>    // 否则回退到使用模块的根。<br>    componentConfig.default || componentConfig<br>  )<br>})</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">* keys方法获取到的是文件的相对路径。使用foreach进行循环操作。foreach内部也是和forin一个意思。forin和forof的区别在于迭代器问题。</span><br><span class=\"line\"></span><br><span class=\"line\">  * ```</span><br><span class=\"line\">    ./App.vue</span><br><span class=\"line\">    ./components/App.vue</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>然后使用 requireComponent 方法，参数为文件位置，便会获取到内容。</p>\n<ul>\n<li>使用 requireComponent(filename)，进行获取，就可以获取到内容。</li>\n</ul>\n</li>\n<li><p>当然这里的一个特点是，这个requireComponent 既是一个方法，也是一个对象，因为它既能像方法一样传递参数进行操作，也可以调用keys这个方法。</p>\n</li>\n<li><p>这里使用的 upperFirst 和 camelCase 是 lodash里面的方法，其中 upperFirst的作用是首字母大写，而camelCase是将字符串转为驼峰命名法，比如空格，-，_将会被划分。</p>\n</li>\n<li><p>在这里，首先fileName是一个文件的路径和名字，所以使用split进行划分/， 然后取出最后一个，然后将后面的文件后缀改为空，然后给camelCase变为驼峰，然后返回的字符串给了upperFirst变为了首字母大写的驼峰。赋值给了componentName。</p>\n<ul>\n<li>```<br>const componentName = upperFirst(<br>  camelCase(<pre><code>// 获取和目录深度无关的文件名\nfileName\n  .split(&#39;/&#39;)\n  .pop()\n  .replace(/\\.\\w+$/, &#39;&#39;)\n</code></pre>\n  )<br>)<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">* 然后就是注册组件了，使用了 Vue.component 方法。进行注册，Vue.component 第一个参数是名字，第二个参数是需要被Vue实例的对象。</span><br><span class=\"line\"></span><br><span class=\"line\">  * 这里的唯一的问题就是，对于如果没有使用 export default 导出的方法，貌似不会存在 default 这个对象。但是具体的我们需要在后面才会知道。</span><br><span class=\"line\"></span><br><span class=\"line\">  * ```</span><br><span class=\"line\">    Vue.component(</span><br><span class=\"line\">      componentName,</span><br><span class=\"line\">      // 如果这个组件选项是通过 `export default` 导出的，</span><br><span class=\"line\">      // 那么就会优先使用 `.default`，</span><br><span class=\"line\">      // 否则回退到使用模块的根。</span><br><span class=\"line\">      componentConfig.default || componentConfig</span><br><span class=\"line\">    )</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ul>\n<p>​        <strong>如何实现一个方法带有对象的使用。</strong></p>\n<p>​        这里我的一个想法就是修改原型链了，因为JavaScript任何都是存在原型链的，对于方法来说，也是有一个原型链的。简单来理解，方法既可以使用，又可以当作一个构造器来创建对象。</p>\n<ul>\n<li>作为一个构造器来说，方法需要记住的是prototype的指向</li>\n<li>而对于方法的执行来说，需要记住的是 __proto__ 的指向。所以这里对 __proto__ 里面创建了一个方法，然后通过调用这个方法来获取了keys，并且这个本身也是一个方法。</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function T() &#123;</span><br><span class=\"line\">  return 1;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">T.__proto__.keys = function () &#123;</span><br><span class=\"line\">  console.log(2);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"Prop\"><a href=\"#Prop\" class=\"headerlink\" title=\"Prop\"></a>Prop</h1><h2 id=\"Prop的大小写\"><a href=\"#Prop的大小写\" class=\"headerlink\" title=\"Prop的大小写\"></a>Prop的大小写</h2><p>​        简单来说就是驼峰命名法(camelCase)会在HTML上进行使用时需要转换为短横线分割命名(kebab-case)。因为HTML文档解析是大小写不敏感的，所以 postTitle 会被解析成 posttitle</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;blog-post :post-title=&quot;a&quot;&gt;&lt;/blog-post&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">Vue.component(&#x27;blog-post&#x27;, &#123;</span><br><span class=\"line\">  // 在 JavaScript 中是 camelCase 的</span><br><span class=\"line\">  props: [&#x27;postTitle&#x27;],</span><br><span class=\"line\">  template: &#x27;&lt;h3&gt;&#123;&#123; postTitle &#125;&#125;&lt;/h3&gt;&#x27;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>​        但是如果是使用的字符串模板，那么就不会有这个限制。</p>\n<p>​        意思就是说，使用template这种，模板是字符串的，应该是中间有个步骤在解析的时候会将驼峰自动转换为短横线。所以没有问题。</p>\n<h2 id=\"Prop类型\"><a href=\"#Prop类型\" class=\"headerlink\" title=\"Prop类型\"></a>Prop类型</h2><ul>\n<li><p>正常prop在使用的时候是使用的数组，加上字符串进行存储。此时的prop是一个数组的形式。</p>\n<ul>\n<li><p>```<br>props: [‘title’, ‘author’]</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">* 当然我们可以设置prop的值的类型。此时的prop是一个对象的形式。</span><br><span class=\"line\"></span><br><span class=\"line\">  * ```</span><br><span class=\"line\">    props: &#123;</span><br><span class=\"line\">      title: String,</span><br><span class=\"line\">      likes: Number,</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>对于设置了类型，但是类型对不上的，会报错，但是还是会正常显示，并不会进行类型转换。</p>\n</li>\n</ul>\n</li>\n<li><p>后面还会将一个写法，props里面的prop也是一个对象，我们后续再进行一个讲解。</p>\n<ul>\n<li>```<br>props: {<pre><code>propA: &#123;\n    type: String,\n    default: &#39;111&#39;,\n    required: true\n&#125;\n</code></pre>\n}<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">## 传递静态或动态Prop</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t简单来说，prop的传递是通过在使用组件时，添加上了attribute属性在DOM树上，然后再进行的传递，所以这个是可以使用 v-bind 进行绑定的。</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t当然通过这里我也学会一个小case，就是在这样使用的时候，会把42作为一个数字传递过去，而不是字符串，对于布尔值也是一样，如果要传递一个字符串，需要再使用 &#x27;&#x27; 进行划分。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<blog-post :likes=\"42\"></blog-post><br>42， false， [12, 41]， {}<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">​\t\t对于要传入一个对象的所有property，我们可以使用 v-bind，进行直接传入。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<blog-post v-bind=\"post\"></blog-post></li>\n</ul>\n</li>\n</ul>\n<p>就等于将 post 里面的对象进行传递</p>\n<p>&lt;blog-post<br>  v-bind:id=”post.id”<br>  v-bind:title=”post.title”</p>\n<blockquote>\n\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">​\t\t当然这里的优先级来说，首先对于子组件没有的prop，是不会进行赋值的，其次对于对象里面存在，同时在外面也进行过一个操作的。比如下面这个情况，是以单独的为重点。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p><blog-post :post-title=\"a\" v-bind=\"post\"></blog-post></p>\n<p>post: {<br>  id: 1,<br>  ‘post-title’: ‘xxxx’,<br>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">​\t\t其次，就是对于对象里面的属性，在子组件的props里没有，但是确实这个标签的属性的，会被挂载为一个属性。</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t比如：下面这个title就是子组件不存在的，但是属于标签上的属性，我们就可以看到DOM解构上就存在了，同时，我们也发现，id属性应该也是DOM树上的，但是却没有，应该是对于props里面存在的属性会被拦截，只有不在的才会跳出拦截。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>post: {<br>  id: 1,<br>  title: ‘xxxx’,<br>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">## 单向数据流</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t简单来说，对于这个父子组件的值的传递，所以为了保证子组件意外变更父级组件的状态，我们让子组件不能进行更新，更新会报出警告。并且不能进行更改。</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t然而记住，这个只是对栈进行了一个锁定，并没有对堆进行锁定，所以简单来说就是值类型是会被警告，但是对于引用类型来说，还是可以直接进行修改，并不会爆出警告。</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t这是一个需要记住的问题。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t对于会进行修改数据，但是又不想污染了父组件的data的，我们这里，有两个方式</span><br><span class=\"line\"></span><br><span class=\"line\">* 第一种就是使用了data将props的值重新进行赋值了 **这个子组件接下来希望将其作为一个本地的 prop 数据来使用** 。</span><br><span class=\"line\">  * ```</span><br><span class=\"line\">    props: [&#x27;initialCounter&#x27;],</span><br><span class=\"line\">    data: function () &#123;</span><br><span class=\"line\">      return &#123;</span><br><span class=\"line\">        counter: this.initialCounter</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>第二种就是使用计算属性，简单来说就是并没有修改原数据，仅仅只是使用了原数据。常用于 <strong>以一种原始的值传入且需要进行转换</strong> 。</li>\n</ul>\n<h2 id=\"Prop-验证\"><a href=\"#Prop-验证\" class=\"headerlink\" title=\"Prop 验证\"></a>Prop 验证</h2><p>​        验证类型是否满足需求，以及是否是必填项。</p>\n<h3 id=\"类型检查\"><a href=\"#类型检查\" class=\"headerlink\" title=\"类型检查\"></a>类型检查</h3><ul>\n<li>类型的限制</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">props: &#123;</span><br><span class=\"line\">\tA: Number,</span><br><span class=\"line\">\tB: [Number, String],</span><br><span class=\"line\">\tC: &#123;</span><br><span class=\"line\">\t\ttype: String,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>是否为必填项和默认值</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">props: &#123;</span><br><span class=\"line\">\tA: &#123;</span><br><span class=\"line\">\t\trequired: true,</span><br><span class=\"line\">\t\tdefault: &#x27;AA&#x27;,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>注意：</strong></p>\n<p>对象和数组的默认值必须从一个工厂函数获取。简单来说就是需要是一个函数，函数返回一个对象或者数组。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">default: () =&gt; &#123;</span><br><span class=\"line\">\treturn &#123;</span><br><span class=\"line\">\t\ta: 1</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<ul>\n<li>自定义一个验证函数</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A: &#123;</span><br><span class=\"line\">\tvalidator: function(value) &#123;</span><br><span class=\"line\">\t\t//返回值是 true 和 false</span><br><span class=\"line\">\t\treturn true;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<blockquote>\n<p>​        注意那些 prop 会在一个组件实例创建<strong>之前</strong>进行验证，所以实例的 property (如 <code>data</code>、<code>computed</code> 等) 在 <code>default</code> 或 <code>validator</code> 函数中是不可用的。</p>\n</blockquote>\n<h2 id=\"非-Prop-的-Attribute\"><a href=\"#非-Prop-的-Attribute\" class=\"headerlink\" title=\"非 Prop 的 Attribute\"></a>非 Prop 的 Attribute</h2><p>​        一个非 prop 的 attribute 是指传向一个组件，但是该组件并没有相应 prop 定义的 attribute。</p>\n<p>​        这个在前面也有说过，因为prop的传递是在标签上进行的传递，那么怎么区别这个属性是prop的值还是我是要给标签上的值呢。这里就是非Prop的属性</p>\n<p>​        简单来理解，就是对于声明的属性，但是却没有prop属性进行接收，那么就会被添加到组件的根元素上。</p>\n<h3 id=\"替换-合并已有的-Attribute\"><a href=\"#替换-合并已有的-Attribute\" class=\"headerlink\" title=\"替换/合并已有的 Attribute\"></a>替换/合并已有的 Attribute</h3><p>​        简单来说就是我在组件的根元素上已经存在了这个属性，但是我在外面使用的使用对这个属性进行了重新的赋值，但是我的需求不是进行覆盖，而是进行合并，此时就是这个 替换/合并 属性</p>\n<p>​        但是这里从官网上看出，并没有什么方法，但是对于 class 和 style 这两个属性，我们会进行合并操作，但是对于其他属性，比如 type 等，我们就会出现替换掉的操作。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">子组件，c-c</span><br><span class=\"line\">div.A[type=&#x27;AA&#x27;]</span><br><span class=\"line\"></span><br><span class=\"line\">父组件的使用</span><br><span class=\"line\">c-c.B[type=&#x27;BB&#x27;]</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"禁用-Attribute-继承\"><a href=\"#禁用-Attribute-继承\" class=\"headerlink\" title=\"禁用 Attribute 继承\"></a>禁用 Attribute 继承</h3><p>​        简单来说就是因为在使用这个组件时，一些没有被prop的属性会被加入根标签，但是有的时候是不想这样的，所以我们可以使用 inheritAttrs: false，代表了继承属性为false。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Vue.component(&#x27;my-component&#x27;, &#123;</span><br><span class=\"line\">\t//这个属性，为false，代表了多余的属性不会被记录在dom树上。（多余是指没有在props定义的），默认为true。</span><br><span class=\"line\">  inheritAttrs: false,</span><br><span class=\"line\">  // ...</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>​        当然对于需要被继承的属性，我们可以使用 $attrs 进行获取。这个属性包含了一个属性名和一个属性值。</p>\n<p>​        通过 inheritAttrs 和 $attrs 这两个属性，就可以自己决定属性应该被赋予哪个元素。通常用于编写基础组件。</p>\n<p>​        下面这个例子，首先，使用了 inheritAttrs 进行了拦截。对于props不存在的属性将不会出现在根元素上。然后再对input标签上添加了一个 v-bind=”$attrs” 因为$attrs 属性是一个键值对。然后将其赋值给了input标签上。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Vue.component(&#x27;base-input&#x27;, &#123;</span><br><span class=\"line\">  inheritAttrs: false,</span><br><span class=\"line\">  props: [&#x27;label&#x27;, &#x27;value&#x27;],</span><br><span class=\"line\">  template: `</span><br><span class=\"line\">    &lt;label&gt;</span><br><span class=\"line\">      &#123;&#123; label &#125;&#125;</span><br><span class=\"line\">      &lt;input</span><br><span class=\"line\">        v-bind=&quot;$attrs&quot;</span><br><span class=\"line\">        v-bind:value=&quot;value&quot;</span><br><span class=\"line\">        v-on:input=&quot;$emit(&#x27;input&#x27;, $event.target.value)&quot;</span><br><span class=\"line\">      &gt;</span><br><span class=\"line\">    &lt;/label&gt;</span><br><span class=\"line\">  `</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;base-input</span><br><span class=\"line\">  label=&quot;Username:&quot;</span><br><span class=\"line\">  v-model=&quot;username&quot;</span><br><span class=\"line\">  required</span><br><span class=\"line\">  placeholder=&quot;Enter your username&quot;</span><br><span class=\"line\">&gt;&lt;/base-input&gt;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$attrs 的值。</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\trequired: &quot;&quot;</span><br><span class=\"line\">\tplaceholder: &quot;Enter your username&quot;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意 <code>inheritAttrs: false</code> 选项<strong>不会</strong>影响 <code>style</code> 和 <code>class</code> 的绑定。</p>\n</blockquote>\n<p>​        通过这个方式来进行操作的话，不用担心哪个是真正的根元素。</p>\n<h1 id=\"自定义事件\"><a href=\"#自定义事件\" class=\"headerlink\" title=\"自定义事件\"></a>自定义事件</h1><h2 id=\"事件名\"><a href=\"#事件名\" class=\"headerlink\" title=\"事件名\"></a>事件名</h2><p>​        首先要注意一个地方，那就是，对于 vue 的 v-on 监听来说，（语法糖是@）。这个是不会将短横线转为驼峰的。</p>\n<p>​        我们从前面可以知道，对于 props 来说，传递的属性如果是短横线，那么在props里面可以使用驼峰来进行处理，但是对于事件来说不行。</p>\n<p>​        这里就会好奇为什么prop可以短横线转驼峰，但是事件不能呢。有的说是JavaScript的命名规范里面不能使用短横线命名。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">this.$emit(&#x27;myEvent&#x27;)</span><br><span class=\"line\">&lt;!-- 没有效果 --&gt;</span><br><span class=\"line\">因为 短横线不能转换为驼峰。所以没有效果。</span><br><span class=\"line\">&lt;my-component v-on:my-event=&quot;doSomething&quot;&gt;&lt;/my-component&gt;</span><br></pre></td></tr></table></figure>\n\n<p>​        所以对于 @myEvent 将会被转化为 @myevent。</p>\n<p>​        所以最好的建议就是全部都是用 kebab-case。这里不但有HTML大小写不敏感的原因，还有对于模板字符串来说。大小写是规定的。</p>\n<h2 id=\"自定义组件的v-model-2-2-0\"><a href=\"#自定义组件的v-model-2-2-0\" class=\"headerlink\" title=\"自定义组件的v-model 2.2.0+\"></a>自定义组件的v-model 2.2.0+</h2><p>​        v-model 这个默认是利用名为 value 的prop 和 input 的事件。当然对于input的单选框和其他的会将value属性用于不同的prop。但是我们可以使用 model 选项来解决 v-model的冲突。</p>\n<p>​        简单的理解一下下面的内容，prop：checked，这个默认是value，代表了使用props的checked作为v-model的绑定。event：change，默认是input，代表监听的事件名称是change，这些都是可以进行修改的。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Vue.component(&#x27;base-checkbox&#x27;, &#123;</span><br><span class=\"line\">  model: &#123;</span><br><span class=\"line\">    prop: &#x27;checked&#x27;,</span><br><span class=\"line\">    event: &#x27;change&#x27;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  props: &#123;</span><br><span class=\"line\">    checked: Boolean</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  template: `</span><br><span class=\"line\">    &lt;input</span><br><span class=\"line\">      type=&quot;checkbox&quot;</span><br><span class=\"line\">      v-bind:checked=&quot;checked&quot;</span><br><span class=\"line\">      v-on:change=&quot;$emit(&#x27;change&#x27;, $event.target.checked)&quot;</span><br><span class=\"line\">    &gt;</span><br><span class=\"line\">  `</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>​        比如我这里进行一个修改。就是将 prop 的checked改成了XXX，于是相对应的。props的名字也要有一个XXX的存在。同理。我可以将event改成一个AAA，那么就会将emit提交的事件名称修改为AAA。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">model: &#123;</span><br><span class=\"line\">  prop: &#x27;XXX&#x27;,</span><br><span class=\"line\">  event: &#x27;AA&#x27;</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">props: &#123;</span><br><span class=\"line\">  XXX: String</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">template: `</span><br><span class=\"line\">  &lt;input</span><br><span class=\"line\">  :value=&quot;XXX&quot;</span><br><span class=\"line\">  @change=&quot;$emit(&#x27;AA&#x27;, $event.target.value)&quot;</span><br><span class=\"line\">  &gt;</span><br><span class=\"line\">`</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意你仍然需要在组件的 props 选项里声明 checked 这个 prop。</p>\n</blockquote>\n<h2 id=\"将原生事件绑定到组件\"><a href=\"#将原生事件绑定到组件\" class=\"headerlink\" title=\"将原生事件绑定到组件\"></a>将原生事件绑定到组件</h2><p>​        简单来说就是我想对一个标签进行监听，比如input监听，方法在本身，但是组件的input标签是在子组件的。那么此时我们就可以发现。子组件的输入并不会调用这个方法。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;base-input @input=&quot;onInput&quot;&gt;&lt;/base-input&gt;</span><br></pre></td></tr></table></figure>\n\n<p>​        我们可以先做一个原生的示例。通过下面这个示例我们可以发现。在输入input的时候会输出1，2 。因为这个是冒泡的原因。所以先进行的子组件的执行，再进行的父组件的执行。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div oninput=&quot;console.log(2);&quot;&gt;</span><br><span class=\"line\">  &lt;input oninput=&quot;console.log(1);&quot;/&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n\n<p>​        那么我们做一个vue组件的示例。并且我们也可以发现。此时就不会执行 myInput 方法了。只会执行组件内部的input的方法。不会执行外部的。原因的话。我们可以知道对于没有props接收的属性一般会被加入根元素，但是我们可以发现对于 监听属性来说，并没有加入到根元素。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=&quot;app&quot;&gt;</span><br><span class=\"line\">  &lt;base-input @input=&quot;myInput&quot;&gt;&lt;/base-input&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">Vue.component(&#x27;base-input&#x27;, &#123;</span><br><span class=\"line\">  template: `&lt;input @input=&quot;CInput&quot;&gt;`,</span><br><span class=\"line\">  methods: &#123;</span><br><span class=\"line\">    CInput() &#123;</span><br><span class=\"line\">      console.log(&#x27;c&#x27;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>​        具体的原因还不清楚。但是要记住就是直接使用监听是不会被监听成功的。有可能是监听要通过JavaScript进行操作，但是组件的元素会被替换，所以监听会失效。</p>\n<p>​        因此我们可以使用 .native 修饰符 那么此时就可以将监听放入根元素了。当然，这个的效果简单来说就是会将事件绑定给根元素。但是如果本来根元素不支持这个事件，那么就会静默失败，比如 div的根元素绑定一个focus，就会失败。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;base-input @input.native=&quot;myInput&quot;&gt;&lt;/base-input&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>​        此时，对于根元素并不是我想要绑定的元素，这个时候，我们知道，对于props，有一个叫做。$attrs，和 inheritAttrs 进行搭配，可以使父组件传递的props在子组件能够有一个自己规定的位置出现。那么同时事件也有一个 $listeners 属性，他是一个对象，里面包含了作用在这个组件上的监听器。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div&gt;&lt;input v-on=&quot;$listeners&quot; @input=&quot;CInput&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n\n<p>​        但是注意，如果使用了 .native 那么将不会出现在 $listeners 里面。不管 .native 是否会绑定成功。</p>\n<p>​        下面这个是使用computed，这里记住一个问题，那就是 下面这个写法是会将 input 的监听进行覆盖的一个操作。但是又通过了 $emit 向上通知了父组件的 input。同理 使用 this.$listeners[‘input’] 也会覆盖input。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">computed: &#123;</span><br><span class=\"line\">  inputListeners: function () &#123;</span><br><span class=\"line\">    var vm = this</span><br><span class=\"line\">    // `Object.assign` 将所有的对象合并为一个新对象</span><br><span class=\"line\">    return Object.assign(&#123;&#125;,</span><br><span class=\"line\">      // 我们从父级添加所有的监听器</span><br><span class=\"line\">      this.$listeners,</span><br><span class=\"line\">      // 然后我们添加自定义监听器，</span><br><span class=\"line\">      // 或覆写一些监听器的行为</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        // 这里确保组件配合 `v-model` 的工作</span><br><span class=\"line\">        input: function (event) &#123;</span><br><span class=\"line\">        \tvm.$emit(&#x27;input&#x27;, event.target.value)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"sync修饰符-2-3-0\"><a href=\"#sync修饰符-2-3-0\" class=\"headerlink\" title=\".sync修饰符 2.3.0+\"></a>.sync修饰符 2.3.0+</h2><p>​        因为双向绑定会带来维护上的问题。因为对于data的变更不清楚来源。</p>\n<p>​        所以我们推荐 update:myPropName 来代替。在一个包含 title 的假设的组件。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">this.$emit(&#x27;update:title&#x27;, newTitle)</span><br></pre></td></tr></table></figure>\n\n<p>​        因此就引出了sync修饰符，这算是一个语法糖。</p>\n<ul>\n<li><p>对于父组件来说，变化就是将 :title 和 :update:title 进行了合并，简单来说就像是进行了 v-model 的操作一样。</p>\n<ul>\n<li>```<br>&lt;base-input<br>  v-bind:title=”a”<br>  v-on:update:title=”a”<blockquote>\n\n</blockquote>\n<base-input :title.sync=\"a\"></base-input><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">* 对于子组件来说，没有什么变化， 这里的 :title.sync 就是 @update:title 加上了 :title，所以对于 $emit 也是使用原来的 update:title 进行的提交。</span><br><span class=\"line\"></span><br><span class=\"line\">  * ```</span><br><span class=\"line\">    this.$emit(&#x27;update:title&#x27;, Math.random());</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ul>\n<p>在这里，还有一个问题就是。我们可以发现对于 emit提交时带的参数，父组件如果要将方法写在那个标签上进行表达式的执行，那么 $event 就是第一个参数。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">this.$emit(&#x27;update:title&#x27;, 1);</span><br><span class=\"line\"></span><br><span class=\"line\">//这里的 $event 就是 子元素在 $emit 提交时的第二个参数，从第二个参数开始的提交就是会传递给父元素的参数。这里只是第二个，如果没有参数的话，就会为undefined</span><br><span class=\"line\">&lt;base-input @update:title=&quot;a = $event&quot;&gt;&lt;/base-input&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n<blockquote>\n<p>注意带有 <code>.sync</code> 修饰符的 <code>v-bind</code> <strong>不能</strong>和表达式一起使用 (例如 <code>v-bind:title.sync=”doc.title + ‘!’”</code> 是无效的)。取而代之的是，你只能提供你想要绑定的 property 名，类似 <code>v-model</code>。</p>\n</blockquote>\n<p>​        当然，这里的 sync修饰符 也可以和 v-bind 进行搭配</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;text-document v-bind.sync=&quot;doc&quot;&gt;&lt;/text-document&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">this.$emit(&#x27;update:title&#x27;, 1111);</span><br></pre></td></tr></table></figure>\n\n\n\n<blockquote>\n<p>将 <code>v-bind.sync</code> 用在一个字面量的对象上，例如 <code>v-bind.sync=”&#123; title: doc.title &#125;”</code>，是无法正常工作的，因为在解析一个像这样的复杂表达式的时候，有很多边缘情况需要考虑。</p>\n</blockquote>\n<h1 id=\"插槽\"><a href=\"#插槽\" class=\"headerlink\" title=\"插槽\"></a>插槽</h1><p>​        简单来说就是，因为Vue的组件化思路，所以很多都是以组件进行的开发。但是为了降低组件和组件的解耦性，就可以使用插槽，将组件之间的联系进一步的降低。</p>\n<p>​        在 2.6.0中，提供了新的语法 v-slot 来代替了 slot 和 slot-scope</p>\n<h2 id=\"插槽内容\"><a href=\"#插槽内容\" class=\"headerlink\" title=\"插槽内容\"></a>插槽内容</h2><p>​        </p>\n<p><strong>一个简单的示例</strong></p>\n<p>​        下面的示例就代表了 Your Profile 将会代替 slot这个标签进行显示。当然 插槽的内部可以包含任何模板代码，包括HTML和其他组件，这也是我们常会使用的方法。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;navigation-link url=&quot;/profile&quot;&gt;</span><br><span class=\"line\">  Your Profile</span><br><span class=\"line\">&lt;/navigation-link&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&lt;a&gt;</span><br><span class=\"line\">  &lt;slot&gt;&lt;/slot&gt;</span><br><span class=\"line\">&lt;/a&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"编译作用域\"><a href=\"#编译作用域\" class=\"headerlink\" title=\"编译作用域\"></a>编译作用域</h2><p>​        简单来说，看下面这个代码，这个 a 应该是 父级组件上的 a呢，还是子组件上的a呢。</p>\n<p>​        最终的结果就是这个是 父级组件上的a。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div&gt;</span><br><span class=\"line\">\t&lt;base-input&gt;&#123;&#123; a &#125;&#125;&lt;/base-input&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n\n<p>这里有条规则</p>\n<blockquote>\n<p>父级模板里的所有内容都是在父级作用域中编译的；子模板里的所有内容都是在子作用域中编译的。</p>\n</blockquote>\n<h2 id=\"后背内容\"><a href=\"#后背内容\" class=\"headerlink\" title=\"后背内容\"></a>后背内容</h2><p>​        简单来说就是一个插槽的默认值。简单来说就是写在 slot 里面的内容就是 插槽的默认值。</p>\n<p>​        如果你在使用组件的时候没有使用插槽，那么就会使用这个默认的内容，并且这个默认的内容的作用域是在子组件的。</p>\n<p>​        如果提供有内容，那么便会渲染来取代内容。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div&gt;&lt;slot&gt;&#123;&#123; x &#125;&#125;&lt;/slot&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"具名插槽\"><a href=\"#具名插槽\" class=\"headerlink\" title=\"具名插槽\"></a>具名插槽</h2><p>​        简单来说就是使用name将插槽能够指定的使用在某个位置。对于没有使用name的，会有一个默认的name default。 </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;slot name=&quot;header&quot;&gt;&lt;/slot&gt;</span><br></pre></td></tr></table></figure>\n\n<p>​        那么在使用这个具名插槽的时候，我们就可以使用一个 template 进行包裹，然后在里面使用 v-slot指令，并以 v-slot 的参数的形式提供名称。</p>\n<p>​        从下面的代码可以看出，对于使用了 template加上v-slot的，就是寻找name相对应的。对于没有使用的就会被作为一个默认，就算中间隔了一个template v-slot 也一样。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;base-layout&gt;</span><br><span class=\"line\">  &lt;template v-slot:header&gt;</span><br><span class=\"line\">    &lt;h1&gt;Here might be a page title&lt;/h1&gt;</span><br><span class=\"line\">  &lt;/template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">  &lt;p&gt;A paragraph for the main content.&lt;/p&gt;</span><br><span class=\"line\">  &lt;p&gt;And another one.&lt;/p&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">  &lt;template v-slot:footer&gt;</span><br><span class=\"line\">    &lt;p&gt;Here&#x27;s some contact info&lt;/p&gt;</span><br><span class=\"line\">  &lt;/template&gt;</span><br><span class=\"line\">&lt;/base-layout&gt;</span><br></pre></td></tr></table></figure>\n\n<p>​        当然，为了语义的方便，我们建议还是可以将默认的放入一个 template v-slot:default，当然，这个default不要也可以，但是如果加了default，那么就不会将其他外层标签也加入默认，但是如果没有加上default的话，那么就会加入默认。</p>\n<p>​        比如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;template v-slot:default&gt;</span><br><span class=\"line\">  &lt;p&gt;A paragraph for the main content.&lt;/p&gt;</span><br><span class=\"line\">  &lt;p&gt;And another one.&lt;/p&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\">//下面这个不会显示。</span><br><span class=\"line\">&lt;p&gt;And another one.&lt;/p&gt;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  &lt;p&gt;A paragraph for the main content.&lt;/p&gt;</span><br><span class=\"line\">  &lt;p&gt;And another one.&lt;/p&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\">//上面的template没有使用default，下面这个会显示出来，因为都被算在了插槽里面</span><br><span class=\"line\">&lt;p&gt;And another one.&lt;/p&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"作用域插槽\"><a href=\"#作用域插槽\" class=\"headerlink\" title=\"作用域插槽\"></a>作用域插槽</h2><p>​        2.6.0 废弃了 slot-scope</p>\n<p>​        因为我们可以知道，插槽的默认的作用域是编译时的环境，所以一般常常是父级作用域，那么此时我们要如何将作用域作用域子级。</p>\n<p>​        这个时候就是要使用作用域插槽的时候了。</p>\n<ul>\n<li>简单来说就是子组件在进行slot创建时，通过 v-bind 绑定一个属性，然后属性的值是data的值。</li>\n<li>然后在使用的时候，通过 v-slot:xx=”xxx” 进行了属性的获取，这里 xxx就是子组件传递过来的一系列的属性而形成的对象。</li>\n<li>此时我们就可以在父组件里面使用到子组件的data了，当然，建议这个还是少使用吧，因为这个造成了组件的透明度降低。</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;slot :x=&quot;x1&quot;&gt;&lt;/slot&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;template v-slot:default=&quot;a&quot;&gt;</span><br><span class=\"line\">a.x</span><br><span class=\"line\">&lt;/template&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"独占默认插槽的缩写语法\"><a href=\"#独占默认插槽的缩写语法\" class=\"headerlink\" title=\"独占默认插槽的缩写语法\"></a>独占默认插槽的缩写语法</h3><p>​        就是说，只有被提供的内容只存在默认插槽的存在时，组件的标签才可以被当作插槽的模板来使用。此时我们就可以直接把 v-slot 用在组件上。</p>\n<p>​        这里我们首先知道 v-slot 可以使用在组件上，并且插槽是可以接收一个组件的。但是我们后面可以发现，如果直接使用组件，会出现插槽的位置无法正确的定位。</p>\n<p>​        然后我么可以发现，其实对组件是不能进行插槽的定位的。意思就是说，对于组件来说，使用插槽的 v-slot 不能定位到对应的具名插槽。</p>\n<p>​        比如下面这个情况，我开始以为 v-slot:footer 和 v-slot:header，都会按照正确的位置进行拜访，因为这个就是具名插槽的作用，只能用于template，对于下面这个test组件，虽然我们也使用了 v-slot:header 但是他并没有去header，而是就为普通的标签的行为。v-slot不会在除了template上起作用。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;base-input&gt;</span><br><span class=\"line\">  &lt;template v-slot:footer&gt;</span><br><span class=\"line\">  \t&lt;ttt&gt;&lt;/ttt&gt;</span><br><span class=\"line\">  &lt;/template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">  &lt;p&gt;123&lt;/p&gt;</span><br><span class=\"line\">  &lt;p&gt;111&lt;/p&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">  &lt;test v-slot:header&gt;&lt;/test&gt;</span><br><span class=\"line\">&lt;/base-input&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;current-user v-slot:default=&quot;slotProps&quot;&gt;</span><br><span class=\"line\">  &#123;&#123; slotProps.user.firstName &#125;&#125;</span><br><span class=\"line\">&lt;/current-user&gt;</span><br></pre></td></tr></table></figure>\n\n<p>​        缩写语法</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;current-user v-slot=&quot;slotProps&quot;&gt;</span><br><span class=\"line\">  &#123;&#123; slotProps.user.firstName &#125;&#125;</span><br><span class=\"line\">&lt;/current-user&gt;</span><br></pre></td></tr></table></figure>\n\n<p>​        案例形式。简单来说就是，如果base-input内部只有一个默认插槽，那么我们可以将这个 base-input 内部的整体都作为一个 slot的代替，如果是以前， base-input&gt;template[v-slot=”slotProps”] 但是我们可以将template进行省略，所以变成了 base-input[v-slot=”slotProps”]</p>\n<p>​        当然，上面这个也是进行了缩写了的。完整的话，需要加上 v-slot:default。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;base-input v-slot=&quot;slotProps&quot;&gt;</span><br><span class=\"line\">&lt;/base-input&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"解构插槽Prop\"><a href=\"#解构插槽Prop\" class=\"headerlink\" title=\"解构插槽Prop\"></a>解构插槽Prop</h3><p>​        简单来说就是说，作用域插槽的内部原理就是将插槽的内容包裹在一个参数的函数内部。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function (slotProps) &#123;</span><br><span class=\"line\">  // 插槽内容</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>​        在下面这个标签的使用里。使用了解构赋值的形式， { user } = slotProps，在这里，解构赋值的效果就是，取出了 slotProps的user给了 user。当然我们也可以使用其他的解构赋值的行为。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;current-user v-slot=&quot;&#123; user &#125;&quot;&gt;</span><br><span class=\"line\">  &#123;&#123; user.firstName &#125;&#125;</span><br><span class=\"line\">&lt;/current-user&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"动态插槽名\"><a href=\"#动态插槽名\" class=\"headerlink\" title=\"动态插槽名\"></a>动态插槽名</h2><p>​        2.6.0 新增</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;template v-slot:[dynamicSlotName]&gt;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&lt;/template\t&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"具名插槽的缩写\"><a href=\"#具名插槽的缩写\" class=\"headerlink\" title=\"具名插槽的缩写\"></a>具名插槽的缩写</h2><p>​        2.6.0 新增</p>\n<p>​        简单来说，就是插槽的语法糖，v-slot =&gt; #，但是对于没有参数的话是无效的。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;current #header=&quot;&#123; user &#125;&quot;&gt;&lt;/current&gt;</span><br><span class=\"line\">//下面这个是无效的。</span><br><span class=\"line\">&lt;current #=&quot;&#123; user &#125;&quot;&gt;&lt;/current&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"动态组件-amp-异步组件\"><a href=\"#动态组件-amp-异步组件\" class=\"headerlink\" title=\"动态组件&amp;异步组件\"></a>动态组件&amp;异步组件</h1><h2 id=\"在动态组件上使用-keep-alive\"><a href=\"#在动态组件上使用-keep-alive\" class=\"headerlink\" title=\"在动态组件上使用 keep-alive\"></a>在动态组件上使用 keep-alive</h2><p>​        之前，我们使用 is 属性来对组件进行切换。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;component v-bind:is=&quot;currentTabComponent&quot;&gt;&lt;/component&gt;</span><br></pre></td></tr></table></figure>\n\n<p>​        现在，我们在组件进行切换的时候，想要保存组件的状态。以避免重复的渲染。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- 失活的组件将会被缓存！--&gt;</span><br><span class=\"line\">&lt;keep-alive&gt;</span><br><span class=\"line\">  &lt;component v-bind:is=&quot;currentTabComponent&quot;&gt;&lt;/component&gt;</span><br><span class=\"line\">&lt;/keep-alive&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"异步组件\"><a href=\"#异步组件\" class=\"headerlink\" title=\"异步组件\"></a>异步组件</h2><p>​        将应用分割成小一些的代码块，并且只在需要的时候才从服务器进行加载。对此Vue允许使用一个工厂函数的方式进行定义组件。Vue只有在这个组件需要被渲染，并把结果缓存起来供未来重渲染。</p>\n<p>​        下面这个简单的例子，表示了第二个参数是一个函数，函数需要使用resolve和reject，表示会以promise进行调用，通过resolve返回渲染对象，荣国reject表示加载失败。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Vue.component(&#x27;async-example&#x27;, function (resolve, reject) &#123;</span><br><span class=\"line\">  setTimeout(function () &#123;</span><br><span class=\"line\">    // 向 `resolve` 回调传递组件定义</span><br><span class=\"line\">    resolve(&#123;</span><br><span class=\"line\">      template: &#x27;&lt;div&gt;I am async!&lt;/div&gt;&#x27;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;, 1000)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>​        一个推荐的做法是将异步组件和 <a href=\"https://webpack.js.org/guides/code-splitting/\">webpack 的 code-splitting 功能</a>一起配合使用</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Vue.component(&#x27;async-webpack-example&#x27;, function (resolve) &#123;</span><br><span class=\"line\">  // 这个特殊的 `require` 语法将会告诉 webpack</span><br><span class=\"line\">  // 自动将你的构建代码切割成多个包，这些包</span><br><span class=\"line\">  // 会通过 Ajax 请求加载</span><br><span class=\"line\">  require([&#x27;./my-async-component&#x27;], resolve)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>​        但是因为我这个异步组件和搭配webpack这个用的比较少，所以在这里就没有进行详细的讲述，就直接贴上Vue的官网链接了。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://cn.vuejs.org/v2/guide/components-dynamic-async.html#异步组件</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"处理加载状态\"><a href=\"#处理加载状态\" class=\"headerlink\" title=\"处理加载状态\"></a>处理加载状态</h3><p>​        2.3.0 新增</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const AsyncComponent = () =&gt; (&#123;</span><br><span class=\"line\">  // 需要加载的组件 (应该是一个 `Promise` 对象)</span><br><span class=\"line\">  component: import(&#x27;./MyComponent.vue&#x27;),</span><br><span class=\"line\">  // 异步组件加载时使用的组件</span><br><span class=\"line\">  loading: LoadingComponent,</span><br><span class=\"line\">  // 加载失败时使用的组件</span><br><span class=\"line\">  error: ErrorComponent,</span><br><span class=\"line\">  // 展示加载时组件的延时时间。默认值是 200 (毫秒)</span><br><span class=\"line\">  delay: 200,</span><br><span class=\"line\">  // 如果提供了超时时间且组件加载也超时了，</span><br><span class=\"line\">  // 则使用加载失败时使用的组件。默认值是：`Infinity`</span><br><span class=\"line\">  timeout: 3000</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n\n\n<blockquote>\n<p>注意如果你希望在 <a href=\"https://github.com/vuejs/vue-router\">Vue Router</a> 的路由组件中使用上述语法的话，你必须使用 Vue Router 2.4.0+ 版本。</p>\n</blockquote>\n<h1 id=\"处理边界情况\"><a href=\"#处理边界情况\" class=\"headerlink\" title=\"处理边界情况\"></a>处理边界情况</h1><h2 id=\"访问元素-amp-组件\"><a href=\"#访问元素-amp-组件\" class=\"headerlink\" title=\"访问元素 &amp; 组件\"></a>访问元素 &amp; 组件</h2><h3 id=\"访问根实例-this-root\"><a href=\"#访问根实例-this-root\" class=\"headerlink\" title=\"访问根实例 this.$root\"></a>访问根实例 this.$root</h3><p>​        这个可以通过 <code>this.$root</code>，进行访问。如果是methods里面的方法aa，那么就可以通过 <code>this.$root.aa</code> 进行访问。</p>\n<p>​        所有的子组件都可以将这个实例作为一个全局 store 来访问或者使用。</p>\n<blockquote>\n<p>对于 demo 或非常小型的有少量组件的应用来说这是很方便的。不过这个模式扩展到中大型应用来说就不然了。因此在绝大多数情况下，我们强烈推荐使用 <a href=\"https://github.com/vuejs/vuex\">Vuex</a> 来管理应用的状态。</p>\n</blockquote>\n<h3 id=\"访问父级组件实例\"><a href=\"#访问父级组件实例\" class=\"headerlink\" title=\"访问父级组件实例\"></a>访问父级组件实例</h3><p>​        可以通过 $parent 属性来访问一个父组件的实例。<br>​        但是请注意，这样写虽然是可以直接对父组件进行了操作，可以代替props来进行数据的访问，但是却会造成数据的修改时不清楚修改的源头。</p>\n<h3 id=\"访问子组件实例或子元素\"><a href=\"#访问子组件实例或子元素\" class=\"headerlink\" title=\"访问子组件实例或子元素\"></a>访问子组件实例或子元素</h3><p>​        可以通过 ref 属性，为子组件赋予一个ID引用。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;base-input ref=&quot;usernameInput&quot;&gt;&lt;/base-input&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">那么父组件就可以通过 this.$refs.usernameInput 来访问子组件了。</span><br></pre></td></tr></table></figure>\n\n<p>​        但是记住，this.$refs，里面存放的只会有属于自己的子组件，以及有可能会有自己的子孙级组件。这个我们一会儿就说。</p>\n<p>​        ref同时也可以写在原生的HTML标签上面，for example <code>&lt;input type=&quot;text&quot; ref=&quot;inpu&quot;&gt;</code> 如果写在了原生的HTML上面，我们通过$refs获取时也是一个原生的标签，并且也可以使用方法，比如 <code>focus</code> 等。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=&quot;app&quot;&gt;</span><br><span class=\"line\">    &lt;input type=&quot;text&quot; ref=&quot;input&quot;&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">//在父组件的方法里面使用这个便可以调用input的原生focus进行聚焦。</span><br><span class=\"line\">this.$refs.inpu.focus()</span><br></pre></td></tr></table></figure>\n\n\n\n<p>关于父组件的 refs 是否会含有子组件，这个应该是在哪个组件被编译就会存在于哪个组件。</p>\n<p>​        比如看看下面这个文件的内容。template存在一个插槽和input，然后在使用组件的时候，插槽又是插入了一个input，但是如果我们查看结果，就会发现，插槽所写的ref会存在与父组件，而在template里面所写的，便会存在于子组件。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template: `&lt;div&gt;&lt;slot&gt;&lt;/slot&gt;&lt;input type=&quot;text&quot; ref=&quot;input&quot;&gt;&lt;/div&gt;`,</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;aaaa ref=&quot;ssss&quot;&gt;</span><br><span class=\"line\">    &lt;input type=&quot;text&quot; ref=&quot;inpu&quot;&gt;</span><br><span class=\"line\">&lt;/aaaa&gt;</span><br></pre></td></tr></table></figure>\n\n<p>​        当 ref 和 v-for 一起使用的时候，ref会包含整个数组。一般来说，refs是一个对象，但是对于使用了v-for的来说，就会变成一个数组，就算是ref使用了v-bind 进行了绑定，也会变为存在不同ref的对象，内部含有数组。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;li :ref=&quot;i&quot; v-for=&quot;i in 10&quot;&gt;&lt;/li&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">1: [li]</span><br><span class=\"line\">2: [li]</span><br><span class=\"line\">3: [li]</span><br><span class=\"line\">4: [li]</span><br><span class=\"line\"></span><br><span class=\"line\">形成的还是数组，虽然数组的长度只有1。</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"依赖注入\"><a href=\"#依赖注入\" class=\"headerlink\" title=\"依赖注入\"></a>依赖注入</h3><p>​        简单来说，就是父子组件可以通过 $parent 来进行访问，但是对于嵌套的情况，会造成 $parent.$parent 那么此时就是依赖注入的时候。</p>\n<p>​        这里用到了两个新的实例的选项。 provide &amp; inject</p>\n<p><strong>provide</strong> 选项允许我们指定我们想要提供给后代组件的数据/方法。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">provide: function() &#123;</span><br><span class=\"line\">\treturn &#123;</span><br><span class=\"line\">\t\tget: this.get</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>inject</strong> 在任何后代组件里，我们都可以使用 inject 选项来接收指定的属性进行注入。</p>\n<p><strong>例子</strong>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">father</span><br><span class=\"line\">\tchildren</span><br><span class=\"line\">\t\tgrandson</span><br><span class=\"line\"></span><br><span class=\"line\">那么此时 grandson要使用 father组件的方法就需要 this.$parent.$parent 来进行调用，但是对于有多层的调用会出现意想不到的问题。</span><br></pre></td></tr></table></figure>\n\n<p>​        使用 provide 和 inject 进行处理，需要记住，这个的调用创建应该是先于data，所以如果当data和inject进行了重合，那么便会出现data覆盖了inject，但是他们都是属于 init injected &amp; reacted 周期。在使用 beforeCreate 之后， 以及 created 之前。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">先使用 provide 进行提供需要给后代的方法和数据。</span><br><span class=\"line\">const app = new Vue(&#123;</span><br><span class=\"line\">\tprovide() &#123;</span><br><span class=\"line\">\t\treturn &#123;</span><br><span class=\"line\">\t\t\tname: this.output,</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">然后在后代使用 inject 进行注入，注入之后就可以使用 this.name进行使用。</span><br><span class=\"line\">Vue.component(&#x27;xx&#x27;, &#123;</span><br><span class=\"line\">\tinject: [&#x27;name&#x27;],</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"程序化的事件侦听器\"><a href=\"#程序化的事件侦听器\" class=\"headerlink\" title=\"程序化的事件侦听器\"></a>程序化的事件侦听器</h2><p>通过 $on(eventName, eventHandler) 来侦听一个事件。</p>\n<p>通过 $once(eventName, eventHandler) 来一次性的侦听一个事件。</p>\n<p>通过 $off(eventName, eventHandler)  来停止侦听一个事件。</p>\n<p>一般来说是很少进行使用的，但是当你需要在一个组件的实例上手动的侦听事件时，它们便派上了用场。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mounted() &#123;</span><br><span class=\"line\">\tthis.pi = new Pi(&#123;&#125;);</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">beforeDestroy() &#123;</span><br><span class=\"line\">\tthis.pi.destroy();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果使用程序化的侦听器来解决这个问题：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mounted() &#123;</span><br><span class=\"line\">\tconst pi = new Pi(&#123;&#125;);</span><br><span class=\"line\">\tthis.$once(&#x27;hook:beforeDestroy&#x27;, function() &#123;</span><br><span class=\"line\">\t\tpi.destroy();</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n\n<p><strong>注意</strong>：</p>\n<blockquote>\n<p>​        Vue 的事件系统不同于浏览器的 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget\">EventTarget API</a>。尽管它们工作起来是相似的，但是 <code>$emit</code>、<code>$on</code>, 和 <code>$off</code> 并不是 <code>dispatchEvent</code>、<code>addEventListener</code> 和 <code>removeEventListener</code> 的别名。</p>\n</blockquote>\n<h2 id=\"循环引用\"><a href=\"#循环引用\" class=\"headerlink\" title=\"循环引用\"></a>循环引用</h2><h3 id=\"递归组件\"><a href=\"#递归组件\" class=\"headerlink\" title=\"递归组件\"></a>递归组件</h3><p>​        组件是可以在他们自己的模板中调用自身的，但是只能通过name选项来做这件事。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">name: &#x27;stack&#x27;,</span><br><span class=\"line\">tempalte: `&lt;div&gt;&lt;stack&gt;&lt;/stack&gt;&lt;/div&gt;`,</span><br></pre></td></tr></table></figure>\n\n<p>​        简单来说就是可以进行递归的循环，所以需要注意，并且发现对于全局注册组件，也可以使用组件名称进行递归组件。</p>\n<h3 id=\"组件之间的循环引用\"><a href=\"#组件之间的循环引用\" class=\"headerlink\" title=\"组件之间的循环引用\"></a>组件之间的循环引用</h3><p>​        对于组件之间的相互调用，组件在渲染树中互相为对方的后代和祖先。当通过 Vue.component 全局注册组件的时候，这个悖论将会被解开。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tree-father</span><br><span class=\"line\">\ttree-other</span><br><span class=\"line\">\t</span><br><span class=\"line\">tree-other</span><br><span class=\"line\">\ttree-father</span><br></pre></td></tr></table></figure>\n\n<p>​        然而，如果你使用一个模块系统依赖/导入组件，则会遇到一个错误。</p>\n<p>​        所以此时的解决办法就是：</p>\n<ul>\n<li><p>将注册事件放入 beforeCreate 进行注册。</p>\n<ul>\n<li>```<br>beforeCreate() {<pre><code>this.$options.components.ComponentA = require(&#39;./component-a.vue&#39;);\n</code></pre>\n}<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">* 或者，在本地进行注册组件的时候，可以使用 webpack 异步 import</span><br><span class=\"line\"></span><br><span class=\"line\">  * ```</span><br><span class=\"line\">    components: &#123;</span><br><span class=\"line\">    \tComponentA: () =&gt; import(&#x27;./component-a.vue&#x27;);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"模板定义的代替品\"><a href=\"#模板定义的代替品\" class=\"headerlink\" title=\"模板定义的代替品\"></a>模板定义的代替品</h2><h3 id=\"内联模板\"><a href=\"#内联模板\" class=\"headerlink\" title=\"内联模板\"></a>内联模板</h3><p>​        简单来说就是，组件内部的内容将会作为模板，而不是将其视为分布式内容(或者插槽？)。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;my-component inline-template&gt;</span><br><span class=\"line\">    &lt;div&gt;</span><br><span class=\"line\">        &lt;p&gt;These are compiled as the component&#x27;s own template.&lt;/p&gt;</span><br><span class=\"line\">        &lt;p&gt;Not parent&#x27;s transclusion content.&lt;/p&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">&lt;/my-component&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">Vue.component(&#x27;my-component&#x27;, &#123;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p><strong>注意点</strong>：</p>\n<ul>\n<li>使用的模板名需要是存在的</li>\n<li>如果要使用内联模板，那么对于全局注册的组件时需要的信息可以不需要，比如(template，data，methods等)。</li>\n<li>个人感觉这个和 template 的效果很相似。但是注意，使用内联模板也是可以使用data和methods的。所以这个的作用应该是很像 .vue 文件的使用。</li>\n</ul>\n<h3 id=\"X-Template\"><a href=\"#X-Template\" class=\"headerlink\" title=\"X-Template\"></a>X-Template</h3><p>​        使用 script 脚本，并且将type设置为 text/x-template，然后通过使用 id 来引用模板。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script type=&quot;text/x-template&quot; id=&quot;hello-world-template&quot;&gt;</span><br><span class=\"line\">  &lt;p&gt;Hello hello hello&lt;/p&gt;</span><br><span class=\"line\">&lt;/script&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">Vue.component(&#x27;hello-world&#x27;, &#123;</span><br><span class=\"line\">  template: &#x27;#hello-world-template&#x27;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>​        这些替代模板都是将 模板内部的标签 和 数据 以及操作等进行了分割。</p>\n<h2 id=\"控制更新\"><a href=\"#控制更新\" class=\"headerlink\" title=\"控制更新\"></a>控制更新</h2><h3 id=\"强制更新\"><a href=\"#强制更新\" class=\"headerlink\" title=\"强制更新\"></a>强制更新</h3><p>​        使用 $forceUpdate</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">data() &#123;</span><br><span class=\"line\">\treturn &#123;</span><br><span class=\"line\">\t\tx: [1, 3],</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">this.x[1] = 10;</span><br><span class=\"line\">//此时，虽然数据发生了改变，但是因为vue2的数据响应式无法对数组的直接操作进行通知，所以不会发生更新，那么此时就需要使用 this.$forceUpdate(); 来进行强制更新了。</span><br><span class=\"line\">this.$forceUpdate();</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"使用-v-once-的廉价静态组件\"><a href=\"#使用-v-once-的廉价静态组件\" class=\"headerlink\" title=\"使用 v-once 的廉价静态组件\"></a>使用 v-once 的廉价静态组件</h3><p>​        Vue 渲染纯HTML非常快，但是有时你的组件包含了大量的静态内容。在这些情况下，可以确保只被评估一次。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Vue.component(&#x27;terms-of-service&#x27;, &#123;</span><br><span class=\"line\">  template: `</span><br><span class=\"line\">    &lt;div v-once&gt;</span><br><span class=\"line\">      &lt;h1&gt;Terms of Service&lt;/h1&gt;</span><br><span class=\"line\">      ... a lot of static content ...</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">  `</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p><strong>注意</strong>：</p>\n<p>尽量不要过度的使用这种模式。除非真的渲染缓慢。</p>\n"},{"title":"router4源码","date":"2022-02-11T11:49:25.000Z","_content":"\n\n\n#  router4 源码的学习\n\n​\t\t在学习router的时候，发现了一个地方，就是**beforeRouteEnter** 里面添加了next参数，然后就发现了，如果不调用就会出现问题，但是如果不添加next参数就不会出这个问题，然后就准备看看源码，刚开始看的源码时vue2的，所以现在重看一个vue3的。\n\n\n\n​\t\t**rotuer.ts / 852** \n\n```\n// check in-component beforeRouteEnter\nguards = extractComponentsGuards(\n  enteringRecords,\n  'beforeRouteEnter',\n  to,\n  from\n)\nguards.push(canceledNavigationCheck)\n```\n\n* 大概就是调用方法。这里的 **enteringRecords** 参数是通过 769 line 返回值\n\n  * ```\n    const [leavingRecords, updatingRecords, enteringRecords] =\n          extractChangingRecords(to, from)\n    ```\n\n  *  **extractChangingRecords** 方法。1238 line。\n\n    * 记住是返回数组，然后数组是代表了会触发 leaving，enter，update 的记录。代码后面有分析，这里就不占空间了。\n\n  *  **navigate** 方法， 763 line\n\n    * ```\n      大概就是，先获取到路由的记录\n      \n      const [leavingRecords, updatingRecords, enteringRecords] =\n            extractChangingRecords(to, from)\n      ```\n\n    * ```\n      调用 beforeRouteLeave，注意，这里的leavingRecoreds 记录使用了 reverse 进行了逆序。所以触发会从下到上。同时 reverse会修改原数组。\n      \n      guards = extractComponentsGuards(\n        leavingRecords.reverse(),\n        'beforeRouteLeave',\n        to,\n        from\n      )\n      ```\n\n    * ```\n      循环 leaving 记录。\n      \n      \n      // leavingRecords is already reversed\n      for (const record of leavingRecords) {\n        record.leaveGuards.forEach(guard => {\n          guards.push(guardToPromiseFn(guard, to, from))\n        })\n      }\n      ```\n\n\n\n\n\n## router/ts\tcreateRouter方法\t355\n\n### navigate 方法 763\n\n```\n// 返回要触发对应声明周期的 路由的记录\nconst [leavingRecords, updatingRecords, enteringRecords] =\n\textractChangingRecords(to, from)\n```\n\n```\n// all components here have been resolved once because we are leaving\n\n\nguards = extractComponentsGuards(\n  leavingRecords.reverse(),\n  'beforeRouteLeave',\n  to,\n  from\n)\n```\n\n\n\n## **extractChangingRecords** 方法。\n\n* ```\n  const enteringRecords: RouteRecordNormalized[] = [] 代表定义的是一个数组。类型是 RouteRecordNormalized \n  ```\n\n* ```\n  function extractChangingRecords(\n    to: RouteLocationNormalized,\n    from: RouteLocationNormalizedLoaded\n  ) {\n    // 数组类型\n    const leavingRecords: RouteRecordNormalized[] = []\n    const updatingRecords: RouteRecordNormalized[] = []\n    const enteringRecords: RouteRecordNormalized[] = []\n  \n    // matched 代表的是匹配上的路由部分。\n    //这里就是寻找len要比较长的一个。\n    const len = Math.max(from.matched.length, to.matched.length)\n    for (let i = 0; i < len; i++) {\n      // 这里就是 recordFrom 就让他等于 from 的匹配路由\n      const recordFrom = from.matched[i]\n      //如果路由存在，那么就会\n      // 从 to 里面匹配上的路由 进行find方法。轮询查看是否有满足的。\n      // isSameRouteRecord 方法就是 判断两个路由是不是一个。这里使用了 aliasOf 定义此记录是否是另一个记录的别名。如果该记录是原始记录，则此属性为 undefined。\n      if (recordFrom) {\n        // 如果轮询找到了，那么就会把这个 from 的匹配路由push为 update的记录。\n        // 如果找不到，说明没有，那么就会 push 一个 leaving记录。\n        if (to.matched.find(record => isSameRouteRecord(record, recordFrom)))\n          updatingRecords.push(recordFrom)\n        else leavingRecords.push(recordFrom)\n      }\n      // 记录此时的 to 的匹配路由\n      const recordTo = to.matched[i]\n      // 如果存在\n      if (recordTo) {\n        // the type doesn't matter because we are comparing per reference\n        // 判断原路由是否存在，不存在则会push为 enter 记录\n        if (!from.matched.find(record => isSameRouteRecord(record, recordTo))) {\n          enteringRecords.push(recordTo)\n        }\n      }\n    }\n  \n    // 最后返回所有的记录\n    return [leavingRecords, updatingRecords, enteringRecords]\n  }\n  ```\n\n  \n\n## navigationGuards/ts \n\n### extractComponentsGuards方法 230\n\n\n\n### isRouteComponent 方法 357\n\n```\n/**\n * Allows differentiating lazy components from functional components and vue-class-component\n * 允许区分惰性组件与功能组件和vue类组件\n *\n * @param component\n */\nfunction isRouteComponent(\n  component: RawRouteComponent\n): component is RouteComponent {\n  // 组件要为对象，且存在 displayName，props，__vccOpts属性\n  return (\n    typeof component === 'object' ||\n    'displayName' in component ||\n    'props' in component ||\n    '__vccOpts' in component\n  )\n}\n```\n\n\n\n### guardToPromiseFn方法 110\n\n```\n\n```\n\n","source":"_drafts/router/源码/router4/router4源码.md","raw":"---\ntitle: router4源码\ndate: 2022-02-11 19:49:25\ntags:\n - router\ncategories:\n - router\n---\n\n\n\n#  router4 源码的学习\n\n​\t\t在学习router的时候，发现了一个地方，就是**beforeRouteEnter** 里面添加了next参数，然后就发现了，如果不调用就会出现问题，但是如果不添加next参数就不会出这个问题，然后就准备看看源码，刚开始看的源码时vue2的，所以现在重看一个vue3的。\n\n\n\n​\t\t**rotuer.ts / 852** \n\n```\n// check in-component beforeRouteEnter\nguards = extractComponentsGuards(\n  enteringRecords,\n  'beforeRouteEnter',\n  to,\n  from\n)\nguards.push(canceledNavigationCheck)\n```\n\n* 大概就是调用方法。这里的 **enteringRecords** 参数是通过 769 line 返回值\n\n  * ```\n    const [leavingRecords, updatingRecords, enteringRecords] =\n          extractChangingRecords(to, from)\n    ```\n\n  *  **extractChangingRecords** 方法。1238 line。\n\n    * 记住是返回数组，然后数组是代表了会触发 leaving，enter，update 的记录。代码后面有分析，这里就不占空间了。\n\n  *  **navigate** 方法， 763 line\n\n    * ```\n      大概就是，先获取到路由的记录\n      \n      const [leavingRecords, updatingRecords, enteringRecords] =\n            extractChangingRecords(to, from)\n      ```\n\n    * ```\n      调用 beforeRouteLeave，注意，这里的leavingRecoreds 记录使用了 reverse 进行了逆序。所以触发会从下到上。同时 reverse会修改原数组。\n      \n      guards = extractComponentsGuards(\n        leavingRecords.reverse(),\n        'beforeRouteLeave',\n        to,\n        from\n      )\n      ```\n\n    * ```\n      循环 leaving 记录。\n      \n      \n      // leavingRecords is already reversed\n      for (const record of leavingRecords) {\n        record.leaveGuards.forEach(guard => {\n          guards.push(guardToPromiseFn(guard, to, from))\n        })\n      }\n      ```\n\n\n\n\n\n## router/ts\tcreateRouter方法\t355\n\n### navigate 方法 763\n\n```\n// 返回要触发对应声明周期的 路由的记录\nconst [leavingRecords, updatingRecords, enteringRecords] =\n\textractChangingRecords(to, from)\n```\n\n```\n// all components here have been resolved once because we are leaving\n\n\nguards = extractComponentsGuards(\n  leavingRecords.reverse(),\n  'beforeRouteLeave',\n  to,\n  from\n)\n```\n\n\n\n## **extractChangingRecords** 方法。\n\n* ```\n  const enteringRecords: RouteRecordNormalized[] = [] 代表定义的是一个数组。类型是 RouteRecordNormalized \n  ```\n\n* ```\n  function extractChangingRecords(\n    to: RouteLocationNormalized,\n    from: RouteLocationNormalizedLoaded\n  ) {\n    // 数组类型\n    const leavingRecords: RouteRecordNormalized[] = []\n    const updatingRecords: RouteRecordNormalized[] = []\n    const enteringRecords: RouteRecordNormalized[] = []\n  \n    // matched 代表的是匹配上的路由部分。\n    //这里就是寻找len要比较长的一个。\n    const len = Math.max(from.matched.length, to.matched.length)\n    for (let i = 0; i < len; i++) {\n      // 这里就是 recordFrom 就让他等于 from 的匹配路由\n      const recordFrom = from.matched[i]\n      //如果路由存在，那么就会\n      // 从 to 里面匹配上的路由 进行find方法。轮询查看是否有满足的。\n      // isSameRouteRecord 方法就是 判断两个路由是不是一个。这里使用了 aliasOf 定义此记录是否是另一个记录的别名。如果该记录是原始记录，则此属性为 undefined。\n      if (recordFrom) {\n        // 如果轮询找到了，那么就会把这个 from 的匹配路由push为 update的记录。\n        // 如果找不到，说明没有，那么就会 push 一个 leaving记录。\n        if (to.matched.find(record => isSameRouteRecord(record, recordFrom)))\n          updatingRecords.push(recordFrom)\n        else leavingRecords.push(recordFrom)\n      }\n      // 记录此时的 to 的匹配路由\n      const recordTo = to.matched[i]\n      // 如果存在\n      if (recordTo) {\n        // the type doesn't matter because we are comparing per reference\n        // 判断原路由是否存在，不存在则会push为 enter 记录\n        if (!from.matched.find(record => isSameRouteRecord(record, recordTo))) {\n          enteringRecords.push(recordTo)\n        }\n      }\n    }\n  \n    // 最后返回所有的记录\n    return [leavingRecords, updatingRecords, enteringRecords]\n  }\n  ```\n\n  \n\n## navigationGuards/ts \n\n### extractComponentsGuards方法 230\n\n\n\n### isRouteComponent 方法 357\n\n```\n/**\n * Allows differentiating lazy components from functional components and vue-class-component\n * 允许区分惰性组件与功能组件和vue类组件\n *\n * @param component\n */\nfunction isRouteComponent(\n  component: RawRouteComponent\n): component is RouteComponent {\n  // 组件要为对象，且存在 displayName，props，__vccOpts属性\n  return (\n    typeof component === 'object' ||\n    'displayName' in component ||\n    'props' in component ||\n    '__vccOpts' in component\n  )\n}\n```\n\n\n\n### guardToPromiseFn方法 110\n\n```\n\n```\n\n","slug":"router/源码/router4/router4源码","published":0,"updated":"2022-02-14T07:11:00.609Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckznhkk8t007xikubf25f27y3","content":"<h1 id=\"router4-源码的学习\"><a href=\"#router4-源码的学习\" class=\"headerlink\" title=\"router4 源码的学习\"></a>router4 源码的学习</h1><p>​        在学习router的时候，发现了一个地方，就是<strong>beforeRouteEnter</strong> 里面添加了next参数，然后就发现了，如果不调用就会出现问题，但是如果不添加next参数就不会出这个问题，然后就准备看看源码，刚开始看的源码时vue2的，所以现在重看一个vue3的。</p>\n<p>​        <strong>rotuer.ts / 852</strong> </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// check in-component beforeRouteEnter</span><br><span class=\"line\">guards = extractComponentsGuards(</span><br><span class=\"line\">  enteringRecords,</span><br><span class=\"line\">  &#x27;beforeRouteEnter&#x27;,</span><br><span class=\"line\">  to,</span><br><span class=\"line\">  from</span><br><span class=\"line\">)</span><br><span class=\"line\">guards.push(canceledNavigationCheck)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>大概就是调用方法。这里的 <strong>enteringRecords</strong> 参数是通过 769 line 返回值</p>\n<ul>\n<li><p>```<br>const [leavingRecords, updatingRecords, enteringRecords] =</p>\n<pre><code>  extractChangingRecords(to, from)\n</code></pre>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">*  **extractChangingRecords** 方法。1238 line。</span><br><span class=\"line\"></span><br><span class=\"line\">  * 记住是返回数组，然后数组是代表了会触发 leaving，enter，update 的记录。代码后面有分析，这里就不占空间了。</span><br><span class=\"line\"></span><br><span class=\"line\">*  **navigate** 方法， 763 line</span><br><span class=\"line\"></span><br><span class=\"line\">  * ```</span><br><span class=\"line\">    大概就是，先获取到路由的记录</span><br><span class=\"line\">    </span><br><span class=\"line\">    const [leavingRecords, updatingRecords, enteringRecords] =</span><br><span class=\"line\">          extractChangingRecords(to, from)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>```<br>调用 beforeRouteLeave，注意，这里的leavingRecoreds 记录使用了 reverse 进行了逆序。所以触发会从下到上。同时 reverse会修改原数组。guards = extractComponentsGuards(<br>  leavingRecords.reverse(),<br>  ‘beforeRouteLeave’,<br>  to,<br>  from<br>)<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">* ```</span><br><span class=\"line\">  循环 leaving 记录。</span><br><span class=\"line\">  </span><br><span class=\"line\">  </span><br><span class=\"line\">  // leavingRecords is already reversed</span><br><span class=\"line\">  for (const record of leavingRecords) &#123;</span><br><span class=\"line\">    record.leaveGuards.forEach(guard =&gt; &#123;</span><br><span class=\"line\">      guards.push(guardToPromiseFn(guard, to, from))</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"router-ts-createRouter方法-355\"><a href=\"#router-ts-createRouter方法-355\" class=\"headerlink\" title=\"router/ts    createRouter方法    355\"></a>router/ts    createRouter方法    355</h2><h3 id=\"navigate-方法-763\"><a href=\"#navigate-方法-763\" class=\"headerlink\" title=\"navigate 方法 763\"></a>navigate 方法 763</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 返回要触发对应声明周期的 路由的记录</span><br><span class=\"line\">const [leavingRecords, updatingRecords, enteringRecords] =</span><br><span class=\"line\">\textractChangingRecords(to, from)</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// all components here have been resolved once because we are leaving</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">guards = extractComponentsGuards(</span><br><span class=\"line\">  leavingRecords.reverse(),</span><br><span class=\"line\">  &#x27;beforeRouteLeave&#x27;,</span><br><span class=\"line\">  to,</span><br><span class=\"line\">  from</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"extractChangingRecords-方法。\"><a href=\"#extractChangingRecords-方法。\" class=\"headerlink\" title=\"extractChangingRecords 方法。\"></a><strong>extractChangingRecords</strong> 方法。</h2><ul>\n<li>```<br>const enteringRecords: RouteRecordNormalized[] = [] 代表定义的是一个数组。类型是 RouteRecordNormalized <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">* ```</span><br><span class=\"line\">  function extractChangingRecords(</span><br><span class=\"line\">    to: RouteLocationNormalized,</span><br><span class=\"line\">    from: RouteLocationNormalizedLoaded</span><br><span class=\"line\">  ) &#123;</span><br><span class=\"line\">    // 数组类型</span><br><span class=\"line\">    const leavingRecords: RouteRecordNormalized[] = []</span><br><span class=\"line\">    const updatingRecords: RouteRecordNormalized[] = []</span><br><span class=\"line\">    const enteringRecords: RouteRecordNormalized[] = []</span><br><span class=\"line\">  </span><br><span class=\"line\">    // matched 代表的是匹配上的路由部分。</span><br><span class=\"line\">    //这里就是寻找len要比较长的一个。</span><br><span class=\"line\">    const len = Math.max(from.matched.length, to.matched.length)</span><br><span class=\"line\">    for (let i = 0; i &lt; len; i++) &#123;</span><br><span class=\"line\">      // 这里就是 recordFrom 就让他等于 from 的匹配路由</span><br><span class=\"line\">      const recordFrom = from.matched[i]</span><br><span class=\"line\">      //如果路由存在，那么就会</span><br><span class=\"line\">      // 从 to 里面匹配上的路由 进行find方法。轮询查看是否有满足的。</span><br><span class=\"line\">      // isSameRouteRecord 方法就是 判断两个路由是不是一个。这里使用了 aliasOf 定义此记录是否是另一个记录的别名。如果该记录是原始记录，则此属性为 undefined。</span><br><span class=\"line\">      if (recordFrom) &#123;</span><br><span class=\"line\">        // 如果轮询找到了，那么就会把这个 from 的匹配路由push为 update的记录。</span><br><span class=\"line\">        // 如果找不到，说明没有，那么就会 push 一个 leaving记录。</span><br><span class=\"line\">        if (to.matched.find(record =&gt; isSameRouteRecord(record, recordFrom)))</span><br><span class=\"line\">          updatingRecords.push(recordFrom)</span><br><span class=\"line\">        else leavingRecords.push(recordFrom)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      // 记录此时的 to 的匹配路由</span><br><span class=\"line\">      const recordTo = to.matched[i]</span><br><span class=\"line\">      // 如果存在</span><br><span class=\"line\">      if (recordTo) &#123;</span><br><span class=\"line\">        // the type doesn&#x27;t matter because we are comparing per reference</span><br><span class=\"line\">        // 判断原路由是否存在，不存在则会push为 enter 记录</span><br><span class=\"line\">        if (!from.matched.find(record =&gt; isSameRouteRecord(record, recordTo))) &#123;</span><br><span class=\"line\">          enteringRecords.push(recordTo)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">    // 最后返回所有的记录</span><br><span class=\"line\">    return [leavingRecords, updatingRecords, enteringRecords]</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"navigationGuards-ts\"><a href=\"#navigationGuards-ts\" class=\"headerlink\" title=\"navigationGuards/ts\"></a>navigationGuards/ts</h2><h3 id=\"extractComponentsGuards方法-230\"><a href=\"#extractComponentsGuards方法-230\" class=\"headerlink\" title=\"extractComponentsGuards方法 230\"></a>extractComponentsGuards方法 230</h3><h3 id=\"isRouteComponent-方法-357\"><a href=\"#isRouteComponent-方法-357\" class=\"headerlink\" title=\"isRouteComponent 方法 357\"></a>isRouteComponent 方法 357</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * Allows differentiating lazy components from functional components and vue-class-component</span><br><span class=\"line\"> * 允许区分惰性组件与功能组件和vue类组件</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * @param component</span><br><span class=\"line\"> */</span><br><span class=\"line\">function isRouteComponent(</span><br><span class=\"line\">  component: RawRouteComponent</span><br><span class=\"line\">): component is RouteComponent &#123;</span><br><span class=\"line\">  // 组件要为对象，且存在 displayName，props，__vccOpts属性</span><br><span class=\"line\">  return (</span><br><span class=\"line\">    typeof component === &#x27;object&#x27; ||</span><br><span class=\"line\">    &#x27;displayName&#x27; in component ||</span><br><span class=\"line\">    &#x27;props&#x27; in component ||</span><br><span class=\"line\">    &#x27;__vccOpts&#x27; in component</span><br><span class=\"line\">  )</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"guardToPromiseFn方法-110\"><a href=\"#guardToPromiseFn方法-110\" class=\"headerlink\" title=\"guardToPromiseFn方法 110\"></a>guardToPromiseFn方法 110</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"router4-源码的学习\"><a href=\"#router4-源码的学习\" class=\"headerlink\" title=\"router4 源码的学习\"></a>router4 源码的学习</h1><p>​        在学习router的时候，发现了一个地方，就是<strong>beforeRouteEnter</strong> 里面添加了next参数，然后就发现了，如果不调用就会出现问题，但是如果不添加next参数就不会出这个问题，然后就准备看看源码，刚开始看的源码时vue2的，所以现在重看一个vue3的。</p>\n<p>​        <strong>rotuer.ts / 852</strong> </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// check in-component beforeRouteEnter</span><br><span class=\"line\">guards = extractComponentsGuards(</span><br><span class=\"line\">  enteringRecords,</span><br><span class=\"line\">  &#x27;beforeRouteEnter&#x27;,</span><br><span class=\"line\">  to,</span><br><span class=\"line\">  from</span><br><span class=\"line\">)</span><br><span class=\"line\">guards.push(canceledNavigationCheck)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>大概就是调用方法。这里的 <strong>enteringRecords</strong> 参数是通过 769 line 返回值</p>\n<ul>\n<li><p>```<br>const [leavingRecords, updatingRecords, enteringRecords] =</p>\n<pre><code>  extractChangingRecords(to, from)\n</code></pre>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">*  **extractChangingRecords** 方法。1238 line。</span><br><span class=\"line\"></span><br><span class=\"line\">  * 记住是返回数组，然后数组是代表了会触发 leaving，enter，update 的记录。代码后面有分析，这里就不占空间了。</span><br><span class=\"line\"></span><br><span class=\"line\">*  **navigate** 方法， 763 line</span><br><span class=\"line\"></span><br><span class=\"line\">  * ```</span><br><span class=\"line\">    大概就是，先获取到路由的记录</span><br><span class=\"line\">    </span><br><span class=\"line\">    const [leavingRecords, updatingRecords, enteringRecords] =</span><br><span class=\"line\">          extractChangingRecords(to, from)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>```<br>调用 beforeRouteLeave，注意，这里的leavingRecoreds 记录使用了 reverse 进行了逆序。所以触发会从下到上。同时 reverse会修改原数组。guards = extractComponentsGuards(<br>  leavingRecords.reverse(),<br>  ‘beforeRouteLeave’,<br>  to,<br>  from<br>)<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">* ```</span><br><span class=\"line\">  循环 leaving 记录。</span><br><span class=\"line\">  </span><br><span class=\"line\">  </span><br><span class=\"line\">  // leavingRecords is already reversed</span><br><span class=\"line\">  for (const record of leavingRecords) &#123;</span><br><span class=\"line\">    record.leaveGuards.forEach(guard =&gt; &#123;</span><br><span class=\"line\">      guards.push(guardToPromiseFn(guard, to, from))</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"router-ts-createRouter方法-355\"><a href=\"#router-ts-createRouter方法-355\" class=\"headerlink\" title=\"router/ts    createRouter方法    355\"></a>router/ts    createRouter方法    355</h2><h3 id=\"navigate-方法-763\"><a href=\"#navigate-方法-763\" class=\"headerlink\" title=\"navigate 方法 763\"></a>navigate 方法 763</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 返回要触发对应声明周期的 路由的记录</span><br><span class=\"line\">const [leavingRecords, updatingRecords, enteringRecords] =</span><br><span class=\"line\">\textractChangingRecords(to, from)</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// all components here have been resolved once because we are leaving</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">guards = extractComponentsGuards(</span><br><span class=\"line\">  leavingRecords.reverse(),</span><br><span class=\"line\">  &#x27;beforeRouteLeave&#x27;,</span><br><span class=\"line\">  to,</span><br><span class=\"line\">  from</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"extractChangingRecords-方法。\"><a href=\"#extractChangingRecords-方法。\" class=\"headerlink\" title=\"extractChangingRecords 方法。\"></a><strong>extractChangingRecords</strong> 方法。</h2><ul>\n<li>```<br>const enteringRecords: RouteRecordNormalized[] = [] 代表定义的是一个数组。类型是 RouteRecordNormalized <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">* ```</span><br><span class=\"line\">  function extractChangingRecords(</span><br><span class=\"line\">    to: RouteLocationNormalized,</span><br><span class=\"line\">    from: RouteLocationNormalizedLoaded</span><br><span class=\"line\">  ) &#123;</span><br><span class=\"line\">    // 数组类型</span><br><span class=\"line\">    const leavingRecords: RouteRecordNormalized[] = []</span><br><span class=\"line\">    const updatingRecords: RouteRecordNormalized[] = []</span><br><span class=\"line\">    const enteringRecords: RouteRecordNormalized[] = []</span><br><span class=\"line\">  </span><br><span class=\"line\">    // matched 代表的是匹配上的路由部分。</span><br><span class=\"line\">    //这里就是寻找len要比较长的一个。</span><br><span class=\"line\">    const len = Math.max(from.matched.length, to.matched.length)</span><br><span class=\"line\">    for (let i = 0; i &lt; len; i++) &#123;</span><br><span class=\"line\">      // 这里就是 recordFrom 就让他等于 from 的匹配路由</span><br><span class=\"line\">      const recordFrom = from.matched[i]</span><br><span class=\"line\">      //如果路由存在，那么就会</span><br><span class=\"line\">      // 从 to 里面匹配上的路由 进行find方法。轮询查看是否有满足的。</span><br><span class=\"line\">      // isSameRouteRecord 方法就是 判断两个路由是不是一个。这里使用了 aliasOf 定义此记录是否是另一个记录的别名。如果该记录是原始记录，则此属性为 undefined。</span><br><span class=\"line\">      if (recordFrom) &#123;</span><br><span class=\"line\">        // 如果轮询找到了，那么就会把这个 from 的匹配路由push为 update的记录。</span><br><span class=\"line\">        // 如果找不到，说明没有，那么就会 push 一个 leaving记录。</span><br><span class=\"line\">        if (to.matched.find(record =&gt; isSameRouteRecord(record, recordFrom)))</span><br><span class=\"line\">          updatingRecords.push(recordFrom)</span><br><span class=\"line\">        else leavingRecords.push(recordFrom)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      // 记录此时的 to 的匹配路由</span><br><span class=\"line\">      const recordTo = to.matched[i]</span><br><span class=\"line\">      // 如果存在</span><br><span class=\"line\">      if (recordTo) &#123;</span><br><span class=\"line\">        // the type doesn&#x27;t matter because we are comparing per reference</span><br><span class=\"line\">        // 判断原路由是否存在，不存在则会push为 enter 记录</span><br><span class=\"line\">        if (!from.matched.find(record =&gt; isSameRouteRecord(record, recordTo))) &#123;</span><br><span class=\"line\">          enteringRecords.push(recordTo)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">    // 最后返回所有的记录</span><br><span class=\"line\">    return [leavingRecords, updatingRecords, enteringRecords]</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"navigationGuards-ts\"><a href=\"#navigationGuards-ts\" class=\"headerlink\" title=\"navigationGuards/ts\"></a>navigationGuards/ts</h2><h3 id=\"extractComponentsGuards方法-230\"><a href=\"#extractComponentsGuards方法-230\" class=\"headerlink\" title=\"extractComponentsGuards方法 230\"></a>extractComponentsGuards方法 230</h3><h3 id=\"isRouteComponent-方法-357\"><a href=\"#isRouteComponent-方法-357\" class=\"headerlink\" title=\"isRouteComponent 方法 357\"></a>isRouteComponent 方法 357</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * Allows differentiating lazy components from functional components and vue-class-component</span><br><span class=\"line\"> * 允许区分惰性组件与功能组件和vue类组件</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * @param component</span><br><span class=\"line\"> */</span><br><span class=\"line\">function isRouteComponent(</span><br><span class=\"line\">  component: RawRouteComponent</span><br><span class=\"line\">): component is RouteComponent &#123;</span><br><span class=\"line\">  // 组件要为对象，且存在 displayName，props，__vccOpts属性</span><br><span class=\"line\">  return (</span><br><span class=\"line\">    typeof component === &#x27;object&#x27; ||</span><br><span class=\"line\">    &#x27;displayName&#x27; in component ||</span><br><span class=\"line\">    &#x27;props&#x27; in component ||</span><br><span class=\"line\">    &#x27;__vccOpts&#x27; in component</span><br><span class=\"line\">  )</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"guardToPromiseFn方法-110\"><a href=\"#guardToPromiseFn方法-110\" class=\"headerlink\" title=\"guardToPromiseFn方法 110\"></a>guardToPromiseFn方法 110</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n"},{"title":"Vue-使用-基础使用","date":"2021-10-29T15:15:01.000Z","_content":"\n\n\n#  Vue的基本使用\n\n```\n简单入门教程\n\thttps://cn.vuejs.org/v2/guide/\nAPI\n\thttps://cn.vuejs.org/v2/api/\n\n在这里我就先进行一个简单的教程的学习。不过于深入了解。\n```\n\n\n\n# 介绍\n\n```\nhttps://cn.vuejs.org/v2/guide/index.html\n```\n\n\n\n## 引入\n\n​\t\t这里我们使用 script 进行引入\n\n​\t\t还可以使用 **npm** 进行下载引入 和 使用 **VueCLI** 脚手架，使用 npm 和 脚手架 的好处是，我们可以方便进行包管理。进行较大型应用时可以进行使用。但是我们这里的主要目的时了解 Vue 的基本使用和Vue 的一些规范，所以就直接使用 **script** 引入。\n\n​\t\t对于 **script** 引入，有两种：\n\n* 第一种是直接进行引入。这种是创建了一个全局 Vue 的的实例，可以在后面进行使用，但是不能在前面进行使用。\n\n  * ```\n    <script src=\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\"></script>\n    ```\n\n* 第二种是使用了 模块化 。 在引用以后，可以在改代码的后面直接进行使用。但是不能在 另外一个 script 标签内部使用，具体的原因是 使用了 module ，这个属于异步加载了。对于script 的异步我们后续在了解。\n\n  * ```\n    <script type=\"module\">\n      import Vue from 'https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.esm.browser.js'\n      \n      Vue.log;\n    </script>\n    ```\n\n这里我们使用第一种引入。\n\n\n\n## 声明式渲染\n\n### Mustache 语法 { { valueName }}\n\n```\n<div id=\"app\">\n  { { message }}\n</div>\n\n<!-- 开发环境版本，包含了有帮助的命令行警告 -->\n<script src=\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\"></script>\n<script>\n  const app = new Vue({\n    el: '#app',\n    data: {\n      message: 'test'\n    }\n  });\n</script>\n```\n\n​\t\t这里这个 message 是响应式的。如果我们在浏览器控制台修改了 message 的值，页面也会对应发生变化。里面的原因是使用了 **OBject.defineProperty()** 对于 Vue 的响应式。我们后续在了解 Vue源码的时候在进行讨论。\n\n```\napp.message = 'a';\n\n页面会同时进行修改。\n```\n\n​\t\t这里我们进行一个分析。\n\n```\nnew Vue，这是一个 new 方法，会返回一个实例，里面的参数是一个对象，对象里面又是很多属性和对象的组成。\n\n这里出现了。el 和 data。\n```\n\n```\n其中el，是你要绑定的元素， 可以是 CSS 选择器，也可以是一个 HTMLElement 实例。\n\t参考：\thttps://cn.vuejs.org/v2/api/#el\nCSS选择器： #app, .app, div.app ...\nHTMLElement实例： \n\tconst span = document.querySelector('span.app');\n\tel: span.\n其次，对于有多个满足的情况，只会对第一个进行编译。\n```\n\n```\ndata：\n\t\t我们可以看出，这个是一个data的对象。然后是对对象里面的数据进行了一个响应式的处理。然后我们也可以在后续在开发时可以发现，data是一个 返回的对象。这里是因为对象是使用的地址赋值，如果不通过return {}, 会让共同使用的组件会使用相同的数据。但是如果是return {}。那么在每次返回时都会返回一个新的对象出来。而不会共同使用一个对象。 \n```\n\n\n\n### 使用指令绑定 attribute (v-bind)\n\n```\n<span class=\"app\" v-bind:title=\"message\">\n  { { message }}\n</span>\n```\n\n​\t\t这里 v-bind 是 Vue 提供的 `attribute `。它可以绑定元素原有的 `attribute` 。这个指令的效果是： 将这个元素节点的 `title` attribute 和 Vue 实例的 `message` property 保持一致。\n\n​\t\t可以通过使用 app.message = 'new'; 可以发现，内容也随之更新。\n\n\n\n## 条件与循环\n\n### v-if\n\n```\n<div id=\"app-3\">\n  <p v-if=\"seen\">现在你看到我了</p>\n</div>\n\n\nvar app3 = new Vue({\n  el: '#app-3',\n  data: {\n    seen: true\n  }\n})\n\n这里设置的 seen ， 设置为 true ，就会显示。设置为 false ，就不会显示。\n```\n\n​\t\t可以通过设置 v-if 来进行这个标签的显示和隐藏。此外，Vue 也提供一个强大的过渡效果系统，可以在 Vue 插入/更新/移除元素时自动应用[过渡效果](https://cn.vuejs.org/v2/guide/transitions.html)。\n\n​\t\t这个过渡效果，我们后续在讲。\n\n​\t\t`v-if` 可以控制一个标签的显示和隐藏，还有 `v-show` 也有一样的效果。\n\n**区别：**\n\n* ```\n  https://cn.vuejs.org/v2/guide/conditional.html#v-if-vs-v-show\n  ```\n\n* `v-if` 也是**惰性的**：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。\n* 相比之下，`v-show` 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。\n* 如果需要非常频繁地切换，则使用 `v-show` 较好；如果在运行时条件很少改变，则使用 `v-if` 较好。\n\n\n\n### v-for\n\n```\nhttps://cn.vuejs.org/v2/api/#v-for\n```\n\n​\t\t`v-for` 指令可以绑定数组的数据来渲染一个项目列表：\n\n```\n<div id=\"app-4\">\n  <ol>\n    <li v-for=\"todo in todos\">\n      { { todo.text }}\n    </li>\n  </ol>\n</div>\n\n\nvar app4 = new Vue({\n  el: '#app-4',\n  data: {\n    todos: [\n      { text: '学习 JavaScript' },\n      { text: '学习 Vue' },\n      { text: '整个牛项目' }\n    ]\n  }\n})\n\n循环。 v-for=\"item in items\"，  会循环items，赋值给 item。\n```\n\n**此外：**\n\n​\t在使用 **v-if** 搭配 v-for 时，**v-for** 的优先级会高于 **v-if**。\n\n```\n<li v-for=\"todo in todos\" v-if=\"todo.flag\">\n```\n\n​\t\t在控制台里，输入 `app4.todos.push({ text: '新项目' })`，你会发现列表最后添加了一个新项目。\n\n**注意：**\n\n​\t这里使用了 **push**， 方式添加了新项目，页面发生了改变，但是如果是 app4.todos[4] = xxx， 这样就不会发生页面的改变，这里是因为Vue 响应式的原因，至于原理，我们后续在讲解。想要提前知道的可以了解一下，Object.defineProperty()。\n\n\n\n## 处理用户输入\n\n​\t\t用户和应用的交互，可以使用 **v-on** 指令来添加一个事件的监听器\n\n这里的 v-on，就代表了 on\n\n```\n<button v-on:click=\"reverseMessage\">反转消息</button>\n\n<button onclick=\"reverseMessage()\">反转消息</button>\n```\n\n```\nvar app5 = new Vue({\n  el: '#app-5',\n  data: {\n    message: 'Hello Vue.js!'\n  },\n  methods: {\n    reverseMessage: function () {\n      this.message = this.message.split('').reverse().join('')\n    }\n  }\n})\n```\n\n​\t\t这里新添加了一个 **methods** 的对象，里面存放的是方法。如果是使用 **Vue** 的属性 **attribute**， **v-on** ，来进行的绑定方法，那么就需要将方法写在这个methods 里面。不写在 methods 里面的方法是没有效果的。\n\n​\t\t其次，这里面建议不要使用 箭头函数，因为箭头函数 的this指向是和 当前的上下文 相关的，所以在箭头函数里面使用不了data的方法。箭头函数的指向是全局。\n\n​\t\t在这里，我们只需要写上逻辑，不需要操作DOM，这个就是 MVVM 中， Vue 的 VM，我们只需要在 M和V 上进行操作即可。\n\n\n\n## v-model 实现双向绑定\n\n​\t\tv-bind，可以实现单向的绑定，就是指可以通过修改data数据来进行页面的修改。\n\n​\t\t但是，如果是对于一个 input 的输入框呢？\n\n​\t\t我们可以将 data 数据绑定到输入框作为一个初始值。\n\n​\t\t但是我们可以在对输入框进行输入时，同时修改 data 的数据吗。显然是不行的。所以就有了 v-model\n\n​\t\tv-model ，它可以进行数据的双向绑定，不但用户的输入会修改 data， data 的变化也会影响视图。\n\n```\n<input v-model=\"message\">\n```\n\n​\t\t通过这个我们 可以看出，v-model 没有说使用value，还是什么，但是却有效果，这里是因为 v-model 会根据控件的类型自动选取正确的方法来更新。限制：\tinput， select， textarea， components\n\n```\nhttps://cn.vuejs.org/v2/api/#v-model\n```\n\n\n\n## 组件化应用构建\n\n​\t\tVue 的另一个重要的概念就是 **组件化** 。几乎任意应用界面都可以抽象为一个组件树。\n\n​\t\t在 Vue 中注册一个组件\n\n```\n// 定义名为 todo-item 的新组件\nVue.component('todo-item', {\n  template: '<li>这是个待办项</li>'\n})\n\nvar app = new Vue(...)\n```\n\n**示例：**\n\n```\n<div id=\"app-6\">\n  <my-item></my-item>\n</div>\n\n\n  Vue.component('my-item', {\n    template: '<li>这是个待办项</li>'\n  });\n\n  var app6 = new Vue({ el: '#app-6' })\n```\n\n**注意点：**\n\n* 使用的方式是，需要在 new 的实例的 Vue 的内部进行调用，因为在 实例内部，你写的方式才会被 Vue 所编译，不然是不会被 Vue 编译的。\n\n* 其次，注册的组件需要在你 new 的实例前面，因为你在编译组件的时候要使用自定义的组件。所以，如果不在之前进行解析的话，就解析不了了。\n\n\n\n## 组件传值\n\n```\n<div id=\"app-6\">\n  <my-item :todo=\"message\"></my-item>\n</div>\n\n\nVue.component('my-item', {\n  props: ['todo'],\n  template: '<li>这是个待办项 { { todo }}</li>',\n});\n\nvar app6 = new Vue({\n  el: '#app-6',\n  data: {\n  \tmessage: false\n  }\n})\n```\n\n​\t\t这里， props 是代表了获取到组件属性传递过来的值，在组件使用时，添加属性，这个属性是和 props 里面的名字相等。这里就是 todo， 其次， **:todo**，是一个语法糖，代表了 **v-bind:todo**，所以就会把 message 的值传递给 todo，然后再传递给 my-item。\n\n\n\n# Vue实例\n\n```\nhttps://cn.vuejs.org/v2/guide/instance.html\n```\n\n\n\n## 创建一个Vue实例\n\n​\t\t每个 Vue 应用都是通过用 `Vue` 函数创建一个新的 **Vue 实例**开始的：\n\n```\nvar vm = new Vue({\n  // 选项\n})\n```\n\n​\t\t虽然没有完全遵循 [MVVM 模型](https://zh.wikipedia.org/wiki/MVVM)，但是 Vue 的设计也受到了它的启发。因此在文档中经常会使用 `vm` (ViewModel 的缩写) 这个变量名表示 Vue 实例。\n\n​\t\t至于为什么 Vue 没有完全遵循 MVVM 的原因是：Vue 中有一个属性，ref，这个属性可以拿到 DOM 对象，直接操作视图，所以违背了 MVVM。\n\n​\t\t在创建一个 Vue 实例时，你可以传入一个 [选项对象]([https://cn.vuejs.org/v2/api/#%E9%80%89%E9%A1%B9-%E6%95%B0%E6%8D%AE](https://cn.vuejs.org/v2/api/#选项-数据)) (data，methods...)。通过这些选项对象来创建你想要的行为。\n\n​\t\t一个 Vue 应用由一个通过 `new Vue` 创建的**根 Vue 实例**，以及可选的嵌套的、可复用的组件树组成。\n\n\n\n## 数据与方法\n\n​\t\t当一个 Vue 实例被创建时，它将 `data` 对象中的所有的 property 加入到 Vue 的**响应式系统**中。当这些 property 的值发生改变时，视图将会产生“响应”，即匹配更新为新的值。\n\n​\t\t大致就可以理解为，需要将数据放在了 data 里面，Vue 就会自动创建响应式。\n\n```\n// 我们的数据对象\nvar data = { a: 1 }\n\n// 该对象被加入到一个 Vue 实例中\nvar vm = new Vue({\n  data: data\n})\n\n// 获得这个实例上的 property\n// 返回源数据中对应的字段\nvm.a == data.a // => true\n\n// 设置 property 也会影响到原始数据\nvm.a = 2\ndata.a // => 2\n\n// ……反之亦然\ndata.a = 3\nvm.a // => 3\n```\n\n​\t\t通过上面我们可以知道，data的数据是直接可以通过 实例的返回来直接获取，数据是直接暴露于实例的顶层。理所当然，methods 的方法也是一样，所以我们会思考，如果方法名和数据名重合会怎么办。\n\n```\n  var app6 = new Vue({\n    el: '#app-6',\n    data: {\n      message: false\n    },\n    methods: {\n      message() {\n        console.log(1);\n      }\n    },\n  })\n  \n通过上面的案例可以看出，方法名是和 data 名称重合，所以在 data 已经创建了数据之后，方法创建会抛出异常。方法创建失败。\n```\n\n```\n  而如果是一个普通的对象，后面的会将前面的覆盖掉。\n  \n  let obj = {\n    a: 1,\n    a() {\n      console.log(2);\n    }\n  }\n  console.log(obj);\n```\n\n​\t\t其次\n\n```\n使用 vm.b = 1;\n这种后续添加数据的方式是不会变成响应式的。\n以及，使用了 Object.freeze() 也会阻止修改现有的 property，也意味着响应系统无法再追踪变化。\n```\n\n​\t\t除了数据 property，Vue 实例还暴露了一些有用的实例 property 与方法。它们都有前缀 `$`，以便与用户定义的 property 区分开来。\n\n```\nvar data = { a: 1 }\nvar vm = new Vue({\n  el: '#example',\n  data: data\n})\n\nvm.$data === data // => true\nvm.$el === document.getElementById('example') // => true\n\n// $watch 是一个实例方法\nvm.$watch('a', function (newValue, oldValue) {\n  // 这个回调将在 `vm.a` 改变后调用\n})\n```\n\n​\t\t你可以在 [API 参考](https://cn.vuejs.org/v2/api/#实例-property)中查阅到完整的实例 property 和方法的列表。\n\n\n\n## 实例生命周期钩子\n\n​\t\t生命周期钩子简单来说就是一个回调函数。在 Vue 在执行到每个过程的时候也会执行这些生命周期的钩子。\n\n​\t\t**举个栗子：**\n\n```\nnew Vue({\n  data: {\n    a: 1\n  },\n  created: function () {\n    // `this` 指向 vm 实例\n    console.log('a is: ' + this.a)\n  }\n})\n// => \"a is: 1\"\n\n在 created 钩子可以用来在一个实例被创建之后执行代码：\n```\n\n**注意：**\n\n> 不要在选项 property 或回调上使用[箭头函数](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions)，比如 `created: () => console.log(this.a)` 或 `vm.$watch('a', newValue => this.myMethod())`。因为箭头函数并没有 `this`，`this` 会作为变量一直向上级词法作用域查找，直至找到为止，经常导致 `Uncaught TypeError: Cannot read property of undefined` 或 `Uncaught TypeError: this.myMethod is not a function` 之类的错误。\n\n\n\n## 生命周期图示\n\n![lifecycle](Vue2-教程-基础使用/lifecycle.png)\n\n\n\n# 模板语法\n\n```\nhttps://cn.vuejs.org/v2/guide/syntax.html\n```\n\n## 插值\n\n**文本：**\n\n​\t\t数据绑定最常见的形式就是使用“Mustache”语法 (双大括号) 的文本插值：\n\n```\n<span>Message: { { msg }}</span>\n```\n\n这里 msg 会替代为 数据对象的 msg。并且还带有响应式的功能。\n\n​\t\t通过使用 [v-once 指令](https://cn.vuejs.org/v2/api/#v-once)，你也能执行一次性地插值，当数据改变时，插值处的内容不会更新。但请留心这会影响到该节点上的其它数据绑定：\n\n```\n<span v-once>这个将不会改变: { { msg }}</span>\n```\n\n\n\n**原始HTML：**\n\n​\t\t双大括号会将数据解释为普通文本，而非 HTML 代码。为了输出真正的 HTML，你需要使用 [`v-html` 指令](https://cn.vuejs.org/v2/api/#v-html)：\n\n```\n<span v-html=\"rawHtml\"></span>\n```\n\n​\t\t会将 span 的内容替换为 rawHtml。并且在里面不会解析 proterty。\n\n> 你的站点上动态渲染的任意 HTML 可能会非常危险，因为它很容易导致 [XSS 攻击](https://en.wikipedia.org/wiki/Cross-site_scripting)。请只对可信内容使用 HTML 插值，**绝不要**对用户提供的内容使用插值。\n\n\n\n**Attribute：（属性）**\n\n​\t\tMustache 语法不能作用在 HTML 标签的属性上，所以要使用 v-bind 指令。\n\n```\n<div v-bind:id=\"dynamicId\"></div>\n\n对于同时使用了 v-bind:id 和 id 的。我们可以发现，谁在后面，其结果就是谁。\n```\n\n​\t\t对于布尔值的 attribute，原生的HTML中，只要存在就意味着值为 true，而 v-bind，工作起来当值为 false，null等，甚至不会渲染。\n\n\n\n**使用 JavaScript 表达式：**\n\n​\t\t对于所有的数据绑定，Vue.js 都提供了完全的 JavaScript 表达式支持。\n\n```\n{ { number + 1 }}\n\n{ { ok ? 'YES' : 'NO' }}\n\n{ { message.split('').reverse().join('') }}\n\n<div v-bind:id=\"'list-' + id\"></div>\n```\n\n\n\n## 指令\n\n​\t\t指令 (Directives) 是带有 `v-` 前缀的特殊 attribute。\n\n**参数：**\n\n​\t\t一些指令能够接收一个“参数”，在指令名称之后以冒号表示。例如，`v-bind` 指令可以用于响应式地更新 HTML attribute：\n\n```\n<a v-bind:href=\"url\">...</a>\n\n此时这个url是和数据的url是绑定的。\n```\n\n​\t\t`v-on` 指令，它用于监听 DOM 事件：\n\n```\n<a v-on:click=\"doSomething\">...</a>\n同时也有 mouseover 等等。\n```\n\n**注意：**\n\n​\t\t使用 v-on 指令监听 DOM 事件，原生的 onclick 方法会先于 v-on 进行监听，其次这个 v-on 里面的方法，既可以是 methods 的，也可以是 data 的。但是建议写在 methods 中。\n\n```\n<div id=\"app-6\">\n  <button @click=\"test1\" onclick=\"console.log(1);\">Button</button>\n</div>\n//其中这里这个 @ 代表了 v-on 的语法糖，我们后续会讲。\n\n\tlet obj = {\n    message: true,\n    test1() {\n      console.log(3);\n    }\n  }\n\n  var app6 = new Vue({\n    el: '#app-6',\n    data: obj,\n    methods: {\n      test() {\n        console.log(2);\n      }\n    }\n  })\n```\n\n\n\n**动态参数： 2.6.0新增**\n\n​\t\t可以用方括号括起来的 JavaScript 表达式作为一个指令的参数：\n\n```\n<!--\n注意，参数表达式的写法存在一些约束，如之后的“对动态参数表达式的约束”章节所述。\n-->\n<a v-bind:[attributeName]=\"url\"> ... </a>\n\n<a v-on:[eventName]=\"doSomething\"> ... </a>\n@[]，也可以。\n```\n\n​\t\t这里的 `attributeName` 会被作为一个 JavaScript 表达式进行动态求值，求得的值将会作为最终的参数来使用。这里的Vue实例中有 data property attributeName，值为 href，则就等价于 v-bind:href=\"url\"\n\n​\t**对动态参数的值的约束**\n\n​\t\t动态参数预期会求出一个字符串，异常情况下值为 `null`。这个特殊的 `null` 值可以被显性地用于移除绑定。任何其它非字符串类型的值都将会触发一个警告。\n\n​\t**对动态参数表达式的约束**\n\n​\t\t动态参数表达式有一些语法约束，因为某些字符，如空格和引号，放在 HTML attribute 名里是无效的。例如：\n\n```\n<!-- 这会触发一个编译警告 -->\n<a v-bind:['foo' + bar]=\"value\"> ... </a>\n\n使用引号会无法编译。\n并且使用了空格也会无法编译。\n```\n\n​\t\t变通的办法是使用没有空格或引号的表达式，或用计算属性替代这种复杂表达式。\n\n​\t\t在 DOM 中使用模板时 (直接在一个 HTML 文件里撰写模板)，还需要避免使用大写字符来命名键名，因为浏览器会把 attribute 名全部强制转为小写：\n\n```\n<!--\n在 DOM 中使用模板时这段代码会被转换为 `v-bind:[someattr]`。\n除非在实例中有一个名为“someattr”的 property，否则代码不会工作。\n-->\n<a v-bind:[someAttr]=\"value\"> ... </a>\n```\n\n\n\n**修饰符：**\n\n​\t\t修饰符 (modifier) 是以半角句号 `.` 指明的特殊后缀，用于指出一个指令应该以特殊方式绑定。例如，`.prevent` 修饰符告诉 `v-on` 指令对于触发的事件调用 `event.preventDefault()`：\n\n​\t\t与之相应的还有 `.laze` `.once` 等等。我们后续进行讲解。\n\n\n\n## 缩写 语法糖\n\n**v-bind 缩写**：\n\n```\n<!-- 完整语法 -->\n<a v-bind:href=\"url\">...</a>\n\n<!-- 缩写 -->\n<a :href=\"url\">...</a>\n\n<!-- 动态参数的缩写 (2.6.0+) -->\n<a :[key]=\"url\"> ... </a>\n```\n\n\n\n**v-on 缩写：**\n\n```\n<!-- 完整语法 -->\n<a v-on:click=\"doSomething\">...</a>\n\n<!-- 缩写 -->\n<a @click=\"doSomething\">...</a>\n\n<!-- 动态参数的缩写 (2.6.0+) -->\n<a @[event]=\"doSomething\"> ... </a>\n```\n\n\n\n# 计算属性和侦听器\n\n```\nhttps://cn.vuejs.org/v2/guide/computed.html\n```\n\n\n\n## 计算属性\n\n​\t\t简单来说，就是将逻辑更深层的解耦，比如：\n\n```\n{ { message.split('').reverse().join('') }}\n```\n\n​\t\t在模板中放入太多的逻辑会让模板过重且难以维护。\n\n​\t\t在这个地方，模板不再是简单的声明式逻辑。你必须看一段时间才能意识到，这里是想要显示变量 `message` 的翻转字符串。当你想要在模板中的多处包含此翻转字符串时，就会更加难以处理。\n\n​\t\t所以，对于任何复杂逻辑，你都应当使用**计算属性**。\n\n​\t\t我认为，从一个开发来看，对于一个表达式，如果以后会有多个地方进行相同的逻辑的使用，就应当使用计算属性，方便维护。\n\n\n\n### 基础例子\n\n```\n<div id=\"app-6\">\n  { { message }}\n  <br>\n  { { reversedMessage }}\n</div>\n```\n\n```\n  const vm = new Vue({\n    el: '#app-6',\n    data: {\n      message: 'true',\n    },\n    computed: {\n      // 计算属性的 getter\n      reversedMessage: function () {\n        // `this` 指向 vm 实例\n        return this.message.split('').reverse().join('')\n      }\n    },\n  })\n```\n\n​\t\t这里我们声明了一个计算属性 `reversedMessage`。我们提供的函数将用作 property `vm.reversedMessage` 的 getter 函数\n\n​\t\t计算属性默认是的方法是一个getter 方法， 就像是使用了 `Object.defineProperty` 的getter一样进行了操作。\n\n\n\n## 计算属性缓存 VS 方法\n\n​\t\t我们也可以发现，可以在插值表达式中使用方法来获取同样的效果。\n\n```\n<p>{ { reversedMessage() }}</p>\n\nmethods: {\n  reversedMessage: function () {\n    return this.message.split('').reverse().join('')\n  }\n}\n```\n\n​\t\t首先，对于结果来说是完全相同的。不同的地方在于，**计算属性是基于它们的响应式依赖进行缓存的**。意思就是说，只有相关的响应式依赖发生了改变，他们才会重新求值。没有发生改变，多次使用计算属性会立即返回之前的结果。\n\n​\t\t**举个栗子：**\n\n```\n<div id=\"app-6\">\n  { { message }}\n  <br>\n  { { reversedMessage }}\n  <br>\n  { { reversedMessage }}\n  <br>\n  { { reversedMessage }}\n</div>\n\n\n  const vm = new Vue({\n    el: '#app-6',\n    data: {\n      message: 'true',\n    },\n    computed: {\n      // 计算属性的 getter\n      reversedMessage: function () {\n        // `this` 指向 vm 实例\n        console.log(1);\n        return this.message.split('').reverse().join('')\n      }\n    },\n  })\n```\n\n​\t\t我这里使用了很多个插值表达式，但是发现控制台的输出，只有一个，这里代表了后续是直接使用的之前的计算结果。\n\n​\t\t其次，在值发生变化之时，也只输出了一次。因此计算属性的缓存效果则比方法有了更好的性能。\n\n​\t\t当然，如果不希望有缓存的存在，可以使用方法来替代。\n\n\n\n## 计算属性 VS 侦听属性\n\n​\t\tVue 提供了一种更通用的方式来观察和响应 Vue 实例上的数据变动：**侦听属性**。 `watch`  。\n\n​\t\t侦听属性 和 计算属性的不同\n\n```\nwatch: {\n  firstName: function (val) {\n  \tthis.fullName = val + ' ' + this.lastName\n  },\n  lastName: function (val) {\n  \tthis.fullName = this.firstName + ' ' + val\n  }\n},\ncomputed: {\n  fullName: function () {\n  \treturn this.firstName + ' ' + this.lastName\n  }\n}\n```\n\n​\t\t从上面可以看出，侦听属性(watch)的特点是，当一个属性发生改变后，调用的方法。\n\n​\t\t其次，需要对其进行初始化，因为在最开始侦听属性不会进行调用。\n\n​\t\t最后，这个侦听属性的执行时机，我们通过一个简单的死循环就可以看出。侦听属性在 DOM 的变化之前。但是处于值的变化之后。起码下面这个情况满足。这个说法。\n\n```\nwatch: {\n  message: function (val) {\n  console.log(this.message);\n  while (true) {\n  \tconsole.log(this.message);\n  }\n  \tthis.reversedMessage = val + ' --- ';\n  }\n},\n```\n\n\n\n## 计算属性的setter\n\n​\t\t默认计算属性只有 getter，不过在需要时你也可以提供一个 setter。\n\n```\ncomputed: {\n  fullName: {\n    // getter\n    get: function () {\n      return this.firstName + ' ' + this.lastName\n    },\n    // setter\n    set: function (newValue) {\n      var names = newValue.split(' ')\n      this.firstName = names[0]\n      this.lastName = names[names.length - 1]\n    }\n  }\n}\n```\n\n​\t\t在运行 `vm.fullName = 'John Doe'` 时，setter 会被调用，`vm.firstName` 和 `vm.lastName` 也会相应地被更新。\n\n​\t\t当然，如果你这样写，只能说你是小机灵鬼了，一直调用了 setter 方法导致溢出。\n\n```\nset: function (newValue) {\n  console.log(newValue);\n  this.reversedMessage += '1';\n}\n```\n\n​\t\t同时我们也可以使用一些简单的方式查看这个 setter 的执行时机。通过下面这个方式，我们发现了，setter 的执行在值的变化之前。\n\n```\ncomputed: {\n  // 计算属性的 getter\n  reversedMessage: {\n    get: function () {\n      // `this` 指向 vm 实例\n      console.log(1);\n      return this.message.split('').reverse().join('')\n    },\n    set: function (newValue) {\n      console.log(this.reversedMessage, newValue);\n      while (true) {\n      console.log(this.reversedMessage);\n    };\n  }\n},\n```\n\n\n\n## 侦听器\n\n> ​\t\t虽然计算属性在大多数情况下更合适，但有时也需要一个自定义的侦听器。这就是为什么 Vue 通过 `watch` 选项提供了一个更通用的方法，来响应数据的变化。当需要在数据变化时执行异步或开销较大的操作时，这个方式是最有用的。\n\n​\t\t简单来说就是对于一个异步，和一个开销大的操作时，监听器比较合适。\n\n​\t\t异步操作，限制访问频率(防抖)，设置中间状态等。\n\n\n\n# Class 与 Style 绑定\n\n```\nhttps://cn.vuejs.org/v2/guide/class-and-style.html\n```\n\n​\t\t在将 `v-bind` 用于 `class` 和 `style` 时，Vue.js 做了专门的增强。表达式结果的类型除了字符串之外，还可以是对象或数组。\n\n\n\n## 绑定 HTML Class\n\n### 对象语法\n\n```\nv-bind:class=\"{ active: isActive, 'text-danger': hasError }\"\n```\n\n​\t\t这样，就会根据 后面的真值来判断前面这个类是否能存在。并且这里 active 是一个字符串，就算这个 active 和后面的一个 data 数据重名，最终渲染的还是一个字符串。如何能让 active 也变成一个变量类型，\n\n```\n<div v-bind:class=\"{ [message]: flag }\"></div>\n```\n\n​\t\t这里使用了动态绑定，所以 message  会从data里面进行查找。找不到则为 undefined 的字符串。并且可以使用 .undefined 来进行操作。对于不是字符串的，会转为字符串处理。\n\n​\t\t并且绑定的数据对象不必内联定义在模板里。\n\n```\n<div v-bind:class=\"classObject\"></div>\n\ndata: {\n  classObject: {\n    active: true,\n    'text-danger': false\n  }\n}\n```\n\n​\t\t如果写在 data 里面，我还不知道如何将类名动态绑定。并且后面的 true 和 false 都是写死的那种，只能在后续使用方法改变。\n\n```\n    computed: {\n      classObject: function () {\n        return {\n          [this.message]: this.flag\n        }\n      }\n    },\n```\n\n​\t\t如果写在计算属性里面，那么类名和真值都可以通过 this 进行获取。类名还是一样通过 [] 获取。不加上就会直接当成一个字符串。\n\n\n\n### 数组语法\n\n​\t\t我们可以把一个数组传给 `v-bind:class`，以应用一个 class 列表\n\n```\n<div v-bind:class=\"[activeClass, errorClass]\"></div>\n\ndata: {\n  activeClass: 'active',\n  errorClass: 'text-danger'\n}\n```\n\n​\t\t对于不是字符串的，不会被显示，需要是字符串类型才会显示。\n\n​\t\t同时，也能写三元表达式\n\n```\n<div v-bind:class=\"[isActive ? activeClass : '', errorClass]\"></div>\n```\n\n​\t\t在数组语法中也可以使用对象语法：\n\n```\n<div v-bind:class=\"[{ active: isActive }, errorClass]\"></div>\n```\n\n\n\n### 在组件上\n\n​\t\t当在一个自定义组件上使用 `class` property 时，这些 class 将被添加到该组件的根元素上面。这个元素上已经存在的 class 不会被覆盖。\n\n```\nVue.component('my-component', {\n  template: '<p class=\"foo bar\">Hi</p>'\n})\n\n<my-component class=\"baz boo\"></my-component>\n\n<p class=\"foo bar baz boo\">Hi</p>\n```\n\n​\t\t在渲染的时候，重复的类名不会被消除。当然，最终的渲染结果还是看CSS的权重级别。\n\n\n\n## 绑定内联样式\n\n### 对象语法\n\n​\t\t`v-bind:style` 的对象语法十分直观——看着非常像 CSS，但其实是一个 JavaScript 对象。CSS property 名可以用驼峰式 (camelCase) 或短横线分隔 (kebab-case，记得用引号括起来) 来命名\n\n```\n<div v-bind:style=\"{ color: activeColor, fontSize: fontSize + 'px' }\"></div>\n\n<div v-bind:style=\"{ color: activeColor, 'font-size': fontSize + 'px' }\"></div>\n\ndata: {\n  activeColor: 'red',\n  fontSize: 30\n}\n```\n\n​\t\t当然也能绑定到一个样式对象。大致还是和上面的要求一样。\n\n\n\n### 数组语法\n\n​\t\t`v-bind:style` 的数组语法可以将多个样式对象应用到同一个元素上：\n\n```\n<div v-bind:style=\"[activeColor]\">123</div>\n\nactiveColor: {\n\tfontSize: '30px'\n},\n```\n\n​\t\t当然，也能将其作为一个数组加对象整合为一个返回值，绑定到一个样式对象。\n\n\n\n### 自动添加前缀\n\n​\t\t当 `v-bind:style` 使用需要添加[浏览器引擎前缀](https://developer.mozilla.org/zh-CN/docs/Glossary/Vendor_Prefix)的 CSS property 时，如 `transform`，Vue.js 会自动侦测并添加相应的前缀。\n\n​\t\t其次，对于使用了 v-bind:style 和 style 的，会以 v-bind:style 为主。\n\n\n\n### 多重值 （2.3.0）\n\n​\t\t从 2.3.0 起你可以为 `style` 绑定中的 property 提供一个包含多个值的数组，常用于提供多个带前缀的值\n\n```\n<div :style=\"{ display: ['-webkit-box', '-ms-flexbox', 'flex'] }\"></div>\n```\n\n​\t\t这样写只会渲染数组中最后一个被浏览器支持的值。在本例中，如果浏览器支持不带浏览器前缀的 flexbox，那么就只会渲染 `display: flex`。\n\n​\t\t**意思就是说**，对于这样的一个值的数组，我们会从后往前进行赋值，直到遇到浏览器可以支持的值，例如本例来说，先判断，flex，再判断 -ms-flexbox，最后再判断 -webkit-box。\n\n\n\n# 条件渲染\n\n```\nhttps://cn.vuejs.org/v2/guide/conditional.html\n```\n\n\n\n## v-if\n\n​\t\t`v-if` 指令用于条件性地渲染一块内容。这块内容只会在指令的表达式返回 truthy 值的时候被渲染。\n\n​\t\t也可以用 `v-else` 添加一个“else 块”：\n\n```\n<h1 v-if=\"awesome\">Vue is awesome!</h1>\n<h1 v-else>Oh no 😢</h1>\n```\n\n\n\n### 在 `<template>` 元素上使用 `v-if` 条件渲染分组\n\n​\t\t因为 `v-if` 是一个指令，所以必须将它添加到一个元素上。但是如果想切换多个元素呢？此时可以把一个 `<template>` 元素当做不可见的包裹元素，并在上面使用 `v-if`。最终的渲染结果将不包含 `<template>` 元素。\n\n```\n<template v-if=\"ok\">\n  <h1>Title</h1>\n  <p>Paragraph 1</p>\n  <p>Paragraph 2</p>\n</template>\n```\n\n​\t\t这里很好理解。首先 v-if 只能添加到一个元素上，所以我们使用了一个元素进行了包裹，然后这个 template 的一个特点就是不会显示，例如\n\n```\n<template>\n\t<div>123</div>\n</template>\n\n最终的显示结果就是\n<div>123</div>\n```\n\n​\t\t所以这个的好处在于，既能产生包裹，还能不将其 DOM 的结构进行变化。\n\n\n\n### v-else\n\n​\t\t你可以使用 `v-else` 指令来表示 `v-if` 的“else 块”\n\n​\t\t`v-else` 元素必须紧跟在带 `v-if` 或者 `v-else-if` 的元素的后面，否则它将不会被识别。\n\n```\n<div v-if=\"Math.random() > 0.5\">\n  Now you see me\n</div>\n<div v-else>\n  Now you don't\n</div>\n```\n\n\n\n### v-else-if（2.1.0）\n\n​\t\t`v-else-if`，顾名思义，充当 `v-if` 的“else-if 块”，可以连续使用\n\n​\t\t类似于 `v-else`，`v-else-if` 也必须紧跟在带 `v-if` 或者 `v-else-if` 的元素之后。\n\n```\n<div v-if=\"type === 'A'\">A</div>\n<div v-else-if=\"type === 'B'\">B</div>\n<div v-else>Not A/B/C</div>\n```\n\n\n\n### 用 `key` 管理可复用的元素\n\n​\t\tVue 会尽可能高效地渲染元素，通常会复用已有元素而不是从头开始渲染。这么做除了使 Vue 变得非常快之外，还有其它一些好处。\n\n```\n<template v-if=\"loginType === 'username'\">\n  <label>Username</label>\n  <input placeholder=\"Enter your username\">\n</template>\n<template v-else>\n  <label>Email</label>\n  <input placeholder=\"Enter your email address\">\n</template>\n```\n\n​\t\t那么在上面的代码中切换 `loginType` 将不会清除用户已经输入的内容。因为两个模板使用了相同的元素，`<input>` 不会被替换掉——仅仅是替换了它的 `placeholder`。\n\n\n\n​\t\t对于上述的代码，切换了 input  的输入框，但是却对于 value 值没有发生改变。但是如果我们会发现对于类名，style等属性是会发生改变。我们同时也可以知道 value 是input输入框的值，如果是对于 DOM 元素，可以通过 value 进行获取，但是在这里，虽然使用了 value 的属性，但是只要进行输入了，value 的值也不起效果。\n\n​\t\t但是我们同时也发现了，再切换之后，DOM 的指向没有改变。并且也发现了 value 的值在控制台的输出是有变化的。只是对于输入框的内容没有变化。个人猜测，这里input的输入和value 其实中间不是完全直接对应。输入框显示的 value 只是作为了一个最初值。但是内部的value已经发生了变化。\n\n​\t\t当然解决这个方法很简单。\n\n*  Vue 为你提供了一种方式来表达“这两个元素是完全独立的，不要复用它们”。只需添加一个具有唯一值的 `key` attribute 即可\n\n  * ```\n    <input placeholder=\"Enter your username\" key=\"username-input\">\n    ```\n\n  * 这里，只需要 key 值不同即可。并且发现加了 key 值之后， DOM 获取的元素已经不会根据你的按钮发生变化，并且值也不会发生变化了，因为已经不是一个 input 框了，就算是换回来也不是一个了，因为 v-if 是直接修改了 DOM 树。\n\n  * ```\n    <template v-if=\"loginType === 'username'\">\n      <label>Username</label>\n      <input key=\"a\" class=\"a\" style=\"color: red; font-size: 20px\" placeholder=\"Enter your username\" value=\"1\">\n    </template>\n    <template v-else>\n      <label>Email</label>\n      <input key=\"b\" class=\"b\" placeholder=\"Enter your email address\" value=\"2\">\n    </template>\n    \n    \n    记住，这个需要放在 vue实例之后，应该是因为 template 的原因。\n    const a = document.querySelector('input.a'),\n    \tb = document.querySelector('input.b');\n    function c() {\n      console.log(a);\n      console.log(a.value);\n    }\n    ```\n\n* 当然，还可以使用 v-model 将数据进行绑定，那么input输入框的显示也会跟数据有关了。并且 v-model 是进行的复用。因为 DOM 的输出是会发生变化的。并且输入框和data数据是实时绑定了的。\n\n\n\n## v-show\n\n​\t\t另一个用于根据条件展示元素的选项是 `v-show` 指令。用法大致一样\n\n```\n<h1 v-show=\"ok\">Hello!</h1>\n```\n\n​\t\t同的是带有 `v-show` 的元素始终会被渲染并保留在 DOM 中。`v-show` 只是简单地切换元素的 CSS property `display`。\n\n> 注意，`v-show` 不支持 `<template>` 元素，也不支持 `v-else`。\n\n​\t\tv-show 不支持 template 元素，意思就是说，你在 template 元素上使用 v-show，不管是 true 还是 false，template 都会显示在页面上，而如果你使用v-if就会发现，结果是不一样的。\n\n​\t\tv-show 不支持 v-else，就如字面上来说，不支持的意思。\n\n\n\n## v-if VS v-show\n\n​\t\t`v-if` 是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。\n\n​\t\t`v-if` 也是**惰性的**：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。\n\n​\t\t相比之下，`v-show` 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。\n\n​\t\t一般来说，`v-if` 有更高的切换开销，而 `v-show` 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 `v-show` 较好；如果在运行时条件很少改变，则使用 `v-if` 较好。\n\n​\t\t**简单概括：**\n\n* **v-if** 是会直接和 DOM 树相关。而 **v-show** 只是简单的使用了 display:none，和渲染树相关。\n* 所以 v-if 对于切换会产生高开销，因为每次都会进行 DOM 的修改。而 v-show 会产生初始渲染的高开销，因为不管是否显示都会渲染。\n* 所以，对于频繁切换使用 v-show，对于很少改变使用 v-if。\n\n\n\n## v-if 和 v-for 一起使用\n\n> **不推荐**同时使用 `v-if` 和 `v-for`。请查阅[风格指南](https://cn.vuejs.org/v2/style-guide/#避免-v-if-和-v-for-用在一起-必要)以获取更多信息。\n\n​\t\t当 `v-if` 与 `v-for` 一起使用时，`v-for` 具有比 `v-if` 更高的优先级。请查阅[列表渲染指南](https://cn.vuejs.org/v2/guide/list.html#v-for-with-v-if)以获取详细信息。\n\n​\t\t当它们处于同一节点，`v-for` 的优先级比 `v-if` 更高，这意味着 `v-if` 将分别重复运行于每个 `v-for` 循环中。当你只想为*部分*项渲染节点时，这种优先级的机制会十分有用。\n\n​\t\t通过查看了 风格指南，主要说几点：\n\n* 避免一起使用\n\n* 对于需要过滤一个列表中的项目，采用计算属性\n\n  * ```\n    v-for=\"user in users\" v-if=\"user.isActive\"\n    \n    可以对 user 使用一个计算属性 activeUser 使用filter过滤后返回\n    v-for=\"user in activeUsers\"\n    \n    computed: {\n    \tactiveUsers: function() {\n    \t\treturn this.users.filter((user) => user.isActive);\n    \t}\n    }\n    ```\n\n* 对于会直接应该被隐藏的列表，将 v-if 放在上层，不要在每次循环的时候判断\n\n  * ```\n    v-for=\"user in users\" v-if=\"shouldShowUsers\"\n    \n    shouldShowUsers 这是对一个 users 进行的判断，只要为 false，所有的 users都不会显示，所以这个建议放在上层\n    v-if=\"shouldShowUsers\"\n    \tv-for=\"user in users\"\n    ```\n\n\n\n# 列表渲染\n\n```\nhttps://cn.vuejs.org/v2/guide/list.html\n```\n\n\n\n## 用 v-for 把一个数组对应为一组元素\n\n​\t\t我们可以用 `v-for` 指令基于一个数组来渲染一个列表。`v-for` 指令需要使用 `item in items` 形式的特殊语法，其中 `items` 是源数据数组，而 `item` 则是被迭代的数组元素的**别名**。\n\n```\n<ul id=\"example-1\">\n  <li v-for=\"item in items\" :key=\"item.message\">\n    {{ item.message }}\n  </li>\n</ul>\n\nitems: [\n  { message: 'Foo' },\n  { message: 'Bar' }\n]\n```\n\n​\t\t`v-for` 还支持一个可选的第二个参数，即当前项的索引。\n\n```\n<li v-for=\"(item, index) in items\">\n\t{{ parentMessage }} - {{ index }} - {{ item.message }}\n</li>\n```\n\n​\t\tindex 从0开始。\n\n​\t\t你也可以用 `of` 替代 `in` 作为分隔符，因为它更接近 JavaScript 迭代器的语法\n\n```\n<div v-for=\"item of items\"></div>\n```\n\n\n\n## 在 `v-for` 里使用对象\n\n​\t\t你也可以用 `v-for` 来遍历一个对象的 property。\n\n```\n<li v-for=\"value in object\">\n\t{{ value }}\n</li>\n\nobject: {\n  title: 'How to do lists in Vue',\n  author: 'Jane Doe',\n  publishedAt: '2016-04-10'\n}\n```\n\n​\t\t你也可以提供第二个的参数为 property 名称 (也就是键名)\n\n```\n<div v-for=\"(value, name) in object\">\n  {{ name }}: {{ value }}\n</div>\n\ntitle: How to do lists in Vue\n```\n\n​\t\t还可以用第三个参数作为索引\n\n```\n<div v-for=\"(value, name, index) in object\">\n\n0\n1\n2\n```\n\n> ​\t\t在遍历对象时，会按 `Object.keys()` 的结果遍历，但是**不能**保证它的结果在不同的 JavaScript 引擎下都一致。\n\n\n\n**注意：**\n\n* 如果 v-for 里面是一个正整数n，那么将会变成 1~n，如果是一个小数，会报错。\n  * 因为这个方法是会对其进行length操作，所以对于非正整数将出问题。\n* 如果v-for里面是一个字符串，那么将会把字符串挨个字符输出。\n\n\n\n## 维护状态\n\n​\t\t当 Vue 正在更新使用 `v-for` 渲染的元素列表时，它默认使用“就地更新”的策略。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序，而是就地更新每个元素，并且确保它们在每个索引位置正确渲染。这个类似 Vue 1.x 的 `track-by=\"$index\"`。\n\n​\t\t**简单来说就是**，发现了变化，不会查看是否是有匹配的 DOM，而是直接将原来位置上的DOM进行改变。比如如果只是位置发生了改变，如果使用默认的方式，那么就会挨着将DOM进行修改，但是如果使用了key来进行维护，那么会查看是否有key值存在的，有的话就会直接使用key的DOM进行维护。没有再创建。\n\n​\t\t这个默认的模式是高效的，但是**只适用于不依赖子组件状态或临时 DOM 状态 (例如：表单输入值) 的列表渲染输出**。\n\n​\t\t**这里给的意思就是说**，如果对于依赖了子组件话，那么进行修改的时候需要耗费大量的时间，所以需要进行一些判断来处理要使用什么方法。\n\n​\t\t为了给 Vue 一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一 `key` attribute\n\n​\t\t就是说可以使用key来进行定位。\n\n```\n<div v-for=\"item in items\" v-bind:key=\"item.id\">\n  <!-- 内容 -->\n</div>\n```\n\n​\t\t建议尽可能在使用 `v-for` 时提供 `key` attribute，除非遍历输出的 DOM 内容非常简单，或者是刻意依赖默认行为以获取性能上的提升。\n\n​\t\t因为它是 Vue 识别节点的一个通用机制，`key` 并不仅与 `v-for` 特别关联。后面我们将在指南中看到，它还具有其它用途。\n\n​\t\t其次对于key值，不要使用index下标进行赋值，因为如果你对数组进行了变化，位置变化等，可能下标也会发生改变，这样可能还会降低性能。\n\n> ​\t\t不要使用对象或数组之类的非基本类型值作为 `v-for` 的 `key`。请用字符串或数值类型的值。\n\n\n\n## 数组更新检测\n\n### 变更方法\n\n​\t\t因为Vue的响应式是相对于Object.defineProperty的使用。所以Vue对数组的处理方式是，对方法进行了包裹，所以使用了数组的方法也会触发视图的更新。\n\n​\t\t这些方法包括了\n\n```\npush，pop，shift，unshift，splice，sort，reverse\n```\n\n\n\n### 替换数组\n\n​\t\t变更方法，顾名思义，会变更调用了这些方法的原始数组。相比之下，也有非变更方法，例如 `filter()`、`concat()` 和 `slice()`。它们不会变更原始数组，而**总是返回一个新数组**。当使用非变更方法时，可以用新数组替换旧数组。\n\n```\nexample1.items = example1.items.filter(function (item) {\n  return item.message.match(/Foo/)\n})\n```\n\n​\t\t简单来说，上面的变更方法在调用之后是会变化原数组的。但是我们也有不会变更原数组的方法。所以对于这些不会变更原数组的方法，我们可以选择直接进行重新赋值。\n\n```\nitems = newItems\n```\n\n​\t\t我们可以发现对数组直接进行赋值也触发了视图的变化。因为我们对items这个数组也进行了监听。地址的改变也触发了视图的变化，同理，对于一个对象也是一样的。\n\n​\t\t你可能认为这将导致 Vue 丢弃现有 DOM 并重新渲染整个列表。幸运的是，事实并非如此。Vue 为了使得 DOM 元素得到最大范围的重用而实现了一些智能的启发式方法，所以用一个含有相同元素的数组去替换原来的数组是非常高效的操作。\n\n> ​\t\t由于 JavaScript 的限制，Vue **不能检测**数组和对象的变化。[深入响应式原理](https://cn.vuejs.org/v2/guide/reactivity.html#检测变化的注意事项)中有相关的讨论。\n\n\n\n### 显示过滤/排序后的结果\n\n​\t\t有时，我们想要显示一个数组经过过滤或排序后的版本，而不实际变更或重置原始数据。在这种情况下，可以创建一个计算属性，来返回过滤或排序后的数组。\n\n```\n<li v-for=\"n in evenNumbers\">{{ n }}</li>\n\ncomputed: {\n  evenNumbers: function () {\n    return this.numbers.filter(function (number) {\n      return number % 2 === 0\n    })\n\t}\n}\n```\n\n​\t\t对于计算属性不适合的情况下，比如是循环嵌套了循环，此时对于循环内层，用不了计算属性，可以使用方法\n\n```\n<ul v-for=\"set in sets\">\n  <li v-for=\"n in even(set)\">{{ n }}</li>\n</ul>\n\neven: function (numbers) {\n  return numbers.filter(function (number) {\n  \treturn number % 2 === 0\n  })\n}\n```\n\n​\t\t当然，你可能会想着，我对这个内层也加一个计算属性啊，但是，是没有效果的，简单来说就是因为就近原则，一个是循环的set，一个计算属性的set，他会先找循环的set。\n\n\n\n### 在 v-for 里使用值范围\n\n​\t\t`v-for` 也可以接受整数。在这种情况下，它会把模板重复对应次数。\n\n​\t\t对于字符串则会将字符进行循环。\n\n\n\n### 在 \\<template> 上使用 v-for\n\n​\t\t类似于 `v-if`，你也可以利用带有 `v-for` 的 `<template>` 来循环渲染一段包含多个元素的内容。\n\n\n\n### 在组件上使用 `v-for`\n\n​\t\t在自定义组件上，你可以像在任何普通元素上一样使用 `v-for`。\n\n```\n<my-component v-for=\"item in items\" :key=\"item.id\"></my-component>\n```\n\n​\t\t**2.2.0+ 的版本里，当在组件上使用 `v-for` 时，`key` 现在是必须的。**\n\n​\t\t然而，任何数据都不会被自动传递到组件里，因为组件有自己独立的作用域。为了把迭代数据传递到组件里，我们要使用 prop。\n\n```\n<ul>\n  <li\n    is=\"todo-item\"\n    v-for=\"(todo, index) in todos\"\n    v-bind:key=\"todo.id\"\n    v-bind:title=\"todo.title\"\n    v-on:remove=\"todos.splice(index, 1)\"\n  ></li>\n</ul>\n\nVue.component('todo-item', {\n  template: '\\\n    <li>\\\n      {{ title }}\\\n      <button v-on:click=\"$emit(\\'remove\\')\">Remove</button>\\\n    </li>\\\n  ',\n  props: ['title']\n})\n```\n\n> ​\t\t注意这里的 `is=\"todo-item\"` attribute。这种做法在使用 DOM 模板时是十分必要的，因为在 `<ul>` 元素内只有 `<li>` 元素会被看作有效内容。这样做实现的效果与 `<todo-item>` 相同，但是可以避开一些潜在的浏览器解析错误。查看 [DOM 模板解析说明](https://cn.vuejs.org/v2/guide/components.html#解析-DOM-模板时的注意事项) 来了解更多信息。\n\n​\t\t简单来说，ul 元素内只有li元素被看作有效，我们使用is方法进行了替换，这样重点可以避开潜在的浏览器解析错误。当然这是一个Vue的方法。\n\n\n\n# 事件处理\n\n```\nhttps://cn.vuejs.org/v2/guide/events.html\n```\n\n\n\n## 监听事件\n\n​\t\t可以用 `v-on` 指令监听 DOM 事件，并在触发时运行一些 JavaScript 代码。对应的语法糖，`@`\n\n```\n<button v-on:click=\"counter += 1\">Add 1</button>\n```\n\n\n\n## 事件处理方法\n\n​\t\t然而许多事件处理逻辑会更为复杂，所以直接把 JavaScript 代码写在 `v-on` 指令中是不可行的。因此 `v-on` 还可以接收一个需要调用的方法名称。\n\n```\n<!-- `greet` 是在下面定义的方法名 -->\n<button v-on:click=\"greet\">Greet</button>\n\n// 在 `methods` 对象中定义方法\nmethods: {\n  greet: function (event) {\n    // `this` 在方法里指向当前 Vue 实例\n    alert('Hello ' + this.name + '!')\n    // `event` 是原生 DOM 事件\n    if (event) {\n    \talert(event.target.tagName)\n    }\n  }\n}\n\n// 也可以用 JavaScript 直接调用方法\nvm.greet() // => 'Hello Vue.js!'\n```\n\n\n\n## 内联处理器中的方法\n\n​\t\t除了直接绑定到一个方法，也可以在内联 JavaScript 语句中调用方法：\n\n```\n<button v-on:click=\"say('hi')\">Say hi</button>\n\nmethods: {\n  say: function (message) {\n  \talert(message)\n  }\n}\n```\n\n​\t\t有时也需要在内联语句处理器中访问原始的 DOM 事件。可以用特殊变量 `$event` 把它传入方法\n\n```\n<button v-on:click=\"warn('Form cannot be submitted yet.', $event)\">Submit</button>\n```\n\n\n\n**对于event方法的使用：**\n\n* 如果方法是不带参数的，可以直接使用event，或者参数上加上event\n\n  * ```\n    <button @click=\"change\">button</button>\n    \n    change(event) {console.log(event);},\n    change() {console.log(event);}\n    ```\n\n  * 不同点：\n\n    * 如果使用了 @click=change()，加上了括号，对于第一个，传参event的，无法使用，第二个可以使用。\n\n* 当然我们也可以使用 $event 来传递这个参数。\n\n\n\n## 事件修饰符\n\n​\t\t在事件处理程序中调用 `event.preventDefault()` 或 `event.stopPropagation()` 是非常常见的需求。尽管我们可以在方法中轻松实现这点，但更好的方式是：方法只有纯粹的数据逻辑，而不是去处理 DOM 事件细节。\n\n​\t\t首先默认使用的click方法就是冒泡类型。\n\n​\t\t常见的事件修饰符\n\n```\n.stop\n\t阻止事件的冒泡\n.prevent\n\t阻止事件的默认行为，对于在父元素使用了阻止默认行为，子元素的默认行为都会被阻止。\n.capture\n\t转为捕获事件监听，事件的监听顺序是 root --> target 捕获， target --> root 冒泡\n.self\n\t只有目标元素是自身才会触发，对于子元素的点击也不会触发。\n.once\t/ 2.1.4 新增\n\t只触发一次。\n.passive / 2.3.0 新增\n\t\n```\n\n​\t\t不像其它只能对原生的 DOM 事件起作用的修饰符，`.once` 修饰符还能被用到自定义的[组件事件](https://cn.vuejs.org/v2/guide/components-custom-events.html)上\n\n> ​\t\t使用修饰符时，顺序很重要；相应的代码会以同样的顺序产生。因此，用 `v-on:click.prevent.self` 会阻止**所有的点击**，而 `v-on:click.self.prevent` 只会阻止对元素自身的点击。\n\n```\n<div @click.prevent.self=\"change\">\n  <a href=\"#1\" @click=\"change1\">321</a>\n  <div @click=\"change1\">123</div>\n</div>\n\n<div @click.self.prevent=\"change\">\n  <a href=\"#1\" @click=\"change1\">321</a>\n  <div @click=\"change1\">123</div>\n</div>\n```\n\n​\t\t**热知识**：父元素阻止了默认行为会影响到子元素。\n\n​\t\t**热知识2：** click方法会先于默认行为执行。并且要冒泡结束了之后才会执行。\n\n​\t\tVue 还对应 [`addEventListener` 中的 `passive` 选项](https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Parameters)提供了 `.passive` 修饰符。\n\n```\n<!-- 滚动事件的默认行为 (即滚动行为) 将会立即触发 -->\n<!-- 而不会等待 `onScroll` 完成  -->\n<!-- 这其中包含 `event.preventDefault()` 的情况 -->\n<div v-on:scroll.passive=\"onScroll\">...</div>\n```\n\n​\t\t他这里是这样说，貌似意思是说，默认行为会先触发，然后再触发 onScroll 的方法，但是我对一个。a标签进行操作的时候发现是先输出，然后在跳转，对于一个scroll行为的测试从肉眼上看也是和a标签一样，当然这个滚动的行为可能才滚1帧就开始触发了循环，导致卡帧也有可能。所以我现在不知道如何判断。\n\n```\n<div @click=\"change\">\n\t<a href=\"#1\" @click.passive=\"change1\">321</a>\n</div>\n\nmethods: {\n  change() {\n    console.log('father');\n    let date = new Date().getTime() + 1000;\n    while (date > new Date()) {\n\n    };\n  },\n  change1() {\n  \tconsole.log('children');\n  }\n}\n```\n\n​\t\t发现是先输出控制台，然后url再变化的。\n\n​\t\t并且如果父元素使用了 prevent，子元素的passive无效，passive只能让本元素上的prevent无效。\n\n​\t\t这个 `.passive` 修饰符尤其能够提升移动端的性能。 \n\n​\t\t\n\n## 按键修饰符\n\n​\t\t在监听键盘事件时，我们经常需要检查详细的按键。Vue 允许为 `v-on` 在监听键盘事件时添加按键修饰符\n\n```\n<!-- 只有在 `key` 是 `Enter` 时调用 `vm.submit()` -->\n<input v-on:keyup.enter=\"submit\">\n```\n\n\n\n### 按键码\n\n> ​\t\t`keyCode` 的事件用法[已经被废弃了](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/keyCode)并可能不会被最新的浏览器支持。\n\n​\t\t使用 `keyCode` attribute 也是允许的：\n\n```\n<input v-on:keyup.13=\"submit\">\n```\n\n​\t\t为了在必要的情况下支持旧浏览器，Vue 提供了绝大多数常用的按键码的别名：\n\n```\n.enter\t.tab\t.delete (捕获“删除”和“退格”键)\t.esc\t.space\t.up\t.down\t.left\t.right\n```\n\n> ​\t\t有一些按键 (`.esc` 以及所有的方向键) 在 IE9 中有不同的 `key` 值, 如果你想支持 IE9，这些内置的别名应该是首选。\n\n​\t\t你还可以通过全局 `config.keyCodes` 对象[自定义按键修饰符别名](https://cn.vuejs.org/v2/api/#keyCodes)：\n\n```\n// 可以使用 `v-on:keyup.f1`\nVue.config.keyCodes.f1 = 112\n```\n\n​\t\t按键别名可以进行覆盖，当然这个不建议这样写已经存在的。\n\n**注意：**\n\n​\t\t按键别名不要使用大写，因为大写的在 `<input v-on:keyup.enter=\"submit\"> `，在这里会转为小写，所以无法使用成功。\n\n```\n<input type=\"text\" @keyup.A=\"change\">\n\nVue.config.keyCodes.A = 97;\n```\n\n\n\n## 系统修饰键\n\n​\t\t可以用如下修饰符来实现仅在按下相应按键时才触发鼠标或键盘事件的监听器。(2.1.0新增)\n\n```\n.ctrl\n.alt\n.shift\n.meta\n\t就是Windows键盘上的那个Windows图标按钮。mac同理\n```\n\n> ​\t\t注意：在 Mac 系统键盘上，meta 对应 command 键 (⌘)。在 Windows 系统键盘 meta 对应 Windows 徽标键 (⊞)。在 Sun 操作系统键盘上，meta 对应实心宝石键 (◆)。在其他特定键盘上，尤其在 MIT 和 Lisp 机器的键盘、以及其后继产品，比如 Knight 键盘、space-cadet 键盘，meta 被标记为“META”。在 Symbolics 键盘上，meta 被标记为“META”或者“Meta”。\n>\n\n```\n<!-- Alt + C -->\n<input v-on:keyup.alt.67=\"clear\">\n\n<!-- Ctrl + Click -->\n<div v-on:click.ctrl=\"doSomething\">Do something</div>\n```\n\n**注意：**\n\n* 使用系统修饰键对于 @keyup.67.ctrl 和 @keyup.ctrl.67 是一样的。不会有先后顺序。\n* 请注意修饰键与常规按键不同，在和 `keyup` 事件一起用时，事件触发时修饰键必须处于按下状态。换句话说，只有在按住 `ctrl` 的情况下释放其它按键，才能触发 `keyup.ctrl`。而单单释放 `ctrl` 也不会触发事件。如果你想要这样的行为，请为 `ctrl` 换用 `keyCode`：`keyup.17`。17代表了ctrl\n* **@keyup.17.67** 这个代表了按这两个其中一个都有效\n* 系统修饰键可以使用多个。\n\n\n\n### .exact 修饰符（2.5.0新增）\n\n​\t\t`.exact` 修饰符允许你控制由精确的系统修饰键组合触发的事件。\n\n​\t\t**作用**：用于**精确**控制系统修饰键按键的修饰符。主要在于精确两个字。并且是对系统修饰键起作用的。\n\n```\n<input type=\"text\" @keyup.a.up.exact=\"change\">\n\t这个里面没有系统修饰键，监听了两个按键，最终效果：没有什么区别，唯一的区别就是如果此时你按了系统修饰键将不会触发。\n\t所以这个代表了<!-- 没有任何系统修饰键被按下的时候才触发 -->\n```\n\n```\n<input type=\"text\" @keyup.ctrl.up.exact=\"change\">\n\t这个里面存在了系统修饰键 ctrl，所以效果就是必须按了 ctrl才会有用，（当然这个是系统修饰键的效果），.exact修饰符 的效果就是，系统修饰键必须只按了ctrl才有用。精确。加上系统修饰键。\n\t其次.exact 修饰符没有位置的要求，和系统修饰键一样没有位置要求，\n\t然后就是对于 <input type=\"text\" @keyup.exact.ctrl.up.a=\"change\"> 我们可以发现， 一个exact修饰符，一个ctrl系统修饰键，两个普通按键修饰符。所以最终的效果是，有且只有按了ctrl键，加上普通按键修饰符的其中一个就行。\n\t<!-- 有且只有 Ctrl 被按下的时候才触发 -->\n```\n\n\n\n### 鼠标按钮修饰符（2.2.0新增）\n\n​\t\t这些修饰符会限制处理函数仅响应特定的鼠标按钮。\n\n```\n.left\n.right\n.middle\n```\n\n​\t\t用于点击事件，对于keyup事件不起作用，当然对于系统修饰键和.exact修饰符没有这些要求。\n\n```\n<div @click.middle.ctrl.exact=\"change\">321</div>\n\t要求是 ctrl键 + 鼠标中键才会触发。\n```\n\n\n\n## 为什么要在 HTML 中监听事件\n\n​\t\t你可能注意到这种事件监听的方式违背了关注点分离 (separation of concern) 这个长期以来的优良传统。但不必担心，因为所有的 Vue.js 事件处理方法和表达式都严格绑定在当前视图的 ViewModel 上，它不会导致任何维护上的困难。实际上，使用 `v-on` 有几个好处：\n\n1. 扫一眼 HTML 模板便能轻松定位在 JavaScript 代码里对应的方法。\n2. 因为你无须在 JavaScript 里手动绑定事件，你的 ViewModel 代码可以是非常纯粹的逻辑，和 DOM 完全解耦，更易于测试。\n3. 当一个 ViewModel 被销毁时，所有的事件处理器都会自动被删除。你无须担心如何清理它们。\n\n\n\n**概括就是说**：虽然是在html中进行的使用监听，但是真正的处理是绑定在VM上的。其次对于v-on的好处：1.能够一眼看出方法。2.和DOM完全解耦。3.当一个VM被销毁时，所有的事件会自动清除。\n\n\n\n# 表单输入绑定\n\n```\nhttps://cn.vuejs.org/v2/guide/forms.html\n```\n\n\n\n## 基础用法\n\n​\t\t你可以用 `v-model` 指令在表单 `<input>`、`<textarea>` 及 `<select>` 元素上创建双向数据绑定。它会根据控件类型自动选取正确的方法来更新元素。\n\n```\n<input v-model=\"message\" placeholder=\"edit me\">\n这里，我是用 v-model，并没有绑定给value，但是会自动选取正确的方法进行更新。\n```\n\n\n\n**注意：**\n\n* v-model 会忽略元素自带的value，checked等属性，而是使用Vue实例的数据作为来源。\n\n\n\n​\t\t`v-model` 在内部为不同的输入元素使用不同的 property 并抛出不同的事件。\n\n- text 和 textarea 元素使用 `value` property 和 `input` 事件；\n- checkbox 和 radio 使用 `checked` property 和 `change` 事件；（使用的是真值方式truth）\n- select 字段将 `value` 作为 prop 并将 `change` 作为事件。\n\n\n\n> ​\t\t对于需要使用[输入法](https://zh.wikipedia.org/wiki/输入法) (如中文、日文、韩文等) 的语言，你会发现 `v-model` 不会在输入法组合文字过程中得到更新。如果你也想处理这个过程，请使用 `input` 事件。\n\n​\t\t你在输入框输入加上一个input事件的监听的时候就会发现。如果在输入的时候使用了中文，虽然在按键的时候发生了input事件，但是v-model的值并没有得到更新。\n\n​\t\t但是如果是普通的input输入框的监听则会发生更新。\n\n```\n<input type=\"text\" v-model=\"string\" @input=\"change\" oninput=\"console.log('event:    ' + event.target.value);\">\n```\n\n​\t\t并且在进行了空格之后会发生多次的更新。\n\n\n\n### 文本 和 多行文本\n\n```\n<input type=\"text\" v-model=\"message\">\n<textarea v-model=\"message\"></textarea>\n```\n\n​\t\t在文本区域插值 (`<textarea>{{text}}</textarea>`) 并不会生效，应用 `v-model` 来代替。\n\n\n\n### 复选框\n\n​\t\t单个复选框，直接布尔值进行的判断，对于不是布尔类型的使用了truth方式。\n\n```\n<input type=\"checkbox\" id=\"checkbox\" v-model=\"checked\">\n```\n\n​\t\t对于多个复选框\n\n​\t\t注意：复选框和单选框是通过value进行判断。\n\n```\n<input type=\"checkbox\" id=\"jack\" value=\"Jack\" v-model=\"checkedNames\">\n<label for=\"jack\">Jack</label>\n<input type=\"checkbox\" id=\"john\" value=\"John\" v-model=\"checkedNames\">\n<label for=\"john\">John</label>\n<input type=\"checkbox\" id=\"mike\" value=\"Mike\" v-model=\"checkedNames\">\n<label for=\"mike\">Mike</label>\n```\n\n​\t\t~~我们可以发现，这里没有对复选框进行分组，正常的情况下，复选框需要进行name的分组，相同的name为一组。这个好像是对单选框的。复选框应该本来就可以不用分组？~~\n\n​\t\t对于一个复选框，如果绑定了v-model，但是value不绑定，那么点击一个就是点击多个。因为没有使用value属性，值为null，所以所有为null都会被同步变化。\n\n​\t\t同时，如果多选的复选框，但是绑定的属性不是一个数组那么最终也会变为全部都会出现相同的变化。 `checkedNames: 1,` \n\n\n\n\n\n### 单选按钮\n\n```\n  <input type=\"radio\" name=\"aa\" id=\"jack\" value=\"Jack\" v-model=\"checkedNames\">\n  <label for=\"jack\">Jack</label>\n  <input type=\"radio\" name=\"cc\" id=\"john\" value=\"John\" v-model=\"checkedNames\">\n  <label for=\"john\">John</label>\n  <input type=\"radio\" name=\"aa\" id=\"mike\" value=\"Mike\" v-model=\"checkedNames\">\n  <label for=\"mike\">Mike</label>\n```\n\n​\t\t在这里，我将name进行不同的划分，但是可以发现他们还是一组的成员。\n\n​\t\t~~所以我们可以这样认为，使用了v-model之后，name也会绑定为这个属性的名称，所以你自己定义的属性名称是没有作用的。~~（注意：这里不是说，绑定的是v-model属性的名称，而是说，name的绑定和v-model的属性相关了。但是值不知道是什么。）\n\n​\t\t**注意：** 首先我们可以测试出来，name的属性还是没有改变，因为如果添加了一个 相同name，但是没有使用v-model的，会出现竞争。\n\n​\t\t对于单选按钮，**没有使用value的**，那么v-model绑定的属性取出来的值是空。就是那种什么都没有的空。**并且name属性默认不同**。\n\n​\t\t如果自己定义了name属性，那么会以自己定义的为准。但是如果使用了value，搭配了v-model，对于同value，不同name，两个都选上。 ~~那么name属性还是以v-model为准（是指相同的v-model有相同的name）。~~\n\n​\t\t并且，如果value相等，name不等，那么点击时，都会一起变化。如果name相等了，那么点击时点击那个就是哪个，但是value的值不变，并且对于初始化来说，是根据value的值来进行的变化，所以会以最后一个为准。\n\n​\t\t这里有很多问题，但是这些都是可以手动避免的。大概知道就行。我也被自己扯蒙了。\n\n\n\n### 选择框\n\n​\t\t单选时，直接绑定一个值即可\n\n```\n  <select v-model=\"selected\">\n    <option disabled value=\"\">请选择</option>\n    <option>A</option>\n    <option>B</option>\n    <option>C</option>\n  </select>\n  <span>Selected: {{ selected }}</span>\n```\n\n​\t\t我们也可以发现，对于使用option的时候，可以不添加value属性，此时绑定的值就是内容。\n\n**注意：**如果没有规定 value 属性，选项的值将设置为 \\<option> 标签中的内容。\n\n**注意：**\n\n> ​\t\t如果 `v-model` 表达式的初始值未能匹配任何选项，`<select>` 元素将被渲染为“未选中”状态。在 iOS 中，这会使用户无法选择第一个选项。因为这样的情况下，iOS 不会触发 change 事件。因此，更推荐像上面这样提供一个值为空的禁用选项。\n\n​\t\t当然这个我不清楚，毕竟我没有IOS。。。。。。\n\n\n\n​\t\t多选时就是绑定一个数组\n\n```\n<select v-model=\"selected\" multiple style=\"width: 50px;\">\n  <option>A</option>\n  <option>B</option>\n  <option>C</option>\n</select>\n<br>\n<span>Selected: {{ selected }}</span>\n```\n\n​\t\t首先，select多选框的属性 multiple，其次就是使用的数组了。\n\n​\t\t对于不是使用数组的，将不会初始化成功，但是在后续的赋值还是会转化为数组。\n\n​\t\t当然，对于 option 也可以使用v-for进行动态渲染。\n\n```\n<option v-for=\"item in options\">{{ item }}</option>\n```\n\n\n\n## 值绑定\n\n​\t\t对于单选按钮，复选框及选择框的选项，`v-model` 绑定的值通常是静态字符串 (对于复选框也可以是布尔值)：\n\n​\t\t但是有时我们可能想把值绑定到 Vue 实例的一个动态 property 上，这时可以用 `v-bind` 实现，并且这个 property 的值可以不是字符串。\n\n```\n<!-- 当选中时，`picked` 为字符串 \"a\" -->\n<input type=\"radio\" v-model=\"picked\" value=\"a\">\n```\n\n```\n<!-- 当选中时，`picked` 为a 的值 -->\n<input type=\"radio\" v-model=\"picked\" :value=\"a\">\n```\n\n\n\n### 复选框\n\n```\n<input\n  type=\"checkbox\"\n  v-model=\"toggle\"\n  true-value=\"yes\"\n  false-value=\"no\"\n>\n\n// 当选中时\nvm.toggle === 'yes'\n// 当没有选中时\nvm.toggle === 'no'\n```\n\n​\t\t针对多个复选框。其值还是为value值，如果没有value，其值就是null\n\n> ​\t\t这里的 `true-value` 和 `false-value` attribute 并不会影响输入控件的 `value` attribute，因为浏览器在提交表单时并不会包含未被选中的复选框。如果要确保表单中这两个值中的一个能够被提交，(即“yes”或“no”)，请换用单选按钮。\n\n​\t\t所以这个 true/false value 是单选时比较有用。\n\n\n\n### 单选按钮\n\n```\n<input type=\"radio\" v-model=\"pick\" v-bind:value=\"a\">\n\n// 当选中时\nvm.pick === vm.a\n```\n\n​\t\n\n### 选择框的选项\n\n```\n<select v-model=\"selected\">\n    <!-- 内联对象字面量 -->\n  <option v-bind:value=\"{ number: 123 }\">123</option>\n</select>\n\n// 当选中时\ntypeof vm.selected // => 'object'\nvm.selected.number // => 123\n```\n\n​\t\t通过这个我们可以看出，这个是可以使用对象的，同理，我们对于其他的选项框也可以使用对象的形式。\n\n\n\n## 修饰符\n\n### .lazy\n\n​\t\t在默认情况下，`v-model` 在每次 `input` 事件触发后将输入框的值与数据进行同步 (除了[上述](https://cn.vuejs.org/v2/guide/forms.html#vmodel-ime-tip)输入法组合文字时)。你可以添加 `lazy` 修饰符，从而转为在 `change` 事件_之后_进行同步\n\n```\n<!-- 在“change”时而非“input”时更新 -->\n<input v-model.lazy=\"msg\">\n```\n\n​\t\t在输入之后使用回车，便是change事件。\n\n\n\n### .number\n\n​\t\t如果想自动将用户的输入值转为数值类型，可以给 `v-model` 添加 `number` 修饰符\n\n```\n<input v-model.number=\"age\" type=\"number\">\n```\n\n​\t\t无法输入字符串。\n\n​\t\t这通常很有用，因为即使在 `type=\"number\"` 时，HTML 输入元素的值也总会返回字符串。如果这个值无法被 `parseFloat()` 解析，则会返回原始的值。\n\n​\t\t如何出现无法解析的情况，因为可以输入 e，+，-等，所以还是可以无法解析，问题在于无法解析输出的类型是字符串，但是貌似内容为''，\n\n\n\n### .trim\n\n​\t\t如果要自动过滤用户输入的首尾空白字符，可以给 `v-model` 添加 `trim` 修饰符：\n\n```\n<input v-model.trim=\"msg\">\n```\n\n​\t\t没啥说的。就是字符串的 trim 方法。这个方法的使用是返回一个新的。\n\n\n\n## 在组件上使用 v-model （2.2.0+ 新增）\n\n​\t\tHTML 原生的输入元素类型并不总能满足需求。幸好，Vue 的组件系统允许你创建具有完全自定义行为且可复用的输入组件。这些输入组件甚至可以和 `v-model` 一起使用！\n\n​\t\t要了解更多，请参阅组件指南中的[自定义输入组件](https://cn.vuejs.org/v2/guide/components-custom-events.html#自定义组件的-v-model)。\n\n​\t\t讲真，没有看懂。\n\n​\t\t我们通过跳转，看到了自定义组件的 v-model 我只能大概知道\n\n​\t\t一个组件上的 `v-model` 默认会利用名为 `value` 的 prop 和名为 `input` 的事件，但是像单选框、复选框等类型的输入控件可能会将 `value` attribute 用于[不同的目的](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/checkbox#Value)。`model` 选项可以用来避免这样的冲突\n\n```\nVue.component('base-checkbox', {\n  model: {\n    prop: 'checked',\n    event: 'change'\n  },\n  props: {\n    checked: Boolean\n  },\n  template: `\n    <input\n      type=\"checkbox\"\n      v-bind:checked=\"checked\"\n      v-on:change=\"$emit('change', $event.target.checked)\"\n    >\n  `\n})\n\n使用v-model时\n<base-checkbox v-model=\"lovingVue\"></base-checkbox>\n```\n\n​\t\t这里因为使用了v-model进行传值，所以使用了model: {}，设置了prop的名字，然后在props进行使用，此时传递的值就和父组件的 lovingVue 进行了绑定。然后通过事件$emit， change进行的提交。\n\n​\t\t这里的 `lovingVue` 的值将会传入这个名为 `checked` 的 prop。同时当 `<base-checkbox>` 触发一个 `change` 事件并附带一个新的值的时候，这个 `lovingVue` 的 property 将会被更新。\n\n> ​\t\t注意你仍然需要在组件的 `props` 选项里声明 `checked` 这个 prop。\n\n\n\n# 组件基础\n\n```\nhttps://cn.vuejs.org/v2/guide/components.html\n```\n\n\n\n## 基本示例\n\n​\t\t这里有一个 Vue 组件的示例\n\n```\n// 定义一个名为 button-counter 的新组件\nVue.component('button-counter', {\n  data: function () {\n    return {\n      count: 0\n    }\n  },\n  template: '<button v-on:click=\"count++\">You clicked me {{ count }} times.</button>'\n})\n```\n\n​\t\t组件是可复用的 Vue 实例，且带有一个名字：在这个例子中是 `<button-counter>`。我们可以在一个通过 `new Vue` 创建的 Vue 根实例中，把这个组件作为自定义元素来使用\n\n```\n<div id=\"components-demo\">\n  <button-counter></button-counter>\n</div>\n```\n\n​\t\t当然注意上面这个组件的定义顺序要在你的Vue实例之前。因为编译问题，如果在之后的话就不会被编译了。\n\n```\nVue.componnet('button', { });\n\nconst vm = new Vue();\n```\n\n​\t\t因为组件是可复用的 Vue 实例，所以它们与 `new Vue` 接收相同的选项，例如 `data`、`computed`、`watch`、`methods` 以及生命周期钩子等。仅有的例外是像 `el` 这样根实例特有的选项。\n\n\n\n## 组件的复用\n\n​\t\t组件在被创建之后，可以被多次使用。\n\n### data必须是一个函数\n\n​\t\t当我们定义这个 `<button-counter>` 组件时，你可能会发现它的 `data` 并不是像这样直接提供一个对象\n\n```\nVue.component('button', {\n\tdata: {\n\t\treturn {\n\t\t\t\n\t\t};\n\t},\n})\n\nconst vm = new Vue({\n\tdata: {\n\t\t\n\t},\n})\n```\n\n​\t\t当然如果你不这样写也不会报错，但是这样会有一个问题，那就是所以这个组件都会使用同一个对象的数据，一个发生了改变，所有都会发生改变。所以就是用了函数，这个会每次都调用了一次函数，形成一个新的作用域位置。\n\n​\t\t这个就是使用了闭包的方法，当然你可能在想，是不是可以利用这个闭包，然后既能让数据不同步，又能让部分数据进行同步。当然，我没有解决掉。因为首先我们可以知道闭包的使用方式。\n\n```\nfunction Fn() {\n\treturn fn() {}\n}\n\nlet fn = Fn();\n这个时候使用fn，就可以使用闭包。但是data是重复的创建Fn(). 所以每次都还是会创建新东西。\n```\n\n​\t\t所以我现在不知道如何使用闭包的方式，当然，我们可以将方法写在全局，然后再组件里进行闭包。还是可以的。\n\n\n\n## 组件的组织\n\n​\t\t为了能在模板中使用，这些组件必须先注册以便 Vue 能够识别。这里有两种组件的注册类型：**全局注册**和**局部注册**。至此，我们的组件都只是通过 `Vue.component` 全局注册的\n\n​\t\t全局注册的组件可以用在其被注册之后的任何 (通过 `new Vue`) 新创建的 Vue 根实例，也包括其组件树中的所有子组件的模板中。\n\n​\t\t局部注册的方式就是先将内容对象赋值给了一个变量，然后通过使用变量来进行注册。\n\n```\nlet ComponentA = {  }\n\nnew Vue({\n\tel: '#xx',\n\tcomponents: {\n\t\t'component-a': ComponentA,\n\t},\n})\n```\n\n\n\n## 通过Prop向子组件传递数据\n\n​\t\t简单来说，就是写在props属性里面的会添加到属性，父组件在调用子组件时，可以通过在标签里添加对应的属性，属性里面的值将会传递给子组件。\n\n```\nVue.component('blog-post', {\n  props: ['title'],\n  template: '<h3>{{ title }}</h3>'\n})\n\n<blog-post title=\"My journey with Vue\"></blog-post>\n```\n\n​\t\t当然对于这个props，也有另一个写法，props使用对象，对象里面又是一个对象，default代表了默认值，type代表了类型，当然也有其他属性。但是我们后面在详细了解。\n\n```\nprops: {\n  'title': {\n    default: '123',\n    type: String\n  }\n},\n```\n\n```\n<blog-post title=\"My journey with Vue\"></blog-post>\n<blog-post></blog-post>\n```\n\n​\t\t当然这个自定的属性attribute，也是可以使用v-bind: 来动态绑定。当然我们也可以使用v-model，但是这里也有其他的问题，具体后续在了解。\n\n​\t\t传递的属性也能是对象，对于一些应该属于统一对象的，可以将其化为一个对象进行传递。\n\n\n\n## 单个根元素\n\n​\t\t简单来说，就是在创建时，只能以一个根元素。如果根元素不止一个就会报错\n\n```\n<div></div>\n<div></div>\n```\n\n​\t\t上面这个写法就会报错，但是下面这个写法。将所有的元素都放在了一个根元素的下级。\n\n```\n<div>\n  <div></div>\n  <div></div>\n</div>\n```\n\n​\t\t这里的原因。我不清楚，只能说在Vue里面如果使用了下面这个写法时，可以知道，只会将第一个进行Vue的渲染，第二个将不会进行渲染操作。通过查阅资料，有的说是diff算法的原因，也有说是为了避免出现多个根元素，找不到以谁为主体。\n\n​\t\t这个现在主要作为一个了解。\n\n```\n<div id=\"app\">1</div>\n<div id=\"app\">2</div>\n```\n\n\n\n## 监听子组件事件\n\n​\t\t父组件可以给子组件传值了，但是子组件如何在一定的条件下通知父组件呢。\n\n​\t\t使用方式：\n\n​\t\t1.首先父元素在传递的时候，传递一个可以被子元素监听的方法\n\n```\n<blog-post @test=\"enlarge\" post=\"{title: 1}\"></blog-post>\n```\n\n​\t\t2.然后子元素就可以通过使用 $emit 进行调用这个方法。注意$emit('xxxx')，xxx就是那个元素上的属性attribute，\n\n```\n<button v-on:click=\"$emit('test')\">\n```\n\n​\t\t3.传递值的方式，这个方法的第一个是方法名，后面的就是要传递的值。\n\n```\n$emit('test', 1, 2);\n```\n\n**注意：**\n\n* 父元素进行传递时，直接写上方法名即可 `@test=\"enlarge\"` \n\n* 因为html是不分大小写的，所以进行传递的时候，建议不要带有大写，对于$emit('xxx')，存在大写，则会监听失败。\n\n* 如果是 `@test=\"enlarge()\"` 那么子组件传递参数则无效，`$emit('test', 1, 2);` 子组件这个写法虽然传递了参数，但是并不会传递值，因为父组件在传递的时候是直接传递了方法的调用的结果。\n\n  * ```\n    @test=\"enlarge()\n    $emit('test', 1, 2);\n    \n    结果：空\n    ```\n\n*  `@test=\"enlarge(1, 2)` 同理，这样在子组件调用的时候传递过来的值就直接是是1和2。并不会因为 `$emit('test', 321, 123);` 改成321，123。\n\n  * ```\n    @test=\"enlarge(1, 2)\n    $emit('test', 11111, 22222);\n    \n    结果：1, 2\n    ```\n\n*  `@test=\"enlarge($event, 12, 321, 312)\"` 这样写有是一个特点，你会发现，这个$event 代表的不是点击的事件了，而是子组件传递的值。这个event就类似于了一个子组件的待定参数。\n\n  * ```\n    @test=\"enlarge($event, 1, 2)\n    $emit('test', 11111, 22222);\n    \n    结果：11111, 1, 2\n    ```\n\n\n\n### 使用事件抛出一个值\n\n​\t\t可以使用 `$emit` 的第二个参数来提供这个值\n\n```\n<button v-on:click=\"$emit('enlarge-text', 0.1)\">\n```\n\n​\t\t然后当在父级组件监听这个事件的时候，我们可以通过 `$event` 访问到被抛出的这个值\n\n```\n@enlarge-text=\"postFontSize += $event\"\n```\n\n​\t\t如果这个是一个方法，那么这个值会作为第一个参数传入这个方法\n\n```\nonEnlargeText: function (enlargeAmount) {\n\tthis.postFontSize += enlargeAmount\n}\n```\n\n\n\n### 在组件上使用 v-model\n\n​\t\t首先我们可以这样理解\n\n```\n<input v-model=\"searchText\">\n\n等价于\n\n<input\n  v-bind:value=\"searchText\"\n  v-on:input=\"searchText = $event.target.value\"\n>\n```\n\n​\t\tv-model的效果就是值的改变会影响到view的改变，输入的变化会影响值的改变。而v-bind，值的改变会影响到视图的改变，但是并没有双向的绑定。\n\n\n\n​\t\t所以用在组件上时。\n\n```\n<custom-input\n  v-bind:value=\"searchText\"\n  v-on:input=\"searchText = $event\"\n></custom-input>\n```\n\n​\t\t所以此时我们需要绑定一个input方法将其传递出来。\n\n​\t\t为了让它正常工作，这个组件内的 `<input>` 必须：\n\n- 将其 `value` attribute 绑定到一个名叫 `value` 的 prop 上\n- 在其 `input` 事件被触发时，将新的值通过自定义的 `input` 事件抛出\n\n```\nVue.component('custom-input', {\n  props: ['value'],\n  template: `\n    <input\n      v-bind:value=\"value\"\n      v-on:input=\"$emit('input', $event.target.value)\"\n    >`\n})\n```\n\n​\t\t所以此时我们就能理解了，上面的那个组件使用v-model时的传递方式了。\n\n​\t\t同时我么可以看一下那个[自定义事件的 v-model](https://cn.vuejs.org/v2/guide/components-custom-events.html)\n\n```\nVue.component('base-checkbox', {\n  model: {\n    prop: 'checked',\n    event: 'change'\n  },\n  props: {\n    checked: Boolean\n  },\n  template: `\n    <input\n      type=\"checkbox\"\n      v-bind:checked=\"checked\"\n      v-on:change=\"$emit('change', $event.target.checked)\"\n    >`\n})\n\n使用\n<base-checkbox v-model=\"lovingVue\"></base-checkbox>\n```\n\n​\t\t这里的model里面有prop和event，其中checked代表了传递的值。这个名字可以自己定义。 这里的event，值为change，则代表了是change事件，如果命名为input则为input的事件，当然，其实这里也是可以自己命名的。主要是为了方便认知。\n\n​\t\t这个和上一个组件的通信的区别\n\n* 普通的是将值返回给上级，然后上级进行方法的操作。\n\n  * ```\n    <c :name=\"name\" @inputf=\"fn\">12</c>\n    \n    子组件的内容：\n    <input type=\"text\" :value=\"name\" @input=\"this.$emit('inputf', event.target.value);\">\n    \n    这里再对fn写上一个方法，此时对于一个input输入就会出现对应的方法被执行。\n    ```\n\n* 对于v-model，则是发现直接将其传递给上级，上级不需要再指定一个方法。\n\n  * ```\n    <c v-model=\"searchText\"></c>\n    \n    子组件的内容\n    <input type=\"text\" :value=\"myInput\" @input=\"inputE($event)\">\n    ```\n\n  * 首先在使用组件的时候，使用v-mdoel方法。子组件，此时可以使用 model对象进行指定。当然，如果此时不指定怎么办\n\n  * 对于有value的情况：\n\n    * 首先，对于父组件使用v-model传递给了子组件的值，子组件如果使用了value的变量名，则会以此值进行接收。就算是checkbox，也是使用的value进行接收。不管子组件的内容(目前我的测试来说。)\n\n    * ```\n      props: {\n        value: {\n        \ttype: Boolean,\n        \tdefalut: false,\n        },\n      },\n      \n      记住props的写法，开始我写成了data式的写法，把默认值直接写在了后面，如果直接写后面是写变量的类型\n      props: {\n      \tvalue: String,\n      }\n      ```\n\n  * 对于没有value的情况：\n\n    * 没有value，还没有添加一个model对象进行指定，那么就不会传入成功。\n\n    * 进行了model的指定，那么便会使用这个变量进行赋值。\n\n      * ```\n        model: {\n          prop: 'myInput',\n          event: 'inp'\n        },\n        props: ['myInput'],\n        ```\n\n  * 到此，我们已经解决了如何传值，下一步就是更新数据。\n\n    * 因为 v-model的特点就是会将值进行了绑定，所以我们只需要通知同步就行了\n\n    * ```\n      <input type=\"text\" :value=\"myInput\" @input=\"inputE($event)\">\n      ```\n\n    * input事件，绑定了inputE方法，然后inputE里面通过$emit进行传递。事件名称就是model里面的事件名称，inp, 如果没有进行重命名，那么就是 input事件。父组件不需要做什么，因为v-model自动对事件和参数进行了赋值。当然，也是可以赋值常数的。\n\n  * 同时我们通过这个案例也知道了，如果你对一个input输入框加了v-model，也加了input的监听，在input的监听修改了v-model的值，那么会以input的为主。\n\n\n\n## 通过插槽分发内容\n\n​\t\t简单来说，就是可以在标签内部使用标签，然后标签可以传递给子元素显示。父元素的使用方式就是下面这样。子元素只需要定义一个 slot，然后slot的位置就会显示为你定义的。\n\n```\n<alert-box>\n  Something bad happened.\n</alert-box>\n```\n\n```\nVue.component('alert-box', {\n  template: `\n    <div class=\"demo-alert-box\">\n      <strong>Error!</strong>\n      <slot></slot> 这里就会被渲染为其他的。\n    </div>`\n})\n```\n\n​\t\t这里在简单的说几个地方。\n\n​\t\t1.如果使用了多个slot，默认每个slot都会全部都会显示，但是又不是你想的那种显示。我不知道怎么描述。直接看例子就懂了：\n\n```\n<p>123</p>\n<slot></slot>\n<slot></slot>\n<p>321</p>\n\n\n<tt>\n  <div>123</div>\n  <div>321</div>\n</tt>\n```\n\n​\t\t下面这个我定义了两个slot，然后组件名为tt，tt里面有两个div标签值为123和321。你可能会认为一个 slot为123，一个slot为321.但是其实不是，因为你没有给定name，所以这两个div会被当成一个传递给插槽。然后两个插槽都会被赋值。所以值为\n\n<img src=\"Vue2-教程-基础使用/image-20211105095952701.png\" alt=\"image-20211105095952701\" style=\"zoom:50%;\" />\n\n\n\n​\t\t那么要如何实现上面预想的效果呢，使用name。一个不带 `name` 的 `<slot>` 出口会带有隐含的名字“default”。\n\n​\t\t然后就是父组件如何使用了，这里有三个写法\n\n```\n<div slot=\"aa\">123</div>\n\n<template v-slot:aa>\n\t<div>123</div>\n</template>\n\n<template #aa>\n\t<div>123</div>\n</template>\n```\n\n​\t\t上面这三个写法，\n\n* 第一个是一个旧的写法，不建议，因为建议是使用一个template进行包裹，template作为一个html5的新特性。\n\n* 第二个是使用的v-slot进行绑定。但是需要将其放在template上，才有效果\n\n* 第三个就是第二个的一个语法糖写法。\n\n* 然后就是如何使用变量，首先可以使用 v-bind 进行绑定。其次也可以使用 [] 进行表示。\n\n  * ```\n    :slot=\"name\" :v-slot:name :#name\n    v-slot:[name] #[name]\n    ```\n\n\n\n​\t\t然后就是插槽是会将值进行覆盖的。所以如果你在slot上写的一些样式和方法不会显示，对应的方式就是（**v-if，v-for** 有效果，因为这些是对DOM树进行了变化，所以会在DOM树的添加，而不是对一个属性的覆盖。但是对于一些class和v-show就没用了。）\n\n* 第一种，父元素写方法和样式，但是这样一个子组件就对父组件不透明了\n\n* 第二种，在外面套上一层标签。向下面这样就行了。\n\n  * ```\n    <div v-show=\"false\">\n    \t<slot></slot>\n    </div>\n    ```\n\n\n\n​\t\t其他的部分，详见Vue的 [插槽](https://cn.vuejs.org/v2/guide/components-slots.html) 部分。\n\n\n\n## 动态组件\n\n​\t\t简单来说就是不同组件会进行动态切换，所以可以使用\n\n```\n<component :is=\"name\"></component>\n<button @click=\"change\">change</button>\n```\n\n​\t\t这里 component 是一个标签，is使用v-bind绑定了name，然后通过一个点击事件来修改了name的值，所以component，is就会被指定修改成其他的组件名。\n\n​\t\t这个is属性应该是html里面的那个is属性，但是具体的使用方式我现在看不懂，可以取MDN里面进行了解，这里我们就当作is会指定一个组件名，然后这个component标签就会被替换成组件名。\n\n\n\n​\t\t在上述示例中，name可以包括：\n\n- 已注册组件的名字，或\n- 一个组件的选项对象\n\n\n\n注意：\n\n​\t\t这个is属性可以用于常规的html元素上。\n\n​\t\t但是对于attribute将会作为DOM attribute进行绑定，对于像 `value` 这样的 property，若想让其如预期般工作，你需要使用 [`.prop` 修饰器](https://cn.vuejs.org/v2/api/#v-bind)。\n\n​\t\t这里就扯出了 attribute 和 property 的一个区别，我这里就贴一个 [StackOverflow](https://stackoverflow.com/questions/6003819/properties-and-attributes-in-html#answer-6004028) 和 一个对应 StackOverflow 的 [CSDN ](https://blog.csdn.net/rudy_zhou/article/details/104058741) 的一个中文的讲解 \n\n​\t\t大概就是说，attribute属性是一个HTML的上的属性，而property是一个DOM对象上的属性。有的属性开始是继承了attribute，但是后续会被修改，此时可以从property看出，但是不会从attribute看出。\n\n\n\n## 解析 DOM 模板时的注意事项\n\n​\t\t简单来说，就是有的HTML 元素限制了其内部的元素是哪些，对于不属于的，会被提升到外部，触发其他问题。\n\n```\n<ul>、<ol>、<table> 和 <select>\n```\n\n​\t\t有的元素是，只能存在于特定的元素内部\n\n```\n<li>、<tr> 和 <option>\n```\n\n​\t\t案例\n\n```\n<table>\n  <blog-post-row></blog-post-row>\n</table>\n```\n\n​\t\t对于上面的情况，blog-post-row 会被提升到外部，所以会出现页面布局的问题。\n\n​\t\t解决方式，使用is attribute。\n\n```\n<table>\n  <tr is=\"blog-post-row\"></tr>\n</table>\n```\n\n\n\n需要注意的是**如果我们从以下来源使用模板的话，这条限制是*不存在* 的**：\n\n- 字符串 (例如：`template: '...'`) \n\n  - ```\n    Vue.component('tt', {\n      template: `\n        <table>\n        \t<p>1</p>\n        </table>\n      `,\n    });\n    ```\n\n  - 此时 p 标签存在于table 内部。\n\n- [单文件组件 (`.vue`)](https://cn.vuejs.org/v2/guide/single-file-components.html) \n\n- [`<script type=\"text/x-template\">`](https://cn.vuejs.org/v2/guide/components-edge-cases.html#X-Template) \n\n  ​\t当然这些，我也没有测试过，所以不清楚。\n\n\n\n至此，简单的一个基础就了解完了，详细的还是看看Vue官网的 文档和API吧\n\n```\nhttps://cn.vuejs.org/v2/api/\n```\n\n```\nhttps://cn.vuejs.org/v2/guide/\n```\n\n","source":"_posts/Vue/Vue2教程/Vue2-教程-基础使用.md","raw":"---\ntitle: Vue-使用-基础使用\ndate: 2021-10-29 23:15:01\ntags:\n - Vue\n - Vue2\n - 文档\ncategories:\n - Vue\n - Vue2文档\n---\n\n\n\n#  Vue的基本使用\n\n```\n简单入门教程\n\thttps://cn.vuejs.org/v2/guide/\nAPI\n\thttps://cn.vuejs.org/v2/api/\n\n在这里我就先进行一个简单的教程的学习。不过于深入了解。\n```\n\n\n\n# 介绍\n\n```\nhttps://cn.vuejs.org/v2/guide/index.html\n```\n\n\n\n## 引入\n\n​\t\t这里我们使用 script 进行引入\n\n​\t\t还可以使用 **npm** 进行下载引入 和 使用 **VueCLI** 脚手架，使用 npm 和 脚手架 的好处是，我们可以方便进行包管理。进行较大型应用时可以进行使用。但是我们这里的主要目的时了解 Vue 的基本使用和Vue 的一些规范，所以就直接使用 **script** 引入。\n\n​\t\t对于 **script** 引入，有两种：\n\n* 第一种是直接进行引入。这种是创建了一个全局 Vue 的的实例，可以在后面进行使用，但是不能在前面进行使用。\n\n  * ```\n    <script src=\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\"></script>\n    ```\n\n* 第二种是使用了 模块化 。 在引用以后，可以在改代码的后面直接进行使用。但是不能在 另外一个 script 标签内部使用，具体的原因是 使用了 module ，这个属于异步加载了。对于script 的异步我们后续在了解。\n\n  * ```\n    <script type=\"module\">\n      import Vue from 'https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.esm.browser.js'\n      \n      Vue.log;\n    </script>\n    ```\n\n这里我们使用第一种引入。\n\n\n\n## 声明式渲染\n\n### Mustache 语法 { { valueName }}\n\n```\n<div id=\"app\">\n  { { message }}\n</div>\n\n<!-- 开发环境版本，包含了有帮助的命令行警告 -->\n<script src=\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\"></script>\n<script>\n  const app = new Vue({\n    el: '#app',\n    data: {\n      message: 'test'\n    }\n  });\n</script>\n```\n\n​\t\t这里这个 message 是响应式的。如果我们在浏览器控制台修改了 message 的值，页面也会对应发生变化。里面的原因是使用了 **OBject.defineProperty()** 对于 Vue 的响应式。我们后续在了解 Vue源码的时候在进行讨论。\n\n```\napp.message = 'a';\n\n页面会同时进行修改。\n```\n\n​\t\t这里我们进行一个分析。\n\n```\nnew Vue，这是一个 new 方法，会返回一个实例，里面的参数是一个对象，对象里面又是很多属性和对象的组成。\n\n这里出现了。el 和 data。\n```\n\n```\n其中el，是你要绑定的元素， 可以是 CSS 选择器，也可以是一个 HTMLElement 实例。\n\t参考：\thttps://cn.vuejs.org/v2/api/#el\nCSS选择器： #app, .app, div.app ...\nHTMLElement实例： \n\tconst span = document.querySelector('span.app');\n\tel: span.\n其次，对于有多个满足的情况，只会对第一个进行编译。\n```\n\n```\ndata：\n\t\t我们可以看出，这个是一个data的对象。然后是对对象里面的数据进行了一个响应式的处理。然后我们也可以在后续在开发时可以发现，data是一个 返回的对象。这里是因为对象是使用的地址赋值，如果不通过return {}, 会让共同使用的组件会使用相同的数据。但是如果是return {}。那么在每次返回时都会返回一个新的对象出来。而不会共同使用一个对象。 \n```\n\n\n\n### 使用指令绑定 attribute (v-bind)\n\n```\n<span class=\"app\" v-bind:title=\"message\">\n  { { message }}\n</span>\n```\n\n​\t\t这里 v-bind 是 Vue 提供的 `attribute `。它可以绑定元素原有的 `attribute` 。这个指令的效果是： 将这个元素节点的 `title` attribute 和 Vue 实例的 `message` property 保持一致。\n\n​\t\t可以通过使用 app.message = 'new'; 可以发现，内容也随之更新。\n\n\n\n## 条件与循环\n\n### v-if\n\n```\n<div id=\"app-3\">\n  <p v-if=\"seen\">现在你看到我了</p>\n</div>\n\n\nvar app3 = new Vue({\n  el: '#app-3',\n  data: {\n    seen: true\n  }\n})\n\n这里设置的 seen ， 设置为 true ，就会显示。设置为 false ，就不会显示。\n```\n\n​\t\t可以通过设置 v-if 来进行这个标签的显示和隐藏。此外，Vue 也提供一个强大的过渡效果系统，可以在 Vue 插入/更新/移除元素时自动应用[过渡效果](https://cn.vuejs.org/v2/guide/transitions.html)。\n\n​\t\t这个过渡效果，我们后续在讲。\n\n​\t\t`v-if` 可以控制一个标签的显示和隐藏，还有 `v-show` 也有一样的效果。\n\n**区别：**\n\n* ```\n  https://cn.vuejs.org/v2/guide/conditional.html#v-if-vs-v-show\n  ```\n\n* `v-if` 也是**惰性的**：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。\n* 相比之下，`v-show` 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。\n* 如果需要非常频繁地切换，则使用 `v-show` 较好；如果在运行时条件很少改变，则使用 `v-if` 较好。\n\n\n\n### v-for\n\n```\nhttps://cn.vuejs.org/v2/api/#v-for\n```\n\n​\t\t`v-for` 指令可以绑定数组的数据来渲染一个项目列表：\n\n```\n<div id=\"app-4\">\n  <ol>\n    <li v-for=\"todo in todos\">\n      { { todo.text }}\n    </li>\n  </ol>\n</div>\n\n\nvar app4 = new Vue({\n  el: '#app-4',\n  data: {\n    todos: [\n      { text: '学习 JavaScript' },\n      { text: '学习 Vue' },\n      { text: '整个牛项目' }\n    ]\n  }\n})\n\n循环。 v-for=\"item in items\"，  会循环items，赋值给 item。\n```\n\n**此外：**\n\n​\t在使用 **v-if** 搭配 v-for 时，**v-for** 的优先级会高于 **v-if**。\n\n```\n<li v-for=\"todo in todos\" v-if=\"todo.flag\">\n```\n\n​\t\t在控制台里，输入 `app4.todos.push({ text: '新项目' })`，你会发现列表最后添加了一个新项目。\n\n**注意：**\n\n​\t这里使用了 **push**， 方式添加了新项目，页面发生了改变，但是如果是 app4.todos[4] = xxx， 这样就不会发生页面的改变，这里是因为Vue 响应式的原因，至于原理，我们后续在讲解。想要提前知道的可以了解一下，Object.defineProperty()。\n\n\n\n## 处理用户输入\n\n​\t\t用户和应用的交互，可以使用 **v-on** 指令来添加一个事件的监听器\n\n这里的 v-on，就代表了 on\n\n```\n<button v-on:click=\"reverseMessage\">反转消息</button>\n\n<button onclick=\"reverseMessage()\">反转消息</button>\n```\n\n```\nvar app5 = new Vue({\n  el: '#app-5',\n  data: {\n    message: 'Hello Vue.js!'\n  },\n  methods: {\n    reverseMessage: function () {\n      this.message = this.message.split('').reverse().join('')\n    }\n  }\n})\n```\n\n​\t\t这里新添加了一个 **methods** 的对象，里面存放的是方法。如果是使用 **Vue** 的属性 **attribute**， **v-on** ，来进行的绑定方法，那么就需要将方法写在这个methods 里面。不写在 methods 里面的方法是没有效果的。\n\n​\t\t其次，这里面建议不要使用 箭头函数，因为箭头函数 的this指向是和 当前的上下文 相关的，所以在箭头函数里面使用不了data的方法。箭头函数的指向是全局。\n\n​\t\t在这里，我们只需要写上逻辑，不需要操作DOM，这个就是 MVVM 中， Vue 的 VM，我们只需要在 M和V 上进行操作即可。\n\n\n\n## v-model 实现双向绑定\n\n​\t\tv-bind，可以实现单向的绑定，就是指可以通过修改data数据来进行页面的修改。\n\n​\t\t但是，如果是对于一个 input 的输入框呢？\n\n​\t\t我们可以将 data 数据绑定到输入框作为一个初始值。\n\n​\t\t但是我们可以在对输入框进行输入时，同时修改 data 的数据吗。显然是不行的。所以就有了 v-model\n\n​\t\tv-model ，它可以进行数据的双向绑定，不但用户的输入会修改 data， data 的变化也会影响视图。\n\n```\n<input v-model=\"message\">\n```\n\n​\t\t通过这个我们 可以看出，v-model 没有说使用value，还是什么，但是却有效果，这里是因为 v-model 会根据控件的类型自动选取正确的方法来更新。限制：\tinput， select， textarea， components\n\n```\nhttps://cn.vuejs.org/v2/api/#v-model\n```\n\n\n\n## 组件化应用构建\n\n​\t\tVue 的另一个重要的概念就是 **组件化** 。几乎任意应用界面都可以抽象为一个组件树。\n\n​\t\t在 Vue 中注册一个组件\n\n```\n// 定义名为 todo-item 的新组件\nVue.component('todo-item', {\n  template: '<li>这是个待办项</li>'\n})\n\nvar app = new Vue(...)\n```\n\n**示例：**\n\n```\n<div id=\"app-6\">\n  <my-item></my-item>\n</div>\n\n\n  Vue.component('my-item', {\n    template: '<li>这是个待办项</li>'\n  });\n\n  var app6 = new Vue({ el: '#app-6' })\n```\n\n**注意点：**\n\n* 使用的方式是，需要在 new 的实例的 Vue 的内部进行调用，因为在 实例内部，你写的方式才会被 Vue 所编译，不然是不会被 Vue 编译的。\n\n* 其次，注册的组件需要在你 new 的实例前面，因为你在编译组件的时候要使用自定义的组件。所以，如果不在之前进行解析的话，就解析不了了。\n\n\n\n## 组件传值\n\n```\n<div id=\"app-6\">\n  <my-item :todo=\"message\"></my-item>\n</div>\n\n\nVue.component('my-item', {\n  props: ['todo'],\n  template: '<li>这是个待办项 { { todo }}</li>',\n});\n\nvar app6 = new Vue({\n  el: '#app-6',\n  data: {\n  \tmessage: false\n  }\n})\n```\n\n​\t\t这里， props 是代表了获取到组件属性传递过来的值，在组件使用时，添加属性，这个属性是和 props 里面的名字相等。这里就是 todo， 其次， **:todo**，是一个语法糖，代表了 **v-bind:todo**，所以就会把 message 的值传递给 todo，然后再传递给 my-item。\n\n\n\n# Vue实例\n\n```\nhttps://cn.vuejs.org/v2/guide/instance.html\n```\n\n\n\n## 创建一个Vue实例\n\n​\t\t每个 Vue 应用都是通过用 `Vue` 函数创建一个新的 **Vue 实例**开始的：\n\n```\nvar vm = new Vue({\n  // 选项\n})\n```\n\n​\t\t虽然没有完全遵循 [MVVM 模型](https://zh.wikipedia.org/wiki/MVVM)，但是 Vue 的设计也受到了它的启发。因此在文档中经常会使用 `vm` (ViewModel 的缩写) 这个变量名表示 Vue 实例。\n\n​\t\t至于为什么 Vue 没有完全遵循 MVVM 的原因是：Vue 中有一个属性，ref，这个属性可以拿到 DOM 对象，直接操作视图，所以违背了 MVVM。\n\n​\t\t在创建一个 Vue 实例时，你可以传入一个 [选项对象]([https://cn.vuejs.org/v2/api/#%E9%80%89%E9%A1%B9-%E6%95%B0%E6%8D%AE](https://cn.vuejs.org/v2/api/#选项-数据)) (data，methods...)。通过这些选项对象来创建你想要的行为。\n\n​\t\t一个 Vue 应用由一个通过 `new Vue` 创建的**根 Vue 实例**，以及可选的嵌套的、可复用的组件树组成。\n\n\n\n## 数据与方法\n\n​\t\t当一个 Vue 实例被创建时，它将 `data` 对象中的所有的 property 加入到 Vue 的**响应式系统**中。当这些 property 的值发生改变时，视图将会产生“响应”，即匹配更新为新的值。\n\n​\t\t大致就可以理解为，需要将数据放在了 data 里面，Vue 就会自动创建响应式。\n\n```\n// 我们的数据对象\nvar data = { a: 1 }\n\n// 该对象被加入到一个 Vue 实例中\nvar vm = new Vue({\n  data: data\n})\n\n// 获得这个实例上的 property\n// 返回源数据中对应的字段\nvm.a == data.a // => true\n\n// 设置 property 也会影响到原始数据\nvm.a = 2\ndata.a // => 2\n\n// ……反之亦然\ndata.a = 3\nvm.a // => 3\n```\n\n​\t\t通过上面我们可以知道，data的数据是直接可以通过 实例的返回来直接获取，数据是直接暴露于实例的顶层。理所当然，methods 的方法也是一样，所以我们会思考，如果方法名和数据名重合会怎么办。\n\n```\n  var app6 = new Vue({\n    el: '#app-6',\n    data: {\n      message: false\n    },\n    methods: {\n      message() {\n        console.log(1);\n      }\n    },\n  })\n  \n通过上面的案例可以看出，方法名是和 data 名称重合，所以在 data 已经创建了数据之后，方法创建会抛出异常。方法创建失败。\n```\n\n```\n  而如果是一个普通的对象，后面的会将前面的覆盖掉。\n  \n  let obj = {\n    a: 1,\n    a() {\n      console.log(2);\n    }\n  }\n  console.log(obj);\n```\n\n​\t\t其次\n\n```\n使用 vm.b = 1;\n这种后续添加数据的方式是不会变成响应式的。\n以及，使用了 Object.freeze() 也会阻止修改现有的 property，也意味着响应系统无法再追踪变化。\n```\n\n​\t\t除了数据 property，Vue 实例还暴露了一些有用的实例 property 与方法。它们都有前缀 `$`，以便与用户定义的 property 区分开来。\n\n```\nvar data = { a: 1 }\nvar vm = new Vue({\n  el: '#example',\n  data: data\n})\n\nvm.$data === data // => true\nvm.$el === document.getElementById('example') // => true\n\n// $watch 是一个实例方法\nvm.$watch('a', function (newValue, oldValue) {\n  // 这个回调将在 `vm.a` 改变后调用\n})\n```\n\n​\t\t你可以在 [API 参考](https://cn.vuejs.org/v2/api/#实例-property)中查阅到完整的实例 property 和方法的列表。\n\n\n\n## 实例生命周期钩子\n\n​\t\t生命周期钩子简单来说就是一个回调函数。在 Vue 在执行到每个过程的时候也会执行这些生命周期的钩子。\n\n​\t\t**举个栗子：**\n\n```\nnew Vue({\n  data: {\n    a: 1\n  },\n  created: function () {\n    // `this` 指向 vm 实例\n    console.log('a is: ' + this.a)\n  }\n})\n// => \"a is: 1\"\n\n在 created 钩子可以用来在一个实例被创建之后执行代码：\n```\n\n**注意：**\n\n> 不要在选项 property 或回调上使用[箭头函数](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions)，比如 `created: () => console.log(this.a)` 或 `vm.$watch('a', newValue => this.myMethod())`。因为箭头函数并没有 `this`，`this` 会作为变量一直向上级词法作用域查找，直至找到为止，经常导致 `Uncaught TypeError: Cannot read property of undefined` 或 `Uncaught TypeError: this.myMethod is not a function` 之类的错误。\n\n\n\n## 生命周期图示\n\n![lifecycle](Vue2-教程-基础使用/lifecycle.png)\n\n\n\n# 模板语法\n\n```\nhttps://cn.vuejs.org/v2/guide/syntax.html\n```\n\n## 插值\n\n**文本：**\n\n​\t\t数据绑定最常见的形式就是使用“Mustache”语法 (双大括号) 的文本插值：\n\n```\n<span>Message: { { msg }}</span>\n```\n\n这里 msg 会替代为 数据对象的 msg。并且还带有响应式的功能。\n\n​\t\t通过使用 [v-once 指令](https://cn.vuejs.org/v2/api/#v-once)，你也能执行一次性地插值，当数据改变时，插值处的内容不会更新。但请留心这会影响到该节点上的其它数据绑定：\n\n```\n<span v-once>这个将不会改变: { { msg }}</span>\n```\n\n\n\n**原始HTML：**\n\n​\t\t双大括号会将数据解释为普通文本，而非 HTML 代码。为了输出真正的 HTML，你需要使用 [`v-html` 指令](https://cn.vuejs.org/v2/api/#v-html)：\n\n```\n<span v-html=\"rawHtml\"></span>\n```\n\n​\t\t会将 span 的内容替换为 rawHtml。并且在里面不会解析 proterty。\n\n> 你的站点上动态渲染的任意 HTML 可能会非常危险，因为它很容易导致 [XSS 攻击](https://en.wikipedia.org/wiki/Cross-site_scripting)。请只对可信内容使用 HTML 插值，**绝不要**对用户提供的内容使用插值。\n\n\n\n**Attribute：（属性）**\n\n​\t\tMustache 语法不能作用在 HTML 标签的属性上，所以要使用 v-bind 指令。\n\n```\n<div v-bind:id=\"dynamicId\"></div>\n\n对于同时使用了 v-bind:id 和 id 的。我们可以发现，谁在后面，其结果就是谁。\n```\n\n​\t\t对于布尔值的 attribute，原生的HTML中，只要存在就意味着值为 true，而 v-bind，工作起来当值为 false，null等，甚至不会渲染。\n\n\n\n**使用 JavaScript 表达式：**\n\n​\t\t对于所有的数据绑定，Vue.js 都提供了完全的 JavaScript 表达式支持。\n\n```\n{ { number + 1 }}\n\n{ { ok ? 'YES' : 'NO' }}\n\n{ { message.split('').reverse().join('') }}\n\n<div v-bind:id=\"'list-' + id\"></div>\n```\n\n\n\n## 指令\n\n​\t\t指令 (Directives) 是带有 `v-` 前缀的特殊 attribute。\n\n**参数：**\n\n​\t\t一些指令能够接收一个“参数”，在指令名称之后以冒号表示。例如，`v-bind` 指令可以用于响应式地更新 HTML attribute：\n\n```\n<a v-bind:href=\"url\">...</a>\n\n此时这个url是和数据的url是绑定的。\n```\n\n​\t\t`v-on` 指令，它用于监听 DOM 事件：\n\n```\n<a v-on:click=\"doSomething\">...</a>\n同时也有 mouseover 等等。\n```\n\n**注意：**\n\n​\t\t使用 v-on 指令监听 DOM 事件，原生的 onclick 方法会先于 v-on 进行监听，其次这个 v-on 里面的方法，既可以是 methods 的，也可以是 data 的。但是建议写在 methods 中。\n\n```\n<div id=\"app-6\">\n  <button @click=\"test1\" onclick=\"console.log(1);\">Button</button>\n</div>\n//其中这里这个 @ 代表了 v-on 的语法糖，我们后续会讲。\n\n\tlet obj = {\n    message: true,\n    test1() {\n      console.log(3);\n    }\n  }\n\n  var app6 = new Vue({\n    el: '#app-6',\n    data: obj,\n    methods: {\n      test() {\n        console.log(2);\n      }\n    }\n  })\n```\n\n\n\n**动态参数： 2.6.0新增**\n\n​\t\t可以用方括号括起来的 JavaScript 表达式作为一个指令的参数：\n\n```\n<!--\n注意，参数表达式的写法存在一些约束，如之后的“对动态参数表达式的约束”章节所述。\n-->\n<a v-bind:[attributeName]=\"url\"> ... </a>\n\n<a v-on:[eventName]=\"doSomething\"> ... </a>\n@[]，也可以。\n```\n\n​\t\t这里的 `attributeName` 会被作为一个 JavaScript 表达式进行动态求值，求得的值将会作为最终的参数来使用。这里的Vue实例中有 data property attributeName，值为 href，则就等价于 v-bind:href=\"url\"\n\n​\t**对动态参数的值的约束**\n\n​\t\t动态参数预期会求出一个字符串，异常情况下值为 `null`。这个特殊的 `null` 值可以被显性地用于移除绑定。任何其它非字符串类型的值都将会触发一个警告。\n\n​\t**对动态参数表达式的约束**\n\n​\t\t动态参数表达式有一些语法约束，因为某些字符，如空格和引号，放在 HTML attribute 名里是无效的。例如：\n\n```\n<!-- 这会触发一个编译警告 -->\n<a v-bind:['foo' + bar]=\"value\"> ... </a>\n\n使用引号会无法编译。\n并且使用了空格也会无法编译。\n```\n\n​\t\t变通的办法是使用没有空格或引号的表达式，或用计算属性替代这种复杂表达式。\n\n​\t\t在 DOM 中使用模板时 (直接在一个 HTML 文件里撰写模板)，还需要避免使用大写字符来命名键名，因为浏览器会把 attribute 名全部强制转为小写：\n\n```\n<!--\n在 DOM 中使用模板时这段代码会被转换为 `v-bind:[someattr]`。\n除非在实例中有一个名为“someattr”的 property，否则代码不会工作。\n-->\n<a v-bind:[someAttr]=\"value\"> ... </a>\n```\n\n\n\n**修饰符：**\n\n​\t\t修饰符 (modifier) 是以半角句号 `.` 指明的特殊后缀，用于指出一个指令应该以特殊方式绑定。例如，`.prevent` 修饰符告诉 `v-on` 指令对于触发的事件调用 `event.preventDefault()`：\n\n​\t\t与之相应的还有 `.laze` `.once` 等等。我们后续进行讲解。\n\n\n\n## 缩写 语法糖\n\n**v-bind 缩写**：\n\n```\n<!-- 完整语法 -->\n<a v-bind:href=\"url\">...</a>\n\n<!-- 缩写 -->\n<a :href=\"url\">...</a>\n\n<!-- 动态参数的缩写 (2.6.0+) -->\n<a :[key]=\"url\"> ... </a>\n```\n\n\n\n**v-on 缩写：**\n\n```\n<!-- 完整语法 -->\n<a v-on:click=\"doSomething\">...</a>\n\n<!-- 缩写 -->\n<a @click=\"doSomething\">...</a>\n\n<!-- 动态参数的缩写 (2.6.0+) -->\n<a @[event]=\"doSomething\"> ... </a>\n```\n\n\n\n# 计算属性和侦听器\n\n```\nhttps://cn.vuejs.org/v2/guide/computed.html\n```\n\n\n\n## 计算属性\n\n​\t\t简单来说，就是将逻辑更深层的解耦，比如：\n\n```\n{ { message.split('').reverse().join('') }}\n```\n\n​\t\t在模板中放入太多的逻辑会让模板过重且难以维护。\n\n​\t\t在这个地方，模板不再是简单的声明式逻辑。你必须看一段时间才能意识到，这里是想要显示变量 `message` 的翻转字符串。当你想要在模板中的多处包含此翻转字符串时，就会更加难以处理。\n\n​\t\t所以，对于任何复杂逻辑，你都应当使用**计算属性**。\n\n​\t\t我认为，从一个开发来看，对于一个表达式，如果以后会有多个地方进行相同的逻辑的使用，就应当使用计算属性，方便维护。\n\n\n\n### 基础例子\n\n```\n<div id=\"app-6\">\n  { { message }}\n  <br>\n  { { reversedMessage }}\n</div>\n```\n\n```\n  const vm = new Vue({\n    el: '#app-6',\n    data: {\n      message: 'true',\n    },\n    computed: {\n      // 计算属性的 getter\n      reversedMessage: function () {\n        // `this` 指向 vm 实例\n        return this.message.split('').reverse().join('')\n      }\n    },\n  })\n```\n\n​\t\t这里我们声明了一个计算属性 `reversedMessage`。我们提供的函数将用作 property `vm.reversedMessage` 的 getter 函数\n\n​\t\t计算属性默认是的方法是一个getter 方法， 就像是使用了 `Object.defineProperty` 的getter一样进行了操作。\n\n\n\n## 计算属性缓存 VS 方法\n\n​\t\t我们也可以发现，可以在插值表达式中使用方法来获取同样的效果。\n\n```\n<p>{ { reversedMessage() }}</p>\n\nmethods: {\n  reversedMessage: function () {\n    return this.message.split('').reverse().join('')\n  }\n}\n```\n\n​\t\t首先，对于结果来说是完全相同的。不同的地方在于，**计算属性是基于它们的响应式依赖进行缓存的**。意思就是说，只有相关的响应式依赖发生了改变，他们才会重新求值。没有发生改变，多次使用计算属性会立即返回之前的结果。\n\n​\t\t**举个栗子：**\n\n```\n<div id=\"app-6\">\n  { { message }}\n  <br>\n  { { reversedMessage }}\n  <br>\n  { { reversedMessage }}\n  <br>\n  { { reversedMessage }}\n</div>\n\n\n  const vm = new Vue({\n    el: '#app-6',\n    data: {\n      message: 'true',\n    },\n    computed: {\n      // 计算属性的 getter\n      reversedMessage: function () {\n        // `this` 指向 vm 实例\n        console.log(1);\n        return this.message.split('').reverse().join('')\n      }\n    },\n  })\n```\n\n​\t\t我这里使用了很多个插值表达式，但是发现控制台的输出，只有一个，这里代表了后续是直接使用的之前的计算结果。\n\n​\t\t其次，在值发生变化之时，也只输出了一次。因此计算属性的缓存效果则比方法有了更好的性能。\n\n​\t\t当然，如果不希望有缓存的存在，可以使用方法来替代。\n\n\n\n## 计算属性 VS 侦听属性\n\n​\t\tVue 提供了一种更通用的方式来观察和响应 Vue 实例上的数据变动：**侦听属性**。 `watch`  。\n\n​\t\t侦听属性 和 计算属性的不同\n\n```\nwatch: {\n  firstName: function (val) {\n  \tthis.fullName = val + ' ' + this.lastName\n  },\n  lastName: function (val) {\n  \tthis.fullName = this.firstName + ' ' + val\n  }\n},\ncomputed: {\n  fullName: function () {\n  \treturn this.firstName + ' ' + this.lastName\n  }\n}\n```\n\n​\t\t从上面可以看出，侦听属性(watch)的特点是，当一个属性发生改变后，调用的方法。\n\n​\t\t其次，需要对其进行初始化，因为在最开始侦听属性不会进行调用。\n\n​\t\t最后，这个侦听属性的执行时机，我们通过一个简单的死循环就可以看出。侦听属性在 DOM 的变化之前。但是处于值的变化之后。起码下面这个情况满足。这个说法。\n\n```\nwatch: {\n  message: function (val) {\n  console.log(this.message);\n  while (true) {\n  \tconsole.log(this.message);\n  }\n  \tthis.reversedMessage = val + ' --- ';\n  }\n},\n```\n\n\n\n## 计算属性的setter\n\n​\t\t默认计算属性只有 getter，不过在需要时你也可以提供一个 setter。\n\n```\ncomputed: {\n  fullName: {\n    // getter\n    get: function () {\n      return this.firstName + ' ' + this.lastName\n    },\n    // setter\n    set: function (newValue) {\n      var names = newValue.split(' ')\n      this.firstName = names[0]\n      this.lastName = names[names.length - 1]\n    }\n  }\n}\n```\n\n​\t\t在运行 `vm.fullName = 'John Doe'` 时，setter 会被调用，`vm.firstName` 和 `vm.lastName` 也会相应地被更新。\n\n​\t\t当然，如果你这样写，只能说你是小机灵鬼了，一直调用了 setter 方法导致溢出。\n\n```\nset: function (newValue) {\n  console.log(newValue);\n  this.reversedMessage += '1';\n}\n```\n\n​\t\t同时我们也可以使用一些简单的方式查看这个 setter 的执行时机。通过下面这个方式，我们发现了，setter 的执行在值的变化之前。\n\n```\ncomputed: {\n  // 计算属性的 getter\n  reversedMessage: {\n    get: function () {\n      // `this` 指向 vm 实例\n      console.log(1);\n      return this.message.split('').reverse().join('')\n    },\n    set: function (newValue) {\n      console.log(this.reversedMessage, newValue);\n      while (true) {\n      console.log(this.reversedMessage);\n    };\n  }\n},\n```\n\n\n\n## 侦听器\n\n> ​\t\t虽然计算属性在大多数情况下更合适，但有时也需要一个自定义的侦听器。这就是为什么 Vue 通过 `watch` 选项提供了一个更通用的方法，来响应数据的变化。当需要在数据变化时执行异步或开销较大的操作时，这个方式是最有用的。\n\n​\t\t简单来说就是对于一个异步，和一个开销大的操作时，监听器比较合适。\n\n​\t\t异步操作，限制访问频率(防抖)，设置中间状态等。\n\n\n\n# Class 与 Style 绑定\n\n```\nhttps://cn.vuejs.org/v2/guide/class-and-style.html\n```\n\n​\t\t在将 `v-bind` 用于 `class` 和 `style` 时，Vue.js 做了专门的增强。表达式结果的类型除了字符串之外，还可以是对象或数组。\n\n\n\n## 绑定 HTML Class\n\n### 对象语法\n\n```\nv-bind:class=\"{ active: isActive, 'text-danger': hasError }\"\n```\n\n​\t\t这样，就会根据 后面的真值来判断前面这个类是否能存在。并且这里 active 是一个字符串，就算这个 active 和后面的一个 data 数据重名，最终渲染的还是一个字符串。如何能让 active 也变成一个变量类型，\n\n```\n<div v-bind:class=\"{ [message]: flag }\"></div>\n```\n\n​\t\t这里使用了动态绑定，所以 message  会从data里面进行查找。找不到则为 undefined 的字符串。并且可以使用 .undefined 来进行操作。对于不是字符串的，会转为字符串处理。\n\n​\t\t并且绑定的数据对象不必内联定义在模板里。\n\n```\n<div v-bind:class=\"classObject\"></div>\n\ndata: {\n  classObject: {\n    active: true,\n    'text-danger': false\n  }\n}\n```\n\n​\t\t如果写在 data 里面，我还不知道如何将类名动态绑定。并且后面的 true 和 false 都是写死的那种，只能在后续使用方法改变。\n\n```\n    computed: {\n      classObject: function () {\n        return {\n          [this.message]: this.flag\n        }\n      }\n    },\n```\n\n​\t\t如果写在计算属性里面，那么类名和真值都可以通过 this 进行获取。类名还是一样通过 [] 获取。不加上就会直接当成一个字符串。\n\n\n\n### 数组语法\n\n​\t\t我们可以把一个数组传给 `v-bind:class`，以应用一个 class 列表\n\n```\n<div v-bind:class=\"[activeClass, errorClass]\"></div>\n\ndata: {\n  activeClass: 'active',\n  errorClass: 'text-danger'\n}\n```\n\n​\t\t对于不是字符串的，不会被显示，需要是字符串类型才会显示。\n\n​\t\t同时，也能写三元表达式\n\n```\n<div v-bind:class=\"[isActive ? activeClass : '', errorClass]\"></div>\n```\n\n​\t\t在数组语法中也可以使用对象语法：\n\n```\n<div v-bind:class=\"[{ active: isActive }, errorClass]\"></div>\n```\n\n\n\n### 在组件上\n\n​\t\t当在一个自定义组件上使用 `class` property 时，这些 class 将被添加到该组件的根元素上面。这个元素上已经存在的 class 不会被覆盖。\n\n```\nVue.component('my-component', {\n  template: '<p class=\"foo bar\">Hi</p>'\n})\n\n<my-component class=\"baz boo\"></my-component>\n\n<p class=\"foo bar baz boo\">Hi</p>\n```\n\n​\t\t在渲染的时候，重复的类名不会被消除。当然，最终的渲染结果还是看CSS的权重级别。\n\n\n\n## 绑定内联样式\n\n### 对象语法\n\n​\t\t`v-bind:style` 的对象语法十分直观——看着非常像 CSS，但其实是一个 JavaScript 对象。CSS property 名可以用驼峰式 (camelCase) 或短横线分隔 (kebab-case，记得用引号括起来) 来命名\n\n```\n<div v-bind:style=\"{ color: activeColor, fontSize: fontSize + 'px' }\"></div>\n\n<div v-bind:style=\"{ color: activeColor, 'font-size': fontSize + 'px' }\"></div>\n\ndata: {\n  activeColor: 'red',\n  fontSize: 30\n}\n```\n\n​\t\t当然也能绑定到一个样式对象。大致还是和上面的要求一样。\n\n\n\n### 数组语法\n\n​\t\t`v-bind:style` 的数组语法可以将多个样式对象应用到同一个元素上：\n\n```\n<div v-bind:style=\"[activeColor]\">123</div>\n\nactiveColor: {\n\tfontSize: '30px'\n},\n```\n\n​\t\t当然，也能将其作为一个数组加对象整合为一个返回值，绑定到一个样式对象。\n\n\n\n### 自动添加前缀\n\n​\t\t当 `v-bind:style` 使用需要添加[浏览器引擎前缀](https://developer.mozilla.org/zh-CN/docs/Glossary/Vendor_Prefix)的 CSS property 时，如 `transform`，Vue.js 会自动侦测并添加相应的前缀。\n\n​\t\t其次，对于使用了 v-bind:style 和 style 的，会以 v-bind:style 为主。\n\n\n\n### 多重值 （2.3.0）\n\n​\t\t从 2.3.0 起你可以为 `style` 绑定中的 property 提供一个包含多个值的数组，常用于提供多个带前缀的值\n\n```\n<div :style=\"{ display: ['-webkit-box', '-ms-flexbox', 'flex'] }\"></div>\n```\n\n​\t\t这样写只会渲染数组中最后一个被浏览器支持的值。在本例中，如果浏览器支持不带浏览器前缀的 flexbox，那么就只会渲染 `display: flex`。\n\n​\t\t**意思就是说**，对于这样的一个值的数组，我们会从后往前进行赋值，直到遇到浏览器可以支持的值，例如本例来说，先判断，flex，再判断 -ms-flexbox，最后再判断 -webkit-box。\n\n\n\n# 条件渲染\n\n```\nhttps://cn.vuejs.org/v2/guide/conditional.html\n```\n\n\n\n## v-if\n\n​\t\t`v-if` 指令用于条件性地渲染一块内容。这块内容只会在指令的表达式返回 truthy 值的时候被渲染。\n\n​\t\t也可以用 `v-else` 添加一个“else 块”：\n\n```\n<h1 v-if=\"awesome\">Vue is awesome!</h1>\n<h1 v-else>Oh no 😢</h1>\n```\n\n\n\n### 在 `<template>` 元素上使用 `v-if` 条件渲染分组\n\n​\t\t因为 `v-if` 是一个指令，所以必须将它添加到一个元素上。但是如果想切换多个元素呢？此时可以把一个 `<template>` 元素当做不可见的包裹元素，并在上面使用 `v-if`。最终的渲染结果将不包含 `<template>` 元素。\n\n```\n<template v-if=\"ok\">\n  <h1>Title</h1>\n  <p>Paragraph 1</p>\n  <p>Paragraph 2</p>\n</template>\n```\n\n​\t\t这里很好理解。首先 v-if 只能添加到一个元素上，所以我们使用了一个元素进行了包裹，然后这个 template 的一个特点就是不会显示，例如\n\n```\n<template>\n\t<div>123</div>\n</template>\n\n最终的显示结果就是\n<div>123</div>\n```\n\n​\t\t所以这个的好处在于，既能产生包裹，还能不将其 DOM 的结构进行变化。\n\n\n\n### v-else\n\n​\t\t你可以使用 `v-else` 指令来表示 `v-if` 的“else 块”\n\n​\t\t`v-else` 元素必须紧跟在带 `v-if` 或者 `v-else-if` 的元素的后面，否则它将不会被识别。\n\n```\n<div v-if=\"Math.random() > 0.5\">\n  Now you see me\n</div>\n<div v-else>\n  Now you don't\n</div>\n```\n\n\n\n### v-else-if（2.1.0）\n\n​\t\t`v-else-if`，顾名思义，充当 `v-if` 的“else-if 块”，可以连续使用\n\n​\t\t类似于 `v-else`，`v-else-if` 也必须紧跟在带 `v-if` 或者 `v-else-if` 的元素之后。\n\n```\n<div v-if=\"type === 'A'\">A</div>\n<div v-else-if=\"type === 'B'\">B</div>\n<div v-else>Not A/B/C</div>\n```\n\n\n\n### 用 `key` 管理可复用的元素\n\n​\t\tVue 会尽可能高效地渲染元素，通常会复用已有元素而不是从头开始渲染。这么做除了使 Vue 变得非常快之外，还有其它一些好处。\n\n```\n<template v-if=\"loginType === 'username'\">\n  <label>Username</label>\n  <input placeholder=\"Enter your username\">\n</template>\n<template v-else>\n  <label>Email</label>\n  <input placeholder=\"Enter your email address\">\n</template>\n```\n\n​\t\t那么在上面的代码中切换 `loginType` 将不会清除用户已经输入的内容。因为两个模板使用了相同的元素，`<input>` 不会被替换掉——仅仅是替换了它的 `placeholder`。\n\n\n\n​\t\t对于上述的代码，切换了 input  的输入框，但是却对于 value 值没有发生改变。但是如果我们会发现对于类名，style等属性是会发生改变。我们同时也可以知道 value 是input输入框的值，如果是对于 DOM 元素，可以通过 value 进行获取，但是在这里，虽然使用了 value 的属性，但是只要进行输入了，value 的值也不起效果。\n\n​\t\t但是我们同时也发现了，再切换之后，DOM 的指向没有改变。并且也发现了 value 的值在控制台的输出是有变化的。只是对于输入框的内容没有变化。个人猜测，这里input的输入和value 其实中间不是完全直接对应。输入框显示的 value 只是作为了一个最初值。但是内部的value已经发生了变化。\n\n​\t\t当然解决这个方法很简单。\n\n*  Vue 为你提供了一种方式来表达“这两个元素是完全独立的，不要复用它们”。只需添加一个具有唯一值的 `key` attribute 即可\n\n  * ```\n    <input placeholder=\"Enter your username\" key=\"username-input\">\n    ```\n\n  * 这里，只需要 key 值不同即可。并且发现加了 key 值之后， DOM 获取的元素已经不会根据你的按钮发生变化，并且值也不会发生变化了，因为已经不是一个 input 框了，就算是换回来也不是一个了，因为 v-if 是直接修改了 DOM 树。\n\n  * ```\n    <template v-if=\"loginType === 'username'\">\n      <label>Username</label>\n      <input key=\"a\" class=\"a\" style=\"color: red; font-size: 20px\" placeholder=\"Enter your username\" value=\"1\">\n    </template>\n    <template v-else>\n      <label>Email</label>\n      <input key=\"b\" class=\"b\" placeholder=\"Enter your email address\" value=\"2\">\n    </template>\n    \n    \n    记住，这个需要放在 vue实例之后，应该是因为 template 的原因。\n    const a = document.querySelector('input.a'),\n    \tb = document.querySelector('input.b');\n    function c() {\n      console.log(a);\n      console.log(a.value);\n    }\n    ```\n\n* 当然，还可以使用 v-model 将数据进行绑定，那么input输入框的显示也会跟数据有关了。并且 v-model 是进行的复用。因为 DOM 的输出是会发生变化的。并且输入框和data数据是实时绑定了的。\n\n\n\n## v-show\n\n​\t\t另一个用于根据条件展示元素的选项是 `v-show` 指令。用法大致一样\n\n```\n<h1 v-show=\"ok\">Hello!</h1>\n```\n\n​\t\t同的是带有 `v-show` 的元素始终会被渲染并保留在 DOM 中。`v-show` 只是简单地切换元素的 CSS property `display`。\n\n> 注意，`v-show` 不支持 `<template>` 元素，也不支持 `v-else`。\n\n​\t\tv-show 不支持 template 元素，意思就是说，你在 template 元素上使用 v-show，不管是 true 还是 false，template 都会显示在页面上，而如果你使用v-if就会发现，结果是不一样的。\n\n​\t\tv-show 不支持 v-else，就如字面上来说，不支持的意思。\n\n\n\n## v-if VS v-show\n\n​\t\t`v-if` 是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。\n\n​\t\t`v-if` 也是**惰性的**：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。\n\n​\t\t相比之下，`v-show` 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。\n\n​\t\t一般来说，`v-if` 有更高的切换开销，而 `v-show` 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 `v-show` 较好；如果在运行时条件很少改变，则使用 `v-if` 较好。\n\n​\t\t**简单概括：**\n\n* **v-if** 是会直接和 DOM 树相关。而 **v-show** 只是简单的使用了 display:none，和渲染树相关。\n* 所以 v-if 对于切换会产生高开销，因为每次都会进行 DOM 的修改。而 v-show 会产生初始渲染的高开销，因为不管是否显示都会渲染。\n* 所以，对于频繁切换使用 v-show，对于很少改变使用 v-if。\n\n\n\n## v-if 和 v-for 一起使用\n\n> **不推荐**同时使用 `v-if` 和 `v-for`。请查阅[风格指南](https://cn.vuejs.org/v2/style-guide/#避免-v-if-和-v-for-用在一起-必要)以获取更多信息。\n\n​\t\t当 `v-if` 与 `v-for` 一起使用时，`v-for` 具有比 `v-if` 更高的优先级。请查阅[列表渲染指南](https://cn.vuejs.org/v2/guide/list.html#v-for-with-v-if)以获取详细信息。\n\n​\t\t当它们处于同一节点，`v-for` 的优先级比 `v-if` 更高，这意味着 `v-if` 将分别重复运行于每个 `v-for` 循环中。当你只想为*部分*项渲染节点时，这种优先级的机制会十分有用。\n\n​\t\t通过查看了 风格指南，主要说几点：\n\n* 避免一起使用\n\n* 对于需要过滤一个列表中的项目，采用计算属性\n\n  * ```\n    v-for=\"user in users\" v-if=\"user.isActive\"\n    \n    可以对 user 使用一个计算属性 activeUser 使用filter过滤后返回\n    v-for=\"user in activeUsers\"\n    \n    computed: {\n    \tactiveUsers: function() {\n    \t\treturn this.users.filter((user) => user.isActive);\n    \t}\n    }\n    ```\n\n* 对于会直接应该被隐藏的列表，将 v-if 放在上层，不要在每次循环的时候判断\n\n  * ```\n    v-for=\"user in users\" v-if=\"shouldShowUsers\"\n    \n    shouldShowUsers 这是对一个 users 进行的判断，只要为 false，所有的 users都不会显示，所以这个建议放在上层\n    v-if=\"shouldShowUsers\"\n    \tv-for=\"user in users\"\n    ```\n\n\n\n# 列表渲染\n\n```\nhttps://cn.vuejs.org/v2/guide/list.html\n```\n\n\n\n## 用 v-for 把一个数组对应为一组元素\n\n​\t\t我们可以用 `v-for` 指令基于一个数组来渲染一个列表。`v-for` 指令需要使用 `item in items` 形式的特殊语法，其中 `items` 是源数据数组，而 `item` 则是被迭代的数组元素的**别名**。\n\n```\n<ul id=\"example-1\">\n  <li v-for=\"item in items\" :key=\"item.message\">\n    {{ item.message }}\n  </li>\n</ul>\n\nitems: [\n  { message: 'Foo' },\n  { message: 'Bar' }\n]\n```\n\n​\t\t`v-for` 还支持一个可选的第二个参数，即当前项的索引。\n\n```\n<li v-for=\"(item, index) in items\">\n\t{{ parentMessage }} - {{ index }} - {{ item.message }}\n</li>\n```\n\n​\t\tindex 从0开始。\n\n​\t\t你也可以用 `of` 替代 `in` 作为分隔符，因为它更接近 JavaScript 迭代器的语法\n\n```\n<div v-for=\"item of items\"></div>\n```\n\n\n\n## 在 `v-for` 里使用对象\n\n​\t\t你也可以用 `v-for` 来遍历一个对象的 property。\n\n```\n<li v-for=\"value in object\">\n\t{{ value }}\n</li>\n\nobject: {\n  title: 'How to do lists in Vue',\n  author: 'Jane Doe',\n  publishedAt: '2016-04-10'\n}\n```\n\n​\t\t你也可以提供第二个的参数为 property 名称 (也就是键名)\n\n```\n<div v-for=\"(value, name) in object\">\n  {{ name }}: {{ value }}\n</div>\n\ntitle: How to do lists in Vue\n```\n\n​\t\t还可以用第三个参数作为索引\n\n```\n<div v-for=\"(value, name, index) in object\">\n\n0\n1\n2\n```\n\n> ​\t\t在遍历对象时，会按 `Object.keys()` 的结果遍历，但是**不能**保证它的结果在不同的 JavaScript 引擎下都一致。\n\n\n\n**注意：**\n\n* 如果 v-for 里面是一个正整数n，那么将会变成 1~n，如果是一个小数，会报错。\n  * 因为这个方法是会对其进行length操作，所以对于非正整数将出问题。\n* 如果v-for里面是一个字符串，那么将会把字符串挨个字符输出。\n\n\n\n## 维护状态\n\n​\t\t当 Vue 正在更新使用 `v-for` 渲染的元素列表时，它默认使用“就地更新”的策略。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序，而是就地更新每个元素，并且确保它们在每个索引位置正确渲染。这个类似 Vue 1.x 的 `track-by=\"$index\"`。\n\n​\t\t**简单来说就是**，发现了变化，不会查看是否是有匹配的 DOM，而是直接将原来位置上的DOM进行改变。比如如果只是位置发生了改变，如果使用默认的方式，那么就会挨着将DOM进行修改，但是如果使用了key来进行维护，那么会查看是否有key值存在的，有的话就会直接使用key的DOM进行维护。没有再创建。\n\n​\t\t这个默认的模式是高效的，但是**只适用于不依赖子组件状态或临时 DOM 状态 (例如：表单输入值) 的列表渲染输出**。\n\n​\t\t**这里给的意思就是说**，如果对于依赖了子组件话，那么进行修改的时候需要耗费大量的时间，所以需要进行一些判断来处理要使用什么方法。\n\n​\t\t为了给 Vue 一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一 `key` attribute\n\n​\t\t就是说可以使用key来进行定位。\n\n```\n<div v-for=\"item in items\" v-bind:key=\"item.id\">\n  <!-- 内容 -->\n</div>\n```\n\n​\t\t建议尽可能在使用 `v-for` 时提供 `key` attribute，除非遍历输出的 DOM 内容非常简单，或者是刻意依赖默认行为以获取性能上的提升。\n\n​\t\t因为它是 Vue 识别节点的一个通用机制，`key` 并不仅与 `v-for` 特别关联。后面我们将在指南中看到，它还具有其它用途。\n\n​\t\t其次对于key值，不要使用index下标进行赋值，因为如果你对数组进行了变化，位置变化等，可能下标也会发生改变，这样可能还会降低性能。\n\n> ​\t\t不要使用对象或数组之类的非基本类型值作为 `v-for` 的 `key`。请用字符串或数值类型的值。\n\n\n\n## 数组更新检测\n\n### 变更方法\n\n​\t\t因为Vue的响应式是相对于Object.defineProperty的使用。所以Vue对数组的处理方式是，对方法进行了包裹，所以使用了数组的方法也会触发视图的更新。\n\n​\t\t这些方法包括了\n\n```\npush，pop，shift，unshift，splice，sort，reverse\n```\n\n\n\n### 替换数组\n\n​\t\t变更方法，顾名思义，会变更调用了这些方法的原始数组。相比之下，也有非变更方法，例如 `filter()`、`concat()` 和 `slice()`。它们不会变更原始数组，而**总是返回一个新数组**。当使用非变更方法时，可以用新数组替换旧数组。\n\n```\nexample1.items = example1.items.filter(function (item) {\n  return item.message.match(/Foo/)\n})\n```\n\n​\t\t简单来说，上面的变更方法在调用之后是会变化原数组的。但是我们也有不会变更原数组的方法。所以对于这些不会变更原数组的方法，我们可以选择直接进行重新赋值。\n\n```\nitems = newItems\n```\n\n​\t\t我们可以发现对数组直接进行赋值也触发了视图的变化。因为我们对items这个数组也进行了监听。地址的改变也触发了视图的变化，同理，对于一个对象也是一样的。\n\n​\t\t你可能认为这将导致 Vue 丢弃现有 DOM 并重新渲染整个列表。幸运的是，事实并非如此。Vue 为了使得 DOM 元素得到最大范围的重用而实现了一些智能的启发式方法，所以用一个含有相同元素的数组去替换原来的数组是非常高效的操作。\n\n> ​\t\t由于 JavaScript 的限制，Vue **不能检测**数组和对象的变化。[深入响应式原理](https://cn.vuejs.org/v2/guide/reactivity.html#检测变化的注意事项)中有相关的讨论。\n\n\n\n### 显示过滤/排序后的结果\n\n​\t\t有时，我们想要显示一个数组经过过滤或排序后的版本，而不实际变更或重置原始数据。在这种情况下，可以创建一个计算属性，来返回过滤或排序后的数组。\n\n```\n<li v-for=\"n in evenNumbers\">{{ n }}</li>\n\ncomputed: {\n  evenNumbers: function () {\n    return this.numbers.filter(function (number) {\n      return number % 2 === 0\n    })\n\t}\n}\n```\n\n​\t\t对于计算属性不适合的情况下，比如是循环嵌套了循环，此时对于循环内层，用不了计算属性，可以使用方法\n\n```\n<ul v-for=\"set in sets\">\n  <li v-for=\"n in even(set)\">{{ n }}</li>\n</ul>\n\neven: function (numbers) {\n  return numbers.filter(function (number) {\n  \treturn number % 2 === 0\n  })\n}\n```\n\n​\t\t当然，你可能会想着，我对这个内层也加一个计算属性啊，但是，是没有效果的，简单来说就是因为就近原则，一个是循环的set，一个计算属性的set，他会先找循环的set。\n\n\n\n### 在 v-for 里使用值范围\n\n​\t\t`v-for` 也可以接受整数。在这种情况下，它会把模板重复对应次数。\n\n​\t\t对于字符串则会将字符进行循环。\n\n\n\n### 在 \\<template> 上使用 v-for\n\n​\t\t类似于 `v-if`，你也可以利用带有 `v-for` 的 `<template>` 来循环渲染一段包含多个元素的内容。\n\n\n\n### 在组件上使用 `v-for`\n\n​\t\t在自定义组件上，你可以像在任何普通元素上一样使用 `v-for`。\n\n```\n<my-component v-for=\"item in items\" :key=\"item.id\"></my-component>\n```\n\n​\t\t**2.2.0+ 的版本里，当在组件上使用 `v-for` 时，`key` 现在是必须的。**\n\n​\t\t然而，任何数据都不会被自动传递到组件里，因为组件有自己独立的作用域。为了把迭代数据传递到组件里，我们要使用 prop。\n\n```\n<ul>\n  <li\n    is=\"todo-item\"\n    v-for=\"(todo, index) in todos\"\n    v-bind:key=\"todo.id\"\n    v-bind:title=\"todo.title\"\n    v-on:remove=\"todos.splice(index, 1)\"\n  ></li>\n</ul>\n\nVue.component('todo-item', {\n  template: '\\\n    <li>\\\n      {{ title }}\\\n      <button v-on:click=\"$emit(\\'remove\\')\">Remove</button>\\\n    </li>\\\n  ',\n  props: ['title']\n})\n```\n\n> ​\t\t注意这里的 `is=\"todo-item\"` attribute。这种做法在使用 DOM 模板时是十分必要的，因为在 `<ul>` 元素内只有 `<li>` 元素会被看作有效内容。这样做实现的效果与 `<todo-item>` 相同，但是可以避开一些潜在的浏览器解析错误。查看 [DOM 模板解析说明](https://cn.vuejs.org/v2/guide/components.html#解析-DOM-模板时的注意事项) 来了解更多信息。\n\n​\t\t简单来说，ul 元素内只有li元素被看作有效，我们使用is方法进行了替换，这样重点可以避开潜在的浏览器解析错误。当然这是一个Vue的方法。\n\n\n\n# 事件处理\n\n```\nhttps://cn.vuejs.org/v2/guide/events.html\n```\n\n\n\n## 监听事件\n\n​\t\t可以用 `v-on` 指令监听 DOM 事件，并在触发时运行一些 JavaScript 代码。对应的语法糖，`@`\n\n```\n<button v-on:click=\"counter += 1\">Add 1</button>\n```\n\n\n\n## 事件处理方法\n\n​\t\t然而许多事件处理逻辑会更为复杂，所以直接把 JavaScript 代码写在 `v-on` 指令中是不可行的。因此 `v-on` 还可以接收一个需要调用的方法名称。\n\n```\n<!-- `greet` 是在下面定义的方法名 -->\n<button v-on:click=\"greet\">Greet</button>\n\n// 在 `methods` 对象中定义方法\nmethods: {\n  greet: function (event) {\n    // `this` 在方法里指向当前 Vue 实例\n    alert('Hello ' + this.name + '!')\n    // `event` 是原生 DOM 事件\n    if (event) {\n    \talert(event.target.tagName)\n    }\n  }\n}\n\n// 也可以用 JavaScript 直接调用方法\nvm.greet() // => 'Hello Vue.js!'\n```\n\n\n\n## 内联处理器中的方法\n\n​\t\t除了直接绑定到一个方法，也可以在内联 JavaScript 语句中调用方法：\n\n```\n<button v-on:click=\"say('hi')\">Say hi</button>\n\nmethods: {\n  say: function (message) {\n  \talert(message)\n  }\n}\n```\n\n​\t\t有时也需要在内联语句处理器中访问原始的 DOM 事件。可以用特殊变量 `$event` 把它传入方法\n\n```\n<button v-on:click=\"warn('Form cannot be submitted yet.', $event)\">Submit</button>\n```\n\n\n\n**对于event方法的使用：**\n\n* 如果方法是不带参数的，可以直接使用event，或者参数上加上event\n\n  * ```\n    <button @click=\"change\">button</button>\n    \n    change(event) {console.log(event);},\n    change() {console.log(event);}\n    ```\n\n  * 不同点：\n\n    * 如果使用了 @click=change()，加上了括号，对于第一个，传参event的，无法使用，第二个可以使用。\n\n* 当然我们也可以使用 $event 来传递这个参数。\n\n\n\n## 事件修饰符\n\n​\t\t在事件处理程序中调用 `event.preventDefault()` 或 `event.stopPropagation()` 是非常常见的需求。尽管我们可以在方法中轻松实现这点，但更好的方式是：方法只有纯粹的数据逻辑，而不是去处理 DOM 事件细节。\n\n​\t\t首先默认使用的click方法就是冒泡类型。\n\n​\t\t常见的事件修饰符\n\n```\n.stop\n\t阻止事件的冒泡\n.prevent\n\t阻止事件的默认行为，对于在父元素使用了阻止默认行为，子元素的默认行为都会被阻止。\n.capture\n\t转为捕获事件监听，事件的监听顺序是 root --> target 捕获， target --> root 冒泡\n.self\n\t只有目标元素是自身才会触发，对于子元素的点击也不会触发。\n.once\t/ 2.1.4 新增\n\t只触发一次。\n.passive / 2.3.0 新增\n\t\n```\n\n​\t\t不像其它只能对原生的 DOM 事件起作用的修饰符，`.once` 修饰符还能被用到自定义的[组件事件](https://cn.vuejs.org/v2/guide/components-custom-events.html)上\n\n> ​\t\t使用修饰符时，顺序很重要；相应的代码会以同样的顺序产生。因此，用 `v-on:click.prevent.self` 会阻止**所有的点击**，而 `v-on:click.self.prevent` 只会阻止对元素自身的点击。\n\n```\n<div @click.prevent.self=\"change\">\n  <a href=\"#1\" @click=\"change1\">321</a>\n  <div @click=\"change1\">123</div>\n</div>\n\n<div @click.self.prevent=\"change\">\n  <a href=\"#1\" @click=\"change1\">321</a>\n  <div @click=\"change1\">123</div>\n</div>\n```\n\n​\t\t**热知识**：父元素阻止了默认行为会影响到子元素。\n\n​\t\t**热知识2：** click方法会先于默认行为执行。并且要冒泡结束了之后才会执行。\n\n​\t\tVue 还对应 [`addEventListener` 中的 `passive` 选项](https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Parameters)提供了 `.passive` 修饰符。\n\n```\n<!-- 滚动事件的默认行为 (即滚动行为) 将会立即触发 -->\n<!-- 而不会等待 `onScroll` 完成  -->\n<!-- 这其中包含 `event.preventDefault()` 的情况 -->\n<div v-on:scroll.passive=\"onScroll\">...</div>\n```\n\n​\t\t他这里是这样说，貌似意思是说，默认行为会先触发，然后再触发 onScroll 的方法，但是我对一个。a标签进行操作的时候发现是先输出，然后在跳转，对于一个scroll行为的测试从肉眼上看也是和a标签一样，当然这个滚动的行为可能才滚1帧就开始触发了循环，导致卡帧也有可能。所以我现在不知道如何判断。\n\n```\n<div @click=\"change\">\n\t<a href=\"#1\" @click.passive=\"change1\">321</a>\n</div>\n\nmethods: {\n  change() {\n    console.log('father');\n    let date = new Date().getTime() + 1000;\n    while (date > new Date()) {\n\n    };\n  },\n  change1() {\n  \tconsole.log('children');\n  }\n}\n```\n\n​\t\t发现是先输出控制台，然后url再变化的。\n\n​\t\t并且如果父元素使用了 prevent，子元素的passive无效，passive只能让本元素上的prevent无效。\n\n​\t\t这个 `.passive` 修饰符尤其能够提升移动端的性能。 \n\n​\t\t\n\n## 按键修饰符\n\n​\t\t在监听键盘事件时，我们经常需要检查详细的按键。Vue 允许为 `v-on` 在监听键盘事件时添加按键修饰符\n\n```\n<!-- 只有在 `key` 是 `Enter` 时调用 `vm.submit()` -->\n<input v-on:keyup.enter=\"submit\">\n```\n\n\n\n### 按键码\n\n> ​\t\t`keyCode` 的事件用法[已经被废弃了](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/keyCode)并可能不会被最新的浏览器支持。\n\n​\t\t使用 `keyCode` attribute 也是允许的：\n\n```\n<input v-on:keyup.13=\"submit\">\n```\n\n​\t\t为了在必要的情况下支持旧浏览器，Vue 提供了绝大多数常用的按键码的别名：\n\n```\n.enter\t.tab\t.delete (捕获“删除”和“退格”键)\t.esc\t.space\t.up\t.down\t.left\t.right\n```\n\n> ​\t\t有一些按键 (`.esc` 以及所有的方向键) 在 IE9 中有不同的 `key` 值, 如果你想支持 IE9，这些内置的别名应该是首选。\n\n​\t\t你还可以通过全局 `config.keyCodes` 对象[自定义按键修饰符别名](https://cn.vuejs.org/v2/api/#keyCodes)：\n\n```\n// 可以使用 `v-on:keyup.f1`\nVue.config.keyCodes.f1 = 112\n```\n\n​\t\t按键别名可以进行覆盖，当然这个不建议这样写已经存在的。\n\n**注意：**\n\n​\t\t按键别名不要使用大写，因为大写的在 `<input v-on:keyup.enter=\"submit\"> `，在这里会转为小写，所以无法使用成功。\n\n```\n<input type=\"text\" @keyup.A=\"change\">\n\nVue.config.keyCodes.A = 97;\n```\n\n\n\n## 系统修饰键\n\n​\t\t可以用如下修饰符来实现仅在按下相应按键时才触发鼠标或键盘事件的监听器。(2.1.0新增)\n\n```\n.ctrl\n.alt\n.shift\n.meta\n\t就是Windows键盘上的那个Windows图标按钮。mac同理\n```\n\n> ​\t\t注意：在 Mac 系统键盘上，meta 对应 command 键 (⌘)。在 Windows 系统键盘 meta 对应 Windows 徽标键 (⊞)。在 Sun 操作系统键盘上，meta 对应实心宝石键 (◆)。在其他特定键盘上，尤其在 MIT 和 Lisp 机器的键盘、以及其后继产品，比如 Knight 键盘、space-cadet 键盘，meta 被标记为“META”。在 Symbolics 键盘上，meta 被标记为“META”或者“Meta”。\n>\n\n```\n<!-- Alt + C -->\n<input v-on:keyup.alt.67=\"clear\">\n\n<!-- Ctrl + Click -->\n<div v-on:click.ctrl=\"doSomething\">Do something</div>\n```\n\n**注意：**\n\n* 使用系统修饰键对于 @keyup.67.ctrl 和 @keyup.ctrl.67 是一样的。不会有先后顺序。\n* 请注意修饰键与常规按键不同，在和 `keyup` 事件一起用时，事件触发时修饰键必须处于按下状态。换句话说，只有在按住 `ctrl` 的情况下释放其它按键，才能触发 `keyup.ctrl`。而单单释放 `ctrl` 也不会触发事件。如果你想要这样的行为，请为 `ctrl` 换用 `keyCode`：`keyup.17`。17代表了ctrl\n* **@keyup.17.67** 这个代表了按这两个其中一个都有效\n* 系统修饰键可以使用多个。\n\n\n\n### .exact 修饰符（2.5.0新增）\n\n​\t\t`.exact` 修饰符允许你控制由精确的系统修饰键组合触发的事件。\n\n​\t\t**作用**：用于**精确**控制系统修饰键按键的修饰符。主要在于精确两个字。并且是对系统修饰键起作用的。\n\n```\n<input type=\"text\" @keyup.a.up.exact=\"change\">\n\t这个里面没有系统修饰键，监听了两个按键，最终效果：没有什么区别，唯一的区别就是如果此时你按了系统修饰键将不会触发。\n\t所以这个代表了<!-- 没有任何系统修饰键被按下的时候才触发 -->\n```\n\n```\n<input type=\"text\" @keyup.ctrl.up.exact=\"change\">\n\t这个里面存在了系统修饰键 ctrl，所以效果就是必须按了 ctrl才会有用，（当然这个是系统修饰键的效果），.exact修饰符 的效果就是，系统修饰键必须只按了ctrl才有用。精确。加上系统修饰键。\n\t其次.exact 修饰符没有位置的要求，和系统修饰键一样没有位置要求，\n\t然后就是对于 <input type=\"text\" @keyup.exact.ctrl.up.a=\"change\"> 我们可以发现， 一个exact修饰符，一个ctrl系统修饰键，两个普通按键修饰符。所以最终的效果是，有且只有按了ctrl键，加上普通按键修饰符的其中一个就行。\n\t<!-- 有且只有 Ctrl 被按下的时候才触发 -->\n```\n\n\n\n### 鼠标按钮修饰符（2.2.0新增）\n\n​\t\t这些修饰符会限制处理函数仅响应特定的鼠标按钮。\n\n```\n.left\n.right\n.middle\n```\n\n​\t\t用于点击事件，对于keyup事件不起作用，当然对于系统修饰键和.exact修饰符没有这些要求。\n\n```\n<div @click.middle.ctrl.exact=\"change\">321</div>\n\t要求是 ctrl键 + 鼠标中键才会触发。\n```\n\n\n\n## 为什么要在 HTML 中监听事件\n\n​\t\t你可能注意到这种事件监听的方式违背了关注点分离 (separation of concern) 这个长期以来的优良传统。但不必担心，因为所有的 Vue.js 事件处理方法和表达式都严格绑定在当前视图的 ViewModel 上，它不会导致任何维护上的困难。实际上，使用 `v-on` 有几个好处：\n\n1. 扫一眼 HTML 模板便能轻松定位在 JavaScript 代码里对应的方法。\n2. 因为你无须在 JavaScript 里手动绑定事件，你的 ViewModel 代码可以是非常纯粹的逻辑，和 DOM 完全解耦，更易于测试。\n3. 当一个 ViewModel 被销毁时，所有的事件处理器都会自动被删除。你无须担心如何清理它们。\n\n\n\n**概括就是说**：虽然是在html中进行的使用监听，但是真正的处理是绑定在VM上的。其次对于v-on的好处：1.能够一眼看出方法。2.和DOM完全解耦。3.当一个VM被销毁时，所有的事件会自动清除。\n\n\n\n# 表单输入绑定\n\n```\nhttps://cn.vuejs.org/v2/guide/forms.html\n```\n\n\n\n## 基础用法\n\n​\t\t你可以用 `v-model` 指令在表单 `<input>`、`<textarea>` 及 `<select>` 元素上创建双向数据绑定。它会根据控件类型自动选取正确的方法来更新元素。\n\n```\n<input v-model=\"message\" placeholder=\"edit me\">\n这里，我是用 v-model，并没有绑定给value，但是会自动选取正确的方法进行更新。\n```\n\n\n\n**注意：**\n\n* v-model 会忽略元素自带的value，checked等属性，而是使用Vue实例的数据作为来源。\n\n\n\n​\t\t`v-model` 在内部为不同的输入元素使用不同的 property 并抛出不同的事件。\n\n- text 和 textarea 元素使用 `value` property 和 `input` 事件；\n- checkbox 和 radio 使用 `checked` property 和 `change` 事件；（使用的是真值方式truth）\n- select 字段将 `value` 作为 prop 并将 `change` 作为事件。\n\n\n\n> ​\t\t对于需要使用[输入法](https://zh.wikipedia.org/wiki/输入法) (如中文、日文、韩文等) 的语言，你会发现 `v-model` 不会在输入法组合文字过程中得到更新。如果你也想处理这个过程，请使用 `input` 事件。\n\n​\t\t你在输入框输入加上一个input事件的监听的时候就会发现。如果在输入的时候使用了中文，虽然在按键的时候发生了input事件，但是v-model的值并没有得到更新。\n\n​\t\t但是如果是普通的input输入框的监听则会发生更新。\n\n```\n<input type=\"text\" v-model=\"string\" @input=\"change\" oninput=\"console.log('event:    ' + event.target.value);\">\n```\n\n​\t\t并且在进行了空格之后会发生多次的更新。\n\n\n\n### 文本 和 多行文本\n\n```\n<input type=\"text\" v-model=\"message\">\n<textarea v-model=\"message\"></textarea>\n```\n\n​\t\t在文本区域插值 (`<textarea>{{text}}</textarea>`) 并不会生效，应用 `v-model` 来代替。\n\n\n\n### 复选框\n\n​\t\t单个复选框，直接布尔值进行的判断，对于不是布尔类型的使用了truth方式。\n\n```\n<input type=\"checkbox\" id=\"checkbox\" v-model=\"checked\">\n```\n\n​\t\t对于多个复选框\n\n​\t\t注意：复选框和单选框是通过value进行判断。\n\n```\n<input type=\"checkbox\" id=\"jack\" value=\"Jack\" v-model=\"checkedNames\">\n<label for=\"jack\">Jack</label>\n<input type=\"checkbox\" id=\"john\" value=\"John\" v-model=\"checkedNames\">\n<label for=\"john\">John</label>\n<input type=\"checkbox\" id=\"mike\" value=\"Mike\" v-model=\"checkedNames\">\n<label for=\"mike\">Mike</label>\n```\n\n​\t\t~~我们可以发现，这里没有对复选框进行分组，正常的情况下，复选框需要进行name的分组，相同的name为一组。这个好像是对单选框的。复选框应该本来就可以不用分组？~~\n\n​\t\t对于一个复选框，如果绑定了v-model，但是value不绑定，那么点击一个就是点击多个。因为没有使用value属性，值为null，所以所有为null都会被同步变化。\n\n​\t\t同时，如果多选的复选框，但是绑定的属性不是一个数组那么最终也会变为全部都会出现相同的变化。 `checkedNames: 1,` \n\n\n\n\n\n### 单选按钮\n\n```\n  <input type=\"radio\" name=\"aa\" id=\"jack\" value=\"Jack\" v-model=\"checkedNames\">\n  <label for=\"jack\">Jack</label>\n  <input type=\"radio\" name=\"cc\" id=\"john\" value=\"John\" v-model=\"checkedNames\">\n  <label for=\"john\">John</label>\n  <input type=\"radio\" name=\"aa\" id=\"mike\" value=\"Mike\" v-model=\"checkedNames\">\n  <label for=\"mike\">Mike</label>\n```\n\n​\t\t在这里，我将name进行不同的划分，但是可以发现他们还是一组的成员。\n\n​\t\t~~所以我们可以这样认为，使用了v-model之后，name也会绑定为这个属性的名称，所以你自己定义的属性名称是没有作用的。~~（注意：这里不是说，绑定的是v-model属性的名称，而是说，name的绑定和v-model的属性相关了。但是值不知道是什么。）\n\n​\t\t**注意：** 首先我们可以测试出来，name的属性还是没有改变，因为如果添加了一个 相同name，但是没有使用v-model的，会出现竞争。\n\n​\t\t对于单选按钮，**没有使用value的**，那么v-model绑定的属性取出来的值是空。就是那种什么都没有的空。**并且name属性默认不同**。\n\n​\t\t如果自己定义了name属性，那么会以自己定义的为准。但是如果使用了value，搭配了v-model，对于同value，不同name，两个都选上。 ~~那么name属性还是以v-model为准（是指相同的v-model有相同的name）。~~\n\n​\t\t并且，如果value相等，name不等，那么点击时，都会一起变化。如果name相等了，那么点击时点击那个就是哪个，但是value的值不变，并且对于初始化来说，是根据value的值来进行的变化，所以会以最后一个为准。\n\n​\t\t这里有很多问题，但是这些都是可以手动避免的。大概知道就行。我也被自己扯蒙了。\n\n\n\n### 选择框\n\n​\t\t单选时，直接绑定一个值即可\n\n```\n  <select v-model=\"selected\">\n    <option disabled value=\"\">请选择</option>\n    <option>A</option>\n    <option>B</option>\n    <option>C</option>\n  </select>\n  <span>Selected: {{ selected }}</span>\n```\n\n​\t\t我们也可以发现，对于使用option的时候，可以不添加value属性，此时绑定的值就是内容。\n\n**注意：**如果没有规定 value 属性，选项的值将设置为 \\<option> 标签中的内容。\n\n**注意：**\n\n> ​\t\t如果 `v-model` 表达式的初始值未能匹配任何选项，`<select>` 元素将被渲染为“未选中”状态。在 iOS 中，这会使用户无法选择第一个选项。因为这样的情况下，iOS 不会触发 change 事件。因此，更推荐像上面这样提供一个值为空的禁用选项。\n\n​\t\t当然这个我不清楚，毕竟我没有IOS。。。。。。\n\n\n\n​\t\t多选时就是绑定一个数组\n\n```\n<select v-model=\"selected\" multiple style=\"width: 50px;\">\n  <option>A</option>\n  <option>B</option>\n  <option>C</option>\n</select>\n<br>\n<span>Selected: {{ selected }}</span>\n```\n\n​\t\t首先，select多选框的属性 multiple，其次就是使用的数组了。\n\n​\t\t对于不是使用数组的，将不会初始化成功，但是在后续的赋值还是会转化为数组。\n\n​\t\t当然，对于 option 也可以使用v-for进行动态渲染。\n\n```\n<option v-for=\"item in options\">{{ item }}</option>\n```\n\n\n\n## 值绑定\n\n​\t\t对于单选按钮，复选框及选择框的选项，`v-model` 绑定的值通常是静态字符串 (对于复选框也可以是布尔值)：\n\n​\t\t但是有时我们可能想把值绑定到 Vue 实例的一个动态 property 上，这时可以用 `v-bind` 实现，并且这个 property 的值可以不是字符串。\n\n```\n<!-- 当选中时，`picked` 为字符串 \"a\" -->\n<input type=\"radio\" v-model=\"picked\" value=\"a\">\n```\n\n```\n<!-- 当选中时，`picked` 为a 的值 -->\n<input type=\"radio\" v-model=\"picked\" :value=\"a\">\n```\n\n\n\n### 复选框\n\n```\n<input\n  type=\"checkbox\"\n  v-model=\"toggle\"\n  true-value=\"yes\"\n  false-value=\"no\"\n>\n\n// 当选中时\nvm.toggle === 'yes'\n// 当没有选中时\nvm.toggle === 'no'\n```\n\n​\t\t针对多个复选框。其值还是为value值，如果没有value，其值就是null\n\n> ​\t\t这里的 `true-value` 和 `false-value` attribute 并不会影响输入控件的 `value` attribute，因为浏览器在提交表单时并不会包含未被选中的复选框。如果要确保表单中这两个值中的一个能够被提交，(即“yes”或“no”)，请换用单选按钮。\n\n​\t\t所以这个 true/false value 是单选时比较有用。\n\n\n\n### 单选按钮\n\n```\n<input type=\"radio\" v-model=\"pick\" v-bind:value=\"a\">\n\n// 当选中时\nvm.pick === vm.a\n```\n\n​\t\n\n### 选择框的选项\n\n```\n<select v-model=\"selected\">\n    <!-- 内联对象字面量 -->\n  <option v-bind:value=\"{ number: 123 }\">123</option>\n</select>\n\n// 当选中时\ntypeof vm.selected // => 'object'\nvm.selected.number // => 123\n```\n\n​\t\t通过这个我们可以看出，这个是可以使用对象的，同理，我们对于其他的选项框也可以使用对象的形式。\n\n\n\n## 修饰符\n\n### .lazy\n\n​\t\t在默认情况下，`v-model` 在每次 `input` 事件触发后将输入框的值与数据进行同步 (除了[上述](https://cn.vuejs.org/v2/guide/forms.html#vmodel-ime-tip)输入法组合文字时)。你可以添加 `lazy` 修饰符，从而转为在 `change` 事件_之后_进行同步\n\n```\n<!-- 在“change”时而非“input”时更新 -->\n<input v-model.lazy=\"msg\">\n```\n\n​\t\t在输入之后使用回车，便是change事件。\n\n\n\n### .number\n\n​\t\t如果想自动将用户的输入值转为数值类型，可以给 `v-model` 添加 `number` 修饰符\n\n```\n<input v-model.number=\"age\" type=\"number\">\n```\n\n​\t\t无法输入字符串。\n\n​\t\t这通常很有用，因为即使在 `type=\"number\"` 时，HTML 输入元素的值也总会返回字符串。如果这个值无法被 `parseFloat()` 解析，则会返回原始的值。\n\n​\t\t如何出现无法解析的情况，因为可以输入 e，+，-等，所以还是可以无法解析，问题在于无法解析输出的类型是字符串，但是貌似内容为''，\n\n\n\n### .trim\n\n​\t\t如果要自动过滤用户输入的首尾空白字符，可以给 `v-model` 添加 `trim` 修饰符：\n\n```\n<input v-model.trim=\"msg\">\n```\n\n​\t\t没啥说的。就是字符串的 trim 方法。这个方法的使用是返回一个新的。\n\n\n\n## 在组件上使用 v-model （2.2.0+ 新增）\n\n​\t\tHTML 原生的输入元素类型并不总能满足需求。幸好，Vue 的组件系统允许你创建具有完全自定义行为且可复用的输入组件。这些输入组件甚至可以和 `v-model` 一起使用！\n\n​\t\t要了解更多，请参阅组件指南中的[自定义输入组件](https://cn.vuejs.org/v2/guide/components-custom-events.html#自定义组件的-v-model)。\n\n​\t\t讲真，没有看懂。\n\n​\t\t我们通过跳转，看到了自定义组件的 v-model 我只能大概知道\n\n​\t\t一个组件上的 `v-model` 默认会利用名为 `value` 的 prop 和名为 `input` 的事件，但是像单选框、复选框等类型的输入控件可能会将 `value` attribute 用于[不同的目的](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/checkbox#Value)。`model` 选项可以用来避免这样的冲突\n\n```\nVue.component('base-checkbox', {\n  model: {\n    prop: 'checked',\n    event: 'change'\n  },\n  props: {\n    checked: Boolean\n  },\n  template: `\n    <input\n      type=\"checkbox\"\n      v-bind:checked=\"checked\"\n      v-on:change=\"$emit('change', $event.target.checked)\"\n    >\n  `\n})\n\n使用v-model时\n<base-checkbox v-model=\"lovingVue\"></base-checkbox>\n```\n\n​\t\t这里因为使用了v-model进行传值，所以使用了model: {}，设置了prop的名字，然后在props进行使用，此时传递的值就和父组件的 lovingVue 进行了绑定。然后通过事件$emit， change进行的提交。\n\n​\t\t这里的 `lovingVue` 的值将会传入这个名为 `checked` 的 prop。同时当 `<base-checkbox>` 触发一个 `change` 事件并附带一个新的值的时候，这个 `lovingVue` 的 property 将会被更新。\n\n> ​\t\t注意你仍然需要在组件的 `props` 选项里声明 `checked` 这个 prop。\n\n\n\n# 组件基础\n\n```\nhttps://cn.vuejs.org/v2/guide/components.html\n```\n\n\n\n## 基本示例\n\n​\t\t这里有一个 Vue 组件的示例\n\n```\n// 定义一个名为 button-counter 的新组件\nVue.component('button-counter', {\n  data: function () {\n    return {\n      count: 0\n    }\n  },\n  template: '<button v-on:click=\"count++\">You clicked me {{ count }} times.</button>'\n})\n```\n\n​\t\t组件是可复用的 Vue 实例，且带有一个名字：在这个例子中是 `<button-counter>`。我们可以在一个通过 `new Vue` 创建的 Vue 根实例中，把这个组件作为自定义元素来使用\n\n```\n<div id=\"components-demo\">\n  <button-counter></button-counter>\n</div>\n```\n\n​\t\t当然注意上面这个组件的定义顺序要在你的Vue实例之前。因为编译问题，如果在之后的话就不会被编译了。\n\n```\nVue.componnet('button', { });\n\nconst vm = new Vue();\n```\n\n​\t\t因为组件是可复用的 Vue 实例，所以它们与 `new Vue` 接收相同的选项，例如 `data`、`computed`、`watch`、`methods` 以及生命周期钩子等。仅有的例外是像 `el` 这样根实例特有的选项。\n\n\n\n## 组件的复用\n\n​\t\t组件在被创建之后，可以被多次使用。\n\n### data必须是一个函数\n\n​\t\t当我们定义这个 `<button-counter>` 组件时，你可能会发现它的 `data` 并不是像这样直接提供一个对象\n\n```\nVue.component('button', {\n\tdata: {\n\t\treturn {\n\t\t\t\n\t\t};\n\t},\n})\n\nconst vm = new Vue({\n\tdata: {\n\t\t\n\t},\n})\n```\n\n​\t\t当然如果你不这样写也不会报错，但是这样会有一个问题，那就是所以这个组件都会使用同一个对象的数据，一个发生了改变，所有都会发生改变。所以就是用了函数，这个会每次都调用了一次函数，形成一个新的作用域位置。\n\n​\t\t这个就是使用了闭包的方法，当然你可能在想，是不是可以利用这个闭包，然后既能让数据不同步，又能让部分数据进行同步。当然，我没有解决掉。因为首先我们可以知道闭包的使用方式。\n\n```\nfunction Fn() {\n\treturn fn() {}\n}\n\nlet fn = Fn();\n这个时候使用fn，就可以使用闭包。但是data是重复的创建Fn(). 所以每次都还是会创建新东西。\n```\n\n​\t\t所以我现在不知道如何使用闭包的方式，当然，我们可以将方法写在全局，然后再组件里进行闭包。还是可以的。\n\n\n\n## 组件的组织\n\n​\t\t为了能在模板中使用，这些组件必须先注册以便 Vue 能够识别。这里有两种组件的注册类型：**全局注册**和**局部注册**。至此，我们的组件都只是通过 `Vue.component` 全局注册的\n\n​\t\t全局注册的组件可以用在其被注册之后的任何 (通过 `new Vue`) 新创建的 Vue 根实例，也包括其组件树中的所有子组件的模板中。\n\n​\t\t局部注册的方式就是先将内容对象赋值给了一个变量，然后通过使用变量来进行注册。\n\n```\nlet ComponentA = {  }\n\nnew Vue({\n\tel: '#xx',\n\tcomponents: {\n\t\t'component-a': ComponentA,\n\t},\n})\n```\n\n\n\n## 通过Prop向子组件传递数据\n\n​\t\t简单来说，就是写在props属性里面的会添加到属性，父组件在调用子组件时，可以通过在标签里添加对应的属性，属性里面的值将会传递给子组件。\n\n```\nVue.component('blog-post', {\n  props: ['title'],\n  template: '<h3>{{ title }}</h3>'\n})\n\n<blog-post title=\"My journey with Vue\"></blog-post>\n```\n\n​\t\t当然对于这个props，也有另一个写法，props使用对象，对象里面又是一个对象，default代表了默认值，type代表了类型，当然也有其他属性。但是我们后面在详细了解。\n\n```\nprops: {\n  'title': {\n    default: '123',\n    type: String\n  }\n},\n```\n\n```\n<blog-post title=\"My journey with Vue\"></blog-post>\n<blog-post></blog-post>\n```\n\n​\t\t当然这个自定的属性attribute，也是可以使用v-bind: 来动态绑定。当然我们也可以使用v-model，但是这里也有其他的问题，具体后续在了解。\n\n​\t\t传递的属性也能是对象，对于一些应该属于统一对象的，可以将其化为一个对象进行传递。\n\n\n\n## 单个根元素\n\n​\t\t简单来说，就是在创建时，只能以一个根元素。如果根元素不止一个就会报错\n\n```\n<div></div>\n<div></div>\n```\n\n​\t\t上面这个写法就会报错，但是下面这个写法。将所有的元素都放在了一个根元素的下级。\n\n```\n<div>\n  <div></div>\n  <div></div>\n</div>\n```\n\n​\t\t这里的原因。我不清楚，只能说在Vue里面如果使用了下面这个写法时，可以知道，只会将第一个进行Vue的渲染，第二个将不会进行渲染操作。通过查阅资料，有的说是diff算法的原因，也有说是为了避免出现多个根元素，找不到以谁为主体。\n\n​\t\t这个现在主要作为一个了解。\n\n```\n<div id=\"app\">1</div>\n<div id=\"app\">2</div>\n```\n\n\n\n## 监听子组件事件\n\n​\t\t父组件可以给子组件传值了，但是子组件如何在一定的条件下通知父组件呢。\n\n​\t\t使用方式：\n\n​\t\t1.首先父元素在传递的时候，传递一个可以被子元素监听的方法\n\n```\n<blog-post @test=\"enlarge\" post=\"{title: 1}\"></blog-post>\n```\n\n​\t\t2.然后子元素就可以通过使用 $emit 进行调用这个方法。注意$emit('xxxx')，xxx就是那个元素上的属性attribute，\n\n```\n<button v-on:click=\"$emit('test')\">\n```\n\n​\t\t3.传递值的方式，这个方法的第一个是方法名，后面的就是要传递的值。\n\n```\n$emit('test', 1, 2);\n```\n\n**注意：**\n\n* 父元素进行传递时，直接写上方法名即可 `@test=\"enlarge\"` \n\n* 因为html是不分大小写的，所以进行传递的时候，建议不要带有大写，对于$emit('xxx')，存在大写，则会监听失败。\n\n* 如果是 `@test=\"enlarge()\"` 那么子组件传递参数则无效，`$emit('test', 1, 2);` 子组件这个写法虽然传递了参数，但是并不会传递值，因为父组件在传递的时候是直接传递了方法的调用的结果。\n\n  * ```\n    @test=\"enlarge()\n    $emit('test', 1, 2);\n    \n    结果：空\n    ```\n\n*  `@test=\"enlarge(1, 2)` 同理，这样在子组件调用的时候传递过来的值就直接是是1和2。并不会因为 `$emit('test', 321, 123);` 改成321，123。\n\n  * ```\n    @test=\"enlarge(1, 2)\n    $emit('test', 11111, 22222);\n    \n    结果：1, 2\n    ```\n\n*  `@test=\"enlarge($event, 12, 321, 312)\"` 这样写有是一个特点，你会发现，这个$event 代表的不是点击的事件了，而是子组件传递的值。这个event就类似于了一个子组件的待定参数。\n\n  * ```\n    @test=\"enlarge($event, 1, 2)\n    $emit('test', 11111, 22222);\n    \n    结果：11111, 1, 2\n    ```\n\n\n\n### 使用事件抛出一个值\n\n​\t\t可以使用 `$emit` 的第二个参数来提供这个值\n\n```\n<button v-on:click=\"$emit('enlarge-text', 0.1)\">\n```\n\n​\t\t然后当在父级组件监听这个事件的时候，我们可以通过 `$event` 访问到被抛出的这个值\n\n```\n@enlarge-text=\"postFontSize += $event\"\n```\n\n​\t\t如果这个是一个方法，那么这个值会作为第一个参数传入这个方法\n\n```\nonEnlargeText: function (enlargeAmount) {\n\tthis.postFontSize += enlargeAmount\n}\n```\n\n\n\n### 在组件上使用 v-model\n\n​\t\t首先我们可以这样理解\n\n```\n<input v-model=\"searchText\">\n\n等价于\n\n<input\n  v-bind:value=\"searchText\"\n  v-on:input=\"searchText = $event.target.value\"\n>\n```\n\n​\t\tv-model的效果就是值的改变会影响到view的改变，输入的变化会影响值的改变。而v-bind，值的改变会影响到视图的改变，但是并没有双向的绑定。\n\n\n\n​\t\t所以用在组件上时。\n\n```\n<custom-input\n  v-bind:value=\"searchText\"\n  v-on:input=\"searchText = $event\"\n></custom-input>\n```\n\n​\t\t所以此时我们需要绑定一个input方法将其传递出来。\n\n​\t\t为了让它正常工作，这个组件内的 `<input>` 必须：\n\n- 将其 `value` attribute 绑定到一个名叫 `value` 的 prop 上\n- 在其 `input` 事件被触发时，将新的值通过自定义的 `input` 事件抛出\n\n```\nVue.component('custom-input', {\n  props: ['value'],\n  template: `\n    <input\n      v-bind:value=\"value\"\n      v-on:input=\"$emit('input', $event.target.value)\"\n    >`\n})\n```\n\n​\t\t所以此时我们就能理解了，上面的那个组件使用v-model时的传递方式了。\n\n​\t\t同时我么可以看一下那个[自定义事件的 v-model](https://cn.vuejs.org/v2/guide/components-custom-events.html)\n\n```\nVue.component('base-checkbox', {\n  model: {\n    prop: 'checked',\n    event: 'change'\n  },\n  props: {\n    checked: Boolean\n  },\n  template: `\n    <input\n      type=\"checkbox\"\n      v-bind:checked=\"checked\"\n      v-on:change=\"$emit('change', $event.target.checked)\"\n    >`\n})\n\n使用\n<base-checkbox v-model=\"lovingVue\"></base-checkbox>\n```\n\n​\t\t这里的model里面有prop和event，其中checked代表了传递的值。这个名字可以自己定义。 这里的event，值为change，则代表了是change事件，如果命名为input则为input的事件，当然，其实这里也是可以自己命名的。主要是为了方便认知。\n\n​\t\t这个和上一个组件的通信的区别\n\n* 普通的是将值返回给上级，然后上级进行方法的操作。\n\n  * ```\n    <c :name=\"name\" @inputf=\"fn\">12</c>\n    \n    子组件的内容：\n    <input type=\"text\" :value=\"name\" @input=\"this.$emit('inputf', event.target.value);\">\n    \n    这里再对fn写上一个方法，此时对于一个input输入就会出现对应的方法被执行。\n    ```\n\n* 对于v-model，则是发现直接将其传递给上级，上级不需要再指定一个方法。\n\n  * ```\n    <c v-model=\"searchText\"></c>\n    \n    子组件的内容\n    <input type=\"text\" :value=\"myInput\" @input=\"inputE($event)\">\n    ```\n\n  * 首先在使用组件的时候，使用v-mdoel方法。子组件，此时可以使用 model对象进行指定。当然，如果此时不指定怎么办\n\n  * 对于有value的情况：\n\n    * 首先，对于父组件使用v-model传递给了子组件的值，子组件如果使用了value的变量名，则会以此值进行接收。就算是checkbox，也是使用的value进行接收。不管子组件的内容(目前我的测试来说。)\n\n    * ```\n      props: {\n        value: {\n        \ttype: Boolean,\n        \tdefalut: false,\n        },\n      },\n      \n      记住props的写法，开始我写成了data式的写法，把默认值直接写在了后面，如果直接写后面是写变量的类型\n      props: {\n      \tvalue: String,\n      }\n      ```\n\n  * 对于没有value的情况：\n\n    * 没有value，还没有添加一个model对象进行指定，那么就不会传入成功。\n\n    * 进行了model的指定，那么便会使用这个变量进行赋值。\n\n      * ```\n        model: {\n          prop: 'myInput',\n          event: 'inp'\n        },\n        props: ['myInput'],\n        ```\n\n  * 到此，我们已经解决了如何传值，下一步就是更新数据。\n\n    * 因为 v-model的特点就是会将值进行了绑定，所以我们只需要通知同步就行了\n\n    * ```\n      <input type=\"text\" :value=\"myInput\" @input=\"inputE($event)\">\n      ```\n\n    * input事件，绑定了inputE方法，然后inputE里面通过$emit进行传递。事件名称就是model里面的事件名称，inp, 如果没有进行重命名，那么就是 input事件。父组件不需要做什么，因为v-model自动对事件和参数进行了赋值。当然，也是可以赋值常数的。\n\n  * 同时我们通过这个案例也知道了，如果你对一个input输入框加了v-model，也加了input的监听，在input的监听修改了v-model的值，那么会以input的为主。\n\n\n\n## 通过插槽分发内容\n\n​\t\t简单来说，就是可以在标签内部使用标签，然后标签可以传递给子元素显示。父元素的使用方式就是下面这样。子元素只需要定义一个 slot，然后slot的位置就会显示为你定义的。\n\n```\n<alert-box>\n  Something bad happened.\n</alert-box>\n```\n\n```\nVue.component('alert-box', {\n  template: `\n    <div class=\"demo-alert-box\">\n      <strong>Error!</strong>\n      <slot></slot> 这里就会被渲染为其他的。\n    </div>`\n})\n```\n\n​\t\t这里在简单的说几个地方。\n\n​\t\t1.如果使用了多个slot，默认每个slot都会全部都会显示，但是又不是你想的那种显示。我不知道怎么描述。直接看例子就懂了：\n\n```\n<p>123</p>\n<slot></slot>\n<slot></slot>\n<p>321</p>\n\n\n<tt>\n  <div>123</div>\n  <div>321</div>\n</tt>\n```\n\n​\t\t下面这个我定义了两个slot，然后组件名为tt，tt里面有两个div标签值为123和321。你可能会认为一个 slot为123，一个slot为321.但是其实不是，因为你没有给定name，所以这两个div会被当成一个传递给插槽。然后两个插槽都会被赋值。所以值为\n\n<img src=\"Vue2-教程-基础使用/image-20211105095952701.png\" alt=\"image-20211105095952701\" style=\"zoom:50%;\" />\n\n\n\n​\t\t那么要如何实现上面预想的效果呢，使用name。一个不带 `name` 的 `<slot>` 出口会带有隐含的名字“default”。\n\n​\t\t然后就是父组件如何使用了，这里有三个写法\n\n```\n<div slot=\"aa\">123</div>\n\n<template v-slot:aa>\n\t<div>123</div>\n</template>\n\n<template #aa>\n\t<div>123</div>\n</template>\n```\n\n​\t\t上面这三个写法，\n\n* 第一个是一个旧的写法，不建议，因为建议是使用一个template进行包裹，template作为一个html5的新特性。\n\n* 第二个是使用的v-slot进行绑定。但是需要将其放在template上，才有效果\n\n* 第三个就是第二个的一个语法糖写法。\n\n* 然后就是如何使用变量，首先可以使用 v-bind 进行绑定。其次也可以使用 [] 进行表示。\n\n  * ```\n    :slot=\"name\" :v-slot:name :#name\n    v-slot:[name] #[name]\n    ```\n\n\n\n​\t\t然后就是插槽是会将值进行覆盖的。所以如果你在slot上写的一些样式和方法不会显示，对应的方式就是（**v-if，v-for** 有效果，因为这些是对DOM树进行了变化，所以会在DOM树的添加，而不是对一个属性的覆盖。但是对于一些class和v-show就没用了。）\n\n* 第一种，父元素写方法和样式，但是这样一个子组件就对父组件不透明了\n\n* 第二种，在外面套上一层标签。向下面这样就行了。\n\n  * ```\n    <div v-show=\"false\">\n    \t<slot></slot>\n    </div>\n    ```\n\n\n\n​\t\t其他的部分，详见Vue的 [插槽](https://cn.vuejs.org/v2/guide/components-slots.html) 部分。\n\n\n\n## 动态组件\n\n​\t\t简单来说就是不同组件会进行动态切换，所以可以使用\n\n```\n<component :is=\"name\"></component>\n<button @click=\"change\">change</button>\n```\n\n​\t\t这里 component 是一个标签，is使用v-bind绑定了name，然后通过一个点击事件来修改了name的值，所以component，is就会被指定修改成其他的组件名。\n\n​\t\t这个is属性应该是html里面的那个is属性，但是具体的使用方式我现在看不懂，可以取MDN里面进行了解，这里我们就当作is会指定一个组件名，然后这个component标签就会被替换成组件名。\n\n\n\n​\t\t在上述示例中，name可以包括：\n\n- 已注册组件的名字，或\n- 一个组件的选项对象\n\n\n\n注意：\n\n​\t\t这个is属性可以用于常规的html元素上。\n\n​\t\t但是对于attribute将会作为DOM attribute进行绑定，对于像 `value` 这样的 property，若想让其如预期般工作，你需要使用 [`.prop` 修饰器](https://cn.vuejs.org/v2/api/#v-bind)。\n\n​\t\t这里就扯出了 attribute 和 property 的一个区别，我这里就贴一个 [StackOverflow](https://stackoverflow.com/questions/6003819/properties-and-attributes-in-html#answer-6004028) 和 一个对应 StackOverflow 的 [CSDN ](https://blog.csdn.net/rudy_zhou/article/details/104058741) 的一个中文的讲解 \n\n​\t\t大概就是说，attribute属性是一个HTML的上的属性，而property是一个DOM对象上的属性。有的属性开始是继承了attribute，但是后续会被修改，此时可以从property看出，但是不会从attribute看出。\n\n\n\n## 解析 DOM 模板时的注意事项\n\n​\t\t简单来说，就是有的HTML 元素限制了其内部的元素是哪些，对于不属于的，会被提升到外部，触发其他问题。\n\n```\n<ul>、<ol>、<table> 和 <select>\n```\n\n​\t\t有的元素是，只能存在于特定的元素内部\n\n```\n<li>、<tr> 和 <option>\n```\n\n​\t\t案例\n\n```\n<table>\n  <blog-post-row></blog-post-row>\n</table>\n```\n\n​\t\t对于上面的情况，blog-post-row 会被提升到外部，所以会出现页面布局的问题。\n\n​\t\t解决方式，使用is attribute。\n\n```\n<table>\n  <tr is=\"blog-post-row\"></tr>\n</table>\n```\n\n\n\n需要注意的是**如果我们从以下来源使用模板的话，这条限制是*不存在* 的**：\n\n- 字符串 (例如：`template: '...'`) \n\n  - ```\n    Vue.component('tt', {\n      template: `\n        <table>\n        \t<p>1</p>\n        </table>\n      `,\n    });\n    ```\n\n  - 此时 p 标签存在于table 内部。\n\n- [单文件组件 (`.vue`)](https://cn.vuejs.org/v2/guide/single-file-components.html) \n\n- [`<script type=\"text/x-template\">`](https://cn.vuejs.org/v2/guide/components-edge-cases.html#X-Template) \n\n  ​\t当然这些，我也没有测试过，所以不清楚。\n\n\n\n至此，简单的一个基础就了解完了，详细的还是看看Vue官网的 文档和API吧\n\n```\nhttps://cn.vuejs.org/v2/api/\n```\n\n```\nhttps://cn.vuejs.org/v2/guide/\n```\n\n","slug":"Vue/Vue2教程/Vue2-教程-基础使用","published":1,"updated":"2021-12-09T01:56:49.404Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckznhkk8u0081ikub4mwz7rns","content":"<h1 id=\"Vue的基本使用\"><a href=\"#Vue的基本使用\" class=\"headerlink\" title=\"Vue的基本使用\"></a>Vue的基本使用</h1><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">简单入门教程</span><br><span class=\"line\">\thttps://cn.vuejs.org/v2/guide/</span><br><span class=\"line\">API</span><br><span class=\"line\">\thttps://cn.vuejs.org/v2/api/</span><br><span class=\"line\"></span><br><span class=\"line\">在这里我就先进行一个简单的教程的学习。不过于深入了解。</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h1><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://cn.vuejs.org/v2/guide/index.html</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"引入\"><a href=\"#引入\" class=\"headerlink\" title=\"引入\"></a>引入</h2><p>​        这里我们使用 script 进行引入</p>\n<p>​        还可以使用 <strong>npm</strong> 进行下载引入 和 使用 <strong>VueCLI</strong> 脚手架，使用 npm 和 脚手架 的好处是，我们可以方便进行包管理。进行较大型应用时可以进行使用。但是我们这里的主要目的时了解 Vue 的基本使用和Vue 的一些规范，所以就直接使用 <strong>script</strong> 引入。</p>\n<p>​        对于 <strong>script</strong> 引入，有两种：</p>\n<ul>\n<li><p>第一种是直接进行引入。这种是创建了一个全局 Vue 的的实例，可以在后面进行使用，但是不能在前面进行使用。</p>\n<ul>\n<li>```<script src=\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\"></script>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">* 第二种是使用了 模块化 。 在引用以后，可以在改代码的后面直接进行使用。但是不能在 另外一个 script 标签内部使用，具体的原因是 使用了 module ，这个属于异步加载了。对于script 的异步我们后续在了解。</span><br><span class=\"line\"></span><br><span class=\"line\">  * ```</span><br><span class=\"line\">    &lt;script type=&quot;module&quot;&gt;</span><br><span class=\"line\">      import Vue from &#x27;https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.esm.browser.js&#x27;</span><br><span class=\"line\">      </span><br><span class=\"line\">      Vue.log;</span><br><span class=\"line\">    &lt;/script&gt;</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ul>\n<p>这里我们使用第一种引入。</p>\n<h2 id=\"声明式渲染\"><a href=\"#声明式渲染\" class=\"headerlink\" title=\"声明式渲染\"></a>声明式渲染</h2><h3 id=\"Mustache-语法-valueName\"><a href=\"#Mustache-语法-valueName\" class=\"headerlink\" title=\"Mustache 语法 { { valueName }}\"></a>Mustache 语法 { { valueName }}</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=&quot;app&quot;&gt;</span><br><span class=\"line\">  &#123; &#123; message &#125;&#125;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&gt;</span><br><span class=\"line\">&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">  const app = new Vue(&#123;</span><br><span class=\"line\">    el: &#x27;#app&#x27;,</span><br><span class=\"line\">    data: &#123;</span><br><span class=\"line\">      message: &#x27;test&#x27;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<p>​        这里这个 message 是响应式的。如果我们在浏览器控制台修改了 message 的值，页面也会对应发生变化。里面的原因是使用了 <strong>OBject.defineProperty()</strong> 对于 Vue 的响应式。我们后续在了解 Vue源码的时候在进行讨论。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app.message = &#x27;a&#x27;;</span><br><span class=\"line\"></span><br><span class=\"line\">页面会同时进行修改。</span><br></pre></td></tr></table></figure>\n\n<p>​        这里我们进行一个分析。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new Vue，这是一个 new 方法，会返回一个实例，里面的参数是一个对象，对象里面又是很多属性和对象的组成。</span><br><span class=\"line\"></span><br><span class=\"line\">这里出现了。el 和 data。</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">其中el，是你要绑定的元素， 可以是 CSS 选择器，也可以是一个 HTMLElement 实例。</span><br><span class=\"line\">\t参考：\thttps://cn.vuejs.org/v2/api/#el</span><br><span class=\"line\">CSS选择器： #app, .app, div.app ...</span><br><span class=\"line\">HTMLElement实例： </span><br><span class=\"line\">\tconst span = document.querySelector(&#x27;span.app&#x27;);</span><br><span class=\"line\">\tel: span.</span><br><span class=\"line\">其次，对于有多个满足的情况，只会对第一个进行编译。</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">data：</span><br><span class=\"line\">\t\t我们可以看出，这个是一个data的对象。然后是对对象里面的数据进行了一个响应式的处理。然后我们也可以在后续在开发时可以发现，data是一个 返回的对象。这里是因为对象是使用的地址赋值，如果不通过return &#123;&#125;, 会让共同使用的组件会使用相同的数据。但是如果是return &#123;&#125;。那么在每次返回时都会返回一个新的对象出来。而不会共同使用一个对象。 </span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"使用指令绑定-attribute-v-bind\"><a href=\"#使用指令绑定-attribute-v-bind\" class=\"headerlink\" title=\"使用指令绑定 attribute (v-bind)\"></a>使用指令绑定 attribute (v-bind)</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;span class=&quot;app&quot; v-bind:title=&quot;message&quot;&gt;</span><br><span class=\"line\">  &#123; &#123; message &#125;&#125;</span><br><span class=\"line\">&lt;/span&gt;</span><br></pre></td></tr></table></figure>\n\n<p>​        这里 v-bind 是 Vue 提供的 <code>attribute </code>。它可以绑定元素原有的 <code>attribute</code> 。这个指令的效果是： 将这个元素节点的 <code>title</code> attribute 和 Vue 实例的 <code>message</code> property 保持一致。</p>\n<p>​        可以通过使用 app.message = ‘new’; 可以发现，内容也随之更新。</p>\n<h2 id=\"条件与循环\"><a href=\"#条件与循环\" class=\"headerlink\" title=\"条件与循环\"></a>条件与循环</h2><h3 id=\"v-if\"><a href=\"#v-if\" class=\"headerlink\" title=\"v-if\"></a>v-if</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=&quot;app-3&quot;&gt;</span><br><span class=\"line\">  &lt;p v-if=&quot;seen&quot;&gt;现在你看到我了&lt;/p&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">var app3 = new Vue(&#123;</span><br><span class=\"line\">  el: &#x27;#app-3&#x27;,</span><br><span class=\"line\">  data: &#123;</span><br><span class=\"line\">    seen: true</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">这里设置的 seen ， 设置为 true ，就会显示。设置为 false ，就不会显示。</span><br></pre></td></tr></table></figure>\n\n<p>​        可以通过设置 v-if 来进行这个标签的显示和隐藏。此外，Vue 也提供一个强大的过渡效果系统，可以在 Vue 插入/更新/移除元素时自动应用<a href=\"https://cn.vuejs.org/v2/guide/transitions.html\">过渡效果</a>。</p>\n<p>​        这个过渡效果，我们后续在讲。</p>\n<p>​        <code>v-if</code> 可以控制一个标签的显示和隐藏，还有 <code>v-show</code> 也有一样的效果。</p>\n<p><strong>区别：</strong></p>\n<ul>\n<li>```<br><a href=\"https://cn.vuejs.org/v2/guide/conditional.html#v-if-vs-v-show\">https://cn.vuejs.org/v2/guide/conditional.html#v-if-vs-v-show</a><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">* `v-if` 也是**惰性的**：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。</span><br><span class=\"line\">* 相比之下，`v-show` 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。</span><br><span class=\"line\">* 如果需要非常频繁地切换，则使用 `v-show` 较好；如果在运行时条件很少改变，则使用 `v-if` 较好。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">### v-for</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<a href=\"https://cn.vuejs.org/v2/api/#v-for\">https://cn.vuejs.org/v2/api/#v-for</a><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">​\t\t`v-for` 指令可以绑定数组的数据来渲染一个项目列表：</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<div id=\"app-4\">\n<ol>\n  <li v-for=\"todo in todos\">\n    { { todo.text }}\n  </li>\n</ol>\n</div></li>\n</ul>\n<p>var app4 = new Vue({<br>  el: ‘#app-4’,<br>  data: {<br>    todos: [<br>      { text: ‘学习 JavaScript’ },<br>      { text: ‘学习 Vue’ },<br>      { text: ‘整个牛项目’ }<br>    ]<br>  }<br>})</p>\n<p>循环。 v-for=”item in items”，  会循环items，赋值给 item。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">**此外：**</span><br><span class=\"line\"></span><br><span class=\"line\">​\t在使用 **v-if** 搭配 v-for 时，**v-for** 的优先级会高于 **v-if**。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<li v-for=\"todo in todos\" v-if=\"todo.flag\">\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">​\t\t在控制台里，输入 `app4.todos.push(&#123; text: &#x27;新项目&#x27; &#125;)`，你会发现列表最后添加了一个新项目。</span><br><span class=\"line\"></span><br><span class=\"line\">**注意：**</span><br><span class=\"line\"></span><br><span class=\"line\">​\t这里使用了 **push**， 方式添加了新项目，页面发生了改变，但是如果是 app4.todos[4] = xxx， 这样就不会发生页面的改变，这里是因为Vue 响应式的原因，至于原理，我们后续在讲解。想要提前知道的可以了解一下，Object.defineProperty()。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">## 处理用户输入</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t用户和应用的交互，可以使用 **v-on** 指令来添加一个事件的监听器</span><br><span class=\"line\"></span><br><span class=\"line\">这里的 v-on，就代表了 on</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<button v-on:click=\"reverseMessage\">反转消息</button>\n\n<p><button onclick=\"reverseMessage()\">反转消息</button></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>var app5 = new Vue({<br>  el: ‘#app-5’,<br>  data: {<br>    message: ‘Hello Vue.js!’<br>  },<br>  methods: {<br>    reverseMessage: function () {<br>      this.message = this.message.split(‘’).reverse().join(‘’)<br>    }<br>  }<br>})</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">​\t\t这里新添加了一个 **methods** 的对象，里面存放的是方法。如果是使用 **Vue** 的属性 **attribute**， **v-on** ，来进行的绑定方法，那么就需要将方法写在这个methods 里面。不写在 methods 里面的方法是没有效果的。</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t其次，这里面建议不要使用 箭头函数，因为箭头函数 的this指向是和 当前的上下文 相关的，所以在箭头函数里面使用不了data的方法。箭头函数的指向是全局。</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t在这里，我们只需要写上逻辑，不需要操作DOM，这个就是 MVVM 中， Vue 的 VM，我们只需要在 M和V 上进行操作即可。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">## v-model 实现双向绑定</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\tv-bind，可以实现单向的绑定，就是指可以通过修改data数据来进行页面的修改。</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t但是，如果是对于一个 input 的输入框呢？</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t我们可以将 data 数据绑定到输入框作为一个初始值。</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t但是我们可以在对输入框进行输入时，同时修改 data 的数据吗。显然是不行的。所以就有了 v-model</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\tv-model ，它可以进行数据的双向绑定，不但用户的输入会修改 data， data 的变化也会影响视图。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<input v-model=\"message\">\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">​\t\t通过这个我们 可以看出，v-model 没有说使用value，还是什么，但是却有效果，这里是因为 v-model 会根据控件的类型自动选取正确的方法来更新。限制：\tinput， select， textarea， components</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\nhttps://cn.vuejs.org/v2/api/#v-model\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">## 组件化应用构建</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\tVue 的另一个重要的概念就是 **组件化** 。几乎任意应用界面都可以抽象为一个组件树。</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t在 Vue 中注册一个组件</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n// 定义名为 todo-item 的新组件\nVue.component('todo-item', {\n  template: '</li><li>这是个待办项</li>'\n})\n\n<p>var app = new Vue(…)</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">**示例：**</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<div id=\"app-6\">\n  <my-item></my-item>\n</div>\n\n\n<p>  Vue.component(‘my-item’, {<br>    template: ‘<li>这是个待办项</li>‘<br>  });</p>\n<p>  var app6 = new Vue({ el: ‘#app-6’ })</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">**注意点：**</span><br><span class=\"line\"></span><br><span class=\"line\">* 使用的方式是，需要在 new 的实例的 Vue 的内部进行调用，因为在 实例内部，你写的方式才会被 Vue 所编译，不然是不会被 Vue 编译的。</span><br><span class=\"line\"></span><br><span class=\"line\">* 其次，注册的组件需要在你 new 的实例前面，因为你在编译组件的时候要使用自定义的组件。所以，如果不在之前进行解析的话，就解析不了了。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">## 组件传值</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<div id=\"app-6\">\n  <my-item :todo=\"message\"></my-item>\n</div>\n\n\n<p>Vue.component(‘my-item’, {<br>  props: [‘todo’],<br>  template: ‘<li>这是个待办项 { { todo }}</li>‘,<br>});</p>\n<p>var app6 = new Vue({<br>  el: ‘#app-6’,<br>  data: {<br>      message: false<br>  }<br>})</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">​\t\t这里， props 是代表了获取到组件属性传递过来的值，在组件使用时，添加属性，这个属性是和 props 里面的名字相等。这里就是 todo， 其次， **:todo**，是一个语法糖，代表了 **v-bind:todo**，所以就会把 message 的值传递给 todo，然后再传递给 my-item。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"># Vue实例</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p><a href=\"https://cn.vuejs.org/v2/guide/instance.html\">https://cn.vuejs.org/v2/guide/instance.html</a></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">## 创建一个Vue实例</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t每个 Vue 应用都是通过用 `Vue` 函数创建一个新的 **Vue 实例**开始的：</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>var vm = new Vue({<br>  // 选项<br>})</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">​\t\t虽然没有完全遵循 [MVVM 模型](https://zh.wikipedia.org/wiki/MVVM)，但是 Vue 的设计也受到了它的启发。因此在文档中经常会使用 `vm` (ViewModel 的缩写) 这个变量名表示 Vue 实例。</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t至于为什么 Vue 没有完全遵循 MVVM 的原因是：Vue 中有一个属性，ref，这个属性可以拿到 DOM 对象，直接操作视图，所以违背了 MVVM。</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t在创建一个 Vue 实例时，你可以传入一个 [选项对象]([https://cn.vuejs.org/v2/api/#%E9%80%89%E9%A1%B9-%E6%95%B0%E6%8D%AE](https://cn.vuejs.org/v2/api/#选项-数据)) (data，methods...)。通过这些选项对象来创建你想要的行为。</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t一个 Vue 应用由一个通过 `new Vue` 创建的**根 Vue 实例**，以及可选的嵌套的、可复用的组件树组成。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">## 数据与方法</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t当一个 Vue 实例被创建时，它将 `data` 对象中的所有的 property 加入到 Vue 的**响应式系统**中。当这些 property 的值发生改变时，视图将会产生“响应”，即匹配更新为新的值。</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t大致就可以理解为，需要将数据放在了 data 里面，Vue 就会自动创建响应式。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>// 我们的数据对象<br>var data = { a: 1 }</p>\n<p>// 该对象被加入到一个 Vue 实例中<br>var vm = new Vue({<br>  data: data<br>})</p>\n<p>// 获得这个实例上的 property<br>// 返回源数据中对应的字段<br>vm.a == data.a // =&gt; true</p>\n<p>// 设置 property 也会影响到原始数据<br>vm.a = 2<br>data.a // =&gt; 2</p>\n<p>// ……反之亦然<br>data.a = 3<br>vm.a // =&gt; 3</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">​\t\t通过上面我们可以知道，data的数据是直接可以通过 实例的返回来直接获取，数据是直接暴露于实例的顶层。理所当然，methods 的方法也是一样，所以我们会思考，如果方法名和数据名重合会怎么办。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>  var app6 = new Vue({<br>    el: ‘#app-6’,<br>    data: {<br>      message: false<br>    },<br>    methods: {<br>      message() {<br>        console.log(1);<br>      }<br>    },<br>  })</p>\n<p>通过上面的案例可以看出，方法名是和 data 名称重合，所以在 data 已经创建了数据之后，方法创建会抛出异常。方法创建失败。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>  而如果是一个普通的对象，后面的会将前面的覆盖掉。</p>\n<p>  let obj = {<br>    a: 1,<br>    a() {<br>      console.log(2);<br>    }<br>  }<br>  console.log(obj);</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">​\t\t其次</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>使用 vm.b = 1;<br>这种后续添加数据的方式是不会变成响应式的。<br>以及，使用了 Object.freeze() 也会阻止修改现有的 property，也意味着响应系统无法再追踪变化。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">​\t\t除了数据 property，Vue 实例还暴露了一些有用的实例 property 与方法。它们都有前缀 `$`，以便与用户定义的 property 区分开来。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>var data = { a: 1 }<br>var vm = new Vue({<br>  el: ‘#example’,<br>  data: data<br>})</p>\n<p>vm.$data === data // =&gt; true<br>vm.$el === document.getElementById(‘example’) // =&gt; true</p>\n<p>// $watch 是一个实例方法<br>vm.$watch(‘a’, function (newValue, oldValue) {<br>  // 这个回调将在 <code>vm.a</code> 改变后调用<br>})</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">​\t\t你可以在 [API 参考](https://cn.vuejs.org/v2/api/#实例-property)中查阅到完整的实例 property 和方法的列表。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">## 实例生命周期钩子</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t生命周期钩子简单来说就是一个回调函数。在 Vue 在执行到每个过程的时候也会执行这些生命周期的钩子。</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t**举个栗子：**</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>new Vue({<br>  data: {<br>    a: 1<br>  },<br>  created: function () {<br>    // <code>this</code> 指向 vm 实例<br>    console.log(‘a is: ‘ + this.a)<br>  }<br>})<br>// =&gt; “a is: 1”</p>\n<p>在 created 钩子可以用来在一个实例被创建之后执行代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">**注意：**</span><br><span class=\"line\"></span><br><span class=\"line\">&gt; 不要在选项 property 或回调上使用[箭头函数](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions)，比如 `created: () =&gt; console.log(this.a)` 或 `vm.$watch(&#x27;a&#x27;, newValue =&gt; this.myMethod())`。因为箭头函数并没有 `this`，`this` 会作为变量一直向上级词法作用域查找，直至找到为止，经常导致 `Uncaught TypeError: Cannot read property of undefined` 或 `Uncaught TypeError: this.myMethod is not a function` 之类的错误。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">## 生命周期图示</span><br><span class=\"line\"></span><br><span class=\"line\">![lifecycle](Vue2-教程-基础使用/lifecycle.png)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"># 模板语法</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p><a href=\"https://cn.vuejs.org/v2/guide/syntax.html\">https://cn.vuejs.org/v2/guide/syntax.html</a></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">## 插值</span><br><span class=\"line\"></span><br><span class=\"line\">**文本：**</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t数据绑定最常见的形式就是使用“Mustache”语法 (双大括号) 的文本插值：</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p><span>Message: { { msg }}</span></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">这里 msg 会替代为 数据对象的 msg。并且还带有响应式的功能。</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t通过使用 [v-once 指令](https://cn.vuejs.org/v2/api/#v-once)，你也能执行一次性地插值，当数据改变时，插值处的内容不会更新。但请留心这会影响到该节点上的其它数据绑定：</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p><span v-once>这个将不会改变: { { msg }}</span></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">**原始HTML：**</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t双大括号会将数据解释为普通文本，而非 HTML 代码。为了输出真正的 HTML，你需要使用 [`v-html` 指令](https://cn.vuejs.org/v2/api/#v-html)：</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p><span v-html=\"rawHtml\"></span></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">​\t\t会将 span 的内容替换为 rawHtml。并且在里面不会解析 proterty。</span><br><span class=\"line\"></span><br><span class=\"line\">&gt; 你的站点上动态渲染的任意 HTML 可能会非常危险，因为它很容易导致 [XSS 攻击](https://en.wikipedia.org/wiki/Cross-site_scripting)。请只对可信内容使用 HTML 插值，**绝不要**对用户提供的内容使用插值。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">**Attribute：（属性）**</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\tMustache 语法不能作用在 HTML 标签的属性上，所以要使用 v-bind 指令。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<div v-bind:id=\"dynamicId\"></div>\n\n<p>对于同时使用了 v-bind:id 和 id 的。我们可以发现，谁在后面，其结果就是谁。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">​\t\t对于布尔值的 attribute，原生的HTML中，只要存在就意味着值为 true，而 v-bind，工作起来当值为 false，null等，甚至不会渲染。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">**使用 JavaScript 表达式：**</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t对于所有的数据绑定，Vue.js 都提供了完全的 JavaScript 表达式支持。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>{ { number + 1 }}</p>\n<p>{ { ok ? ‘YES’ : ‘NO’ }}</p>\n<p>{ { message.split(‘’).reverse().join(‘’) }}</p>\n<div v-bind:id=\"'list-' + id\"></div>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">## 指令</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t指令 (Directives) 是带有 `v-` 前缀的特殊 attribute。</span><br><span class=\"line\"></span><br><span class=\"line\">**参数：**</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t一些指令能够接收一个“参数”，在指令名称之后以冒号表示。例如，`v-bind` 指令可以用于响应式地更新 HTML attribute：</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<a v-bind:href=\"url\">...</a>\n\n<p>此时这个url是和数据的url是绑定的。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">​\t\t`v-on` 指令，它用于监听 DOM 事件：</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p><a v-on:click=\"doSomething\">…</a><br>同时也有 mouseover 等等。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">**注意：**</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t使用 v-on 指令监听 DOM 事件，原生的 onclick 方法会先于 v-on 进行监听，其次这个 v-on 里面的方法，既可以是 methods 的，也可以是 data 的。但是建议写在 methods 中。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<div id=\"app-6\">\n  <button @click=\"test1\" onclick=\"console.log(1);\">Button</button>\n</div>\n//其中这里这个 @ 代表了 v-on 的语法糖，我们后续会讲。\n\n<pre><code>let obj = &#123;\nmessage: true,\ntest1() &#123;\n  console.log(3);\n&#125;\n</code></pre>\n<p>  }</p>\n<p>  var app6 = new Vue({<br>    el: ‘#app-6’,<br>    data: obj,<br>    methods: {<br>      test() {<br>        console.log(2);<br>      }<br>    }<br>  })</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">**动态参数： 2.6.0新增**</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t可以用方括号括起来的 JavaScript 表达式作为一个指令的参数：</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<!--\n注意，参数表达式的写法存在一些约束，如之后的“对动态参数表达式的约束”章节所述。\n-->\n<p>&lt;a v-bind:[attributeName]=”url”&gt; … </p>\n<p>&lt;a v-on:[eventName]=”doSomething”&gt; … <br>@[]，也可以。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">​\t\t这里的 `attributeName` 会被作为一个 JavaScript 表达式进行动态求值，求得的值将会作为最终的参数来使用。这里的Vue实例中有 data property attributeName，值为 href，则就等价于 v-bind:href=&quot;url&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">​\t**对动态参数的值的约束**</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t动态参数预期会求出一个字符串，异常情况下值为 `null`。这个特殊的 `null` 值可以被显性地用于移除绑定。任何其它非字符串类型的值都将会触发一个警告。</span><br><span class=\"line\"></span><br><span class=\"line\">​\t**对动态参数表达式的约束**</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t动态参数表达式有一些语法约束，因为某些字符，如空格和引号，放在 HTML attribute 名里是无效的。例如：</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<!-- 这会触发一个编译警告 -->\n<p>&lt;a v-bind:[‘foo’ + bar]=”value”&gt; … </p>\n<p>使用引号会无法编译。<br>并且使用了空格也会无法编译。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">​\t\t变通的办法是使用没有空格或引号的表达式，或用计算属性替代这种复杂表达式。</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t在 DOM 中使用模板时 (直接在一个 HTML 文件里撰写模板)，还需要避免使用大写字符来命名键名，因为浏览器会把 attribute 名全部强制转为小写：</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<!--\n在 DOM 中使用模板时这段代码会被转换为 `v-bind:[someattr]`。\n除非在实例中有一个名为“someattr”的 property，否则代码不会工作。\n-->\n<p>&lt;a v-bind:[someAttr]=”value”&gt; … </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">**修饰符：**</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t修饰符 (modifier) 是以半角句号 `.` 指明的特殊后缀，用于指出一个指令应该以特殊方式绑定。例如，`.prevent` 修饰符告诉 `v-on` 指令对于触发的事件调用 `event.preventDefault()`：</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t与之相应的还有 `.laze` `.once` 等等。我们后续进行讲解。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">## 缩写 语法糖</span><br><span class=\"line\"></span><br><span class=\"line\">**v-bind 缩写**：</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<!-- 完整语法 -->\n<p><a v-bind:href=\"url\">…</a></p>\n<!-- 缩写 -->\n<p><a :href=\"url\">…</a></p>\n<!-- 动态参数的缩写 (2.6.0+) -->\n<p>&lt;a :[key]=”url”&gt; … </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">**v-on 缩写：**</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<!-- 完整语法 -->\n<p><a v-on:click=\"doSomething\">…</a></p>\n<!-- 缩写 -->\n<p>&lt;a @click=”doSomething”&gt;…</p>\n<!-- 动态参数的缩写 (2.6.0+) -->\n<p>&lt;a @[event]=”doSomething”&gt; … </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"># 计算属性和侦听器</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p><a href=\"https://cn.vuejs.org/v2/guide/computed.html\">https://cn.vuejs.org/v2/guide/computed.html</a></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">## 计算属性</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t简单来说，就是将逻辑更深层的解耦，比如：</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>{ { message.split(‘’).reverse().join(‘’) }}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">​\t\t在模板中放入太多的逻辑会让模板过重且难以维护。</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t在这个地方，模板不再是简单的声明式逻辑。你必须看一段时间才能意识到，这里是想要显示变量 `message` 的翻转字符串。当你想要在模板中的多处包含此翻转字符串时，就会更加难以处理。</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t所以，对于任何复杂逻辑，你都应当使用**计算属性**。</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t我认为，从一个开发来看，对于一个表达式，如果以后会有多个地方进行相同的逻辑的使用，就应当使用计算属性，方便维护。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">### 基础例子</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<div id=\"app-6\">\n  { { message }}\n  <br>\n  { { reversedMessage }}\n</div>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br></pre></td></tr></table></figure>\n  const vm = new Vue({\n    el: '#app-6',\n    data: {\n      message: 'true',\n    },\n    computed: {\n      // 计算属性的 getter\n      reversedMessage: function () {\n        // `this` 指向 vm 实例\n        return this.message.split('').reverse().join('')\n      }\n    },\n  })\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">​\t\t这里我们声明了一个计算属性 `reversedMessage`。我们提供的函数将用作 property `vm.reversedMessage` 的 getter 函数</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t计算属性默认是的方法是一个getter 方法， 就像是使用了 `Object.defineProperty` 的getter一样进行了操作。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">## 计算属性缓存 VS 方法</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t我们也可以发现，可以在插值表达式中使用方法来获取同样的效果。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>{ { reversedMessage() }}</p>\n\n<p>methods: {<br>  reversedMessage: function () {<br>    return this.message.split(‘’).reverse().join(‘’)<br>  }<br>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">​\t\t首先，对于结果来说是完全相同的。不同的地方在于，**计算属性是基于它们的响应式依赖进行缓存的**。意思就是说，只有相关的响应式依赖发生了改变，他们才会重新求值。没有发生改变，多次使用计算属性会立即返回之前的结果。</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t**举个栗子：**</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<div id=\"app-6\">\n  { { message }}\n  <br>\n  { { reversedMessage }}\n  <br>\n  { { reversedMessage }}\n  <br>\n  { { reversedMessage }}\n</div>\n\n\n<p>  const vm = new Vue({<br>    el: ‘#app-6’,<br>    data: {<br>      message: ‘true’,<br>    },<br>    computed: {<br>      // 计算属性的 getter<br>      reversedMessage: function () {<br>        // <code>this</code> 指向 vm 实例<br>        console.log(1);<br>        return this.message.split(‘’).reverse().join(‘’)<br>      }<br>    },<br>  })</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">​\t\t我这里使用了很多个插值表达式，但是发现控制台的输出，只有一个，这里代表了后续是直接使用的之前的计算结果。</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t其次，在值发生变化之时，也只输出了一次。因此计算属性的缓存效果则比方法有了更好的性能。</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t当然，如果不希望有缓存的存在，可以使用方法来替代。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">## 计算属性 VS 侦听属性</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\tVue 提供了一种更通用的方式来观察和响应 Vue 实例上的数据变动：**侦听属性**。 `watch`  。</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t侦听属性 和 计算属性的不同</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>watch: {<br>  firstName: function (val) {<br>      this.fullName = val + ‘ ‘ + this.lastName<br>  },<br>  lastName: function (val) {<br>      this.fullName = this.firstName + ‘ ‘ + val<br>  }<br>},<br>computed: {<br>  fullName: function () {<br>      return this.firstName + ‘ ‘ + this.lastName<br>  }<br>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">​\t\t从上面可以看出，侦听属性(watch)的特点是，当一个属性发生改变后，调用的方法。</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t其次，需要对其进行初始化，因为在最开始侦听属性不会进行调用。</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t最后，这个侦听属性的执行时机，我们通过一个简单的死循环就可以看出。侦听属性在 DOM 的变化之前。但是处于值的变化之后。起码下面这个情况满足。这个说法。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>watch: {<br>  message: function (val) {<br>  console.log(this.message);<br>  while (true) {<br>      console.log(this.message);<br>  }<br>      this.reversedMessage = val + ‘ — ‘;<br>  }<br>},</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">## 计算属性的setter</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t默认计算属性只有 getter，不过在需要时你也可以提供一个 setter。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>computed: {<br>  fullName: {<br>    // getter<br>    get: function () {<br>      return this.firstName + ‘ ‘ + this.lastName<br>    },<br>    // setter<br>    set: function (newValue) {<br>      var names = newValue.split(‘ ‘)<br>      this.firstName = names[0]<br>      this.lastName = names[names.length - 1]<br>    }<br>  }<br>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">​\t\t在运行 `vm.fullName = &#x27;John Doe&#x27;` 时，setter 会被调用，`vm.firstName` 和 `vm.lastName` 也会相应地被更新。</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t当然，如果你这样写，只能说你是小机灵鬼了，一直调用了 setter 方法导致溢出。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>set: function (newValue) {<br>  console.log(newValue);<br>  this.reversedMessage += ‘1’;<br>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">​\t\t同时我们也可以使用一些简单的方式查看这个 setter 的执行时机。通过下面这个方式，我们发现了，setter 的执行在值的变化之前。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>computed: {<br>  // 计算属性的 getter<br>  reversedMessage: {<br>    get: function () {<br>      // <code>this</code> 指向 vm 实例<br>      console.log(1);<br>      return this.message.split(‘’).reverse().join(‘’)<br>    },<br>    set: function (newValue) {<br>      console.log(this.reversedMessage, newValue);<br>      while (true) {<br>      console.log(this.reversedMessage);<br>    };<br>  }<br>},</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">## 侦听器</span><br><span class=\"line\"></span><br><span class=\"line\">&gt; ​\t\t虽然计算属性在大多数情况下更合适，但有时也需要一个自定义的侦听器。这就是为什么 Vue 通过 `watch` 选项提供了一个更通用的方法，来响应数据的变化。当需要在数据变化时执行异步或开销较大的操作时，这个方式是最有用的。</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t简单来说就是对于一个异步，和一个开销大的操作时，监听器比较合适。</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t异步操作，限制访问频率(防抖)，设置中间状态等。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"># Class 与 Style 绑定</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p><a href=\"https://cn.vuejs.org/v2/guide/class-and-style.html\">https://cn.vuejs.org/v2/guide/class-and-style.html</a></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">​\t\t在将 `v-bind` 用于 `class` 和 `style` 时，Vue.js 做了专门的增强。表达式结果的类型除了字符串之外，还可以是对象或数组。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">## 绑定 HTML Class</span><br><span class=\"line\"></span><br><span class=\"line\">### 对象语法</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>v-bind:class=”{ active: isActive, ‘text-danger’: hasError }”</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">​\t\t这样，就会根据 后面的真值来判断前面这个类是否能存在。并且这里 active 是一个字符串，就算这个 active 和后面的一个 data 数据重名，最终渲染的还是一个字符串。如何能让 active 也变成一个变量类型，</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<div v-bind:class=\"{ [message]: flag }\"></div>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">​\t\t这里使用了动态绑定，所以 message  会从data里面进行查找。找不到则为 undefined 的字符串。并且可以使用 .undefined 来进行操作。对于不是字符串的，会转为字符串处理。</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t并且绑定的数据对象不必内联定义在模板里。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<div v-bind:class=\"classObject\"></div>\n\n<p>data: {<br>  classObject: {<br>    active: true,<br>    ‘text-danger’: false<br>  }<br>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">​\t\t如果写在 data 里面，我还不知道如何将类名动态绑定。并且后面的 true 和 false 都是写死的那种，只能在后续使用方法改变。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<pre><code>computed: &#123;\n  classObject: function () &#123;\n    return &#123;\n      [this.message]: this.flag\n    &#125;\n  &#125;\n&#125;,\n</code></pre>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">​\t\t如果写在计算属性里面，那么类名和真值都可以通过 this 进行获取。类名还是一样通过 [] 获取。不加上就会直接当成一个字符串。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">### 数组语法</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t我们可以把一个数组传给 `v-bind:class`，以应用一个 class 列表</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<div v-bind:class=\"[activeClass, errorClass]\"></div>\n\n<p>data: {<br>  activeClass: ‘active’,<br>  errorClass: ‘text-danger’<br>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">​\t\t对于不是字符串的，不会被显示，需要是字符串类型才会显示。</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t同时，也能写三元表达式</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<div v-bind:class=\"[isActive ? activeClass : '', errorClass]\"></div>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">​\t\t在数组语法中也可以使用对象语法：</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<div v-bind:class=\"[{ active: isActive }, errorClass]\"></div>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">### 在组件上</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t当在一个自定义组件上使用 `class` property 时，这些 class 将被添加到该组件的根元素上面。这个元素上已经存在的 class 不会被覆盖。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\nVue.component('my-component', {\n  template: '<p class=\"foo bar\">Hi</p>'\n})\n\n<p><my-component class=\"baz boo\"></my-component></p>\n<p class=\"foo bar baz boo\">Hi</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">​\t\t在渲染的时候，重复的类名不会被消除。当然，最终的渲染结果还是看CSS的权重级别。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">## 绑定内联样式</span><br><span class=\"line\"></span><br><span class=\"line\">### 对象语法</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t`v-bind:style` 的对象语法十分直观——看着非常像 CSS，但其实是一个 JavaScript 对象。CSS property 名可以用驼峰式 (camelCase) 或短横线分隔 (kebab-case，记得用引号括起来) 来命名</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<div v-bind:style=\"{ color: activeColor, fontSize: fontSize + 'px' }\"></div>\n\n<div v-bind:style=\"{ color: activeColor, 'font-size': fontSize + 'px' }\"></div>\n\n<p>data: {<br>  activeColor: ‘red’,<br>  fontSize: 30<br>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">​\t\t当然也能绑定到一个样式对象。大致还是和上面的要求一样。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">### 数组语法</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t`v-bind:style` 的数组语法可以将多个样式对象应用到同一个元素上：</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<div v-bind:style=\"[activeColor]\">123</div>\n\n<p>activeColor: {<br>    fontSize: ‘30px’<br>},</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">​\t\t当然，也能将其作为一个数组加对象整合为一个返回值，绑定到一个样式对象。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">### 自动添加前缀</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t当 `v-bind:style` 使用需要添加[浏览器引擎前缀](https://developer.mozilla.org/zh-CN/docs/Glossary/Vendor_Prefix)的 CSS property 时，如 `transform`，Vue.js 会自动侦测并添加相应的前缀。</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t其次，对于使用了 v-bind:style 和 style 的，会以 v-bind:style 为主。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">### 多重值 （2.3.0）</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t从 2.3.0 起你可以为 `style` 绑定中的 property 提供一个包含多个值的数组，常用于提供多个带前缀的值</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<div :style=\"{ display: ['-webkit-box', '-ms-flexbox', 'flex'] }\"></div>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">​\t\t这样写只会渲染数组中最后一个被浏览器支持的值。在本例中，如果浏览器支持不带浏览器前缀的 flexbox，那么就只会渲染 `display: flex`。</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t**意思就是说**，对于这样的一个值的数组，我们会从后往前进行赋值，直到遇到浏览器可以支持的值，例如本例来说，先判断，flex，再判断 -ms-flexbox，最后再判断 -webkit-box。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"># 条件渲染</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\nhttps://cn.vuejs.org/v2/guide/conditional.html\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">## v-if</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t`v-if` 指令用于条件性地渲染一块内容。这块内容只会在指令的表达式返回 truthy 值的时候被渲染。</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t也可以用 `v-else` 添加一个“else 块”：</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h1 v-if=\"awesome\">Vue is awesome!</h1>\n<h1 v-else>Oh no 😢</h1>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">### 在 `&lt;template&gt;` 元素上使用 `v-if` 条件渲染分组</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t因为 `v-if` 是一个指令，所以必须将它添加到一个元素上。但是如果想切换多个元素呢？此时可以把一个 `&lt;template&gt;` 元素当做不可见的包裹元素，并在上面使用 `v-if`。最终的渲染结果将不包含 `&lt;template&gt;` 元素。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<template v-if=\"ok\">\n  <h1>Title</h1>\n  <p>Paragraph 1</p>\n  <p>Paragraph 2</p>\n</template>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">​\t\t这里很好理解。首先 v-if 只能添加到一个元素上，所以我们使用了一个元素进行了包裹，然后这个 template 的一个特点就是不会显示，例如</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<template>\n    <div>123</div>\n</template>\n\n<p>最终的显示结果就是</p>\n<div>123</div>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">​\t\t所以这个的好处在于，既能产生包裹，还能不将其 DOM 的结构进行变化。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">### v-else</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t你可以使用 `v-else` 指令来表示 `v-if` 的“else 块”</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t`v-else` 元素必须紧跟在带 `v-if` 或者 `v-else-if` 的元素的后面，否则它将不会被识别。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<div v-if=\"Math.random() > 0.5\">\n  Now you see me\n</div>\n<div v-else>\n  Now you don't\n</div>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">### v-else-if（2.1.0）</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t`v-else-if`，顾名思义，充当 `v-if` 的“else-if 块”，可以连续使用</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t类似于 `v-else`，`v-else-if` 也必须紧跟在带 `v-if` 或者 `v-else-if` 的元素之后。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<div v-if=\"type === 'A'\">A</div>\n<div v-else-if=\"type === 'B'\">B</div>\n<div v-else>Not A/B/C</div>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">### 用 `key` 管理可复用的元素</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\tVue 会尽可能高效地渲染元素，通常会复用已有元素而不是从头开始渲染。这么做除了使 Vue 变得非常快之外，还有其它一些好处。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<template v-if=\"loginType === 'username'\">\n  <label>Username</label>\n  <input placeholder=\"Enter your username\">\n</template>\n<template v-else>\n  <label>Email</label>\n  <input placeholder=\"Enter your email address\">\n</template>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">​\t\t那么在上面的代码中切换 `loginType` 将不会清除用户已经输入的内容。因为两个模板使用了相同的元素，`&lt;input&gt;` 不会被替换掉——仅仅是替换了它的 `placeholder`。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t对于上述的代码，切换了 input  的输入框，但是却对于 value 值没有发生改变。但是如果我们会发现对于类名，style等属性是会发生改变。我们同时也可以知道 value 是input输入框的值，如果是对于 DOM 元素，可以通过 value 进行获取，但是在这里，虽然使用了 value 的属性，但是只要进行输入了，value 的值也不起效果。</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t但是我们同时也发现了，再切换之后，DOM 的指向没有改变。并且也发现了 value 的值在控制台的输出是有变化的。只是对于输入框的内容没有变化。个人猜测，这里input的输入和value 其实中间不是完全直接对应。输入框显示的 value 只是作为了一个最初值。但是内部的value已经发生了变化。</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t当然解决这个方法很简单。</span><br><span class=\"line\"></span><br><span class=\"line\">*  Vue 为你提供了一种方式来表达“这两个元素是完全独立的，不要复用它们”。只需添加一个具有唯一值的 `key` attribute 即可</span><br><span class=\"line\"></span><br><span class=\"line\">  * ```</span><br><span class=\"line\">    &lt;input placeholder=&quot;Enter your username&quot; key=&quot;username-input&quot;&gt;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>这里，只需要 key 值不同即可。并且发现加了 key 值之后， DOM 获取的元素已经不会根据你的按钮发生变化，并且值也不会发生变化了，因为已经不是一个 input 框了，就算是换回来也不是一个了，因为 v-if 是直接修改了 DOM 树。</p>\n</li>\n<li><p>```</p>\n<template v-if=\"loginType === 'username'\">\n  <label>Username</label>\n  <input key=\"a\" class=\"a\" style=\"color: red; font-size: 20px\" placeholder=\"Enter your username\" value=\"1\">\n</template>\n<template v-else>\n  <label>Email</label>\n  <input key=\"b\" class=\"b\" placeholder=\"Enter your email address\" value=\"2\">\n</template>\n\n\n<p>记住，这个需要放在 vue实例之后，应该是因为 template 的原因。<br>const a = document.querySelector(‘input.a’),</p>\n<pre><code>b = document.querySelector(&#39;input.b&#39;);\n</code></pre>\n<p>function c() {<br>  console.log(a);<br>  console.log(a.value);<br>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">* 当然，还可以使用 v-model 将数据进行绑定，那么input输入框的显示也会跟数据有关了。并且 v-model 是进行的复用。因为 DOM 的输出是会发生变化的。并且输入框和data数据是实时绑定了的。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">## v-show</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t另一个用于根据条件展示元素的选项是 `v-show` 指令。用法大致一样</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h1 v-show=\"ok\">Hello!</h1>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">​\t\t同的是带有 `v-show` 的元素始终会被渲染并保留在 DOM 中。`v-show` 只是简单地切换元素的 CSS property `display`。</span><br><span class=\"line\"></span><br><span class=\"line\">&gt; 注意，`v-show` 不支持 `&lt;template&gt;` 元素，也不支持 `v-else`。</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\tv-show 不支持 template 元素，意思就是说，你在 template 元素上使用 v-show，不管是 true 还是 false，template 都会显示在页面上，而如果你使用v-if就会发现，结果是不一样的。</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\tv-show 不支持 v-else，就如字面上来说，不支持的意思。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">## v-if VS v-show</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t`v-if` 是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t`v-if` 也是**惰性的**：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t相比之下，`v-show` 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t一般来说，`v-if` 有更高的切换开销，而 `v-show` 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 `v-show` 较好；如果在运行时条件很少改变，则使用 `v-if` 较好。</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t**简单概括：**</span><br><span class=\"line\"></span><br><span class=\"line\">* **v-if** 是会直接和 DOM 树相关。而 **v-show** 只是简单的使用了 display:none，和渲染树相关。</span><br><span class=\"line\">* 所以 v-if 对于切换会产生高开销，因为每次都会进行 DOM 的修改。而 v-show 会产生初始渲染的高开销，因为不管是否显示都会渲染。</span><br><span class=\"line\">* 所以，对于频繁切换使用 v-show，对于很少改变使用 v-if。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">## v-if 和 v-for 一起使用</span><br><span class=\"line\"></span><br><span class=\"line\">&gt; **不推荐**同时使用 `v-if` 和 `v-for`。请查阅[风格指南](https://cn.vuejs.org/v2/style-guide/#避免-v-if-和-v-for-用在一起-必要)以获取更多信息。</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t当 `v-if` 与 `v-for` 一起使用时，`v-for` 具有比 `v-if` 更高的优先级。请查阅[列表渲染指南](https://cn.vuejs.org/v2/guide/list.html#v-for-with-v-if)以获取详细信息。</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t当它们处于同一节点，`v-for` 的优先级比 `v-if` 更高，这意味着 `v-if` 将分别重复运行于每个 `v-for` 循环中。当你只想为*部分*项渲染节点时，这种优先级的机制会十分有用。</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t通过查看了 风格指南，主要说几点：</span><br><span class=\"line\"></span><br><span class=\"line\">* 避免一起使用</span><br><span class=\"line\"></span><br><span class=\"line\">* 对于需要过滤一个列表中的项目，采用计算属性</span><br><span class=\"line\"></span><br><span class=\"line\">  * ```</span><br><span class=\"line\">    v-for=&quot;user in users&quot; v-if=&quot;user.isActive&quot;</span><br><span class=\"line\">    </span><br><span class=\"line\">    可以对 user 使用一个计算属性 activeUser 使用filter过滤后返回</span><br><span class=\"line\">    v-for=&quot;user in activeUsers&quot;</span><br><span class=\"line\">    </span><br><span class=\"line\">    computed: &#123;</span><br><span class=\"line\">    \tactiveUsers: function() &#123;</span><br><span class=\"line\">    \t\treturn this.users.filter((user) =&gt; user.isActive);</span><br><span class=\"line\">    \t&#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>对于会直接应该被隐藏的列表，将 v-if 放在上层，不要在每次循环的时候判断</p>\n<ul>\n<li>```<br>v-for=”user in users” v-if=”shouldShowUsers”shouldShowUsers 这是对一个 users 进行的判断，只要为 false，所有的 users都不会显示，所以这个建议放在上层<br>v-if=”shouldShowUsers”<pre><code>v-for=&quot;user in users&quot;\n</code></pre>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"># 列表渲染</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<a href=\"https://cn.vuejs.org/v2/guide/list.html\">https://cn.vuejs.org/v2/guide/list.html</a><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">## 用 v-for 把一个数组对应为一组元素</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t我们可以用 `v-for` 指令基于一个数组来渲染一个列表。`v-for` 指令需要使用 `item in items` 形式的特殊语法，其中 `items` 是源数据数组，而 `item` 则是被迭代的数组元素的**别名**。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<ul id=\"example-1\">\n<li v-for=\"item in items\" :key=\"item.message\">\n\n</li>\n</ul></li>\n</ul>\n</li>\n</ul>\n<p>items: [<br>  { message: ‘Foo’ },<br>  { message: ‘Bar’ }<br>]</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">​\t\t`v-for` 还支持一个可选的第二个参数，即当前项的索引。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<li v-for=\"(item, index) in items\">\n     -  - \n</li>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">​\t\tindex 从0开始。</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t你也可以用 `of` 替代 `in` 作为分隔符，因为它更接近 JavaScript 迭代器的语法</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<div v-for=\"item of items\"></div>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">## 在 `v-for` 里使用对象</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t你也可以用 `v-for` 来遍历一个对象的 property。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<li v-for=\"value in object\">\n    \n</li>\n\n<p>object: {<br>  title: ‘How to do lists in Vue’,<br>  author: ‘Jane Doe’,<br>  publishedAt: ‘2016-04-10’<br>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">​\t\t你也可以提供第二个的参数为 property 名称 (也就是键名)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<div v-for=\"(value, name) in object\">\n  : \n</div>\n\n<p>title: How to do lists in Vue</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">​\t\t还可以用第三个参数作为索引</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<div v-for=\"(value, name, index) in object\">\n\n<p>0<br>1<br>2</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">&gt; ​\t\t在遍历对象时，会按 `Object.keys()` 的结果遍历，但是**不能**保证它的结果在不同的 JavaScript 引擎下都一致。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">**注意：**</span><br><span class=\"line\"></span><br><span class=\"line\">* 如果 v-for 里面是一个正整数n，那么将会变成 1~n，如果是一个小数，会报错。</span><br><span class=\"line\">  * 因为这个方法是会对其进行length操作，所以对于非正整数将出问题。</span><br><span class=\"line\">* 如果v-for里面是一个字符串，那么将会把字符串挨个字符输出。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">## 维护状态</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t当 Vue 正在更新使用 `v-for` 渲染的元素列表时，它默认使用“就地更新”的策略。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序，而是就地更新每个元素，并且确保它们在每个索引位置正确渲染。这个类似 Vue 1.x 的 `track-by=&quot;$index&quot;`。</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t**简单来说就是**，发现了变化，不会查看是否是有匹配的 DOM，而是直接将原来位置上的DOM进行改变。比如如果只是位置发生了改变，如果使用默认的方式，那么就会挨着将DOM进行修改，但是如果使用了key来进行维护，那么会查看是否有key值存在的，有的话就会直接使用key的DOM进行维护。没有再创建。</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t这个默认的模式是高效的，但是**只适用于不依赖子组件状态或临时 DOM 状态 (例如：表单输入值) 的列表渲染输出**。</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t**这里给的意思就是说**，如果对于依赖了子组件话，那么进行修改的时候需要耗费大量的时间，所以需要进行一些判断来处理要使用什么方法。</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t为了给 Vue 一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一 `key` attribute</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t就是说可以使用key来进行定位。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<div v-for=\"item in items\" v-bind:key=\"item.id\">\n  <!-- 内容 -->\n</div>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">​\t\t建议尽可能在使用 `v-for` 时提供 `key` attribute，除非遍历输出的 DOM 内容非常简单，或者是刻意依赖默认行为以获取性能上的提升。</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t因为它是 Vue 识别节点的一个通用机制，`key` 并不仅与 `v-for` 特别关联。后面我们将在指南中看到，它还具有其它用途。</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t其次对于key值，不要使用index下标进行赋值，因为如果你对数组进行了变化，位置变化等，可能下标也会发生改变，这样可能还会降低性能。</span><br><span class=\"line\"></span><br><span class=\"line\">&gt; ​\t\t不要使用对象或数组之类的非基本类型值作为 `v-for` 的 `key`。请用字符串或数值类型的值。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">## 数组更新检测</span><br><span class=\"line\"></span><br><span class=\"line\">### 变更方法</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t因为Vue的响应式是相对于Object.defineProperty的使用。所以Vue对数组的处理方式是，对方法进行了包裹，所以使用了数组的方法也会触发视图的更新。</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t这些方法包括了</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\npush，pop，shift，unshift，splice，sort，reverse\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">### 替换数组</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t变更方法，顾名思义，会变更调用了这些方法的原始数组。相比之下，也有非变更方法，例如 `filter()`、`concat()` 和 `slice()`。它们不会变更原始数组，而**总是返回一个新数组**。当使用非变更方法时，可以用新数组替换旧数组。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\nexample1.items = example1.items.filter(function (item) {\n  return item.message.match(/Foo/)\n})\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">​\t\t简单来说，上面的变更方法在调用之后是会变化原数组的。但是我们也有不会变更原数组的方法。所以对于这些不会变更原数组的方法，我们可以选择直接进行重新赋值。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\nitems = newItems\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">​\t\t我们可以发现对数组直接进行赋值也触发了视图的变化。因为我们对items这个数组也进行了监听。地址的改变也触发了视图的变化，同理，对于一个对象也是一样的。</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t你可能认为这将导致 Vue 丢弃现有 DOM 并重新渲染整个列表。幸运的是，事实并非如此。Vue 为了使得 DOM 元素得到最大范围的重用而实现了一些智能的启发式方法，所以用一个含有相同元素的数组去替换原来的数组是非常高效的操作。</span><br><span class=\"line\"></span><br><span class=\"line\">&gt; ​\t\t由于 JavaScript 的限制，Vue **不能检测**数组和对象的变化。[深入响应式原理](https://cn.vuejs.org/v2/guide/reactivity.html#检测变化的注意事项)中有相关的讨论。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">### 显示过滤/排序后的结果</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t有时，我们想要显示一个数组经过过滤或排序后的版本，而不实际变更或重置原始数据。在这种情况下，可以创建一个计算属性，来返回过滤或排序后的数组。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<li v-for=\"n in evenNumbers\"></li>\n\n<p>computed: {<br>  evenNumbers: function () {<br>    return this.numbers.filter(function (number) {<br>      return number % 2 === 0<br>    })<br>    }<br>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">​\t\t对于计算属性不适合的情况下，比如是循环嵌套了循环，此时对于循环内层，用不了计算属性，可以使用方法</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<ul v-for=\"set in sets\">\n  <li v-for=\"n in even(set)\"></li>\n</ul>\n\n<p>even: function (numbers) {<br>  return numbers.filter(function (number) {<br>      return number % 2 === 0<br>  })<br>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">​\t\t当然，你可能会想着，我对这个内层也加一个计算属性啊，但是，是没有效果的，简单来说就是因为就近原则，一个是循环的set，一个计算属性的set，他会先找循环的set。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">### 在 v-for 里使用值范围</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t`v-for` 也可以接受整数。在这种情况下，它会把模板重复对应次数。</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t对于字符串则会将字符进行循环。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">### 在 \\&lt;template&gt; 上使用 v-for</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t类似于 `v-if`，你也可以利用带有 `v-for` 的 `&lt;template&gt;` 来循环渲染一段包含多个元素的内容。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">### 在组件上使用 `v-for`</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t在自定义组件上，你可以像在任何普通元素上一样使用 `v-for`。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p><my-component v-for=\"item in items\" :key=\"item.id\"></my-component></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">​\t\t**2.2.0+ 的版本里，当在组件上使用 `v-for` 时，`key` 现在是必须的。**</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t然而，任何数据都不会被自动传递到组件里，因为组件有自己独立的作用域。为了把迭代数据传递到组件里，我们要使用 prop。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<ul>\n  <li is=\"todo-item\" v-for=\"(todo, index) in todos\" v-bind:key=\"todo.id\" v-bind:title=\"todo.title\" v-on:remove=\"todos.splice(index, 1)\"></li>\n</ul>\n\n<p>Vue.component(‘todo-item’, {<br>  template: ‘<br>    <li><br>      Vue-使用-基础使用<br>      <button v-on:click=\"$emit(\\'remove\\')\">Remove</button><br>    </li><br>  ‘,<br>  props: [‘title’]<br>})</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">&gt; ​\t\t注意这里的 `is=&quot;todo-item&quot;` attribute。这种做法在使用 DOM 模板时是十分必要的，因为在 `&lt;ul&gt;` 元素内只有 `&lt;li&gt;` 元素会被看作有效内容。这样做实现的效果与 `&lt;todo-item&gt;` 相同，但是可以避开一些潜在的浏览器解析错误。查看 [DOM 模板解析说明](https://cn.vuejs.org/v2/guide/components.html#解析-DOM-模板时的注意事项) 来了解更多信息。</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t简单来说，ul 元素内只有li元素被看作有效，我们使用is方法进行了替换，这样重点可以避开潜在的浏览器解析错误。当然这是一个Vue的方法。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"># 事件处理</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p><a href=\"https://cn.vuejs.org/v2/guide/events.html\">https://cn.vuejs.org/v2/guide/events.html</a></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">## 监听事件</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t可以用 `v-on` 指令监听 DOM 事件，并在触发时运行一些 JavaScript 代码。对应的语法糖，`@`</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p><button v-on:click=\"counter += 1\">Add 1</button></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">## 事件处理方法</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t然而许多事件处理逻辑会更为复杂，所以直接把 JavaScript 代码写在 `v-on` 指令中是不可行的。因此 `v-on` 还可以接收一个需要调用的方法名称。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<!-- `greet` 是在下面定义的方法名 -->\n<p><button v-on:click=\"greet\">Greet</button></p>\n<p>// 在 <code>methods</code> 对象中定义方法<br>methods: {<br>  greet: function (event) {<br>    // <code>this</code> 在方法里指向当前 Vue 实例<br>    alert(‘Hello ‘ + this.name + ‘!’)<br>    // <code>event</code> 是原生 DOM 事件<br>    if (event) {<br>        alert(event.target.tagName)<br>    }<br>  }<br>}</p>\n<p>// 也可以用 JavaScript 直接调用方法<br>vm.greet() // =&gt; ‘Hello Vue.js!’</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">## 内联处理器中的方法</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t除了直接绑定到一个方法，也可以在内联 JavaScript 语句中调用方法：</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p><button v-on:click=\"say('hi')\">Say hi</button></p>\n<p>methods: {<br>  say: function (message) {<br>      alert(message)<br>  }<br>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">​\t\t有时也需要在内联语句处理器中访问原始的 DOM 事件。可以用特殊变量 `$event` 把它传入方法</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p><button v-on:click=\"warn('Form cannot be submitted yet.', $event)\">Submit</button></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">**对于event方法的使用：**</span><br><span class=\"line\"></span><br><span class=\"line\">* 如果方法是不带参数的，可以直接使用event，或者参数上加上event</span><br><span class=\"line\"></span><br><span class=\"line\">  * ```</span><br><span class=\"line\">    &lt;button @click=&quot;change&quot;&gt;button&lt;/button&gt;</span><br><span class=\"line\">    </span><br><span class=\"line\">    change(event) &#123;console.log(event);&#125;,</span><br><span class=\"line\">    change() &#123;console.log(event);&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>不同点：</p>\n<ul>\n<li>如果使用了 @click=change()，加上了括号，对于第一个，传参event的，无法使用，第二个可以使用。</li>\n</ul>\n</li>\n<li><p>当然我们也可以使用 $event 来传递这个参数。</p>\n</li>\n</ul>\n<h2 id=\"事件修饰符\"><a href=\"#事件修饰符\" class=\"headerlink\" title=\"事件修饰符\"></a>事件修饰符</h2><p>​        在事件处理程序中调用 <code>event.preventDefault()</code> 或 <code>event.stopPropagation()</code> 是非常常见的需求。尽管我们可以在方法中轻松实现这点，但更好的方式是：方法只有纯粹的数据逻辑，而不是去处理 DOM 事件细节。</p>\n<p>​        首先默认使用的click方法就是冒泡类型。</p>\n<p>​        常见的事件修饰符</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.stop</span><br><span class=\"line\">\t阻止事件的冒泡</span><br><span class=\"line\">.prevent</span><br><span class=\"line\">\t阻止事件的默认行为，对于在父元素使用了阻止默认行为，子元素的默认行为都会被阻止。</span><br><span class=\"line\">.capture</span><br><span class=\"line\">\t转为捕获事件监听，事件的监听顺序是 root --&gt; target 捕获， target --&gt; root 冒泡</span><br><span class=\"line\">.self</span><br><span class=\"line\">\t只有目标元素是自身才会触发，对于子元素的点击也不会触发。</span><br><span class=\"line\">.once\t/ 2.1.4 新增</span><br><span class=\"line\">\t只触发一次。</span><br><span class=\"line\">.passive / 2.3.0 新增</span><br><span class=\"line\">\t</span><br></pre></td></tr></table></figure>\n\n<p>​        不像其它只能对原生的 DOM 事件起作用的修饰符，<code>.once</code> 修饰符还能被用到自定义的<a href=\"https://cn.vuejs.org/v2/guide/components-custom-events.html\">组件事件</a>上</p>\n<blockquote>\n<p>​        使用修饰符时，顺序很重要；相应的代码会以同样的顺序产生。因此，用 <code>v-on:click.prevent.self</code> 会阻止<strong>所有的点击</strong>，而 <code>v-on:click.self.prevent</code> 只会阻止对元素自身的点击。</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div @click.prevent.self=&quot;change&quot;&gt;</span><br><span class=\"line\">  &lt;a href=&quot;#1&quot; @click=&quot;change1&quot;&gt;321&lt;/a&gt;</span><br><span class=\"line\">  &lt;div @click=&quot;change1&quot;&gt;123&lt;/div&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;div @click.self.prevent=&quot;change&quot;&gt;</span><br><span class=\"line\">  &lt;a href=&quot;#1&quot; @click=&quot;change1&quot;&gt;321&lt;/a&gt;</span><br><span class=\"line\">  &lt;div @click=&quot;change1&quot;&gt;123&lt;/div&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n\n<p>​        <strong>热知识</strong>：父元素阻止了默认行为会影响到子元素。</p>\n<p>​        <strong>热知识2：</strong> click方法会先于默认行为执行。并且要冒泡结束了之后才会执行。</p>\n<p>​        Vue 还对应 <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Parameters\"><code>addEventListener</code> 中的 <code>passive</code> 选项</a>提供了 <code>.passive</code> 修饰符。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- 滚动事件的默认行为 (即滚动行为) 将会立即触发 --&gt;</span><br><span class=\"line\">&lt;!-- 而不会等待 `onScroll` 完成  --&gt;</span><br><span class=\"line\">&lt;!-- 这其中包含 `event.preventDefault()` 的情况 --&gt;</span><br><span class=\"line\">&lt;div v-on:scroll.passive=&quot;onScroll&quot;&gt;...&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n\n<p>​        他这里是这样说，貌似意思是说，默认行为会先触发，然后再触发 onScroll 的方法，但是我对一个。a标签进行操作的时候发现是先输出，然后在跳转，对于一个scroll行为的测试从肉眼上看也是和a标签一样，当然这个滚动的行为可能才滚1帧就开始触发了循环，导致卡帧也有可能。所以我现在不知道如何判断。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div @click=&quot;change&quot;&gt;</span><br><span class=\"line\">\t&lt;a href=&quot;#1&quot; @click.passive=&quot;change1&quot;&gt;321&lt;/a&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">methods: &#123;</span><br><span class=\"line\">  change() &#123;</span><br><span class=\"line\">    console.log(&#x27;father&#x27;);</span><br><span class=\"line\">    let date = new Date().getTime() + 1000;</span><br><span class=\"line\">    while (date &gt; new Date()) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  change1() &#123;</span><br><span class=\"line\">  \tconsole.log(&#x27;children&#x27;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>​        发现是先输出控制台，然后url再变化的。</p>\n<p>​        并且如果父元素使用了 prevent，子元素的passive无效，passive只能让本元素上的prevent无效。</p>\n<p>​        这个 <code>.passive</code> 修饰符尤其能够提升移动端的性能。 </p>\n<p>​        </p>\n<h2 id=\"按键修饰符\"><a href=\"#按键修饰符\" class=\"headerlink\" title=\"按键修饰符\"></a>按键修饰符</h2><p>​        在监听键盘事件时，我们经常需要检查详细的按键。Vue 允许为 <code>v-on</code> 在监听键盘事件时添加按键修饰符</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- 只有在 `key` 是 `Enter` 时调用 `vm.submit()` --&gt;</span><br><span class=\"line\">&lt;input v-on:keyup.enter=&quot;submit&quot;&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"按键码\"><a href=\"#按键码\" class=\"headerlink\" title=\"按键码\"></a>按键码</h3><blockquote>\n<p>​        <code>keyCode</code> 的事件用法<a href=\"https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/keyCode\">已经被废弃了</a>并可能不会被最新的浏览器支持。</p>\n</blockquote>\n<p>​        使用 <code>keyCode</code> attribute 也是允许的：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;input v-on:keyup.13=&quot;submit&quot;&gt;</span><br></pre></td></tr></table></figure>\n\n<p>​        为了在必要的情况下支持旧浏览器，Vue 提供了绝大多数常用的按键码的别名：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.enter\t.tab\t.delete (捕获“删除”和“退格”键)\t.esc\t.space\t.up\t.down\t.left\t.right</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>​        有一些按键 (<code>.esc</code> 以及所有的方向键) 在 IE9 中有不同的 <code>key</code> 值, 如果你想支持 IE9，这些内置的别名应该是首选。</p>\n</blockquote>\n<p>​        你还可以通过全局 <code>config.keyCodes</code> 对象<a href=\"https://cn.vuejs.org/v2/api/#keyCodes\">自定义按键修饰符别名</a>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 可以使用 `v-on:keyup.f1`</span><br><span class=\"line\">Vue.config.keyCodes.f1 = 112</span><br></pre></td></tr></table></figure>\n\n<p>​        按键别名可以进行覆盖，当然这个不建议这样写已经存在的。</p>\n<p><strong>注意：</strong></p>\n<p>​        按键别名不要使用大写，因为大写的在 <code>&lt;input v-on:keyup.enter=&quot;submit&quot;&gt; </code>，在这里会转为小写，所以无法使用成功。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;input type=&quot;text&quot; @keyup.A=&quot;change&quot;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">Vue.config.keyCodes.A = 97;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"系统修饰键\"><a href=\"#系统修饰键\" class=\"headerlink\" title=\"系统修饰键\"></a>系统修饰键</h2><p>​        可以用如下修饰符来实现仅在按下相应按键时才触发鼠标或键盘事件的监听器。(2.1.0新增)</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.ctrl</span><br><span class=\"line\">.alt</span><br><span class=\"line\">.shift</span><br><span class=\"line\">.meta</span><br><span class=\"line\">\t就是Windows键盘上的那个Windows图标按钮。mac同理</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>​        注意：在 Mac 系统键盘上，meta 对应 command 键 (⌘)。在 Windows 系统键盘 meta 对应 Windows 徽标键 (⊞)。在 Sun 操作系统键盘上，meta 对应实心宝石键 (◆)。在其他特定键盘上，尤其在 MIT 和 Lisp 机器的键盘、以及其后继产品，比如 Knight 键盘、space-cadet 键盘，meta 被标记为“META”。在 Symbolics 键盘上，meta 被标记为“META”或者“Meta”。</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- Alt + C --&gt;</span><br><span class=\"line\">&lt;input v-on:keyup.alt.67=&quot;clear&quot;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- Ctrl + Click --&gt;</span><br><span class=\"line\">&lt;div v-on:click.ctrl=&quot;doSomething&quot;&gt;Do something&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n\n<p><strong>注意：</strong></p>\n<ul>\n<li>使用系统修饰键对于 @keyup.67.ctrl 和 @keyup.ctrl.67 是一样的。不会有先后顺序。</li>\n<li>请注意修饰键与常规按键不同，在和 <code>keyup</code> 事件一起用时，事件触发时修饰键必须处于按下状态。换句话说，只有在按住 <code>ctrl</code> 的情况下释放其它按键，才能触发 <code>keyup.ctrl</code>。而单单释放 <code>ctrl</code> 也不会触发事件。如果你想要这样的行为，请为 <code>ctrl</code> 换用 <code>keyCode</code>：<code>keyup.17</code>。17代表了ctrl</li>\n<li><strong>@keyup.17.67</strong> 这个代表了按这两个其中一个都有效</li>\n<li>系统修饰键可以使用多个。</li>\n</ul>\n<h3 id=\"exact-修饰符（2-5-0新增）\"><a href=\"#exact-修饰符（2-5-0新增）\" class=\"headerlink\" title=\".exact 修饰符（2.5.0新增）\"></a>.exact 修饰符（2.5.0新增）</h3><p>​        <code>.exact</code> 修饰符允许你控制由精确的系统修饰键组合触发的事件。</p>\n<p>​        <strong>作用</strong>：用于<strong>精确</strong>控制系统修饰键按键的修饰符。主要在于精确两个字。并且是对系统修饰键起作用的。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;input type=&quot;text&quot; @keyup.a.up.exact=&quot;change&quot;&gt;</span><br><span class=\"line\">\t这个里面没有系统修饰键，监听了两个按键，最终效果：没有什么区别，唯一的区别就是如果此时你按了系统修饰键将不会触发。</span><br><span class=\"line\">\t所以这个代表了&lt;!-- 没有任何系统修饰键被按下的时候才触发 --&gt;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;input type=&quot;text&quot; @keyup.ctrl.up.exact=&quot;change&quot;&gt;</span><br><span class=\"line\">\t这个里面存在了系统修饰键 ctrl，所以效果就是必须按了 ctrl才会有用，（当然这个是系统修饰键的效果），.exact修饰符 的效果就是，系统修饰键必须只按了ctrl才有用。精确。加上系统修饰键。</span><br><span class=\"line\">\t其次.exact 修饰符没有位置的要求，和系统修饰键一样没有位置要求，</span><br><span class=\"line\">\t然后就是对于 &lt;input type=&quot;text&quot; @keyup.exact.ctrl.up.a=&quot;change&quot;&gt; 我们可以发现， 一个exact修饰符，一个ctrl系统修饰键，两个普通按键修饰符。所以最终的效果是，有且只有按了ctrl键，加上普通按键修饰符的其中一个就行。</span><br><span class=\"line\">\t&lt;!-- 有且只有 Ctrl 被按下的时候才触发 --&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"鼠标按钮修饰符（2-2-0新增）\"><a href=\"#鼠标按钮修饰符（2-2-0新增）\" class=\"headerlink\" title=\"鼠标按钮修饰符（2.2.0新增）\"></a>鼠标按钮修饰符（2.2.0新增）</h3><p>​        这些修饰符会限制处理函数仅响应特定的鼠标按钮。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.left</span><br><span class=\"line\">.right</span><br><span class=\"line\">.middle</span><br></pre></td></tr></table></figure>\n\n<p>​        用于点击事件，对于keyup事件不起作用，当然对于系统修饰键和.exact修饰符没有这些要求。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div @click.middle.ctrl.exact=&quot;change&quot;&gt;321&lt;/div&gt;</span><br><span class=\"line\">\t要求是 ctrl键 + 鼠标中键才会触发。</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"为什么要在-HTML-中监听事件\"><a href=\"#为什么要在-HTML-中监听事件\" class=\"headerlink\" title=\"为什么要在 HTML 中监听事件\"></a>为什么要在 HTML 中监听事件</h2><p>​        你可能注意到这种事件监听的方式违背了关注点分离 (separation of concern) 这个长期以来的优良传统。但不必担心，因为所有的 Vue.js 事件处理方法和表达式都严格绑定在当前视图的 ViewModel 上，它不会导致任何维护上的困难。实际上，使用 <code>v-on</code> 有几个好处：</p>\n<ol>\n<li>扫一眼 HTML 模板便能轻松定位在 JavaScript 代码里对应的方法。</li>\n<li>因为你无须在 JavaScript 里手动绑定事件，你的 ViewModel 代码可以是非常纯粹的逻辑，和 DOM 完全解耦，更易于测试。</li>\n<li>当一个 ViewModel 被销毁时，所有的事件处理器都会自动被删除。你无须担心如何清理它们。</li>\n</ol>\n<p><strong>概括就是说</strong>：虽然是在html中进行的使用监听，但是真正的处理是绑定在VM上的。其次对于v-on的好处：1.能够一眼看出方法。2.和DOM完全解耦。3.当一个VM被销毁时，所有的事件会自动清除。</p>\n<h1 id=\"表单输入绑定\"><a href=\"#表单输入绑定\" class=\"headerlink\" title=\"表单输入绑定\"></a>表单输入绑定</h1><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://cn.vuejs.org/v2/guide/forms.html</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"基础用法\"><a href=\"#基础用法\" class=\"headerlink\" title=\"基础用法\"></a>基础用法</h2><p>​        你可以用 <code>v-model</code> 指令在表单 <code>&lt;input&gt;</code>、<code>&lt;textarea&gt;</code> 及 <code>&lt;select&gt;</code> 元素上创建双向数据绑定。它会根据控件类型自动选取正确的方法来更新元素。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;input v-model=&quot;message&quot; placeholder=&quot;edit me&quot;&gt;</span><br><span class=\"line\">这里，我是用 v-model，并没有绑定给value，但是会自动选取正确的方法进行更新。</span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>注意：</strong></p>\n<ul>\n<li>v-model 会忽略元素自带的value，checked等属性，而是使用Vue实例的数据作为来源。</li>\n</ul>\n<p>​        <code>v-model</code> 在内部为不同的输入元素使用不同的 property 并抛出不同的事件。</p>\n<ul>\n<li>text 和 textarea 元素使用 <code>value</code> property 和 <code>input</code> 事件；</li>\n<li>checkbox 和 radio 使用 <code>checked</code> property 和 <code>change</code> 事件；（使用的是真值方式truth）</li>\n<li>select 字段将 <code>value</code> 作为 prop 并将 <code>change</code> 作为事件。</li>\n</ul>\n<blockquote>\n<p>​        对于需要使用<a href=\"https://zh.wikipedia.org/wiki/%E8%BE%93%E5%85%A5%E6%B3%95\">输入法</a> (如中文、日文、韩文等) 的语言，你会发现 <code>v-model</code> 不会在输入法组合文字过程中得到更新。如果你也想处理这个过程，请使用 <code>input</code> 事件。</p>\n</blockquote>\n<p>​        你在输入框输入加上一个input事件的监听的时候就会发现。如果在输入的时候使用了中文，虽然在按键的时候发生了input事件，但是v-model的值并没有得到更新。</p>\n<p>​        但是如果是普通的input输入框的监听则会发生更新。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;input type=&quot;text&quot; v-model=&quot;string&quot; @input=&quot;change&quot; oninput=&quot;console.log(&#x27;event:    &#x27; + event.target.value);&quot;&gt;</span><br></pre></td></tr></table></figure>\n\n<p>​        并且在进行了空格之后会发生多次的更新。</p>\n<h3 id=\"文本-和-多行文本\"><a href=\"#文本-和-多行文本\" class=\"headerlink\" title=\"文本 和 多行文本\"></a>文本 和 多行文本</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;input type=&quot;text&quot; v-model=&quot;message&quot;&gt;</span><br><span class=\"line\">&lt;textarea v-model=&quot;message&quot;&gt;&lt;/textarea&gt;</span><br></pre></td></tr></table></figure>\n\n<p>​        在文本区域插值 (<code>&lt;textarea&gt;&#123;&#123;text&#125;&#125;&lt;/textarea&gt;</code>) 并不会生效，应用 <code>v-model</code> 来代替。</p>\n<h3 id=\"复选框\"><a href=\"#复选框\" class=\"headerlink\" title=\"复选框\"></a>复选框</h3><p>​        单个复选框，直接布尔值进行的判断，对于不是布尔类型的使用了truth方式。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;input type=&quot;checkbox&quot; id=&quot;checkbox&quot; v-model=&quot;checked&quot;&gt;</span><br></pre></td></tr></table></figure>\n\n<p>​        对于多个复选框</p>\n<p>​        注意：复选框和单选框是通过value进行判断。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;input type=&quot;checkbox&quot; id=&quot;jack&quot; value=&quot;Jack&quot; v-model=&quot;checkedNames&quot;&gt;</span><br><span class=\"line\">&lt;label for=&quot;jack&quot;&gt;Jack&lt;/label&gt;</span><br><span class=\"line\">&lt;input type=&quot;checkbox&quot; id=&quot;john&quot; value=&quot;John&quot; v-model=&quot;checkedNames&quot;&gt;</span><br><span class=\"line\">&lt;label for=&quot;john&quot;&gt;John&lt;/label&gt;</span><br><span class=\"line\">&lt;input type=&quot;checkbox&quot; id=&quot;mike&quot; value=&quot;Mike&quot; v-model=&quot;checkedNames&quot;&gt;</span><br><span class=\"line\">&lt;label for=&quot;mike&quot;&gt;Mike&lt;/label&gt;</span><br></pre></td></tr></table></figure>\n\n<p>​        <del>我们可以发现，这里没有对复选框进行分组，正常的情况下，复选框需要进行name的分组，相同的name为一组。这个好像是对单选框的。复选框应该本来就可以不用分组？</del></p>\n<p>​        对于一个复选框，如果绑定了v-model，但是value不绑定，那么点击一个就是点击多个。因为没有使用value属性，值为null，所以所有为null都会被同步变化。</p>\n<p>​        同时，如果多选的复选框，但是绑定的属性不是一个数组那么最终也会变为全部都会出现相同的变化。 <code>checkedNames: 1,</code> </p>\n<h3 id=\"单选按钮\"><a href=\"#单选按钮\" class=\"headerlink\" title=\"单选按钮\"></a>单选按钮</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;input type=&quot;radio&quot; name=&quot;aa&quot; id=&quot;jack&quot; value=&quot;Jack&quot; v-model=&quot;checkedNames&quot;&gt;</span><br><span class=\"line\">&lt;label for=&quot;jack&quot;&gt;Jack&lt;/label&gt;</span><br><span class=\"line\">&lt;input type=&quot;radio&quot; name=&quot;cc&quot; id=&quot;john&quot; value=&quot;John&quot; v-model=&quot;checkedNames&quot;&gt;</span><br><span class=\"line\">&lt;label for=&quot;john&quot;&gt;John&lt;/label&gt;</span><br><span class=\"line\">&lt;input type=&quot;radio&quot; name=&quot;aa&quot; id=&quot;mike&quot; value=&quot;Mike&quot; v-model=&quot;checkedNames&quot;&gt;</span><br><span class=\"line\">&lt;label for=&quot;mike&quot;&gt;Mike&lt;/label&gt;</span><br></pre></td></tr></table></figure>\n\n<p>​        在这里，我将name进行不同的划分，但是可以发现他们还是一组的成员。</p>\n<p>​        <del>所以我们可以这样认为，使用了v-model之后，name也会绑定为这个属性的名称，所以你自己定义的属性名称是没有作用的。</del>（注意：这里不是说，绑定的是v-model属性的名称，而是说，name的绑定和v-model的属性相关了。但是值不知道是什么。）</p>\n<p>​        <strong>注意：</strong> 首先我们可以测试出来，name的属性还是没有改变，因为如果添加了一个 相同name，但是没有使用v-model的，会出现竞争。</p>\n<p>​        对于单选按钮，<strong>没有使用value的</strong>，那么v-model绑定的属性取出来的值是空。就是那种什么都没有的空。<strong>并且name属性默认不同</strong>。</p>\n<p>​        如果自己定义了name属性，那么会以自己定义的为准。但是如果使用了value，搭配了v-model，对于同value，不同name，两个都选上。 <del>那么name属性还是以v-model为准（是指相同的v-model有相同的name）。</del></p>\n<p>​        并且，如果value相等，name不等，那么点击时，都会一起变化。如果name相等了，那么点击时点击那个就是哪个，但是value的值不变，并且对于初始化来说，是根据value的值来进行的变化，所以会以最后一个为准。</p>\n<p>​        这里有很多问题，但是这些都是可以手动避免的。大概知道就行。我也被自己扯蒙了。</p>\n<h3 id=\"选择框\"><a href=\"#选择框\" class=\"headerlink\" title=\"选择框\"></a>选择框</h3><p>​        单选时，直接绑定一个值即可</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;select v-model=&quot;selected&quot;&gt;</span><br><span class=\"line\">  &lt;option disabled value=&quot;&quot;&gt;请选择&lt;/option&gt;</span><br><span class=\"line\">  &lt;option&gt;A&lt;/option&gt;</span><br><span class=\"line\">  &lt;option&gt;B&lt;/option&gt;</span><br><span class=\"line\">  &lt;option&gt;C&lt;/option&gt;</span><br><span class=\"line\">&lt;/select&gt;</span><br><span class=\"line\">&lt;span&gt;Selected: &#123;&#123; selected &#125;&#125;&lt;/span&gt;</span><br></pre></td></tr></table></figure>\n\n<p>​        我们也可以发现，对于使用option的时候，可以不添加value属性，此时绑定的值就是内容。</p>\n<p><strong>注意：</strong>如果没有规定 value 属性，选项的值将设置为 &lt;option&gt; 标签中的内容。</p>\n<p><strong>注意：</strong></p>\n<blockquote>\n<p>​        如果 <code>v-model</code> 表达式的初始值未能匹配任何选项，<code>&lt;select&gt;</code> 元素将被渲染为“未选中”状态。在 iOS 中，这会使用户无法选择第一个选项。因为这样的情况下，iOS 不会触发 change 事件。因此，更推荐像上面这样提供一个值为空的禁用选项。</p>\n</blockquote>\n<p>​        当然这个我不清楚，毕竟我没有IOS。。。。。。</p>\n<p>​        多选时就是绑定一个数组</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;select v-model=&quot;selected&quot; multiple style=&quot;width: 50px;&quot;&gt;</span><br><span class=\"line\">  &lt;option&gt;A&lt;/option&gt;</span><br><span class=\"line\">  &lt;option&gt;B&lt;/option&gt;</span><br><span class=\"line\">  &lt;option&gt;C&lt;/option&gt;</span><br><span class=\"line\">&lt;/select&gt;</span><br><span class=\"line\">&lt;br&gt;</span><br><span class=\"line\">&lt;span&gt;Selected: &#123;&#123; selected &#125;&#125;&lt;/span&gt;</span><br></pre></td></tr></table></figure>\n\n<p>​        首先，select多选框的属性 multiple，其次就是使用的数组了。</p>\n<p>​        对于不是使用数组的，将不会初始化成功，但是在后续的赋值还是会转化为数组。</p>\n<p>​        当然，对于 option 也可以使用v-for进行动态渲染。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;option v-for=&quot;item in options&quot;&gt;&#123;&#123; item &#125;&#125;&lt;/option&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"值绑定\"><a href=\"#值绑定\" class=\"headerlink\" title=\"值绑定\"></a>值绑定</h2><p>​        对于单选按钮，复选框及选择框的选项，<code>v-model</code> 绑定的值通常是静态字符串 (对于复选框也可以是布尔值)：</p>\n<p>​        但是有时我们可能想把值绑定到 Vue 实例的一个动态 property 上，这时可以用 <code>v-bind</code> 实现，并且这个 property 的值可以不是字符串。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- 当选中时，`picked` 为字符串 &quot;a&quot; --&gt;</span><br><span class=\"line\">&lt;input type=&quot;radio&quot; v-model=&quot;picked&quot; value=&quot;a&quot;&gt;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- 当选中时，`picked` 为a 的值 --&gt;</span><br><span class=\"line\">&lt;input type=&quot;radio&quot; v-model=&quot;picked&quot; :value=&quot;a&quot;&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"复选框-1\"><a href=\"#复选框-1\" class=\"headerlink\" title=\"复选框\"></a>复选框</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;input</span><br><span class=\"line\">  type=&quot;checkbox&quot;</span><br><span class=\"line\">  v-model=&quot;toggle&quot;</span><br><span class=\"line\">  true-value=&quot;yes&quot;</span><br><span class=\"line\">  false-value=&quot;no&quot;</span><br><span class=\"line\">&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">// 当选中时</span><br><span class=\"line\">vm.toggle === &#x27;yes&#x27;</span><br><span class=\"line\">// 当没有选中时</span><br><span class=\"line\">vm.toggle === &#x27;no&#x27;</span><br></pre></td></tr></table></figure>\n\n<p>​        针对多个复选框。其值还是为value值，如果没有value，其值就是null</p>\n<blockquote>\n<p>​        这里的 <code>true-value</code> 和 <code>false-value</code> attribute 并不会影响输入控件的 <code>value</code> attribute，因为浏览器在提交表单时并不会包含未被选中的复选框。如果要确保表单中这两个值中的一个能够被提交，(即“yes”或“no”)，请换用单选按钮。</p>\n</blockquote>\n<p>​        所以这个 true/false value 是单选时比较有用。</p>\n<h3 id=\"单选按钮-1\"><a href=\"#单选按钮-1\" class=\"headerlink\" title=\"单选按钮\"></a>单选按钮</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;input type=&quot;radio&quot; v-model=&quot;pick&quot; v-bind:value=&quot;a&quot;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">// 当选中时</span><br><span class=\"line\">vm.pick === vm.a</span><br></pre></td></tr></table></figure>\n\n<p>​    </p>\n<h3 id=\"选择框的选项\"><a href=\"#选择框的选项\" class=\"headerlink\" title=\"选择框的选项\"></a>选择框的选项</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;select v-model=&quot;selected&quot;&gt;</span><br><span class=\"line\">    &lt;!-- 内联对象字面量 --&gt;</span><br><span class=\"line\">  &lt;option v-bind:value=&quot;&#123; number: 123 &#125;&quot;&gt;123&lt;/option&gt;</span><br><span class=\"line\">&lt;/select&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">// 当选中时</span><br><span class=\"line\">typeof vm.selected // =&gt; &#x27;object&#x27;</span><br><span class=\"line\">vm.selected.number // =&gt; 123</span><br></pre></td></tr></table></figure>\n\n<p>​        通过这个我们可以看出，这个是可以使用对象的，同理，我们对于其他的选项框也可以使用对象的形式。</p>\n<h2 id=\"修饰符\"><a href=\"#修饰符\" class=\"headerlink\" title=\"修饰符\"></a>修饰符</h2><h3 id=\"lazy\"><a href=\"#lazy\" class=\"headerlink\" title=\".lazy\"></a>.lazy</h3><p>​        在默认情况下，<code>v-model</code> 在每次 <code>input</code> 事件触发后将输入框的值与数据进行同步 (除了<a href=\"https://cn.vuejs.org/v2/guide/forms.html#vmodel-ime-tip\">上述</a>输入法组合文字时)。你可以添加 <code>lazy</code> 修饰符，从而转为在 <code>change</code> 事件_之后_进行同步</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- 在“change”时而非“input”时更新 --&gt;</span><br><span class=\"line\">&lt;input v-model.lazy=&quot;msg&quot;&gt;</span><br></pre></td></tr></table></figure>\n\n<p>​        在输入之后使用回车，便是change事件。</p>\n<h3 id=\"number\"><a href=\"#number\" class=\"headerlink\" title=\".number\"></a>.number</h3><p>​        如果想自动将用户的输入值转为数值类型，可以给 <code>v-model</code> 添加 <code>number</code> 修饰符</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;input v-model.number=&quot;age&quot; type=&quot;number&quot;&gt;</span><br></pre></td></tr></table></figure>\n\n<p>​        无法输入字符串。</p>\n<p>​        这通常很有用，因为即使在 <code>type=&quot;number&quot;</code> 时，HTML 输入元素的值也总会返回字符串。如果这个值无法被 <code>parseFloat()</code> 解析，则会返回原始的值。</p>\n<p>​        如何出现无法解析的情况，因为可以输入 e，+，-等，所以还是可以无法解析，问题在于无法解析输出的类型是字符串，但是貌似内容为’’，</p>\n<h3 id=\"trim\"><a href=\"#trim\" class=\"headerlink\" title=\".trim\"></a>.trim</h3><p>​        如果要自动过滤用户输入的首尾空白字符，可以给 <code>v-model</code> 添加 <code>trim</code> 修饰符：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;input v-model.trim=&quot;msg&quot;&gt;</span><br></pre></td></tr></table></figure>\n\n<p>​        没啥说的。就是字符串的 trim 方法。这个方法的使用是返回一个新的。</p>\n<h2 id=\"在组件上使用-v-model-（2-2-0-新增）\"><a href=\"#在组件上使用-v-model-（2-2-0-新增）\" class=\"headerlink\" title=\"在组件上使用 v-model （2.2.0+ 新增）\"></a>在组件上使用 v-model （2.2.0+ 新增）</h2><p>​        HTML 原生的输入元素类型并不总能满足需求。幸好，Vue 的组件系统允许你创建具有完全自定义行为且可复用的输入组件。这些输入组件甚至可以和 <code>v-model</code> 一起使用！</p>\n<p>​        要了解更多，请参阅组件指南中的<a href=\"https://cn.vuejs.org/v2/guide/components-custom-events.html#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6%E7%9A%84-v-model\">自定义输入组件</a>。</p>\n<p>​        讲真，没有看懂。</p>\n<p>​        我们通过跳转，看到了自定义组件的 v-model 我只能大概知道</p>\n<p>​        一个组件上的 <code>v-model</code> 默认会利用名为 <code>value</code> 的 prop 和名为 <code>input</code> 的事件，但是像单选框、复选框等类型的输入控件可能会将 <code>value</code> attribute 用于<a href=\"https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/checkbox#Value\">不同的目的</a>。<code>model</code> 选项可以用来避免这样的冲突</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Vue.component(&#x27;base-checkbox&#x27;, &#123;</span><br><span class=\"line\">  model: &#123;</span><br><span class=\"line\">    prop: &#x27;checked&#x27;,</span><br><span class=\"line\">    event: &#x27;change&#x27;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  props: &#123;</span><br><span class=\"line\">    checked: Boolean</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  template: `</span><br><span class=\"line\">    &lt;input</span><br><span class=\"line\">      type=&quot;checkbox&quot;</span><br><span class=\"line\">      v-bind:checked=&quot;checked&quot;</span><br><span class=\"line\">      v-on:change=&quot;$emit(&#x27;change&#x27;, $event.target.checked)&quot;</span><br><span class=\"line\">    &gt;</span><br><span class=\"line\">  `</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">使用v-model时</span><br><span class=\"line\">&lt;base-checkbox v-model=&quot;lovingVue&quot;&gt;&lt;/base-checkbox&gt;</span><br></pre></td></tr></table></figure>\n\n<p>​        这里因为使用了v-model进行传值，所以使用了model: {}，设置了prop的名字，然后在props进行使用，此时传递的值就和父组件的 lovingVue 进行了绑定。然后通过事件$emit， change进行的提交。</p>\n<p>​        这里的 <code>lovingVue</code> 的值将会传入这个名为 <code>checked</code> 的 prop。同时当 <code>&lt;base-checkbox&gt;</code> 触发一个 <code>change</code> 事件并附带一个新的值的时候，这个 <code>lovingVue</code> 的 property 将会被更新。</p>\n<blockquote>\n<p>​        注意你仍然需要在组件的 <code>props</code> 选项里声明 <code>checked</code> 这个 prop。</p>\n</blockquote>\n<h1 id=\"组件基础\"><a href=\"#组件基础\" class=\"headerlink\" title=\"组件基础\"></a>组件基础</h1><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://cn.vuejs.org/v2/guide/components.html</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"基本示例\"><a href=\"#基本示例\" class=\"headerlink\" title=\"基本示例\"></a>基本示例</h2><p>​        这里有一个 Vue 组件的示例</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 定义一个名为 button-counter 的新组件</span><br><span class=\"line\">Vue.component(&#x27;button-counter&#x27;, &#123;</span><br><span class=\"line\">  data: function () &#123;</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">      count: 0</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  template: &#x27;&lt;button v-on:click=&quot;count++&quot;&gt;You clicked me &#123;&#123; count &#125;&#125; times.&lt;/button&gt;&#x27;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>​        组件是可复用的 Vue 实例，且带有一个名字：在这个例子中是 <code>&lt;button-counter&gt;</code>。我们可以在一个通过 <code>new Vue</code> 创建的 Vue 根实例中，把这个组件作为自定义元素来使用</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=&quot;components-demo&quot;&gt;</span><br><span class=\"line\">  &lt;button-counter&gt;&lt;/button-counter&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n\n<p>​        当然注意上面这个组件的定义顺序要在你的Vue实例之前。因为编译问题，如果在之后的话就不会被编译了。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Vue.componnet(&#x27;button&#x27;, &#123; &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">const vm = new Vue();</span><br></pre></td></tr></table></figure>\n\n<p>​        因为组件是可复用的 Vue 实例，所以它们与 <code>new Vue</code> 接收相同的选项，例如 <code>data</code>、<code>computed</code>、<code>watch</code>、<code>methods</code> 以及生命周期钩子等。仅有的例外是像 <code>el</code> 这样根实例特有的选项。</p>\n<h2 id=\"组件的复用\"><a href=\"#组件的复用\" class=\"headerlink\" title=\"组件的复用\"></a>组件的复用</h2><p>​        组件在被创建之后，可以被多次使用。</p>\n<h3 id=\"data必须是一个函数\"><a href=\"#data必须是一个函数\" class=\"headerlink\" title=\"data必须是一个函数\"></a>data必须是一个函数</h3><p>​        当我们定义这个 <code>&lt;button-counter&gt;</code> 组件时，你可能会发现它的 <code>data</code> 并不是像这样直接提供一个对象</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Vue.component(&#x27;button&#x27;, &#123;</span><br><span class=\"line\">\tdata: &#123;</span><br><span class=\"line\">\t\treturn &#123;</span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\">\t\t&#125;;</span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">const vm = new Vue(&#123;</span><br><span class=\"line\">\tdata: &#123;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>​        当然如果你不这样写也不会报错，但是这样会有一个问题，那就是所以这个组件都会使用同一个对象的数据，一个发生了改变，所有都会发生改变。所以就是用了函数，这个会每次都调用了一次函数，形成一个新的作用域位置。</p>\n<p>​        这个就是使用了闭包的方法，当然你可能在想，是不是可以利用这个闭包，然后既能让数据不同步，又能让部分数据进行同步。当然，我没有解决掉。因为首先我们可以知道闭包的使用方式。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Fn() &#123;</span><br><span class=\"line\">\treturn fn() &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">let fn = Fn();</span><br><span class=\"line\">这个时候使用fn，就可以使用闭包。但是data是重复的创建Fn(). 所以每次都还是会创建新东西。</span><br></pre></td></tr></table></figure>\n\n<p>​        所以我现在不知道如何使用闭包的方式，当然，我们可以将方法写在全局，然后再组件里进行闭包。还是可以的。</p>\n<h2 id=\"组件的组织\"><a href=\"#组件的组织\" class=\"headerlink\" title=\"组件的组织\"></a>组件的组织</h2><p>​        为了能在模板中使用，这些组件必须先注册以便 Vue 能够识别。这里有两种组件的注册类型：<strong>全局注册</strong>和<strong>局部注册</strong>。至此，我们的组件都只是通过 <code>Vue.component</code> 全局注册的</p>\n<p>​        全局注册的组件可以用在其被注册之后的任何 (通过 <code>new Vue</code>) 新创建的 Vue 根实例，也包括其组件树中的所有子组件的模板中。</p>\n<p>​        局部注册的方式就是先将内容对象赋值给了一个变量，然后通过使用变量来进行注册。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let ComponentA = &#123;  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">new Vue(&#123;</span><br><span class=\"line\">\tel: &#x27;#xx&#x27;,</span><br><span class=\"line\">\tcomponents: &#123;</span><br><span class=\"line\">\t\t&#x27;component-a&#x27;: ComponentA,</span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"通过Prop向子组件传递数据\"><a href=\"#通过Prop向子组件传递数据\" class=\"headerlink\" title=\"通过Prop向子组件传递数据\"></a>通过Prop向子组件传递数据</h2><p>​        简单来说，就是写在props属性里面的会添加到属性，父组件在调用子组件时，可以通过在标签里添加对应的属性，属性里面的值将会传递给子组件。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Vue.component(&#x27;blog-post&#x27;, &#123;</span><br><span class=\"line\">  props: [&#x27;title&#x27;],</span><br><span class=\"line\">  template: &#x27;&lt;h3&gt;&#123;&#123; title &#125;&#125;&lt;/h3&gt;&#x27;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;blog-post title=&quot;My journey with Vue&quot;&gt;&lt;/blog-post&gt;</span><br></pre></td></tr></table></figure>\n\n<p>​        当然对于这个props，也有另一个写法，props使用对象，对象里面又是一个对象，default代表了默认值，type代表了类型，当然也有其他属性。但是我们后面在详细了解。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">props: &#123;</span><br><span class=\"line\">  &#x27;title&#x27;: &#123;</span><br><span class=\"line\">    default: &#x27;123&#x27;,</span><br><span class=\"line\">    type: String</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;blog-post title=&quot;My journey with Vue&quot;&gt;&lt;/blog-post&gt;</span><br><span class=\"line\">&lt;blog-post&gt;&lt;/blog-post&gt;</span><br></pre></td></tr></table></figure>\n\n<p>​        当然这个自定的属性attribute，也是可以使用v-bind: 来动态绑定。当然我们也可以使用v-model，但是这里也有其他的问题，具体后续在了解。</p>\n<p>​        传递的属性也能是对象，对于一些应该属于统一对象的，可以将其化为一个对象进行传递。</p>\n<h2 id=\"单个根元素\"><a href=\"#单个根元素\" class=\"headerlink\" title=\"单个根元素\"></a>单个根元素</h2><p>​        简单来说，就是在创建时，只能以一个根元素。如果根元素不止一个就会报错</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div&gt;&lt;/div&gt;</span><br><span class=\"line\">&lt;div&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n\n<p>​        上面这个写法就会报错，但是下面这个写法。将所有的元素都放在了一个根元素的下级。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div&gt;</span><br><span class=\"line\">  &lt;div&gt;&lt;/div&gt;</span><br><span class=\"line\">  &lt;div&gt;&lt;/div&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n\n<p>​        这里的原因。我不清楚，只能说在Vue里面如果使用了下面这个写法时，可以知道，只会将第一个进行Vue的渲染，第二个将不会进行渲染操作。通过查阅资料，有的说是diff算法的原因，也有说是为了避免出现多个根元素，找不到以谁为主体。</p>\n<p>​        这个现在主要作为一个了解。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=&quot;app&quot;&gt;1&lt;/div&gt;</span><br><span class=\"line\">&lt;div id=&quot;app&quot;&gt;2&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"监听子组件事件\"><a href=\"#监听子组件事件\" class=\"headerlink\" title=\"监听子组件事件\"></a>监听子组件事件</h2><p>​        父组件可以给子组件传值了，但是子组件如何在一定的条件下通知父组件呢。</p>\n<p>​        使用方式：</p>\n<p>​        1.首先父元素在传递的时候，传递一个可以被子元素监听的方法</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;blog-post @test=&quot;enlarge&quot; post=&quot;&#123;title: 1&#125;&quot;&gt;&lt;/blog-post&gt;</span><br></pre></td></tr></table></figure>\n\n<p>​        2.然后子元素就可以通过使用 $emit 进行调用这个方法。注意$emit(‘xxxx’)，xxx就是那个元素上的属性attribute，</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;button v-on:click=&quot;$emit(&#x27;test&#x27;)&quot;&gt;</span><br></pre></td></tr></table></figure>\n\n<p>​        3.传递值的方式，这个方法的第一个是方法名，后面的就是要传递的值。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$emit(&#x27;test&#x27;, 1, 2);</span><br></pre></td></tr></table></figure>\n\n<p><strong>注意：</strong></p>\n<ul>\n<li><p>父元素进行传递时，直接写上方法名即可 <code>@test=&quot;enlarge&quot;</code> </p>\n</li>\n<li><p>因为html是不分大小写的，所以进行传递的时候，建议不要带有大写，对于$emit(‘xxx’)，存在大写，则会监听失败。</p>\n</li>\n<li><p>如果是 <code>@test=&quot;enlarge()&quot;</code> 那么子组件传递参数则无效，<code>$emit(&#39;test&#39;, 1, 2);</code> 子组件这个写法虽然传递了参数，但是并不会传递值，因为父组件在传递的时候是直接传递了方法的调用的结果。</p>\n<ul>\n<li>```<br>@test=”enlarge()<br>$emit(‘test’, 1, 2);结果：空<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">*  `@test=&quot;enlarge(1, 2)` 同理，这样在子组件调用的时候传递过来的值就直接是是1和2。并不会因为 `$emit(&#x27;test&#x27;, 321, 123);` 改成321，123。</span><br><span class=\"line\"></span><br><span class=\"line\">  * ```</span><br><span class=\"line\">    @test=&quot;enlarge(1, 2)</span><br><span class=\"line\">    $emit(&#x27;test&#x27;, 11111, 22222);</span><br><span class=\"line\">    </span><br><span class=\"line\">    结果：1, 2</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p> <code>@test=&quot;enlarge($event, 12, 321, 312)&quot;</code> 这样写有是一个特点，你会发现，这个$event 代表的不是点击的事件了，而是子组件传递的值。这个event就类似于了一个子组件的待定参数。</p>\n</li>\n<li><p>```<br>@test=”enlarge($event, 1, 2)<br>$emit(‘test’, 11111, 22222);</p>\n<p>结果：11111, 1, 2</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">### 使用事件抛出一个值</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t可以使用 `$emit` 的第二个参数来提供这个值</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<button v-on:click=\"$emit('enlarge-text', 0.1)\">\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">​\t\t然后当在父级组件监听这个事件的时候，我们可以通过 `$event` 访问到被抛出的这个值</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n@enlarge-text=\"postFontSize += $event\"\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">​\t\t如果这个是一个方法，那么这个值会作为第一个参数传入这个方法</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\nonEnlargeText: function (enlargeAmount) {\nthis.postFontSize += enlargeAmount\n}\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">### 在组件上使用 v-model</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t首先我们可以这样理解</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n</button><input v-model=\"searchText\"></li>\n</ul>\n<p>等价于</p>\n<p>&lt;input<br>  v-bind:value=”searchText”<br>  v-on:input=”searchText = $event.target.value”</p>\n<blockquote>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">​\t\tv-model的效果就是值的改变会影响到view的改变，输入的变化会影响值的改变。而v-bind，值的改变会影响到视图的改变，但是并没有双向的绑定。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t所以用在组件上时。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>&lt;custom-input<br>  v-bind:value=”searchText”<br>  v-on:input=”searchText = $event”</p>\n<blockquote>\n\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">​\t\t所以此时我们需要绑定一个input方法将其传递出来。</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t为了让它正常工作，这个组件内的 `&lt;input&gt;` 必须：</span><br><span class=\"line\"></span><br><span class=\"line\">- 将其 `value` attribute 绑定到一个名叫 `value` 的 prop 上</span><br><span class=\"line\">- 在其 `input` 事件被触发时，将新的值通过自定义的 `input` 事件抛出</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>Vue.component(‘custom-input’, {<br>  props: [‘value’],<br>  template: <code>     &lt;input       v-bind:value=&quot;value&quot;       v-on:input=&quot;$emit(&#39;input&#39;, $event.target.value)&quot;     &gt;</code><br>})</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">​\t\t所以此时我们就能理解了，上面的那个组件使用v-model时的传递方式了。</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t同时我么可以看一下那个[自定义事件的 v-model](https://cn.vuejs.org/v2/guide/components-custom-events.html)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>Vue.component(‘base-checkbox’, {<br>  model: {<br>    prop: ‘checked’,<br>    event: ‘change’<br>  },<br>  props: {<br>    checked: Boolean<br>  },<br>  template: <code>     &lt;input       type=&quot;checkbox&quot;       v-bind:checked=&quot;checked&quot;       v-on:change=&quot;$emit(&#39;change&#39;, $event.target.checked)&quot;     &gt;</code><br>})</p>\n<p>使用<br><base-checkbox v-model=\"lovingVue\"></base-checkbox></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">​\t\t这里的model里面有prop和event，其中checked代表了传递的值。这个名字可以自己定义。 这里的event，值为change，则代表了是change事件，如果命名为input则为input的事件，当然，其实这里也是可以自己命名的。主要是为了方便认知。</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t这个和上一个组件的通信的区别</span><br><span class=\"line\"></span><br><span class=\"line\">* 普通的是将值返回给上级，然后上级进行方法的操作。</span><br><span class=\"line\"></span><br><span class=\"line\">  * ```</span><br><span class=\"line\">    &lt;c :name=&quot;name&quot; @inputf=&quot;fn&quot;&gt;12&lt;/c&gt;</span><br><span class=\"line\">    </span><br><span class=\"line\">    子组件的内容：</span><br><span class=\"line\">    &lt;input type=&quot;text&quot; :value=&quot;name&quot; @input=&quot;this.$emit(&#x27;inputf&#x27;, event.target.value);&quot;&gt;</span><br><span class=\"line\">    </span><br><span class=\"line\">    这里再对fn写上一个方法，此时对于一个input输入就会出现对应的方法被执行。</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>对于v-model，则是发现直接将其传递给上级，上级不需要再指定一个方法。</p>\n<ul>\n<li><p>```<br><c v-model=\"searchText\"></c></p>\n<p>子组件的内容<br>&lt;input type=”text” :value=”myInput” @input=”inputE($event)”&gt;</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">* 首先在使用组件的时候，使用v-mdoel方法。子组件，此时可以使用 model对象进行指定。当然，如果此时不指定怎么办</span><br><span class=\"line\"></span><br><span class=\"line\">* 对于有value的情况：</span><br><span class=\"line\"></span><br><span class=\"line\">  * 首先，对于父组件使用v-model传递给了子组件的值，子组件如果使用了value的变量名，则会以此值进行接收。就算是checkbox，也是使用的value进行接收。不管子组件的内容(目前我的测试来说。)</span><br><span class=\"line\"></span><br><span class=\"line\">  * ```</span><br><span class=\"line\">    props: &#123;</span><br><span class=\"line\">      value: &#123;</span><br><span class=\"line\">      \ttype: Boolean,</span><br><span class=\"line\">      \tdefalut: false,</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    </span><br><span class=\"line\">    记住props的写法，开始我写成了data式的写法，把默认值直接写在了后面，如果直接写后面是写变量的类型</span><br><span class=\"line\">    props: &#123;</span><br><span class=\"line\">    \tvalue: String,</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>对于没有value的情况：</p>\n<ul>\n<li><p>没有value，还没有添加一个model对象进行指定，那么就不会传入成功。</p>\n</li>\n<li><p>进行了model的指定，那么便会使用这个变量进行赋值。</p>\n<ul>\n<li>```<br>model: {<br>  prop: ‘myInput’,<br>  event: ‘inp’<br>},<br>props: [‘myInput’],<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">* 到此，我们已经解决了如何传值，下一步就是更新数据。</span><br><span class=\"line\"></span><br><span class=\"line\">  * 因为 v-model的特点就是会将值进行了绑定，所以我们只需要通知同步就行了</span><br><span class=\"line\"></span><br><span class=\"line\">  * ```</span><br><span class=\"line\">    &lt;input type=&quot;text&quot; :value=&quot;myInput&quot; @input=&quot;inputE($event)&quot;&gt;</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p>input事件，绑定了inputE方法，然后inputE里面通过$emit进行传递。事件名称就是model里面的事件名称，inp, 如果没有进行重命名，那么就是 input事件。父组件不需要做什么，因为v-model自动对事件和参数进行了赋值。当然，也是可以赋值常数的。</p>\n</li>\n</ul>\n</li>\n<li><p>同时我们通过这个案例也知道了，如果你对一个input输入框加了v-model，也加了input的监听，在input的监听修改了v-model的值，那么会以input的为主。</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"通过插槽分发内容\"><a href=\"#通过插槽分发内容\" class=\"headerlink\" title=\"通过插槽分发内容\"></a>通过插槽分发内容</h2><p>​        简单来说，就是可以在标签内部使用标签，然后标签可以传递给子元素显示。父元素的使用方式就是下面这样。子元素只需要定义一个 slot，然后slot的位置就会显示为你定义的。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;alert-box&gt;</span><br><span class=\"line\">  Something bad happened.</span><br><span class=\"line\">&lt;/alert-box&gt;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Vue.component(&#x27;alert-box&#x27;, &#123;</span><br><span class=\"line\">  template: `</span><br><span class=\"line\">    &lt;div class=&quot;demo-alert-box&quot;&gt;</span><br><span class=\"line\">      &lt;strong&gt;Error!&lt;/strong&gt;</span><br><span class=\"line\">      &lt;slot&gt;&lt;/slot&gt; 这里就会被渲染为其他的。</span><br><span class=\"line\">    &lt;/div&gt;`</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>​        这里在简单的说几个地方。</p>\n<p>​        1.如果使用了多个slot，默认每个slot都会全部都会显示，但是又不是你想的那种显示。我不知道怎么描述。直接看例子就懂了：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;p&gt;123&lt;/p&gt;</span><br><span class=\"line\">&lt;slot&gt;&lt;/slot&gt;</span><br><span class=\"line\">&lt;slot&gt;&lt;/slot&gt;</span><br><span class=\"line\">&lt;p&gt;321&lt;/p&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&lt;tt&gt;</span><br><span class=\"line\">  &lt;div&gt;123&lt;/div&gt;</span><br><span class=\"line\">  &lt;div&gt;321&lt;/div&gt;</span><br><span class=\"line\">&lt;/tt&gt;</span><br></pre></td></tr></table></figure>\n\n<p>​        下面这个我定义了两个slot，然后组件名为tt，tt里面有两个div标签值为123和321。你可能会认为一个 slot为123，一个slot为321.但是其实不是，因为你没有给定name，所以这两个div会被当成一个传递给插槽。然后两个插槽都会被赋值。所以值为</p>\n<img src=\"/.io//image-20211105095952701.png\" alt=\"image-20211105095952701\" style=\"zoom:50%;\">\n\n\n\n<p>​        那么要如何实现上面预想的效果呢，使用name。一个不带 <code>name</code> 的 <code>&lt;slot&gt;</code> 出口会带有隐含的名字“default”。</p>\n<p>​        然后就是父组件如何使用了，这里有三个写法</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div slot=&quot;aa&quot;&gt;123&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;template v-slot:aa&gt;</span><br><span class=\"line\">\t&lt;div&gt;123&lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;template #aa&gt;</span><br><span class=\"line\">\t&lt;div&gt;123&lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br></pre></td></tr></table></figure>\n\n<p>​        上面这三个写法，</p>\n<ul>\n<li><p>第一个是一个旧的写法，不建议，因为建议是使用一个template进行包裹，template作为一个html5的新特性。</p>\n</li>\n<li><p>第二个是使用的v-slot进行绑定。但是需要将其放在template上，才有效果</p>\n</li>\n<li><p>第三个就是第二个的一个语法糖写法。</p>\n</li>\n<li><p>然后就是如何使用变量，首先可以使用 v-bind 进行绑定。其次也可以使用 [] 进行表示。</p>\n<ul>\n<li>```<br>:slot=”name” :v-slot:name :#name<br>v-slot:[name] #[name]<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t然后就是插槽是会将值进行覆盖的。所以如果你在slot上写的一些样式和方法不会显示，对应的方式就是（**v-if，v-for** 有效果，因为这些是对DOM树进行了变化，所以会在DOM树的添加，而不是对一个属性的覆盖。但是对于一些class和v-show就没用了。）</span><br><span class=\"line\"></span><br><span class=\"line\">* 第一种，父元素写方法和样式，但是这样一个子组件就对父组件不透明了</span><br><span class=\"line\"></span><br><span class=\"line\">* 第二种，在外面套上一层标签。向下面这样就行了。</span><br><span class=\"line\"></span><br><span class=\"line\">  * ```</span><br><span class=\"line\">    &lt;div v-show=&quot;false&quot;&gt;</span><br><span class=\"line\">    \t&lt;slot&gt;&lt;/slot&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ul>\n<p>​        其他的部分，详见Vue的 <a href=\"https://cn.vuejs.org/v2/guide/components-slots.html\">插槽</a> 部分。</p>\n<h2 id=\"动态组件\"><a href=\"#动态组件\" class=\"headerlink\" title=\"动态组件\"></a>动态组件</h2><p>​        简单来说就是不同组件会进行动态切换，所以可以使用</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;component :is=&quot;name&quot;&gt;&lt;/component&gt;</span><br><span class=\"line\">&lt;button @click=&quot;change&quot;&gt;change&lt;/button&gt;</span><br></pre></td></tr></table></figure>\n\n<p>​        这里 component 是一个标签，is使用v-bind绑定了name，然后通过一个点击事件来修改了name的值，所以component，is就会被指定修改成其他的组件名。</p>\n<p>​        这个is属性应该是html里面的那个is属性，但是具体的使用方式我现在看不懂，可以取MDN里面进行了解，这里我们就当作is会指定一个组件名，然后这个component标签就会被替换成组件名。</p>\n<p>​        在上述示例中，name可以包括：</p>\n<ul>\n<li>已注册组件的名字，或</li>\n<li>一个组件的选项对象</li>\n</ul>\n<p>注意：</p>\n<p>​        这个is属性可以用于常规的html元素上。</p>\n<p>​        但是对于attribute将会作为DOM attribute进行绑定，对于像 <code>value</code> 这样的 property，若想让其如预期般工作，你需要使用 <a href=\"https://cn.vuejs.org/v2/api/#v-bind\"><code>.prop</code> 修饰器</a>。</p>\n<p>​        这里就扯出了 attribute 和 property 的一个区别，我这里就贴一个 <a href=\"https://stackoverflow.com/questions/6003819/properties-and-attributes-in-html#answer-6004028\">StackOverflow</a> 和 一个对应 StackOverflow 的 <a href=\"https://blog.csdn.net/rudy_zhou/article/details/104058741\">CSDN </a> 的一个中文的讲解 </p>\n<p>​        大概就是说，attribute属性是一个HTML的上的属性，而property是一个DOM对象上的属性。有的属性开始是继承了attribute，但是后续会被修改，此时可以从property看出，但是不会从attribute看出。</p>\n<h2 id=\"解析-DOM-模板时的注意事项\"><a href=\"#解析-DOM-模板时的注意事项\" class=\"headerlink\" title=\"解析 DOM 模板时的注意事项\"></a>解析 DOM 模板时的注意事项</h2><p>​        简单来说，就是有的HTML 元素限制了其内部的元素是哪些，对于不属于的，会被提升到外部，触发其他问题。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;ul&gt;、&lt;ol&gt;、&lt;table&gt; 和 &lt;select&gt;</span><br></pre></td></tr></table></figure>\n\n<p>​        有的元素是，只能存在于特定的元素内部</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;li&gt;、&lt;tr&gt; 和 &lt;option&gt;</span><br></pre></td></tr></table></figure>\n\n<p>​        案例</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;table&gt;</span><br><span class=\"line\">  &lt;blog-post-row&gt;&lt;/blog-post-row&gt;</span><br><span class=\"line\">&lt;/table&gt;</span><br></pre></td></tr></table></figure>\n\n<p>​        对于上面的情况，blog-post-row 会被提升到外部，所以会出现页面布局的问题。</p>\n<p>​        解决方式，使用is attribute。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;table&gt;</span><br><span class=\"line\">  &lt;tr is=&quot;blog-post-row&quot;&gt;&lt;/tr&gt;</span><br><span class=\"line\">&lt;/table&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>需要注意的是<strong>如果我们从以下来源使用模板的话，这条限制是<em>不存在</em> 的</strong>：</p>\n<ul>\n<li><p>字符串 (例如：<code>template: &#39;...&#39;</code>) </p>\n<ul>\n<li><pre><code>Vue.component(&#39;tt&#39;, &#123;\n  template: `\n    &lt;table&gt;\n        &lt;p&gt;1&lt;/p&gt;\n    &lt;/table&gt;\n  `,\n&#125;);\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">  - 此时 p 标签存在于table 内部。</span><br><span class=\"line\"></span><br><span class=\"line\">- [单文件组件 (`.vue`)](https://cn.vuejs.org/v2/guide/single-file-components.html) </span><br><span class=\"line\"></span><br><span class=\"line\">- [`&lt;script type=&quot;text/x-template&quot;&gt;`](https://cn.vuejs.org/v2/guide/components-edge-cases.html#X-Template) </span><br><span class=\"line\"></span><br><span class=\"line\">  ​\t当然这些，我也没有测试过，所以不清楚。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">至此，简单的一个基础就了解完了，详细的还是看看Vue官网的 文档和API吧</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\nhttps://cn.vuejs.org/v2/api/\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br></pre></td></tr></table></figure>\nhttps://cn.vuejs.org/v2/guide/\n</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n</div>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Vue的基本使用\"><a href=\"#Vue的基本使用\" class=\"headerlink\" title=\"Vue的基本使用\"></a>Vue的基本使用</h1><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">简单入门教程</span><br><span class=\"line\">\thttps://cn.vuejs.org/v2/guide/</span><br><span class=\"line\">API</span><br><span class=\"line\">\thttps://cn.vuejs.org/v2/api/</span><br><span class=\"line\"></span><br><span class=\"line\">在这里我就先进行一个简单的教程的学习。不过于深入了解。</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h1><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://cn.vuejs.org/v2/guide/index.html</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"引入\"><a href=\"#引入\" class=\"headerlink\" title=\"引入\"></a>引入</h2><p>​        这里我们使用 script 进行引入</p>\n<p>​        还可以使用 <strong>npm</strong> 进行下载引入 和 使用 <strong>VueCLI</strong> 脚手架，使用 npm 和 脚手架 的好处是，我们可以方便进行包管理。进行较大型应用时可以进行使用。但是我们这里的主要目的时了解 Vue 的基本使用和Vue 的一些规范，所以就直接使用 <strong>script</strong> 引入。</p>\n<p>​        对于 <strong>script</strong> 引入，有两种：</p>\n<ul>\n<li><p>第一种是直接进行引入。这种是创建了一个全局 Vue 的的实例，可以在后面进行使用，但是不能在前面进行使用。</p>\n<ul>\n<li>```<script src=\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\"></script>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">* 第二种是使用了 模块化 。 在引用以后，可以在改代码的后面直接进行使用。但是不能在 另外一个 script 标签内部使用，具体的原因是 使用了 module ，这个属于异步加载了。对于script 的异步我们后续在了解。</span><br><span class=\"line\"></span><br><span class=\"line\">  * ```</span><br><span class=\"line\">    &lt;script type=&quot;module&quot;&gt;</span><br><span class=\"line\">      import Vue from &#x27;https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.esm.browser.js&#x27;</span><br><span class=\"line\">      </span><br><span class=\"line\">      Vue.log;</span><br><span class=\"line\">    &lt;/script&gt;</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ul>\n<p>这里我们使用第一种引入。</p>\n<h2 id=\"声明式渲染\"><a href=\"#声明式渲染\" class=\"headerlink\" title=\"声明式渲染\"></a>声明式渲染</h2><h3 id=\"Mustache-语法-valueName\"><a href=\"#Mustache-语法-valueName\" class=\"headerlink\" title=\"Mustache 语法 { { valueName }}\"></a>Mustache 语法 { { valueName }}</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=&quot;app&quot;&gt;</span><br><span class=\"line\">  &#123; &#123; message &#125;&#125;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&gt;</span><br><span class=\"line\">&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">  const app = new Vue(&#123;</span><br><span class=\"line\">    el: &#x27;#app&#x27;,</span><br><span class=\"line\">    data: &#123;</span><br><span class=\"line\">      message: &#x27;test&#x27;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<p>​        这里这个 message 是响应式的。如果我们在浏览器控制台修改了 message 的值，页面也会对应发生变化。里面的原因是使用了 <strong>OBject.defineProperty()</strong> 对于 Vue 的响应式。我们后续在了解 Vue源码的时候在进行讨论。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app.message = &#x27;a&#x27;;</span><br><span class=\"line\"></span><br><span class=\"line\">页面会同时进行修改。</span><br></pre></td></tr></table></figure>\n\n<p>​        这里我们进行一个分析。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new Vue，这是一个 new 方法，会返回一个实例，里面的参数是一个对象，对象里面又是很多属性和对象的组成。</span><br><span class=\"line\"></span><br><span class=\"line\">这里出现了。el 和 data。</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">其中el，是你要绑定的元素， 可以是 CSS 选择器，也可以是一个 HTMLElement 实例。</span><br><span class=\"line\">\t参考：\thttps://cn.vuejs.org/v2/api/#el</span><br><span class=\"line\">CSS选择器： #app, .app, div.app ...</span><br><span class=\"line\">HTMLElement实例： </span><br><span class=\"line\">\tconst span = document.querySelector(&#x27;span.app&#x27;);</span><br><span class=\"line\">\tel: span.</span><br><span class=\"line\">其次，对于有多个满足的情况，只会对第一个进行编译。</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">data：</span><br><span class=\"line\">\t\t我们可以看出，这个是一个data的对象。然后是对对象里面的数据进行了一个响应式的处理。然后我们也可以在后续在开发时可以发现，data是一个 返回的对象。这里是因为对象是使用的地址赋值，如果不通过return &#123;&#125;, 会让共同使用的组件会使用相同的数据。但是如果是return &#123;&#125;。那么在每次返回时都会返回一个新的对象出来。而不会共同使用一个对象。 </span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"使用指令绑定-attribute-v-bind\"><a href=\"#使用指令绑定-attribute-v-bind\" class=\"headerlink\" title=\"使用指令绑定 attribute (v-bind)\"></a>使用指令绑定 attribute (v-bind)</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;span class=&quot;app&quot; v-bind:title=&quot;message&quot;&gt;</span><br><span class=\"line\">  &#123; &#123; message &#125;&#125;</span><br><span class=\"line\">&lt;/span&gt;</span><br></pre></td></tr></table></figure>\n\n<p>​        这里 v-bind 是 Vue 提供的 <code>attribute </code>。它可以绑定元素原有的 <code>attribute</code> 。这个指令的效果是： 将这个元素节点的 <code>title</code> attribute 和 Vue 实例的 <code>message</code> property 保持一致。</p>\n<p>​        可以通过使用 app.message = ‘new’; 可以发现，内容也随之更新。</p>\n<h2 id=\"条件与循环\"><a href=\"#条件与循环\" class=\"headerlink\" title=\"条件与循环\"></a>条件与循环</h2><h3 id=\"v-if\"><a href=\"#v-if\" class=\"headerlink\" title=\"v-if\"></a>v-if</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=&quot;app-3&quot;&gt;</span><br><span class=\"line\">  &lt;p v-if=&quot;seen&quot;&gt;现在你看到我了&lt;/p&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">var app3 = new Vue(&#123;</span><br><span class=\"line\">  el: &#x27;#app-3&#x27;,</span><br><span class=\"line\">  data: &#123;</span><br><span class=\"line\">    seen: true</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">这里设置的 seen ， 设置为 true ，就会显示。设置为 false ，就不会显示。</span><br></pre></td></tr></table></figure>\n\n<p>​        可以通过设置 v-if 来进行这个标签的显示和隐藏。此外，Vue 也提供一个强大的过渡效果系统，可以在 Vue 插入/更新/移除元素时自动应用<a href=\"https://cn.vuejs.org/v2/guide/transitions.html\">过渡效果</a>。</p>\n<p>​        这个过渡效果，我们后续在讲。</p>\n<p>​        <code>v-if</code> 可以控制一个标签的显示和隐藏，还有 <code>v-show</code> 也有一样的效果。</p>\n<p><strong>区别：</strong></p>\n<ul>\n<li>```<br><a href=\"https://cn.vuejs.org/v2/guide/conditional.html#v-if-vs-v-show\">https://cn.vuejs.org/v2/guide/conditional.html#v-if-vs-v-show</a><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">* `v-if` 也是**惰性的**：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。</span><br><span class=\"line\">* 相比之下，`v-show` 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。</span><br><span class=\"line\">* 如果需要非常频繁地切换，则使用 `v-show` 较好；如果在运行时条件很少改变，则使用 `v-if` 较好。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">### v-for</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<a href=\"https://cn.vuejs.org/v2/api/#v-for\">https://cn.vuejs.org/v2/api/#v-for</a><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">​\t\t`v-for` 指令可以绑定数组的数据来渲染一个项目列表：</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<div id=\"app-4\">\n<ol>\n  <li v-for=\"todo in todos\">\n    { { todo.text }}\n  </li>\n</ol>\n</div></li>\n</ul>\n<p>var app4 = new Vue({<br>  el: ‘#app-4’,<br>  data: {<br>    todos: [<br>      { text: ‘学习 JavaScript’ },<br>      { text: ‘学习 Vue’ },<br>      { text: ‘整个牛项目’ }<br>    ]<br>  }<br>})</p>\n<p>循环。 v-for=”item in items”，  会循环items，赋值给 item。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">**此外：**</span><br><span class=\"line\"></span><br><span class=\"line\">​\t在使用 **v-if** 搭配 v-for 时，**v-for** 的优先级会高于 **v-if**。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<li v-for=\"todo in todos\" v-if=\"todo.flag\">\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">​\t\t在控制台里，输入 `app4.todos.push(&#123; text: &#x27;新项目&#x27; &#125;)`，你会发现列表最后添加了一个新项目。</span><br><span class=\"line\"></span><br><span class=\"line\">**注意：**</span><br><span class=\"line\"></span><br><span class=\"line\">​\t这里使用了 **push**， 方式添加了新项目，页面发生了改变，但是如果是 app4.todos[4] = xxx， 这样就不会发生页面的改变，这里是因为Vue 响应式的原因，至于原理，我们后续在讲解。想要提前知道的可以了解一下，Object.defineProperty()。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">## 处理用户输入</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t用户和应用的交互，可以使用 **v-on** 指令来添加一个事件的监听器</span><br><span class=\"line\"></span><br><span class=\"line\">这里的 v-on，就代表了 on</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<button v-on:click=\"reverseMessage\">反转消息</button>\n\n<p><button onclick=\"reverseMessage()\">反转消息</button></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>var app5 = new Vue({<br>  el: ‘#app-5’,<br>  data: {<br>    message: ‘Hello Vue.js!’<br>  },<br>  methods: {<br>    reverseMessage: function () {<br>      this.message = this.message.split(‘’).reverse().join(‘’)<br>    }<br>  }<br>})</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">​\t\t这里新添加了一个 **methods** 的对象，里面存放的是方法。如果是使用 **Vue** 的属性 **attribute**， **v-on** ，来进行的绑定方法，那么就需要将方法写在这个methods 里面。不写在 methods 里面的方法是没有效果的。</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t其次，这里面建议不要使用 箭头函数，因为箭头函数 的this指向是和 当前的上下文 相关的，所以在箭头函数里面使用不了data的方法。箭头函数的指向是全局。</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t在这里，我们只需要写上逻辑，不需要操作DOM，这个就是 MVVM 中， Vue 的 VM，我们只需要在 M和V 上进行操作即可。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">## v-model 实现双向绑定</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\tv-bind，可以实现单向的绑定，就是指可以通过修改data数据来进行页面的修改。</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t但是，如果是对于一个 input 的输入框呢？</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t我们可以将 data 数据绑定到输入框作为一个初始值。</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t但是我们可以在对输入框进行输入时，同时修改 data 的数据吗。显然是不行的。所以就有了 v-model</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\tv-model ，它可以进行数据的双向绑定，不但用户的输入会修改 data， data 的变化也会影响视图。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<input v-model=\"message\">\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">​\t\t通过这个我们 可以看出，v-model 没有说使用value，还是什么，但是却有效果，这里是因为 v-model 会根据控件的类型自动选取正确的方法来更新。限制：\tinput， select， textarea， components</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\nhttps://cn.vuejs.org/v2/api/#v-model\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">## 组件化应用构建</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\tVue 的另一个重要的概念就是 **组件化** 。几乎任意应用界面都可以抽象为一个组件树。</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t在 Vue 中注册一个组件</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n// 定义名为 todo-item 的新组件\nVue.component('todo-item', {\n  template: '</li><li>这是个待办项</li>'\n})\n\n<p>var app = new Vue(…)</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">**示例：**</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<div id=\"app-6\">\n  <my-item></my-item>\n</div>\n\n\n<p>  Vue.component(‘my-item’, {<br>    template: ‘<li>这是个待办项</li>‘<br>  });</p>\n<p>  var app6 = new Vue({ el: ‘#app-6’ })</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">**注意点：**</span><br><span class=\"line\"></span><br><span class=\"line\">* 使用的方式是，需要在 new 的实例的 Vue 的内部进行调用，因为在 实例内部，你写的方式才会被 Vue 所编译，不然是不会被 Vue 编译的。</span><br><span class=\"line\"></span><br><span class=\"line\">* 其次，注册的组件需要在你 new 的实例前面，因为你在编译组件的时候要使用自定义的组件。所以，如果不在之前进行解析的话，就解析不了了。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">## 组件传值</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<div id=\"app-6\">\n  <my-item :todo=\"message\"></my-item>\n</div>\n\n\n<p>Vue.component(‘my-item’, {<br>  props: [‘todo’],<br>  template: ‘<li>这是个待办项 { { todo }}</li>‘,<br>});</p>\n<p>var app6 = new Vue({<br>  el: ‘#app-6’,<br>  data: {<br>      message: false<br>  }<br>})</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">​\t\t这里， props 是代表了获取到组件属性传递过来的值，在组件使用时，添加属性，这个属性是和 props 里面的名字相等。这里就是 todo， 其次， **:todo**，是一个语法糖，代表了 **v-bind:todo**，所以就会把 message 的值传递给 todo，然后再传递给 my-item。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"># Vue实例</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p><a href=\"https://cn.vuejs.org/v2/guide/instance.html\">https://cn.vuejs.org/v2/guide/instance.html</a></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">## 创建一个Vue实例</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t每个 Vue 应用都是通过用 `Vue` 函数创建一个新的 **Vue 实例**开始的：</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>var vm = new Vue({<br>  // 选项<br>})</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">​\t\t虽然没有完全遵循 [MVVM 模型](https://zh.wikipedia.org/wiki/MVVM)，但是 Vue 的设计也受到了它的启发。因此在文档中经常会使用 `vm` (ViewModel 的缩写) 这个变量名表示 Vue 实例。</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t至于为什么 Vue 没有完全遵循 MVVM 的原因是：Vue 中有一个属性，ref，这个属性可以拿到 DOM 对象，直接操作视图，所以违背了 MVVM。</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t在创建一个 Vue 实例时，你可以传入一个 [选项对象]([https://cn.vuejs.org/v2/api/#%E9%80%89%E9%A1%B9-%E6%95%B0%E6%8D%AE](https://cn.vuejs.org/v2/api/#选项-数据)) (data，methods...)。通过这些选项对象来创建你想要的行为。</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t一个 Vue 应用由一个通过 `new Vue` 创建的**根 Vue 实例**，以及可选的嵌套的、可复用的组件树组成。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">## 数据与方法</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t当一个 Vue 实例被创建时，它将 `data` 对象中的所有的 property 加入到 Vue 的**响应式系统**中。当这些 property 的值发生改变时，视图将会产生“响应”，即匹配更新为新的值。</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t大致就可以理解为，需要将数据放在了 data 里面，Vue 就会自动创建响应式。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>// 我们的数据对象<br>var data = { a: 1 }</p>\n<p>// 该对象被加入到一个 Vue 实例中<br>var vm = new Vue({<br>  data: data<br>})</p>\n<p>// 获得这个实例上的 property<br>// 返回源数据中对应的字段<br>vm.a == data.a // =&gt; true</p>\n<p>// 设置 property 也会影响到原始数据<br>vm.a = 2<br>data.a // =&gt; 2</p>\n<p>// ……反之亦然<br>data.a = 3<br>vm.a // =&gt; 3</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">​\t\t通过上面我们可以知道，data的数据是直接可以通过 实例的返回来直接获取，数据是直接暴露于实例的顶层。理所当然，methods 的方法也是一样，所以我们会思考，如果方法名和数据名重合会怎么办。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>  var app6 = new Vue({<br>    el: ‘#app-6’,<br>    data: {<br>      message: false<br>    },<br>    methods: {<br>      message() {<br>        console.log(1);<br>      }<br>    },<br>  })</p>\n<p>通过上面的案例可以看出，方法名是和 data 名称重合，所以在 data 已经创建了数据之后，方法创建会抛出异常。方法创建失败。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>  而如果是一个普通的对象，后面的会将前面的覆盖掉。</p>\n<p>  let obj = {<br>    a: 1,<br>    a() {<br>      console.log(2);<br>    }<br>  }<br>  console.log(obj);</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">​\t\t其次</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>使用 vm.b = 1;<br>这种后续添加数据的方式是不会变成响应式的。<br>以及，使用了 Object.freeze() 也会阻止修改现有的 property，也意味着响应系统无法再追踪变化。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">​\t\t除了数据 property，Vue 实例还暴露了一些有用的实例 property 与方法。它们都有前缀 `$`，以便与用户定义的 property 区分开来。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>var data = { a: 1 }<br>var vm = new Vue({<br>  el: ‘#example’,<br>  data: data<br>})</p>\n<p>vm.$data === data // =&gt; true<br>vm.$el === document.getElementById(‘example’) // =&gt; true</p>\n<p>// $watch 是一个实例方法<br>vm.$watch(‘a’, function (newValue, oldValue) {<br>  // 这个回调将在 <code>vm.a</code> 改变后调用<br>})</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">​\t\t你可以在 [API 参考](https://cn.vuejs.org/v2/api/#实例-property)中查阅到完整的实例 property 和方法的列表。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">## 实例生命周期钩子</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t生命周期钩子简单来说就是一个回调函数。在 Vue 在执行到每个过程的时候也会执行这些生命周期的钩子。</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t**举个栗子：**</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>new Vue({<br>  data: {<br>    a: 1<br>  },<br>  created: function () {<br>    // <code>this</code> 指向 vm 实例<br>    console.log(‘a is: ‘ + this.a)<br>  }<br>})<br>// =&gt; “a is: 1”</p>\n<p>在 created 钩子可以用来在一个实例被创建之后执行代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">**注意：**</span><br><span class=\"line\"></span><br><span class=\"line\">&gt; 不要在选项 property 或回调上使用[箭头函数](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions)，比如 `created: () =&gt; console.log(this.a)` 或 `vm.$watch(&#x27;a&#x27;, newValue =&gt; this.myMethod())`。因为箭头函数并没有 `this`，`this` 会作为变量一直向上级词法作用域查找，直至找到为止，经常导致 `Uncaught TypeError: Cannot read property of undefined` 或 `Uncaught TypeError: this.myMethod is not a function` 之类的错误。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">## 生命周期图示</span><br><span class=\"line\"></span><br><span class=\"line\">![lifecycle](Vue2-教程-基础使用/lifecycle.png)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"># 模板语法</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p><a href=\"https://cn.vuejs.org/v2/guide/syntax.html\">https://cn.vuejs.org/v2/guide/syntax.html</a></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">## 插值</span><br><span class=\"line\"></span><br><span class=\"line\">**文本：**</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t数据绑定最常见的形式就是使用“Mustache”语法 (双大括号) 的文本插值：</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p><span>Message: { { msg }}</span></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">这里 msg 会替代为 数据对象的 msg。并且还带有响应式的功能。</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t通过使用 [v-once 指令](https://cn.vuejs.org/v2/api/#v-once)，你也能执行一次性地插值，当数据改变时，插值处的内容不会更新。但请留心这会影响到该节点上的其它数据绑定：</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p><span v-once>这个将不会改变: { { msg }}</span></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">**原始HTML：**</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t双大括号会将数据解释为普通文本，而非 HTML 代码。为了输出真正的 HTML，你需要使用 [`v-html` 指令](https://cn.vuejs.org/v2/api/#v-html)：</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p><span v-html=\"rawHtml\"></span></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">​\t\t会将 span 的内容替换为 rawHtml。并且在里面不会解析 proterty。</span><br><span class=\"line\"></span><br><span class=\"line\">&gt; 你的站点上动态渲染的任意 HTML 可能会非常危险，因为它很容易导致 [XSS 攻击](https://en.wikipedia.org/wiki/Cross-site_scripting)。请只对可信内容使用 HTML 插值，**绝不要**对用户提供的内容使用插值。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">**Attribute：（属性）**</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\tMustache 语法不能作用在 HTML 标签的属性上，所以要使用 v-bind 指令。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<div v-bind:id=\"dynamicId\"></div>\n\n<p>对于同时使用了 v-bind:id 和 id 的。我们可以发现，谁在后面，其结果就是谁。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">​\t\t对于布尔值的 attribute，原生的HTML中，只要存在就意味着值为 true，而 v-bind，工作起来当值为 false，null等，甚至不会渲染。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">**使用 JavaScript 表达式：**</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t对于所有的数据绑定，Vue.js 都提供了完全的 JavaScript 表达式支持。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>{ { number + 1 }}</p>\n<p>{ { ok ? ‘YES’ : ‘NO’ }}</p>\n<p>{ { message.split(‘’).reverse().join(‘’) }}</p>\n<div v-bind:id=\"'list-' + id\"></div>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">## 指令</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t指令 (Directives) 是带有 `v-` 前缀的特殊 attribute。</span><br><span class=\"line\"></span><br><span class=\"line\">**参数：**</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t一些指令能够接收一个“参数”，在指令名称之后以冒号表示。例如，`v-bind` 指令可以用于响应式地更新 HTML attribute：</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<a v-bind:href=\"url\">...</a>\n\n<p>此时这个url是和数据的url是绑定的。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">​\t\t`v-on` 指令，它用于监听 DOM 事件：</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p><a v-on:click=\"doSomething\">…</a><br>同时也有 mouseover 等等。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">**注意：**</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t使用 v-on 指令监听 DOM 事件，原生的 onclick 方法会先于 v-on 进行监听，其次这个 v-on 里面的方法，既可以是 methods 的，也可以是 data 的。但是建议写在 methods 中。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<div id=\"app-6\">\n  <button @click=\"test1\" onclick=\"console.log(1);\">Button</button>\n</div>\n//其中这里这个 @ 代表了 v-on 的语法糖，我们后续会讲。\n\n<pre><code>let obj = &#123;\nmessage: true,\ntest1() &#123;\n  console.log(3);\n&#125;\n</code></pre>\n<p>  }</p>\n<p>  var app6 = new Vue({<br>    el: ‘#app-6’,<br>    data: obj,<br>    methods: {<br>      test() {<br>        console.log(2);<br>      }<br>    }<br>  })</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">**动态参数： 2.6.0新增**</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t可以用方括号括起来的 JavaScript 表达式作为一个指令的参数：</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<!--\n注意，参数表达式的写法存在一些约束，如之后的“对动态参数表达式的约束”章节所述。\n-->\n<p>&lt;a v-bind:[attributeName]=”url”&gt; … </p>\n<p>&lt;a v-on:[eventName]=”doSomething”&gt; … <br>@[]，也可以。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">​\t\t这里的 `attributeName` 会被作为一个 JavaScript 表达式进行动态求值，求得的值将会作为最终的参数来使用。这里的Vue实例中有 data property attributeName，值为 href，则就等价于 v-bind:href=&quot;url&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">​\t**对动态参数的值的约束**</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t动态参数预期会求出一个字符串，异常情况下值为 `null`。这个特殊的 `null` 值可以被显性地用于移除绑定。任何其它非字符串类型的值都将会触发一个警告。</span><br><span class=\"line\"></span><br><span class=\"line\">​\t**对动态参数表达式的约束**</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t动态参数表达式有一些语法约束，因为某些字符，如空格和引号，放在 HTML attribute 名里是无效的。例如：</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<!-- 这会触发一个编译警告 -->\n<p>&lt;a v-bind:[‘foo’ + bar]=”value”&gt; … </p>\n<p>使用引号会无法编译。<br>并且使用了空格也会无法编译。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">​\t\t变通的办法是使用没有空格或引号的表达式，或用计算属性替代这种复杂表达式。</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t在 DOM 中使用模板时 (直接在一个 HTML 文件里撰写模板)，还需要避免使用大写字符来命名键名，因为浏览器会把 attribute 名全部强制转为小写：</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<!--\n在 DOM 中使用模板时这段代码会被转换为 `v-bind:[someattr]`。\n除非在实例中有一个名为“someattr”的 property，否则代码不会工作。\n-->\n<p>&lt;a v-bind:[someAttr]=”value”&gt; … </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">**修饰符：**</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t修饰符 (modifier) 是以半角句号 `.` 指明的特殊后缀，用于指出一个指令应该以特殊方式绑定。例如，`.prevent` 修饰符告诉 `v-on` 指令对于触发的事件调用 `event.preventDefault()`：</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t与之相应的还有 `.laze` `.once` 等等。我们后续进行讲解。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">## 缩写 语法糖</span><br><span class=\"line\"></span><br><span class=\"line\">**v-bind 缩写**：</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<!-- 完整语法 -->\n<p><a v-bind:href=\"url\">…</a></p>\n<!-- 缩写 -->\n<p><a :href=\"url\">…</a></p>\n<!-- 动态参数的缩写 (2.6.0+) -->\n<p>&lt;a :[key]=”url”&gt; … </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">**v-on 缩写：**</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<!-- 完整语法 -->\n<p><a v-on:click=\"doSomething\">…</a></p>\n<!-- 缩写 -->\n<p>&lt;a @click=”doSomething”&gt;…</p>\n<!-- 动态参数的缩写 (2.6.0+) -->\n<p>&lt;a @[event]=”doSomething”&gt; … </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"># 计算属性和侦听器</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p><a href=\"https://cn.vuejs.org/v2/guide/computed.html\">https://cn.vuejs.org/v2/guide/computed.html</a></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">## 计算属性</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t简单来说，就是将逻辑更深层的解耦，比如：</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>{ { message.split(‘’).reverse().join(‘’) }}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">​\t\t在模板中放入太多的逻辑会让模板过重且难以维护。</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t在这个地方，模板不再是简单的声明式逻辑。你必须看一段时间才能意识到，这里是想要显示变量 `message` 的翻转字符串。当你想要在模板中的多处包含此翻转字符串时，就会更加难以处理。</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t所以，对于任何复杂逻辑，你都应当使用**计算属性**。</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t我认为，从一个开发来看，对于一个表达式，如果以后会有多个地方进行相同的逻辑的使用，就应当使用计算属性，方便维护。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">### 基础例子</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<div id=\"app-6\">\n  { { message }}\n  <br>\n  { { reversedMessage }}\n</div>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br></pre></td></tr></table></figure>\n  const vm = new Vue({\n    el: '#app-6',\n    data: {\n      message: 'true',\n    },\n    computed: {\n      // 计算属性的 getter\n      reversedMessage: function () {\n        // `this` 指向 vm 实例\n        return this.message.split('').reverse().join('')\n      }\n    },\n  })\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">​\t\t这里我们声明了一个计算属性 `reversedMessage`。我们提供的函数将用作 property `vm.reversedMessage` 的 getter 函数</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t计算属性默认是的方法是一个getter 方法， 就像是使用了 `Object.defineProperty` 的getter一样进行了操作。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">## 计算属性缓存 VS 方法</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t我们也可以发现，可以在插值表达式中使用方法来获取同样的效果。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>{ { reversedMessage() }}</p>\n\n<p>methods: {<br>  reversedMessage: function () {<br>    return this.message.split(‘’).reverse().join(‘’)<br>  }<br>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">​\t\t首先，对于结果来说是完全相同的。不同的地方在于，**计算属性是基于它们的响应式依赖进行缓存的**。意思就是说，只有相关的响应式依赖发生了改变，他们才会重新求值。没有发生改变，多次使用计算属性会立即返回之前的结果。</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t**举个栗子：**</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<div id=\"app-6\">\n  { { message }}\n  <br>\n  { { reversedMessage }}\n  <br>\n  { { reversedMessage }}\n  <br>\n  { { reversedMessage }}\n</div>\n\n\n<p>  const vm = new Vue({<br>    el: ‘#app-6’,<br>    data: {<br>      message: ‘true’,<br>    },<br>    computed: {<br>      // 计算属性的 getter<br>      reversedMessage: function () {<br>        // <code>this</code> 指向 vm 实例<br>        console.log(1);<br>        return this.message.split(‘’).reverse().join(‘’)<br>      }<br>    },<br>  })</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">​\t\t我这里使用了很多个插值表达式，但是发现控制台的输出，只有一个，这里代表了后续是直接使用的之前的计算结果。</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t其次，在值发生变化之时，也只输出了一次。因此计算属性的缓存效果则比方法有了更好的性能。</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t当然，如果不希望有缓存的存在，可以使用方法来替代。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">## 计算属性 VS 侦听属性</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\tVue 提供了一种更通用的方式来观察和响应 Vue 实例上的数据变动：**侦听属性**。 `watch`  。</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t侦听属性 和 计算属性的不同</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>watch: {<br>  firstName: function (val) {<br>      this.fullName = val + ‘ ‘ + this.lastName<br>  },<br>  lastName: function (val) {<br>      this.fullName = this.firstName + ‘ ‘ + val<br>  }<br>},<br>computed: {<br>  fullName: function () {<br>      return this.firstName + ‘ ‘ + this.lastName<br>  }<br>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">​\t\t从上面可以看出，侦听属性(watch)的特点是，当一个属性发生改变后，调用的方法。</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t其次，需要对其进行初始化，因为在最开始侦听属性不会进行调用。</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t最后，这个侦听属性的执行时机，我们通过一个简单的死循环就可以看出。侦听属性在 DOM 的变化之前。但是处于值的变化之后。起码下面这个情况满足。这个说法。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>watch: {<br>  message: function (val) {<br>  console.log(this.message);<br>  while (true) {<br>      console.log(this.message);<br>  }<br>      this.reversedMessage = val + ‘ — ‘;<br>  }<br>},</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">## 计算属性的setter</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t默认计算属性只有 getter，不过在需要时你也可以提供一个 setter。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>computed: {<br>  fullName: {<br>    // getter<br>    get: function () {<br>      return this.firstName + ‘ ‘ + this.lastName<br>    },<br>    // setter<br>    set: function (newValue) {<br>      var names = newValue.split(‘ ‘)<br>      this.firstName = names[0]<br>      this.lastName = names[names.length - 1]<br>    }<br>  }<br>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">​\t\t在运行 `vm.fullName = &#x27;John Doe&#x27;` 时，setter 会被调用，`vm.firstName` 和 `vm.lastName` 也会相应地被更新。</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t当然，如果你这样写，只能说你是小机灵鬼了，一直调用了 setter 方法导致溢出。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>set: function (newValue) {<br>  console.log(newValue);<br>  this.reversedMessage += ‘1’;<br>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">​\t\t同时我们也可以使用一些简单的方式查看这个 setter 的执行时机。通过下面这个方式，我们发现了，setter 的执行在值的变化之前。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>computed: {<br>  // 计算属性的 getter<br>  reversedMessage: {<br>    get: function () {<br>      // <code>this</code> 指向 vm 实例<br>      console.log(1);<br>      return this.message.split(‘’).reverse().join(‘’)<br>    },<br>    set: function (newValue) {<br>      console.log(this.reversedMessage, newValue);<br>      while (true) {<br>      console.log(this.reversedMessage);<br>    };<br>  }<br>},</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">## 侦听器</span><br><span class=\"line\"></span><br><span class=\"line\">&gt; ​\t\t虽然计算属性在大多数情况下更合适，但有时也需要一个自定义的侦听器。这就是为什么 Vue 通过 `watch` 选项提供了一个更通用的方法，来响应数据的变化。当需要在数据变化时执行异步或开销较大的操作时，这个方式是最有用的。</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t简单来说就是对于一个异步，和一个开销大的操作时，监听器比较合适。</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t异步操作，限制访问频率(防抖)，设置中间状态等。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"># Class 与 Style 绑定</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p><a href=\"https://cn.vuejs.org/v2/guide/class-and-style.html\">https://cn.vuejs.org/v2/guide/class-and-style.html</a></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">​\t\t在将 `v-bind` 用于 `class` 和 `style` 时，Vue.js 做了专门的增强。表达式结果的类型除了字符串之外，还可以是对象或数组。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">## 绑定 HTML Class</span><br><span class=\"line\"></span><br><span class=\"line\">### 对象语法</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>v-bind:class=”{ active: isActive, ‘text-danger’: hasError }”</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">​\t\t这样，就会根据 后面的真值来判断前面这个类是否能存在。并且这里 active 是一个字符串，就算这个 active 和后面的一个 data 数据重名，最终渲染的还是一个字符串。如何能让 active 也变成一个变量类型，</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<div v-bind:class=\"{ [message]: flag }\"></div>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">​\t\t这里使用了动态绑定，所以 message  会从data里面进行查找。找不到则为 undefined 的字符串。并且可以使用 .undefined 来进行操作。对于不是字符串的，会转为字符串处理。</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t并且绑定的数据对象不必内联定义在模板里。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<div v-bind:class=\"classObject\"></div>\n\n<p>data: {<br>  classObject: {<br>    active: true,<br>    ‘text-danger’: false<br>  }<br>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">​\t\t如果写在 data 里面，我还不知道如何将类名动态绑定。并且后面的 true 和 false 都是写死的那种，只能在后续使用方法改变。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<pre><code>computed: &#123;\n  classObject: function () &#123;\n    return &#123;\n      [this.message]: this.flag\n    &#125;\n  &#125;\n&#125;,\n</code></pre>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">​\t\t如果写在计算属性里面，那么类名和真值都可以通过 this 进行获取。类名还是一样通过 [] 获取。不加上就会直接当成一个字符串。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">### 数组语法</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t我们可以把一个数组传给 `v-bind:class`，以应用一个 class 列表</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<div v-bind:class=\"[activeClass, errorClass]\"></div>\n\n<p>data: {<br>  activeClass: ‘active’,<br>  errorClass: ‘text-danger’<br>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">​\t\t对于不是字符串的，不会被显示，需要是字符串类型才会显示。</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t同时，也能写三元表达式</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<div v-bind:class=\"[isActive ? activeClass : '', errorClass]\"></div>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">​\t\t在数组语法中也可以使用对象语法：</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<div v-bind:class=\"[{ active: isActive }, errorClass]\"></div>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">### 在组件上</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t当在一个自定义组件上使用 `class` property 时，这些 class 将被添加到该组件的根元素上面。这个元素上已经存在的 class 不会被覆盖。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\nVue.component('my-component', {\n  template: '<p class=\"foo bar\">Hi</p>'\n})\n\n<p><my-component class=\"baz boo\"></my-component></p>\n<p class=\"foo bar baz boo\">Hi</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">​\t\t在渲染的时候，重复的类名不会被消除。当然，最终的渲染结果还是看CSS的权重级别。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">## 绑定内联样式</span><br><span class=\"line\"></span><br><span class=\"line\">### 对象语法</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t`v-bind:style` 的对象语法十分直观——看着非常像 CSS，但其实是一个 JavaScript 对象。CSS property 名可以用驼峰式 (camelCase) 或短横线分隔 (kebab-case，记得用引号括起来) 来命名</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<div v-bind:style=\"{ color: activeColor, fontSize: fontSize + 'px' }\"></div>\n\n<div v-bind:style=\"{ color: activeColor, 'font-size': fontSize + 'px' }\"></div>\n\n<p>data: {<br>  activeColor: ‘red’,<br>  fontSize: 30<br>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">​\t\t当然也能绑定到一个样式对象。大致还是和上面的要求一样。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">### 数组语法</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t`v-bind:style` 的数组语法可以将多个样式对象应用到同一个元素上：</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<div v-bind:style=\"[activeColor]\">123</div>\n\n<p>activeColor: {<br>    fontSize: ‘30px’<br>},</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">​\t\t当然，也能将其作为一个数组加对象整合为一个返回值，绑定到一个样式对象。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">### 自动添加前缀</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t当 `v-bind:style` 使用需要添加[浏览器引擎前缀](https://developer.mozilla.org/zh-CN/docs/Glossary/Vendor_Prefix)的 CSS property 时，如 `transform`，Vue.js 会自动侦测并添加相应的前缀。</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t其次，对于使用了 v-bind:style 和 style 的，会以 v-bind:style 为主。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">### 多重值 （2.3.0）</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t从 2.3.0 起你可以为 `style` 绑定中的 property 提供一个包含多个值的数组，常用于提供多个带前缀的值</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<div :style=\"{ display: ['-webkit-box', '-ms-flexbox', 'flex'] }\"></div>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">​\t\t这样写只会渲染数组中最后一个被浏览器支持的值。在本例中，如果浏览器支持不带浏览器前缀的 flexbox，那么就只会渲染 `display: flex`。</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t**意思就是说**，对于这样的一个值的数组，我们会从后往前进行赋值，直到遇到浏览器可以支持的值，例如本例来说，先判断，flex，再判断 -ms-flexbox，最后再判断 -webkit-box。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"># 条件渲染</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\nhttps://cn.vuejs.org/v2/guide/conditional.html\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">## v-if</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t`v-if` 指令用于条件性地渲染一块内容。这块内容只会在指令的表达式返回 truthy 值的时候被渲染。</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t也可以用 `v-else` 添加一个“else 块”：</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h1 v-if=\"awesome\">Vue is awesome!</h1>\n<h1 v-else>Oh no 😢</h1>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">### 在 `&lt;template&gt;` 元素上使用 `v-if` 条件渲染分组</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t因为 `v-if` 是一个指令，所以必须将它添加到一个元素上。但是如果想切换多个元素呢？此时可以把一个 `&lt;template&gt;` 元素当做不可见的包裹元素，并在上面使用 `v-if`。最终的渲染结果将不包含 `&lt;template&gt;` 元素。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<template v-if=\"ok\">\n  <h1>Title</h1>\n  <p>Paragraph 1</p>\n  <p>Paragraph 2</p>\n</template>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">​\t\t这里很好理解。首先 v-if 只能添加到一个元素上，所以我们使用了一个元素进行了包裹，然后这个 template 的一个特点就是不会显示，例如</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<template>\n    <div>123</div>\n</template>\n\n<p>最终的显示结果就是</p>\n<div>123</div>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">​\t\t所以这个的好处在于，既能产生包裹，还能不将其 DOM 的结构进行变化。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">### v-else</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t你可以使用 `v-else` 指令来表示 `v-if` 的“else 块”</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t`v-else` 元素必须紧跟在带 `v-if` 或者 `v-else-if` 的元素的后面，否则它将不会被识别。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<div v-if=\"Math.random() > 0.5\">\n  Now you see me\n</div>\n<div v-else>\n  Now you don't\n</div>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">### v-else-if（2.1.0）</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t`v-else-if`，顾名思义，充当 `v-if` 的“else-if 块”，可以连续使用</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t类似于 `v-else`，`v-else-if` 也必须紧跟在带 `v-if` 或者 `v-else-if` 的元素之后。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<div v-if=\"type === 'A'\">A</div>\n<div v-else-if=\"type === 'B'\">B</div>\n<div v-else>Not A/B/C</div>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">### 用 `key` 管理可复用的元素</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\tVue 会尽可能高效地渲染元素，通常会复用已有元素而不是从头开始渲染。这么做除了使 Vue 变得非常快之外，还有其它一些好处。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<template v-if=\"loginType === 'username'\">\n  <label>Username</label>\n  <input placeholder=\"Enter your username\">\n</template>\n<template v-else>\n  <label>Email</label>\n  <input placeholder=\"Enter your email address\">\n</template>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">​\t\t那么在上面的代码中切换 `loginType` 将不会清除用户已经输入的内容。因为两个模板使用了相同的元素，`&lt;input&gt;` 不会被替换掉——仅仅是替换了它的 `placeholder`。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t对于上述的代码，切换了 input  的输入框，但是却对于 value 值没有发生改变。但是如果我们会发现对于类名，style等属性是会发生改变。我们同时也可以知道 value 是input输入框的值，如果是对于 DOM 元素，可以通过 value 进行获取，但是在这里，虽然使用了 value 的属性，但是只要进行输入了，value 的值也不起效果。</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t但是我们同时也发现了，再切换之后，DOM 的指向没有改变。并且也发现了 value 的值在控制台的输出是有变化的。只是对于输入框的内容没有变化。个人猜测，这里input的输入和value 其实中间不是完全直接对应。输入框显示的 value 只是作为了一个最初值。但是内部的value已经发生了变化。</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t当然解决这个方法很简单。</span><br><span class=\"line\"></span><br><span class=\"line\">*  Vue 为你提供了一种方式来表达“这两个元素是完全独立的，不要复用它们”。只需添加一个具有唯一值的 `key` attribute 即可</span><br><span class=\"line\"></span><br><span class=\"line\">  * ```</span><br><span class=\"line\">    &lt;input placeholder=&quot;Enter your username&quot; key=&quot;username-input&quot;&gt;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>这里，只需要 key 值不同即可。并且发现加了 key 值之后， DOM 获取的元素已经不会根据你的按钮发生变化，并且值也不会发生变化了，因为已经不是一个 input 框了，就算是换回来也不是一个了，因为 v-if 是直接修改了 DOM 树。</p>\n</li>\n<li><p>```</p>\n<template v-if=\"loginType === 'username'\">\n  <label>Username</label>\n  <input key=\"a\" class=\"a\" style=\"color: red; font-size: 20px\" placeholder=\"Enter your username\" value=\"1\">\n</template>\n<template v-else>\n  <label>Email</label>\n  <input key=\"b\" class=\"b\" placeholder=\"Enter your email address\" value=\"2\">\n</template>\n\n\n<p>记住，这个需要放在 vue实例之后，应该是因为 template 的原因。<br>const a = document.querySelector(‘input.a’),</p>\n<pre><code>b = document.querySelector(&#39;input.b&#39;);\n</code></pre>\n<p>function c() {<br>  console.log(a);<br>  console.log(a.value);<br>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">* 当然，还可以使用 v-model 将数据进行绑定，那么input输入框的显示也会跟数据有关了。并且 v-model 是进行的复用。因为 DOM 的输出是会发生变化的。并且输入框和data数据是实时绑定了的。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">## v-show</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t另一个用于根据条件展示元素的选项是 `v-show` 指令。用法大致一样</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h1 v-show=\"ok\">Hello!</h1>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">​\t\t同的是带有 `v-show` 的元素始终会被渲染并保留在 DOM 中。`v-show` 只是简单地切换元素的 CSS property `display`。</span><br><span class=\"line\"></span><br><span class=\"line\">&gt; 注意，`v-show` 不支持 `&lt;template&gt;` 元素，也不支持 `v-else`。</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\tv-show 不支持 template 元素，意思就是说，你在 template 元素上使用 v-show，不管是 true 还是 false，template 都会显示在页面上，而如果你使用v-if就会发现，结果是不一样的。</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\tv-show 不支持 v-else，就如字面上来说，不支持的意思。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">## v-if VS v-show</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t`v-if` 是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t`v-if` 也是**惰性的**：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t相比之下，`v-show` 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t一般来说，`v-if` 有更高的切换开销，而 `v-show` 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 `v-show` 较好；如果在运行时条件很少改变，则使用 `v-if` 较好。</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t**简单概括：**</span><br><span class=\"line\"></span><br><span class=\"line\">* **v-if** 是会直接和 DOM 树相关。而 **v-show** 只是简单的使用了 display:none，和渲染树相关。</span><br><span class=\"line\">* 所以 v-if 对于切换会产生高开销，因为每次都会进行 DOM 的修改。而 v-show 会产生初始渲染的高开销，因为不管是否显示都会渲染。</span><br><span class=\"line\">* 所以，对于频繁切换使用 v-show，对于很少改变使用 v-if。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">## v-if 和 v-for 一起使用</span><br><span class=\"line\"></span><br><span class=\"line\">&gt; **不推荐**同时使用 `v-if` 和 `v-for`。请查阅[风格指南](https://cn.vuejs.org/v2/style-guide/#避免-v-if-和-v-for-用在一起-必要)以获取更多信息。</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t当 `v-if` 与 `v-for` 一起使用时，`v-for` 具有比 `v-if` 更高的优先级。请查阅[列表渲染指南](https://cn.vuejs.org/v2/guide/list.html#v-for-with-v-if)以获取详细信息。</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t当它们处于同一节点，`v-for` 的优先级比 `v-if` 更高，这意味着 `v-if` 将分别重复运行于每个 `v-for` 循环中。当你只想为*部分*项渲染节点时，这种优先级的机制会十分有用。</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t通过查看了 风格指南，主要说几点：</span><br><span class=\"line\"></span><br><span class=\"line\">* 避免一起使用</span><br><span class=\"line\"></span><br><span class=\"line\">* 对于需要过滤一个列表中的项目，采用计算属性</span><br><span class=\"line\"></span><br><span class=\"line\">  * ```</span><br><span class=\"line\">    v-for=&quot;user in users&quot; v-if=&quot;user.isActive&quot;</span><br><span class=\"line\">    </span><br><span class=\"line\">    可以对 user 使用一个计算属性 activeUser 使用filter过滤后返回</span><br><span class=\"line\">    v-for=&quot;user in activeUsers&quot;</span><br><span class=\"line\">    </span><br><span class=\"line\">    computed: &#123;</span><br><span class=\"line\">    \tactiveUsers: function() &#123;</span><br><span class=\"line\">    \t\treturn this.users.filter((user) =&gt; user.isActive);</span><br><span class=\"line\">    \t&#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>对于会直接应该被隐藏的列表，将 v-if 放在上层，不要在每次循环的时候判断</p>\n<ul>\n<li>```<br>v-for=”user in users” v-if=”shouldShowUsers”shouldShowUsers 这是对一个 users 进行的判断，只要为 false，所有的 users都不会显示，所以这个建议放在上层<br>v-if=”shouldShowUsers”<pre><code>v-for=&quot;user in users&quot;\n</code></pre>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"># 列表渲染</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<a href=\"https://cn.vuejs.org/v2/guide/list.html\">https://cn.vuejs.org/v2/guide/list.html</a><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">## 用 v-for 把一个数组对应为一组元素</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t我们可以用 `v-for` 指令基于一个数组来渲染一个列表。`v-for` 指令需要使用 `item in items` 形式的特殊语法，其中 `items` 是源数据数组，而 `item` 则是被迭代的数组元素的**别名**。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<ul id=\"example-1\">\n<li v-for=\"item in items\" :key=\"item.message\">\n\n</li>\n</ul></li>\n</ul>\n</li>\n</ul>\n<p>items: [<br>  { message: ‘Foo’ },<br>  { message: ‘Bar’ }<br>]</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">​\t\t`v-for` 还支持一个可选的第二个参数，即当前项的索引。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<li v-for=\"(item, index) in items\">\n     -  - \n</li>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">​\t\tindex 从0开始。</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t你也可以用 `of` 替代 `in` 作为分隔符，因为它更接近 JavaScript 迭代器的语法</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<div v-for=\"item of items\"></div>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">## 在 `v-for` 里使用对象</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t你也可以用 `v-for` 来遍历一个对象的 property。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<li v-for=\"value in object\">\n    \n</li>\n\n<p>object: {<br>  title: ‘How to do lists in Vue’,<br>  author: ‘Jane Doe’,<br>  publishedAt: ‘2016-04-10’<br>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">​\t\t你也可以提供第二个的参数为 property 名称 (也就是键名)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<div v-for=\"(value, name) in object\">\n  : \n</div>\n\n<p>title: How to do lists in Vue</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">​\t\t还可以用第三个参数作为索引</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<div v-for=\"(value, name, index) in object\">\n\n<p>0<br>1<br>2</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">&gt; ​\t\t在遍历对象时，会按 `Object.keys()` 的结果遍历，但是**不能**保证它的结果在不同的 JavaScript 引擎下都一致。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">**注意：**</span><br><span class=\"line\"></span><br><span class=\"line\">* 如果 v-for 里面是一个正整数n，那么将会变成 1~n，如果是一个小数，会报错。</span><br><span class=\"line\">  * 因为这个方法是会对其进行length操作，所以对于非正整数将出问题。</span><br><span class=\"line\">* 如果v-for里面是一个字符串，那么将会把字符串挨个字符输出。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">## 维护状态</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t当 Vue 正在更新使用 `v-for` 渲染的元素列表时，它默认使用“就地更新”的策略。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序，而是就地更新每个元素，并且确保它们在每个索引位置正确渲染。这个类似 Vue 1.x 的 `track-by=&quot;$index&quot;`。</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t**简单来说就是**，发现了变化，不会查看是否是有匹配的 DOM，而是直接将原来位置上的DOM进行改变。比如如果只是位置发生了改变，如果使用默认的方式，那么就会挨着将DOM进行修改，但是如果使用了key来进行维护，那么会查看是否有key值存在的，有的话就会直接使用key的DOM进行维护。没有再创建。</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t这个默认的模式是高效的，但是**只适用于不依赖子组件状态或临时 DOM 状态 (例如：表单输入值) 的列表渲染输出**。</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t**这里给的意思就是说**，如果对于依赖了子组件话，那么进行修改的时候需要耗费大量的时间，所以需要进行一些判断来处理要使用什么方法。</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t为了给 Vue 一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一 `key` attribute</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t就是说可以使用key来进行定位。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<div v-for=\"item in items\" v-bind:key=\"item.id\">\n  <!-- 内容 -->\n</div>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">​\t\t建议尽可能在使用 `v-for` 时提供 `key` attribute，除非遍历输出的 DOM 内容非常简单，或者是刻意依赖默认行为以获取性能上的提升。</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t因为它是 Vue 识别节点的一个通用机制，`key` 并不仅与 `v-for` 特别关联。后面我们将在指南中看到，它还具有其它用途。</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t其次对于key值，不要使用index下标进行赋值，因为如果你对数组进行了变化，位置变化等，可能下标也会发生改变，这样可能还会降低性能。</span><br><span class=\"line\"></span><br><span class=\"line\">&gt; ​\t\t不要使用对象或数组之类的非基本类型值作为 `v-for` 的 `key`。请用字符串或数值类型的值。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">## 数组更新检测</span><br><span class=\"line\"></span><br><span class=\"line\">### 变更方法</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t因为Vue的响应式是相对于Object.defineProperty的使用。所以Vue对数组的处理方式是，对方法进行了包裹，所以使用了数组的方法也会触发视图的更新。</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t这些方法包括了</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\npush，pop，shift，unshift，splice，sort，reverse\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">### 替换数组</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t变更方法，顾名思义，会变更调用了这些方法的原始数组。相比之下，也有非变更方法，例如 `filter()`、`concat()` 和 `slice()`。它们不会变更原始数组，而**总是返回一个新数组**。当使用非变更方法时，可以用新数组替换旧数组。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\nexample1.items = example1.items.filter(function (item) {\n  return item.message.match(/Foo/)\n})\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">​\t\t简单来说，上面的变更方法在调用之后是会变化原数组的。但是我们也有不会变更原数组的方法。所以对于这些不会变更原数组的方法，我们可以选择直接进行重新赋值。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\nitems = newItems\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">​\t\t我们可以发现对数组直接进行赋值也触发了视图的变化。因为我们对items这个数组也进行了监听。地址的改变也触发了视图的变化，同理，对于一个对象也是一样的。</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t你可能认为这将导致 Vue 丢弃现有 DOM 并重新渲染整个列表。幸运的是，事实并非如此。Vue 为了使得 DOM 元素得到最大范围的重用而实现了一些智能的启发式方法，所以用一个含有相同元素的数组去替换原来的数组是非常高效的操作。</span><br><span class=\"line\"></span><br><span class=\"line\">&gt; ​\t\t由于 JavaScript 的限制，Vue **不能检测**数组和对象的变化。[深入响应式原理](https://cn.vuejs.org/v2/guide/reactivity.html#检测变化的注意事项)中有相关的讨论。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">### 显示过滤/排序后的结果</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t有时，我们想要显示一个数组经过过滤或排序后的版本，而不实际变更或重置原始数据。在这种情况下，可以创建一个计算属性，来返回过滤或排序后的数组。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<li v-for=\"n in evenNumbers\"></li>\n\n<p>computed: {<br>  evenNumbers: function () {<br>    return this.numbers.filter(function (number) {<br>      return number % 2 === 0<br>    })<br>    }<br>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">​\t\t对于计算属性不适合的情况下，比如是循环嵌套了循环，此时对于循环内层，用不了计算属性，可以使用方法</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<ul v-for=\"set in sets\">\n  <li v-for=\"n in even(set)\"></li>\n</ul>\n\n<p>even: function (numbers) {<br>  return numbers.filter(function (number) {<br>      return number % 2 === 0<br>  })<br>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">​\t\t当然，你可能会想着，我对这个内层也加一个计算属性啊，但是，是没有效果的，简单来说就是因为就近原则，一个是循环的set，一个计算属性的set，他会先找循环的set。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">### 在 v-for 里使用值范围</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t`v-for` 也可以接受整数。在这种情况下，它会把模板重复对应次数。</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t对于字符串则会将字符进行循环。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">### 在 \\&lt;template&gt; 上使用 v-for</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t类似于 `v-if`，你也可以利用带有 `v-for` 的 `&lt;template&gt;` 来循环渲染一段包含多个元素的内容。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">### 在组件上使用 `v-for`</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t在自定义组件上，你可以像在任何普通元素上一样使用 `v-for`。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p><my-component v-for=\"item in items\" :key=\"item.id\"></my-component></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">​\t\t**2.2.0+ 的版本里，当在组件上使用 `v-for` 时，`key` 现在是必须的。**</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t然而，任何数据都不会被自动传递到组件里，因为组件有自己独立的作用域。为了把迭代数据传递到组件里，我们要使用 prop。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<ul>\n  <li is=\"todo-item\" v-for=\"(todo, index) in todos\" v-bind:key=\"todo.id\" v-bind:title=\"todo.title\" v-on:remove=\"todos.splice(index, 1)\"></li>\n</ul>\n\n<p>Vue.component(‘todo-item’, {<br>  template: ‘<br>    <li><br>      Vue-使用-基础使用<br>      <button v-on:click=\"$emit(\\'remove\\')\">Remove</button><br>    </li><br>  ‘,<br>  props: [‘title’]<br>})</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">&gt; ​\t\t注意这里的 `is=&quot;todo-item&quot;` attribute。这种做法在使用 DOM 模板时是十分必要的，因为在 `&lt;ul&gt;` 元素内只有 `&lt;li&gt;` 元素会被看作有效内容。这样做实现的效果与 `&lt;todo-item&gt;` 相同，但是可以避开一些潜在的浏览器解析错误。查看 [DOM 模板解析说明](https://cn.vuejs.org/v2/guide/components.html#解析-DOM-模板时的注意事项) 来了解更多信息。</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t简单来说，ul 元素内只有li元素被看作有效，我们使用is方法进行了替换，这样重点可以避开潜在的浏览器解析错误。当然这是一个Vue的方法。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"># 事件处理</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p><a href=\"https://cn.vuejs.org/v2/guide/events.html\">https://cn.vuejs.org/v2/guide/events.html</a></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">## 监听事件</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t可以用 `v-on` 指令监听 DOM 事件，并在触发时运行一些 JavaScript 代码。对应的语法糖，`@`</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p><button v-on:click=\"counter += 1\">Add 1</button></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">## 事件处理方法</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t然而许多事件处理逻辑会更为复杂，所以直接把 JavaScript 代码写在 `v-on` 指令中是不可行的。因此 `v-on` 还可以接收一个需要调用的方法名称。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<!-- `greet` 是在下面定义的方法名 -->\n<p><button v-on:click=\"greet\">Greet</button></p>\n<p>// 在 <code>methods</code> 对象中定义方法<br>methods: {<br>  greet: function (event) {<br>    // <code>this</code> 在方法里指向当前 Vue 实例<br>    alert(‘Hello ‘ + this.name + ‘!’)<br>    // <code>event</code> 是原生 DOM 事件<br>    if (event) {<br>        alert(event.target.tagName)<br>    }<br>  }<br>}</p>\n<p>// 也可以用 JavaScript 直接调用方法<br>vm.greet() // =&gt; ‘Hello Vue.js!’</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">## 内联处理器中的方法</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t除了直接绑定到一个方法，也可以在内联 JavaScript 语句中调用方法：</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p><button v-on:click=\"say('hi')\">Say hi</button></p>\n<p>methods: {<br>  say: function (message) {<br>      alert(message)<br>  }<br>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">​\t\t有时也需要在内联语句处理器中访问原始的 DOM 事件。可以用特殊变量 `$event` 把它传入方法</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p><button v-on:click=\"warn('Form cannot be submitted yet.', $event)\">Submit</button></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">**对于event方法的使用：**</span><br><span class=\"line\"></span><br><span class=\"line\">* 如果方法是不带参数的，可以直接使用event，或者参数上加上event</span><br><span class=\"line\"></span><br><span class=\"line\">  * ```</span><br><span class=\"line\">    &lt;button @click=&quot;change&quot;&gt;button&lt;/button&gt;</span><br><span class=\"line\">    </span><br><span class=\"line\">    change(event) &#123;console.log(event);&#125;,</span><br><span class=\"line\">    change() &#123;console.log(event);&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>不同点：</p>\n<ul>\n<li>如果使用了 @click=change()，加上了括号，对于第一个，传参event的，无法使用，第二个可以使用。</li>\n</ul>\n</li>\n<li><p>当然我们也可以使用 $event 来传递这个参数。</p>\n</li>\n</ul>\n<h2 id=\"事件修饰符\"><a href=\"#事件修饰符\" class=\"headerlink\" title=\"事件修饰符\"></a>事件修饰符</h2><p>​        在事件处理程序中调用 <code>event.preventDefault()</code> 或 <code>event.stopPropagation()</code> 是非常常见的需求。尽管我们可以在方法中轻松实现这点，但更好的方式是：方法只有纯粹的数据逻辑，而不是去处理 DOM 事件细节。</p>\n<p>​        首先默认使用的click方法就是冒泡类型。</p>\n<p>​        常见的事件修饰符</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.stop</span><br><span class=\"line\">\t阻止事件的冒泡</span><br><span class=\"line\">.prevent</span><br><span class=\"line\">\t阻止事件的默认行为，对于在父元素使用了阻止默认行为，子元素的默认行为都会被阻止。</span><br><span class=\"line\">.capture</span><br><span class=\"line\">\t转为捕获事件监听，事件的监听顺序是 root --&gt; target 捕获， target --&gt; root 冒泡</span><br><span class=\"line\">.self</span><br><span class=\"line\">\t只有目标元素是自身才会触发，对于子元素的点击也不会触发。</span><br><span class=\"line\">.once\t/ 2.1.4 新增</span><br><span class=\"line\">\t只触发一次。</span><br><span class=\"line\">.passive / 2.3.0 新增</span><br><span class=\"line\">\t</span><br></pre></td></tr></table></figure>\n\n<p>​        不像其它只能对原生的 DOM 事件起作用的修饰符，<code>.once</code> 修饰符还能被用到自定义的<a href=\"https://cn.vuejs.org/v2/guide/components-custom-events.html\">组件事件</a>上</p>\n<blockquote>\n<p>​        使用修饰符时，顺序很重要；相应的代码会以同样的顺序产生。因此，用 <code>v-on:click.prevent.self</code> 会阻止<strong>所有的点击</strong>，而 <code>v-on:click.self.prevent</code> 只会阻止对元素自身的点击。</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div @click.prevent.self=&quot;change&quot;&gt;</span><br><span class=\"line\">  &lt;a href=&quot;#1&quot; @click=&quot;change1&quot;&gt;321&lt;/a&gt;</span><br><span class=\"line\">  &lt;div @click=&quot;change1&quot;&gt;123&lt;/div&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;div @click.self.prevent=&quot;change&quot;&gt;</span><br><span class=\"line\">  &lt;a href=&quot;#1&quot; @click=&quot;change1&quot;&gt;321&lt;/a&gt;</span><br><span class=\"line\">  &lt;div @click=&quot;change1&quot;&gt;123&lt;/div&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n\n<p>​        <strong>热知识</strong>：父元素阻止了默认行为会影响到子元素。</p>\n<p>​        <strong>热知识2：</strong> click方法会先于默认行为执行。并且要冒泡结束了之后才会执行。</p>\n<p>​        Vue 还对应 <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Parameters\"><code>addEventListener</code> 中的 <code>passive</code> 选项</a>提供了 <code>.passive</code> 修饰符。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- 滚动事件的默认行为 (即滚动行为) 将会立即触发 --&gt;</span><br><span class=\"line\">&lt;!-- 而不会等待 `onScroll` 完成  --&gt;</span><br><span class=\"line\">&lt;!-- 这其中包含 `event.preventDefault()` 的情况 --&gt;</span><br><span class=\"line\">&lt;div v-on:scroll.passive=&quot;onScroll&quot;&gt;...&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n\n<p>​        他这里是这样说，貌似意思是说，默认行为会先触发，然后再触发 onScroll 的方法，但是我对一个。a标签进行操作的时候发现是先输出，然后在跳转，对于一个scroll行为的测试从肉眼上看也是和a标签一样，当然这个滚动的行为可能才滚1帧就开始触发了循环，导致卡帧也有可能。所以我现在不知道如何判断。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div @click=&quot;change&quot;&gt;</span><br><span class=\"line\">\t&lt;a href=&quot;#1&quot; @click.passive=&quot;change1&quot;&gt;321&lt;/a&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">methods: &#123;</span><br><span class=\"line\">  change() &#123;</span><br><span class=\"line\">    console.log(&#x27;father&#x27;);</span><br><span class=\"line\">    let date = new Date().getTime() + 1000;</span><br><span class=\"line\">    while (date &gt; new Date()) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  change1() &#123;</span><br><span class=\"line\">  \tconsole.log(&#x27;children&#x27;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>​        发现是先输出控制台，然后url再变化的。</p>\n<p>​        并且如果父元素使用了 prevent，子元素的passive无效，passive只能让本元素上的prevent无效。</p>\n<p>​        这个 <code>.passive</code> 修饰符尤其能够提升移动端的性能。 </p>\n<p>​        </p>\n<h2 id=\"按键修饰符\"><a href=\"#按键修饰符\" class=\"headerlink\" title=\"按键修饰符\"></a>按键修饰符</h2><p>​        在监听键盘事件时，我们经常需要检查详细的按键。Vue 允许为 <code>v-on</code> 在监听键盘事件时添加按键修饰符</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- 只有在 `key` 是 `Enter` 时调用 `vm.submit()` --&gt;</span><br><span class=\"line\">&lt;input v-on:keyup.enter=&quot;submit&quot;&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"按键码\"><a href=\"#按键码\" class=\"headerlink\" title=\"按键码\"></a>按键码</h3><blockquote>\n<p>​        <code>keyCode</code> 的事件用法<a href=\"https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/keyCode\">已经被废弃了</a>并可能不会被最新的浏览器支持。</p>\n</blockquote>\n<p>​        使用 <code>keyCode</code> attribute 也是允许的：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;input v-on:keyup.13=&quot;submit&quot;&gt;</span><br></pre></td></tr></table></figure>\n\n<p>​        为了在必要的情况下支持旧浏览器，Vue 提供了绝大多数常用的按键码的别名：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.enter\t.tab\t.delete (捕获“删除”和“退格”键)\t.esc\t.space\t.up\t.down\t.left\t.right</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>​        有一些按键 (<code>.esc</code> 以及所有的方向键) 在 IE9 中有不同的 <code>key</code> 值, 如果你想支持 IE9，这些内置的别名应该是首选。</p>\n</blockquote>\n<p>​        你还可以通过全局 <code>config.keyCodes</code> 对象<a href=\"https://cn.vuejs.org/v2/api/#keyCodes\">自定义按键修饰符别名</a>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 可以使用 `v-on:keyup.f1`</span><br><span class=\"line\">Vue.config.keyCodes.f1 = 112</span><br></pre></td></tr></table></figure>\n\n<p>​        按键别名可以进行覆盖，当然这个不建议这样写已经存在的。</p>\n<p><strong>注意：</strong></p>\n<p>​        按键别名不要使用大写，因为大写的在 <code>&lt;input v-on:keyup.enter=&quot;submit&quot;&gt; </code>，在这里会转为小写，所以无法使用成功。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;input type=&quot;text&quot; @keyup.A=&quot;change&quot;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">Vue.config.keyCodes.A = 97;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"系统修饰键\"><a href=\"#系统修饰键\" class=\"headerlink\" title=\"系统修饰键\"></a>系统修饰键</h2><p>​        可以用如下修饰符来实现仅在按下相应按键时才触发鼠标或键盘事件的监听器。(2.1.0新增)</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.ctrl</span><br><span class=\"line\">.alt</span><br><span class=\"line\">.shift</span><br><span class=\"line\">.meta</span><br><span class=\"line\">\t就是Windows键盘上的那个Windows图标按钮。mac同理</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>​        注意：在 Mac 系统键盘上，meta 对应 command 键 (⌘)。在 Windows 系统键盘 meta 对应 Windows 徽标键 (⊞)。在 Sun 操作系统键盘上，meta 对应实心宝石键 (◆)。在其他特定键盘上，尤其在 MIT 和 Lisp 机器的键盘、以及其后继产品，比如 Knight 键盘、space-cadet 键盘，meta 被标记为“META”。在 Symbolics 键盘上，meta 被标记为“META”或者“Meta”。</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- Alt + C --&gt;</span><br><span class=\"line\">&lt;input v-on:keyup.alt.67=&quot;clear&quot;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- Ctrl + Click --&gt;</span><br><span class=\"line\">&lt;div v-on:click.ctrl=&quot;doSomething&quot;&gt;Do something&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n\n<p><strong>注意：</strong></p>\n<ul>\n<li>使用系统修饰键对于 @keyup.67.ctrl 和 @keyup.ctrl.67 是一样的。不会有先后顺序。</li>\n<li>请注意修饰键与常规按键不同，在和 <code>keyup</code> 事件一起用时，事件触发时修饰键必须处于按下状态。换句话说，只有在按住 <code>ctrl</code> 的情况下释放其它按键，才能触发 <code>keyup.ctrl</code>。而单单释放 <code>ctrl</code> 也不会触发事件。如果你想要这样的行为，请为 <code>ctrl</code> 换用 <code>keyCode</code>：<code>keyup.17</code>。17代表了ctrl</li>\n<li><strong>@keyup.17.67</strong> 这个代表了按这两个其中一个都有效</li>\n<li>系统修饰键可以使用多个。</li>\n</ul>\n<h3 id=\"exact-修饰符（2-5-0新增）\"><a href=\"#exact-修饰符（2-5-0新增）\" class=\"headerlink\" title=\".exact 修饰符（2.5.0新增）\"></a>.exact 修饰符（2.5.0新增）</h3><p>​        <code>.exact</code> 修饰符允许你控制由精确的系统修饰键组合触发的事件。</p>\n<p>​        <strong>作用</strong>：用于<strong>精确</strong>控制系统修饰键按键的修饰符。主要在于精确两个字。并且是对系统修饰键起作用的。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;input type=&quot;text&quot; @keyup.a.up.exact=&quot;change&quot;&gt;</span><br><span class=\"line\">\t这个里面没有系统修饰键，监听了两个按键，最终效果：没有什么区别，唯一的区别就是如果此时你按了系统修饰键将不会触发。</span><br><span class=\"line\">\t所以这个代表了&lt;!-- 没有任何系统修饰键被按下的时候才触发 --&gt;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;input type=&quot;text&quot; @keyup.ctrl.up.exact=&quot;change&quot;&gt;</span><br><span class=\"line\">\t这个里面存在了系统修饰键 ctrl，所以效果就是必须按了 ctrl才会有用，（当然这个是系统修饰键的效果），.exact修饰符 的效果就是，系统修饰键必须只按了ctrl才有用。精确。加上系统修饰键。</span><br><span class=\"line\">\t其次.exact 修饰符没有位置的要求，和系统修饰键一样没有位置要求，</span><br><span class=\"line\">\t然后就是对于 &lt;input type=&quot;text&quot; @keyup.exact.ctrl.up.a=&quot;change&quot;&gt; 我们可以发现， 一个exact修饰符，一个ctrl系统修饰键，两个普通按键修饰符。所以最终的效果是，有且只有按了ctrl键，加上普通按键修饰符的其中一个就行。</span><br><span class=\"line\">\t&lt;!-- 有且只有 Ctrl 被按下的时候才触发 --&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"鼠标按钮修饰符（2-2-0新增）\"><a href=\"#鼠标按钮修饰符（2-2-0新增）\" class=\"headerlink\" title=\"鼠标按钮修饰符（2.2.0新增）\"></a>鼠标按钮修饰符（2.2.0新增）</h3><p>​        这些修饰符会限制处理函数仅响应特定的鼠标按钮。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.left</span><br><span class=\"line\">.right</span><br><span class=\"line\">.middle</span><br></pre></td></tr></table></figure>\n\n<p>​        用于点击事件，对于keyup事件不起作用，当然对于系统修饰键和.exact修饰符没有这些要求。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div @click.middle.ctrl.exact=&quot;change&quot;&gt;321&lt;/div&gt;</span><br><span class=\"line\">\t要求是 ctrl键 + 鼠标中键才会触发。</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"为什么要在-HTML-中监听事件\"><a href=\"#为什么要在-HTML-中监听事件\" class=\"headerlink\" title=\"为什么要在 HTML 中监听事件\"></a>为什么要在 HTML 中监听事件</h2><p>​        你可能注意到这种事件监听的方式违背了关注点分离 (separation of concern) 这个长期以来的优良传统。但不必担心，因为所有的 Vue.js 事件处理方法和表达式都严格绑定在当前视图的 ViewModel 上，它不会导致任何维护上的困难。实际上，使用 <code>v-on</code> 有几个好处：</p>\n<ol>\n<li>扫一眼 HTML 模板便能轻松定位在 JavaScript 代码里对应的方法。</li>\n<li>因为你无须在 JavaScript 里手动绑定事件，你的 ViewModel 代码可以是非常纯粹的逻辑，和 DOM 完全解耦，更易于测试。</li>\n<li>当一个 ViewModel 被销毁时，所有的事件处理器都会自动被删除。你无须担心如何清理它们。</li>\n</ol>\n<p><strong>概括就是说</strong>：虽然是在html中进行的使用监听，但是真正的处理是绑定在VM上的。其次对于v-on的好处：1.能够一眼看出方法。2.和DOM完全解耦。3.当一个VM被销毁时，所有的事件会自动清除。</p>\n<h1 id=\"表单输入绑定\"><a href=\"#表单输入绑定\" class=\"headerlink\" title=\"表单输入绑定\"></a>表单输入绑定</h1><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://cn.vuejs.org/v2/guide/forms.html</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"基础用法\"><a href=\"#基础用法\" class=\"headerlink\" title=\"基础用法\"></a>基础用法</h2><p>​        你可以用 <code>v-model</code> 指令在表单 <code>&lt;input&gt;</code>、<code>&lt;textarea&gt;</code> 及 <code>&lt;select&gt;</code> 元素上创建双向数据绑定。它会根据控件类型自动选取正确的方法来更新元素。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;input v-model=&quot;message&quot; placeholder=&quot;edit me&quot;&gt;</span><br><span class=\"line\">这里，我是用 v-model，并没有绑定给value，但是会自动选取正确的方法进行更新。</span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>注意：</strong></p>\n<ul>\n<li>v-model 会忽略元素自带的value，checked等属性，而是使用Vue实例的数据作为来源。</li>\n</ul>\n<p>​        <code>v-model</code> 在内部为不同的输入元素使用不同的 property 并抛出不同的事件。</p>\n<ul>\n<li>text 和 textarea 元素使用 <code>value</code> property 和 <code>input</code> 事件；</li>\n<li>checkbox 和 radio 使用 <code>checked</code> property 和 <code>change</code> 事件；（使用的是真值方式truth）</li>\n<li>select 字段将 <code>value</code> 作为 prop 并将 <code>change</code> 作为事件。</li>\n</ul>\n<blockquote>\n<p>​        对于需要使用<a href=\"https://zh.wikipedia.org/wiki/%E8%BE%93%E5%85%A5%E6%B3%95\">输入法</a> (如中文、日文、韩文等) 的语言，你会发现 <code>v-model</code> 不会在输入法组合文字过程中得到更新。如果你也想处理这个过程，请使用 <code>input</code> 事件。</p>\n</blockquote>\n<p>​        你在输入框输入加上一个input事件的监听的时候就会发现。如果在输入的时候使用了中文，虽然在按键的时候发生了input事件，但是v-model的值并没有得到更新。</p>\n<p>​        但是如果是普通的input输入框的监听则会发生更新。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;input type=&quot;text&quot; v-model=&quot;string&quot; @input=&quot;change&quot; oninput=&quot;console.log(&#x27;event:    &#x27; + event.target.value);&quot;&gt;</span><br></pre></td></tr></table></figure>\n\n<p>​        并且在进行了空格之后会发生多次的更新。</p>\n<h3 id=\"文本-和-多行文本\"><a href=\"#文本-和-多行文本\" class=\"headerlink\" title=\"文本 和 多行文本\"></a>文本 和 多行文本</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;input type=&quot;text&quot; v-model=&quot;message&quot;&gt;</span><br><span class=\"line\">&lt;textarea v-model=&quot;message&quot;&gt;&lt;/textarea&gt;</span><br></pre></td></tr></table></figure>\n\n<p>​        在文本区域插值 (<code>&lt;textarea&gt;&#123;&#123;text&#125;&#125;&lt;/textarea&gt;</code>) 并不会生效，应用 <code>v-model</code> 来代替。</p>\n<h3 id=\"复选框\"><a href=\"#复选框\" class=\"headerlink\" title=\"复选框\"></a>复选框</h3><p>​        单个复选框，直接布尔值进行的判断，对于不是布尔类型的使用了truth方式。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;input type=&quot;checkbox&quot; id=&quot;checkbox&quot; v-model=&quot;checked&quot;&gt;</span><br></pre></td></tr></table></figure>\n\n<p>​        对于多个复选框</p>\n<p>​        注意：复选框和单选框是通过value进行判断。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;input type=&quot;checkbox&quot; id=&quot;jack&quot; value=&quot;Jack&quot; v-model=&quot;checkedNames&quot;&gt;</span><br><span class=\"line\">&lt;label for=&quot;jack&quot;&gt;Jack&lt;/label&gt;</span><br><span class=\"line\">&lt;input type=&quot;checkbox&quot; id=&quot;john&quot; value=&quot;John&quot; v-model=&quot;checkedNames&quot;&gt;</span><br><span class=\"line\">&lt;label for=&quot;john&quot;&gt;John&lt;/label&gt;</span><br><span class=\"line\">&lt;input type=&quot;checkbox&quot; id=&quot;mike&quot; value=&quot;Mike&quot; v-model=&quot;checkedNames&quot;&gt;</span><br><span class=\"line\">&lt;label for=&quot;mike&quot;&gt;Mike&lt;/label&gt;</span><br></pre></td></tr></table></figure>\n\n<p>​        <del>我们可以发现，这里没有对复选框进行分组，正常的情况下，复选框需要进行name的分组，相同的name为一组。这个好像是对单选框的。复选框应该本来就可以不用分组？</del></p>\n<p>​        对于一个复选框，如果绑定了v-model，但是value不绑定，那么点击一个就是点击多个。因为没有使用value属性，值为null，所以所有为null都会被同步变化。</p>\n<p>​        同时，如果多选的复选框，但是绑定的属性不是一个数组那么最终也会变为全部都会出现相同的变化。 <code>checkedNames: 1,</code> </p>\n<h3 id=\"单选按钮\"><a href=\"#单选按钮\" class=\"headerlink\" title=\"单选按钮\"></a>单选按钮</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;input type=&quot;radio&quot; name=&quot;aa&quot; id=&quot;jack&quot; value=&quot;Jack&quot; v-model=&quot;checkedNames&quot;&gt;</span><br><span class=\"line\">&lt;label for=&quot;jack&quot;&gt;Jack&lt;/label&gt;</span><br><span class=\"line\">&lt;input type=&quot;radio&quot; name=&quot;cc&quot; id=&quot;john&quot; value=&quot;John&quot; v-model=&quot;checkedNames&quot;&gt;</span><br><span class=\"line\">&lt;label for=&quot;john&quot;&gt;John&lt;/label&gt;</span><br><span class=\"line\">&lt;input type=&quot;radio&quot; name=&quot;aa&quot; id=&quot;mike&quot; value=&quot;Mike&quot; v-model=&quot;checkedNames&quot;&gt;</span><br><span class=\"line\">&lt;label for=&quot;mike&quot;&gt;Mike&lt;/label&gt;</span><br></pre></td></tr></table></figure>\n\n<p>​        在这里，我将name进行不同的划分，但是可以发现他们还是一组的成员。</p>\n<p>​        <del>所以我们可以这样认为，使用了v-model之后，name也会绑定为这个属性的名称，所以你自己定义的属性名称是没有作用的。</del>（注意：这里不是说，绑定的是v-model属性的名称，而是说，name的绑定和v-model的属性相关了。但是值不知道是什么。）</p>\n<p>​        <strong>注意：</strong> 首先我们可以测试出来，name的属性还是没有改变，因为如果添加了一个 相同name，但是没有使用v-model的，会出现竞争。</p>\n<p>​        对于单选按钮，<strong>没有使用value的</strong>，那么v-model绑定的属性取出来的值是空。就是那种什么都没有的空。<strong>并且name属性默认不同</strong>。</p>\n<p>​        如果自己定义了name属性，那么会以自己定义的为准。但是如果使用了value，搭配了v-model，对于同value，不同name，两个都选上。 <del>那么name属性还是以v-model为准（是指相同的v-model有相同的name）。</del></p>\n<p>​        并且，如果value相等，name不等，那么点击时，都会一起变化。如果name相等了，那么点击时点击那个就是哪个，但是value的值不变，并且对于初始化来说，是根据value的值来进行的变化，所以会以最后一个为准。</p>\n<p>​        这里有很多问题，但是这些都是可以手动避免的。大概知道就行。我也被自己扯蒙了。</p>\n<h3 id=\"选择框\"><a href=\"#选择框\" class=\"headerlink\" title=\"选择框\"></a>选择框</h3><p>​        单选时，直接绑定一个值即可</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;select v-model=&quot;selected&quot;&gt;</span><br><span class=\"line\">  &lt;option disabled value=&quot;&quot;&gt;请选择&lt;/option&gt;</span><br><span class=\"line\">  &lt;option&gt;A&lt;/option&gt;</span><br><span class=\"line\">  &lt;option&gt;B&lt;/option&gt;</span><br><span class=\"line\">  &lt;option&gt;C&lt;/option&gt;</span><br><span class=\"line\">&lt;/select&gt;</span><br><span class=\"line\">&lt;span&gt;Selected: &#123;&#123; selected &#125;&#125;&lt;/span&gt;</span><br></pre></td></tr></table></figure>\n\n<p>​        我们也可以发现，对于使用option的时候，可以不添加value属性，此时绑定的值就是内容。</p>\n<p><strong>注意：</strong>如果没有规定 value 属性，选项的值将设置为 &lt;option&gt; 标签中的内容。</p>\n<p><strong>注意：</strong></p>\n<blockquote>\n<p>​        如果 <code>v-model</code> 表达式的初始值未能匹配任何选项，<code>&lt;select&gt;</code> 元素将被渲染为“未选中”状态。在 iOS 中，这会使用户无法选择第一个选项。因为这样的情况下，iOS 不会触发 change 事件。因此，更推荐像上面这样提供一个值为空的禁用选项。</p>\n</blockquote>\n<p>​        当然这个我不清楚，毕竟我没有IOS。。。。。。</p>\n<p>​        多选时就是绑定一个数组</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;select v-model=&quot;selected&quot; multiple style=&quot;width: 50px;&quot;&gt;</span><br><span class=\"line\">  &lt;option&gt;A&lt;/option&gt;</span><br><span class=\"line\">  &lt;option&gt;B&lt;/option&gt;</span><br><span class=\"line\">  &lt;option&gt;C&lt;/option&gt;</span><br><span class=\"line\">&lt;/select&gt;</span><br><span class=\"line\">&lt;br&gt;</span><br><span class=\"line\">&lt;span&gt;Selected: &#123;&#123; selected &#125;&#125;&lt;/span&gt;</span><br></pre></td></tr></table></figure>\n\n<p>​        首先，select多选框的属性 multiple，其次就是使用的数组了。</p>\n<p>​        对于不是使用数组的，将不会初始化成功，但是在后续的赋值还是会转化为数组。</p>\n<p>​        当然，对于 option 也可以使用v-for进行动态渲染。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;option v-for=&quot;item in options&quot;&gt;&#123;&#123; item &#125;&#125;&lt;/option&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"值绑定\"><a href=\"#值绑定\" class=\"headerlink\" title=\"值绑定\"></a>值绑定</h2><p>​        对于单选按钮，复选框及选择框的选项，<code>v-model</code> 绑定的值通常是静态字符串 (对于复选框也可以是布尔值)：</p>\n<p>​        但是有时我们可能想把值绑定到 Vue 实例的一个动态 property 上，这时可以用 <code>v-bind</code> 实现，并且这个 property 的值可以不是字符串。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- 当选中时，`picked` 为字符串 &quot;a&quot; --&gt;</span><br><span class=\"line\">&lt;input type=&quot;radio&quot; v-model=&quot;picked&quot; value=&quot;a&quot;&gt;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- 当选中时，`picked` 为a 的值 --&gt;</span><br><span class=\"line\">&lt;input type=&quot;radio&quot; v-model=&quot;picked&quot; :value=&quot;a&quot;&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"复选框-1\"><a href=\"#复选框-1\" class=\"headerlink\" title=\"复选框\"></a>复选框</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;input</span><br><span class=\"line\">  type=&quot;checkbox&quot;</span><br><span class=\"line\">  v-model=&quot;toggle&quot;</span><br><span class=\"line\">  true-value=&quot;yes&quot;</span><br><span class=\"line\">  false-value=&quot;no&quot;</span><br><span class=\"line\">&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">// 当选中时</span><br><span class=\"line\">vm.toggle === &#x27;yes&#x27;</span><br><span class=\"line\">// 当没有选中时</span><br><span class=\"line\">vm.toggle === &#x27;no&#x27;</span><br></pre></td></tr></table></figure>\n\n<p>​        针对多个复选框。其值还是为value值，如果没有value，其值就是null</p>\n<blockquote>\n<p>​        这里的 <code>true-value</code> 和 <code>false-value</code> attribute 并不会影响输入控件的 <code>value</code> attribute，因为浏览器在提交表单时并不会包含未被选中的复选框。如果要确保表单中这两个值中的一个能够被提交，(即“yes”或“no”)，请换用单选按钮。</p>\n</blockquote>\n<p>​        所以这个 true/false value 是单选时比较有用。</p>\n<h3 id=\"单选按钮-1\"><a href=\"#单选按钮-1\" class=\"headerlink\" title=\"单选按钮\"></a>单选按钮</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;input type=&quot;radio&quot; v-model=&quot;pick&quot; v-bind:value=&quot;a&quot;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">// 当选中时</span><br><span class=\"line\">vm.pick === vm.a</span><br></pre></td></tr></table></figure>\n\n<p>​    </p>\n<h3 id=\"选择框的选项\"><a href=\"#选择框的选项\" class=\"headerlink\" title=\"选择框的选项\"></a>选择框的选项</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;select v-model=&quot;selected&quot;&gt;</span><br><span class=\"line\">    &lt;!-- 内联对象字面量 --&gt;</span><br><span class=\"line\">  &lt;option v-bind:value=&quot;&#123; number: 123 &#125;&quot;&gt;123&lt;/option&gt;</span><br><span class=\"line\">&lt;/select&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">// 当选中时</span><br><span class=\"line\">typeof vm.selected // =&gt; &#x27;object&#x27;</span><br><span class=\"line\">vm.selected.number // =&gt; 123</span><br></pre></td></tr></table></figure>\n\n<p>​        通过这个我们可以看出，这个是可以使用对象的，同理，我们对于其他的选项框也可以使用对象的形式。</p>\n<h2 id=\"修饰符\"><a href=\"#修饰符\" class=\"headerlink\" title=\"修饰符\"></a>修饰符</h2><h3 id=\"lazy\"><a href=\"#lazy\" class=\"headerlink\" title=\".lazy\"></a>.lazy</h3><p>​        在默认情况下，<code>v-model</code> 在每次 <code>input</code> 事件触发后将输入框的值与数据进行同步 (除了<a href=\"https://cn.vuejs.org/v2/guide/forms.html#vmodel-ime-tip\">上述</a>输入法组合文字时)。你可以添加 <code>lazy</code> 修饰符，从而转为在 <code>change</code> 事件_之后_进行同步</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- 在“change”时而非“input”时更新 --&gt;</span><br><span class=\"line\">&lt;input v-model.lazy=&quot;msg&quot;&gt;</span><br></pre></td></tr></table></figure>\n\n<p>​        在输入之后使用回车，便是change事件。</p>\n<h3 id=\"number\"><a href=\"#number\" class=\"headerlink\" title=\".number\"></a>.number</h3><p>​        如果想自动将用户的输入值转为数值类型，可以给 <code>v-model</code> 添加 <code>number</code> 修饰符</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;input v-model.number=&quot;age&quot; type=&quot;number&quot;&gt;</span><br></pre></td></tr></table></figure>\n\n<p>​        无法输入字符串。</p>\n<p>​        这通常很有用，因为即使在 <code>type=&quot;number&quot;</code> 时，HTML 输入元素的值也总会返回字符串。如果这个值无法被 <code>parseFloat()</code> 解析，则会返回原始的值。</p>\n<p>​        如何出现无法解析的情况，因为可以输入 e，+，-等，所以还是可以无法解析，问题在于无法解析输出的类型是字符串，但是貌似内容为’’，</p>\n<h3 id=\"trim\"><a href=\"#trim\" class=\"headerlink\" title=\".trim\"></a>.trim</h3><p>​        如果要自动过滤用户输入的首尾空白字符，可以给 <code>v-model</code> 添加 <code>trim</code> 修饰符：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;input v-model.trim=&quot;msg&quot;&gt;</span><br></pre></td></tr></table></figure>\n\n<p>​        没啥说的。就是字符串的 trim 方法。这个方法的使用是返回一个新的。</p>\n<h2 id=\"在组件上使用-v-model-（2-2-0-新增）\"><a href=\"#在组件上使用-v-model-（2-2-0-新增）\" class=\"headerlink\" title=\"在组件上使用 v-model （2.2.0+ 新增）\"></a>在组件上使用 v-model （2.2.0+ 新增）</h2><p>​        HTML 原生的输入元素类型并不总能满足需求。幸好，Vue 的组件系统允许你创建具有完全自定义行为且可复用的输入组件。这些输入组件甚至可以和 <code>v-model</code> 一起使用！</p>\n<p>​        要了解更多，请参阅组件指南中的<a href=\"https://cn.vuejs.org/v2/guide/components-custom-events.html#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6%E7%9A%84-v-model\">自定义输入组件</a>。</p>\n<p>​        讲真，没有看懂。</p>\n<p>​        我们通过跳转，看到了自定义组件的 v-model 我只能大概知道</p>\n<p>​        一个组件上的 <code>v-model</code> 默认会利用名为 <code>value</code> 的 prop 和名为 <code>input</code> 的事件，但是像单选框、复选框等类型的输入控件可能会将 <code>value</code> attribute 用于<a href=\"https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/checkbox#Value\">不同的目的</a>。<code>model</code> 选项可以用来避免这样的冲突</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Vue.component(&#x27;base-checkbox&#x27;, &#123;</span><br><span class=\"line\">  model: &#123;</span><br><span class=\"line\">    prop: &#x27;checked&#x27;,</span><br><span class=\"line\">    event: &#x27;change&#x27;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  props: &#123;</span><br><span class=\"line\">    checked: Boolean</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  template: `</span><br><span class=\"line\">    &lt;input</span><br><span class=\"line\">      type=&quot;checkbox&quot;</span><br><span class=\"line\">      v-bind:checked=&quot;checked&quot;</span><br><span class=\"line\">      v-on:change=&quot;$emit(&#x27;change&#x27;, $event.target.checked)&quot;</span><br><span class=\"line\">    &gt;</span><br><span class=\"line\">  `</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">使用v-model时</span><br><span class=\"line\">&lt;base-checkbox v-model=&quot;lovingVue&quot;&gt;&lt;/base-checkbox&gt;</span><br></pre></td></tr></table></figure>\n\n<p>​        这里因为使用了v-model进行传值，所以使用了model: {}，设置了prop的名字，然后在props进行使用，此时传递的值就和父组件的 lovingVue 进行了绑定。然后通过事件$emit， change进行的提交。</p>\n<p>​        这里的 <code>lovingVue</code> 的值将会传入这个名为 <code>checked</code> 的 prop。同时当 <code>&lt;base-checkbox&gt;</code> 触发一个 <code>change</code> 事件并附带一个新的值的时候，这个 <code>lovingVue</code> 的 property 将会被更新。</p>\n<blockquote>\n<p>​        注意你仍然需要在组件的 <code>props</code> 选项里声明 <code>checked</code> 这个 prop。</p>\n</blockquote>\n<h1 id=\"组件基础\"><a href=\"#组件基础\" class=\"headerlink\" title=\"组件基础\"></a>组件基础</h1><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://cn.vuejs.org/v2/guide/components.html</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"基本示例\"><a href=\"#基本示例\" class=\"headerlink\" title=\"基本示例\"></a>基本示例</h2><p>​        这里有一个 Vue 组件的示例</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 定义一个名为 button-counter 的新组件</span><br><span class=\"line\">Vue.component(&#x27;button-counter&#x27;, &#123;</span><br><span class=\"line\">  data: function () &#123;</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">      count: 0</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  template: &#x27;&lt;button v-on:click=&quot;count++&quot;&gt;You clicked me &#123;&#123; count &#125;&#125; times.&lt;/button&gt;&#x27;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>​        组件是可复用的 Vue 实例，且带有一个名字：在这个例子中是 <code>&lt;button-counter&gt;</code>。我们可以在一个通过 <code>new Vue</code> 创建的 Vue 根实例中，把这个组件作为自定义元素来使用</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=&quot;components-demo&quot;&gt;</span><br><span class=\"line\">  &lt;button-counter&gt;&lt;/button-counter&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n\n<p>​        当然注意上面这个组件的定义顺序要在你的Vue实例之前。因为编译问题，如果在之后的话就不会被编译了。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Vue.componnet(&#x27;button&#x27;, &#123; &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">const vm = new Vue();</span><br></pre></td></tr></table></figure>\n\n<p>​        因为组件是可复用的 Vue 实例，所以它们与 <code>new Vue</code> 接收相同的选项，例如 <code>data</code>、<code>computed</code>、<code>watch</code>、<code>methods</code> 以及生命周期钩子等。仅有的例外是像 <code>el</code> 这样根实例特有的选项。</p>\n<h2 id=\"组件的复用\"><a href=\"#组件的复用\" class=\"headerlink\" title=\"组件的复用\"></a>组件的复用</h2><p>​        组件在被创建之后，可以被多次使用。</p>\n<h3 id=\"data必须是一个函数\"><a href=\"#data必须是一个函数\" class=\"headerlink\" title=\"data必须是一个函数\"></a>data必须是一个函数</h3><p>​        当我们定义这个 <code>&lt;button-counter&gt;</code> 组件时，你可能会发现它的 <code>data</code> 并不是像这样直接提供一个对象</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Vue.component(&#x27;button&#x27;, &#123;</span><br><span class=\"line\">\tdata: &#123;</span><br><span class=\"line\">\t\treturn &#123;</span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\">\t\t&#125;;</span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">const vm = new Vue(&#123;</span><br><span class=\"line\">\tdata: &#123;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>​        当然如果你不这样写也不会报错，但是这样会有一个问题，那就是所以这个组件都会使用同一个对象的数据，一个发生了改变，所有都会发生改变。所以就是用了函数，这个会每次都调用了一次函数，形成一个新的作用域位置。</p>\n<p>​        这个就是使用了闭包的方法，当然你可能在想，是不是可以利用这个闭包，然后既能让数据不同步，又能让部分数据进行同步。当然，我没有解决掉。因为首先我们可以知道闭包的使用方式。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Fn() &#123;</span><br><span class=\"line\">\treturn fn() &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">let fn = Fn();</span><br><span class=\"line\">这个时候使用fn，就可以使用闭包。但是data是重复的创建Fn(). 所以每次都还是会创建新东西。</span><br></pre></td></tr></table></figure>\n\n<p>​        所以我现在不知道如何使用闭包的方式，当然，我们可以将方法写在全局，然后再组件里进行闭包。还是可以的。</p>\n<h2 id=\"组件的组织\"><a href=\"#组件的组织\" class=\"headerlink\" title=\"组件的组织\"></a>组件的组织</h2><p>​        为了能在模板中使用，这些组件必须先注册以便 Vue 能够识别。这里有两种组件的注册类型：<strong>全局注册</strong>和<strong>局部注册</strong>。至此，我们的组件都只是通过 <code>Vue.component</code> 全局注册的</p>\n<p>​        全局注册的组件可以用在其被注册之后的任何 (通过 <code>new Vue</code>) 新创建的 Vue 根实例，也包括其组件树中的所有子组件的模板中。</p>\n<p>​        局部注册的方式就是先将内容对象赋值给了一个变量，然后通过使用变量来进行注册。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let ComponentA = &#123;  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">new Vue(&#123;</span><br><span class=\"line\">\tel: &#x27;#xx&#x27;,</span><br><span class=\"line\">\tcomponents: &#123;</span><br><span class=\"line\">\t\t&#x27;component-a&#x27;: ComponentA,</span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"通过Prop向子组件传递数据\"><a href=\"#通过Prop向子组件传递数据\" class=\"headerlink\" title=\"通过Prop向子组件传递数据\"></a>通过Prop向子组件传递数据</h2><p>​        简单来说，就是写在props属性里面的会添加到属性，父组件在调用子组件时，可以通过在标签里添加对应的属性，属性里面的值将会传递给子组件。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Vue.component(&#x27;blog-post&#x27;, &#123;</span><br><span class=\"line\">  props: [&#x27;title&#x27;],</span><br><span class=\"line\">  template: &#x27;&lt;h3&gt;&#123;&#123; title &#125;&#125;&lt;/h3&gt;&#x27;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;blog-post title=&quot;My journey with Vue&quot;&gt;&lt;/blog-post&gt;</span><br></pre></td></tr></table></figure>\n\n<p>​        当然对于这个props，也有另一个写法，props使用对象，对象里面又是一个对象，default代表了默认值，type代表了类型，当然也有其他属性。但是我们后面在详细了解。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">props: &#123;</span><br><span class=\"line\">  &#x27;title&#x27;: &#123;</span><br><span class=\"line\">    default: &#x27;123&#x27;,</span><br><span class=\"line\">    type: String</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;blog-post title=&quot;My journey with Vue&quot;&gt;&lt;/blog-post&gt;</span><br><span class=\"line\">&lt;blog-post&gt;&lt;/blog-post&gt;</span><br></pre></td></tr></table></figure>\n\n<p>​        当然这个自定的属性attribute，也是可以使用v-bind: 来动态绑定。当然我们也可以使用v-model，但是这里也有其他的问题，具体后续在了解。</p>\n<p>​        传递的属性也能是对象，对于一些应该属于统一对象的，可以将其化为一个对象进行传递。</p>\n<h2 id=\"单个根元素\"><a href=\"#单个根元素\" class=\"headerlink\" title=\"单个根元素\"></a>单个根元素</h2><p>​        简单来说，就是在创建时，只能以一个根元素。如果根元素不止一个就会报错</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div&gt;&lt;/div&gt;</span><br><span class=\"line\">&lt;div&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n\n<p>​        上面这个写法就会报错，但是下面这个写法。将所有的元素都放在了一个根元素的下级。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div&gt;</span><br><span class=\"line\">  &lt;div&gt;&lt;/div&gt;</span><br><span class=\"line\">  &lt;div&gt;&lt;/div&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n\n<p>​        这里的原因。我不清楚，只能说在Vue里面如果使用了下面这个写法时，可以知道，只会将第一个进行Vue的渲染，第二个将不会进行渲染操作。通过查阅资料，有的说是diff算法的原因，也有说是为了避免出现多个根元素，找不到以谁为主体。</p>\n<p>​        这个现在主要作为一个了解。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=&quot;app&quot;&gt;1&lt;/div&gt;</span><br><span class=\"line\">&lt;div id=&quot;app&quot;&gt;2&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"监听子组件事件\"><a href=\"#监听子组件事件\" class=\"headerlink\" title=\"监听子组件事件\"></a>监听子组件事件</h2><p>​        父组件可以给子组件传值了，但是子组件如何在一定的条件下通知父组件呢。</p>\n<p>​        使用方式：</p>\n<p>​        1.首先父元素在传递的时候，传递一个可以被子元素监听的方法</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;blog-post @test=&quot;enlarge&quot; post=&quot;&#123;title: 1&#125;&quot;&gt;&lt;/blog-post&gt;</span><br></pre></td></tr></table></figure>\n\n<p>​        2.然后子元素就可以通过使用 $emit 进行调用这个方法。注意$emit(‘xxxx’)，xxx就是那个元素上的属性attribute，</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;button v-on:click=&quot;$emit(&#x27;test&#x27;)&quot;&gt;</span><br></pre></td></tr></table></figure>\n\n<p>​        3.传递值的方式，这个方法的第一个是方法名，后面的就是要传递的值。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$emit(&#x27;test&#x27;, 1, 2);</span><br></pre></td></tr></table></figure>\n\n<p><strong>注意：</strong></p>\n<ul>\n<li><p>父元素进行传递时，直接写上方法名即可 <code>@test=&quot;enlarge&quot;</code> </p>\n</li>\n<li><p>因为html是不分大小写的，所以进行传递的时候，建议不要带有大写，对于$emit(‘xxx’)，存在大写，则会监听失败。</p>\n</li>\n<li><p>如果是 <code>@test=&quot;enlarge()&quot;</code> 那么子组件传递参数则无效，<code>$emit(&#39;test&#39;, 1, 2);</code> 子组件这个写法虽然传递了参数，但是并不会传递值，因为父组件在传递的时候是直接传递了方法的调用的结果。</p>\n<ul>\n<li>```<br>@test=”enlarge()<br>$emit(‘test’, 1, 2);结果：空<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">*  `@test=&quot;enlarge(1, 2)` 同理，这样在子组件调用的时候传递过来的值就直接是是1和2。并不会因为 `$emit(&#x27;test&#x27;, 321, 123);` 改成321，123。</span><br><span class=\"line\"></span><br><span class=\"line\">  * ```</span><br><span class=\"line\">    @test=&quot;enlarge(1, 2)</span><br><span class=\"line\">    $emit(&#x27;test&#x27;, 11111, 22222);</span><br><span class=\"line\">    </span><br><span class=\"line\">    结果：1, 2</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p> <code>@test=&quot;enlarge($event, 12, 321, 312)&quot;</code> 这样写有是一个特点，你会发现，这个$event 代表的不是点击的事件了，而是子组件传递的值。这个event就类似于了一个子组件的待定参数。</p>\n</li>\n<li><p>```<br>@test=”enlarge($event, 1, 2)<br>$emit(‘test’, 11111, 22222);</p>\n<p>结果：11111, 1, 2</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">### 使用事件抛出一个值</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t可以使用 `$emit` 的第二个参数来提供这个值</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<button v-on:click=\"$emit('enlarge-text', 0.1)\">\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">​\t\t然后当在父级组件监听这个事件的时候，我们可以通过 `$event` 访问到被抛出的这个值</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n@enlarge-text=\"postFontSize += $event\"\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">​\t\t如果这个是一个方法，那么这个值会作为第一个参数传入这个方法</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\nonEnlargeText: function (enlargeAmount) {\nthis.postFontSize += enlargeAmount\n}\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">### 在组件上使用 v-model</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t首先我们可以这样理解</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n</button><input v-model=\"searchText\"></li>\n</ul>\n<p>等价于</p>\n<p>&lt;input<br>  v-bind:value=”searchText”<br>  v-on:input=”searchText = $event.target.value”</p>\n<blockquote>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">​\t\tv-model的效果就是值的改变会影响到view的改变，输入的变化会影响值的改变。而v-bind，值的改变会影响到视图的改变，但是并没有双向的绑定。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t所以用在组件上时。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>&lt;custom-input<br>  v-bind:value=”searchText”<br>  v-on:input=”searchText = $event”</p>\n<blockquote>\n\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">​\t\t所以此时我们需要绑定一个input方法将其传递出来。</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t为了让它正常工作，这个组件内的 `&lt;input&gt;` 必须：</span><br><span class=\"line\"></span><br><span class=\"line\">- 将其 `value` attribute 绑定到一个名叫 `value` 的 prop 上</span><br><span class=\"line\">- 在其 `input` 事件被触发时，将新的值通过自定义的 `input` 事件抛出</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>Vue.component(‘custom-input’, {<br>  props: [‘value’],<br>  template: <code>     &lt;input       v-bind:value=&quot;value&quot;       v-on:input=&quot;$emit(&#39;input&#39;, $event.target.value)&quot;     &gt;</code><br>})</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">​\t\t所以此时我们就能理解了，上面的那个组件使用v-model时的传递方式了。</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t同时我么可以看一下那个[自定义事件的 v-model](https://cn.vuejs.org/v2/guide/components-custom-events.html)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>Vue.component(‘base-checkbox’, {<br>  model: {<br>    prop: ‘checked’,<br>    event: ‘change’<br>  },<br>  props: {<br>    checked: Boolean<br>  },<br>  template: <code>     &lt;input       type=&quot;checkbox&quot;       v-bind:checked=&quot;checked&quot;       v-on:change=&quot;$emit(&#39;change&#39;, $event.target.checked)&quot;     &gt;</code><br>})</p>\n<p>使用<br><base-checkbox v-model=\"lovingVue\"></base-checkbox></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">​\t\t这里的model里面有prop和event，其中checked代表了传递的值。这个名字可以自己定义。 这里的event，值为change，则代表了是change事件，如果命名为input则为input的事件，当然，其实这里也是可以自己命名的。主要是为了方便认知。</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t这个和上一个组件的通信的区别</span><br><span class=\"line\"></span><br><span class=\"line\">* 普通的是将值返回给上级，然后上级进行方法的操作。</span><br><span class=\"line\"></span><br><span class=\"line\">  * ```</span><br><span class=\"line\">    &lt;c :name=&quot;name&quot; @inputf=&quot;fn&quot;&gt;12&lt;/c&gt;</span><br><span class=\"line\">    </span><br><span class=\"line\">    子组件的内容：</span><br><span class=\"line\">    &lt;input type=&quot;text&quot; :value=&quot;name&quot; @input=&quot;this.$emit(&#x27;inputf&#x27;, event.target.value);&quot;&gt;</span><br><span class=\"line\">    </span><br><span class=\"line\">    这里再对fn写上一个方法，此时对于一个input输入就会出现对应的方法被执行。</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>对于v-model，则是发现直接将其传递给上级，上级不需要再指定一个方法。</p>\n<ul>\n<li><p>```<br><c v-model=\"searchText\"></c></p>\n<p>子组件的内容<br>&lt;input type=”text” :value=”myInput” @input=”inputE($event)”&gt;</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">* 首先在使用组件的时候，使用v-mdoel方法。子组件，此时可以使用 model对象进行指定。当然，如果此时不指定怎么办</span><br><span class=\"line\"></span><br><span class=\"line\">* 对于有value的情况：</span><br><span class=\"line\"></span><br><span class=\"line\">  * 首先，对于父组件使用v-model传递给了子组件的值，子组件如果使用了value的变量名，则会以此值进行接收。就算是checkbox，也是使用的value进行接收。不管子组件的内容(目前我的测试来说。)</span><br><span class=\"line\"></span><br><span class=\"line\">  * ```</span><br><span class=\"line\">    props: &#123;</span><br><span class=\"line\">      value: &#123;</span><br><span class=\"line\">      \ttype: Boolean,</span><br><span class=\"line\">      \tdefalut: false,</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    </span><br><span class=\"line\">    记住props的写法，开始我写成了data式的写法，把默认值直接写在了后面，如果直接写后面是写变量的类型</span><br><span class=\"line\">    props: &#123;</span><br><span class=\"line\">    \tvalue: String,</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>对于没有value的情况：</p>\n<ul>\n<li><p>没有value，还没有添加一个model对象进行指定，那么就不会传入成功。</p>\n</li>\n<li><p>进行了model的指定，那么便会使用这个变量进行赋值。</p>\n<ul>\n<li>```<br>model: {<br>  prop: ‘myInput’,<br>  event: ‘inp’<br>},<br>props: [‘myInput’],<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">* 到此，我们已经解决了如何传值，下一步就是更新数据。</span><br><span class=\"line\"></span><br><span class=\"line\">  * 因为 v-model的特点就是会将值进行了绑定，所以我们只需要通知同步就行了</span><br><span class=\"line\"></span><br><span class=\"line\">  * ```</span><br><span class=\"line\">    &lt;input type=&quot;text&quot; :value=&quot;myInput&quot; @input=&quot;inputE($event)&quot;&gt;</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p>input事件，绑定了inputE方法，然后inputE里面通过$emit进行传递。事件名称就是model里面的事件名称，inp, 如果没有进行重命名，那么就是 input事件。父组件不需要做什么，因为v-model自动对事件和参数进行了赋值。当然，也是可以赋值常数的。</p>\n</li>\n</ul>\n</li>\n<li><p>同时我们通过这个案例也知道了，如果你对一个input输入框加了v-model，也加了input的监听，在input的监听修改了v-model的值，那么会以input的为主。</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"通过插槽分发内容\"><a href=\"#通过插槽分发内容\" class=\"headerlink\" title=\"通过插槽分发内容\"></a>通过插槽分发内容</h2><p>​        简单来说，就是可以在标签内部使用标签，然后标签可以传递给子元素显示。父元素的使用方式就是下面这样。子元素只需要定义一个 slot，然后slot的位置就会显示为你定义的。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;alert-box&gt;</span><br><span class=\"line\">  Something bad happened.</span><br><span class=\"line\">&lt;/alert-box&gt;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Vue.component(&#x27;alert-box&#x27;, &#123;</span><br><span class=\"line\">  template: `</span><br><span class=\"line\">    &lt;div class=&quot;demo-alert-box&quot;&gt;</span><br><span class=\"line\">      &lt;strong&gt;Error!&lt;/strong&gt;</span><br><span class=\"line\">      &lt;slot&gt;&lt;/slot&gt; 这里就会被渲染为其他的。</span><br><span class=\"line\">    &lt;/div&gt;`</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>​        这里在简单的说几个地方。</p>\n<p>​        1.如果使用了多个slot，默认每个slot都会全部都会显示，但是又不是你想的那种显示。我不知道怎么描述。直接看例子就懂了：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;p&gt;123&lt;/p&gt;</span><br><span class=\"line\">&lt;slot&gt;&lt;/slot&gt;</span><br><span class=\"line\">&lt;slot&gt;&lt;/slot&gt;</span><br><span class=\"line\">&lt;p&gt;321&lt;/p&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&lt;tt&gt;</span><br><span class=\"line\">  &lt;div&gt;123&lt;/div&gt;</span><br><span class=\"line\">  &lt;div&gt;321&lt;/div&gt;</span><br><span class=\"line\">&lt;/tt&gt;</span><br></pre></td></tr></table></figure>\n\n<p>​        下面这个我定义了两个slot，然后组件名为tt，tt里面有两个div标签值为123和321。你可能会认为一个 slot为123，一个slot为321.但是其实不是，因为你没有给定name，所以这两个div会被当成一个传递给插槽。然后两个插槽都会被赋值。所以值为</p>\n<img src=\"/.io//image-20211105095952701.png\" alt=\"image-20211105095952701\" style=\"zoom:50%;\">\n\n\n\n<p>​        那么要如何实现上面预想的效果呢，使用name。一个不带 <code>name</code> 的 <code>&lt;slot&gt;</code> 出口会带有隐含的名字“default”。</p>\n<p>​        然后就是父组件如何使用了，这里有三个写法</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div slot=&quot;aa&quot;&gt;123&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;template v-slot:aa&gt;</span><br><span class=\"line\">\t&lt;div&gt;123&lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;template #aa&gt;</span><br><span class=\"line\">\t&lt;div&gt;123&lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br></pre></td></tr></table></figure>\n\n<p>​        上面这三个写法，</p>\n<ul>\n<li><p>第一个是一个旧的写法，不建议，因为建议是使用一个template进行包裹，template作为一个html5的新特性。</p>\n</li>\n<li><p>第二个是使用的v-slot进行绑定。但是需要将其放在template上，才有效果</p>\n</li>\n<li><p>第三个就是第二个的一个语法糖写法。</p>\n</li>\n<li><p>然后就是如何使用变量，首先可以使用 v-bind 进行绑定。其次也可以使用 [] 进行表示。</p>\n<ul>\n<li>```<br>:slot=”name” :v-slot:name :#name<br>v-slot:[name] #[name]<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t然后就是插槽是会将值进行覆盖的。所以如果你在slot上写的一些样式和方法不会显示，对应的方式就是（**v-if，v-for** 有效果，因为这些是对DOM树进行了变化，所以会在DOM树的添加，而不是对一个属性的覆盖。但是对于一些class和v-show就没用了。）</span><br><span class=\"line\"></span><br><span class=\"line\">* 第一种，父元素写方法和样式，但是这样一个子组件就对父组件不透明了</span><br><span class=\"line\"></span><br><span class=\"line\">* 第二种，在外面套上一层标签。向下面这样就行了。</span><br><span class=\"line\"></span><br><span class=\"line\">  * ```</span><br><span class=\"line\">    &lt;div v-show=&quot;false&quot;&gt;</span><br><span class=\"line\">    \t&lt;slot&gt;&lt;/slot&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ul>\n<p>​        其他的部分，详见Vue的 <a href=\"https://cn.vuejs.org/v2/guide/components-slots.html\">插槽</a> 部分。</p>\n<h2 id=\"动态组件\"><a href=\"#动态组件\" class=\"headerlink\" title=\"动态组件\"></a>动态组件</h2><p>​        简单来说就是不同组件会进行动态切换，所以可以使用</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;component :is=&quot;name&quot;&gt;&lt;/component&gt;</span><br><span class=\"line\">&lt;button @click=&quot;change&quot;&gt;change&lt;/button&gt;</span><br></pre></td></tr></table></figure>\n\n<p>​        这里 component 是一个标签，is使用v-bind绑定了name，然后通过一个点击事件来修改了name的值，所以component，is就会被指定修改成其他的组件名。</p>\n<p>​        这个is属性应该是html里面的那个is属性，但是具体的使用方式我现在看不懂，可以取MDN里面进行了解，这里我们就当作is会指定一个组件名，然后这个component标签就会被替换成组件名。</p>\n<p>​        在上述示例中，name可以包括：</p>\n<ul>\n<li>已注册组件的名字，或</li>\n<li>一个组件的选项对象</li>\n</ul>\n<p>注意：</p>\n<p>​        这个is属性可以用于常规的html元素上。</p>\n<p>​        但是对于attribute将会作为DOM attribute进行绑定，对于像 <code>value</code> 这样的 property，若想让其如预期般工作，你需要使用 <a href=\"https://cn.vuejs.org/v2/api/#v-bind\"><code>.prop</code> 修饰器</a>。</p>\n<p>​        这里就扯出了 attribute 和 property 的一个区别，我这里就贴一个 <a href=\"https://stackoverflow.com/questions/6003819/properties-and-attributes-in-html#answer-6004028\">StackOverflow</a> 和 一个对应 StackOverflow 的 <a href=\"https://blog.csdn.net/rudy_zhou/article/details/104058741\">CSDN </a> 的一个中文的讲解 </p>\n<p>​        大概就是说，attribute属性是一个HTML的上的属性，而property是一个DOM对象上的属性。有的属性开始是继承了attribute，但是后续会被修改，此时可以从property看出，但是不会从attribute看出。</p>\n<h2 id=\"解析-DOM-模板时的注意事项\"><a href=\"#解析-DOM-模板时的注意事项\" class=\"headerlink\" title=\"解析 DOM 模板时的注意事项\"></a>解析 DOM 模板时的注意事项</h2><p>​        简单来说，就是有的HTML 元素限制了其内部的元素是哪些，对于不属于的，会被提升到外部，触发其他问题。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;ul&gt;、&lt;ol&gt;、&lt;table&gt; 和 &lt;select&gt;</span><br></pre></td></tr></table></figure>\n\n<p>​        有的元素是，只能存在于特定的元素内部</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;li&gt;、&lt;tr&gt; 和 &lt;option&gt;</span><br></pre></td></tr></table></figure>\n\n<p>​        案例</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;table&gt;</span><br><span class=\"line\">  &lt;blog-post-row&gt;&lt;/blog-post-row&gt;</span><br><span class=\"line\">&lt;/table&gt;</span><br></pre></td></tr></table></figure>\n\n<p>​        对于上面的情况，blog-post-row 会被提升到外部，所以会出现页面布局的问题。</p>\n<p>​        解决方式，使用is attribute。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;table&gt;</span><br><span class=\"line\">  &lt;tr is=&quot;blog-post-row&quot;&gt;&lt;/tr&gt;</span><br><span class=\"line\">&lt;/table&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>需要注意的是<strong>如果我们从以下来源使用模板的话，这条限制是<em>不存在</em> 的</strong>：</p>\n<ul>\n<li><p>字符串 (例如：<code>template: &#39;...&#39;</code>) </p>\n<ul>\n<li><pre><code>Vue.component(&#39;tt&#39;, &#123;\n  template: `\n    &lt;table&gt;\n        &lt;p&gt;1&lt;/p&gt;\n    &lt;/table&gt;\n  `,\n&#125;);\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">  - 此时 p 标签存在于table 内部。</span><br><span class=\"line\"></span><br><span class=\"line\">- [单文件组件 (`.vue`)](https://cn.vuejs.org/v2/guide/single-file-components.html) </span><br><span class=\"line\"></span><br><span class=\"line\">- [`&lt;script type=&quot;text/x-template&quot;&gt;`](https://cn.vuejs.org/v2/guide/components-edge-cases.html#X-Template) </span><br><span class=\"line\"></span><br><span class=\"line\">  ​\t当然这些，我也没有测试过，所以不清楚。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">至此，简单的一个基础就了解完了，详细的还是看看Vue官网的 文档和API吧</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\nhttps://cn.vuejs.org/v2/api/\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br></pre></td></tr></table></figure>\nhttps://cn.vuejs.org/v2/guide/\n</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n</div>"}],"PostAsset":[{"_id":"source/_posts/CSS/CSS-flex/image-20211027210947232.png","post":"ckznhkk7i0024ikub2aah4ina","slug":"image-20211027210947232.png","modified":1,"renderable":1},{"_id":"source/_posts/CSS/CSS-flex/image-20211027211015004.png","post":"ckznhkk7i0024ikub2aah4ina","slug":"image-20211027211015004.png","modified":1,"renderable":1},{"_id":"source/_posts/CSS/CSS-flex/image-20211027212431340.png","post":"ckznhkk7i0024ikub2aah4ina","slug":"image-20211027212431340.png","modified":1,"renderable":1},{"_id":"source/_posts/CSS/CSS-flex/image-20211027213217557.png","post":"ckznhkk7i0024ikub2aah4ina","slug":"image-20211027213217557.png","modified":1,"renderable":1},{"_id":"source/_posts/CSS/CSS-flex/image-20211027214029980.png","post":"ckznhkk7i0024ikub2aah4ina","slug":"image-20211027214029980.png","modified":1,"renderable":1},{"_id":"source/_posts/CSS/外边距合并/image-20211020224217218.png","post":"ckznhkk7j0027ikubcmolcfn3","slug":"image-20211020224217218.png","modified":1,"renderable":1},{"_id":"source/_posts/CSS/外边距合并/image-20211020224237425.png","post":"ckznhkk7j0027ikubcmolcfn3","slug":"image-20211020224237425.png","modified":1,"renderable":1},{"_id":"source/_posts/CSS/外边距合并/image-20211021103824947.png","post":"ckznhkk7j0027ikubcmolcfn3","slug":"image-20211021103824947.png","modified":1,"renderable":1},{"_id":"source/_posts/HTML/HTML-标签的title/image-20211030223916508.png","post":"ckznhkk7q0034ikub3suddnho","slug":"image-20211030223916508.png","modified":1,"renderable":1},{"_id":"source/_posts/CSS/border-radius的原理和使用/image-20211025104342522.png","post":"ckznhkk7i0020ikubgfl40ktw","slug":"image-20211025104342522.png","modified":1,"renderable":1},{"_id":"source/_posts/CSS/border-radius的原理和使用/image-20211025104917514.png","post":"ckznhkk7i0020ikubgfl40ktw","slug":"image-20211025104917514.png","modified":1,"renderable":1},{"_id":"source/_posts/CSS/border-radius的原理和使用/image-20211025155459099.png","post":"ckznhkk7i0020ikubgfl40ktw","slug":"image-20211025155459099.png","modified":1,"renderable":1},{"_id":"source/_posts/HTML/块环境上下文/image-20211022110540794.png","post":"ckznhkk7r003aikub1eak86go","slug":"image-20211022110540794.png","modified":1,"renderable":1},{"_id":"source/_posts/HTML/块环境上下文/image-20211022161542404.png","post":"ckznhkk7r003aikub1eak86go","slug":"image-20211022161542404.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue/Vue生命周期/lifecycle.png","post":"ckznhkk80003mikubddff7yfn","slug":"lifecycle.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue/Vue生命周期/lifecycle9.jpg","post":"ckznhkk80003mikubddff7yfn","slug":"lifecycle9.jpg","modified":1,"renderable":1},{"_id":"source/_posts/Node JS/JavaScript事件循环/image-20211107211640084.png","post":"ckznhkk83003vikubeg8f12gq","slug":"image-20211107211640084.png","modified":1,"renderable":1},{"_id":"source/_posts/其他/HTTP和HTTPS/image-20210831164301870.png","post":"ckznhkk850046ikub3bol02e3","slug":"image-20210831164301870.png","modified":1,"renderable":1},{"_id":"source/_posts/Node JS/NodeJS下载和npm安装/image-20211228140948410-16406717947501.png","post":"ckznhkk83003zikubab78bq7s","slug":"image-20211228140948410-16406717947501.png","modified":1,"renderable":1},{"_id":"source/_posts/其他/HTTP概述/image-20211024100324347.png","post":"ckznhkk850049ikubbnkkd4rc","slug":"image-20211024100324347.png","modified":1,"renderable":1},{"_id":"source/_posts/其他/HTTP概述/image-20211024104204389.png","post":"ckznhkk850049ikubbnkkd4rc","slug":"image-20211024104204389.png","modified":1,"renderable":1},{"_id":"source/_posts/其他/浏览器缓存策略/image-20211023161739229.png","post":"ckznhkk87004kikubgjv38i60","slug":"image-20211023161739229.png","modified":1,"renderable":1},{"_id":"source/_posts/其他/TCP/image-20211106102234899.png","post":"ckznhkk86004dikubgrxt6h3f","slug":"image-20211106102234899.png","modified":1,"renderable":1},{"_id":"source/_posts/其他/TCP/image-20211106102310315.png","post":"ckznhkk86004dikubgrxt6h3f","slug":"image-20211106102310315.png","modified":1,"renderable":1},{"_id":"source/_posts/其他/TCP/image-20211106102333564.png","post":"ckznhkk86004dikubgrxt6h3f","slug":"image-20211106102333564.png","modified":1,"renderable":1},{"_id":"source/_posts/其他/TCP/image-20211106102433477.png","post":"ckznhkk86004dikubgrxt6h3f","slug":"image-20211106102433477.png","modified":1,"renderable":1},{"_id":"source/_posts/其他/TCP/image-20211106102459740.png","post":"ckznhkk86004dikubgrxt6h3f","slug":"image-20211106102459740.png","modified":1,"renderable":1},{"_id":"source/_posts/其他/TCP/image-20211106102538627.png","post":"ckznhkk86004dikubgrxt6h3f","slug":"image-20211106102538627.png","modified":1,"renderable":1},{"_id":"source/_posts/其他/TCP/image-20211106103554196.png","post":"ckznhkk86004dikubgrxt6h3f","slug":"image-20211106103554196.png","modified":1,"renderable":1},{"_id":"source/_posts/随笔/next/image-20211018105920422.png","post":"ckznhkk89004vikub6z299npe","slug":"image-20211018105920422.png","modified":1,"renderable":1},{"_id":"source/_posts/随笔/next/image-20211018110658046.png","post":"ckznhkk89004vikub6z299npe","slug":"image-20211018110658046.png","modified":1,"renderable":1},{"_id":"source/_posts/随笔/next/image-20211018110937363.png","post":"ckznhkk89004vikub6z299npe","slug":"image-20211018110937363.png","modified":1,"renderable":1},{"_id":"source/_posts/随笔/浏览器的回流和重绘/painted and re-render.jpg","post":"ckznhkk8c0058ikub8syc34cx","slug":"painted and re-render.jpg","modified":1,"renderable":1},{"_id":"source/_posts/JavaScript/概念/JavaScript-冒泡和捕获/image-20210907141230550.png","post":"ckznhkk8m006likub4nor5vxw","slug":"image-20210907141230550.png","modified":1,"renderable":1},{"_id":"source/_posts/JavaScript/概念/JavaScript原型链/290701352241158.jpg","post":"ckznhkk8o006vikub3vib9425","slug":"290701352241158.jpg","modified":1,"renderable":1},{"_id":"source/_posts/JavaScript/概念/JavaScript原型链/image-20211110100356010.png","post":"ckznhkk8o006vikub3vib9425","slug":"image-20211110100356010.png","modified":1,"renderable":1},{"_id":"source/_posts/JavaScript/概念/JavaScript原型链/image-20211110101346723.png","post":"ckznhkk8o006vikub3vib9425","slug":"image-20211110101346723.png","modified":1,"renderable":1},{"_id":"source/_posts/JavaScript/概念/JavaScript类型转换/image-20211019105728109.png","post":"ckznhkk8r007hikubdyaj5rct","slug":"image-20211019105728109.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue/Vue2教程/Vue2-教程-基础使用/image-20211105095952701.png","post":"ckznhkk8u0081ikub4mwz7rns","slug":"image-20211105095952701.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue/Vue2教程/Vue2-教程-基础使用/lifecycle.png","post":"ckznhkk8u0081ikub4mwz7rns","slug":"lifecycle.png","modified":1,"renderable":1}],"PostCategory":[{"post_id":"ckznhkk700009ikubaf8j4l1v","category_id":"ckznhkk73000fikubd9an4ou1","_id":"ckznhkk76000pikub8v2l1p8z"},{"post_id":"ckznhkk6p0001ikub3yy5c6en","category_id":"ckznhkk6y0004ikubgons9neb","_id":"ckznhkk78000xikubeuai4o02"},{"post_id":"ckznhkk6p0001ikub3yy5c6en","category_id":"ckznhkk75000likubemr7ag68","_id":"ckznhkk790010ikubdnj9436a"},{"post_id":"ckznhkk70000aikubabygek2x","category_id":"ckznhkk73000fikubd9an4ou1","_id":"ckznhkk7a0013ikubcnmy4v5j"},{"post_id":"ckznhkk6z0007ikub3zkt768q","category_id":"ckznhkk71000bikubcfubfkpf","_id":"ckznhkk7c001cikub139193ht"},{"post_id":"ckznhkk6z0007ikub3zkt768q","category_id":"ckznhkk78000wikub8t4374fl","_id":"ckznhkk7c001gikub0zrc0byi"},{"post_id":"ckznhkk790011ikub962w5fyu","category_id":"ckznhkk6y0004ikubgons9neb","_id":"ckznhkk7d001jikub93e9esgb"},{"post_id":"ckznhkk790011ikub962w5fyu","category_id":"ckznhkk75000likubemr7ag68","_id":"ckznhkk7e001nikuba8ug6k59"},{"post_id":"ckznhkk7b0018ikubdy9c5czb","category_id":"ckznhkk73000fikubd9an4ou1","_id":"ckznhkk7g001qikub3451glvf"},{"post_id":"ckznhkk72000eikubgx2k8rzo","category_id":"ckznhkk73000fikubd9an4ou1","_id":"ckznhkk7h001vikubhcm0fgni"},{"post_id":"ckznhkk7d001iikubec48ef7n","category_id":"ckznhkk73000fikubd9an4ou1","_id":"ckznhkk7h001xikuben6pd4q8"},{"post_id":"ckznhkk7e001mikub5fov2duw","category_id":"ckznhkk73000fikubd9an4ou1","_id":"ckznhkk7i0021ikub4i6kaize"},{"post_id":"ckznhkk74000jikub0kqgeivn","category_id":"ckznhkk7d001kikub1ak3gy7u","_id":"ckznhkk7j0025ikub9ib160w6"},{"post_id":"ckznhkk75000nikubcnbpetgy","category_id":"ckznhkk7g001rikub7ddrakzg","_id":"ckznhkk7k0029ikub2p4b5349"},{"post_id":"ckznhkk76000oikub7zujgra5","category_id":"ckznhkk7h001zikuba1braor0","_id":"ckznhkk7l002fikub8iks6blq"},{"post_id":"ckznhkk76000sikub433q0oku","category_id":"ckznhkk7k0028ikubag5ge8yu","_id":"ckznhkk7n002nikubgjby0w1q"},{"post_id":"ckznhkk78000uikubac8w7vkl","category_id":"ckznhkk7k0028ikubag5ge8yu","_id":"ckznhkk7o002sikub1hy0blqp"},{"post_id":"ckznhkk78000yikub494n5u9r","category_id":"ckznhkk7m002mikubefwx9ows","_id":"ckznhkk7p002yikub22fudvv1"},{"post_id":"ckznhkk7o002rikub3jp03am5","category_id":"ckznhkk6y0004ikubgons9neb","_id":"ckznhkk7q0032ikubbx5sh0dj"},{"post_id":"ckznhkk7p002xikubfy49ht31","category_id":"ckznhkk73000fikubd9an4ou1","_id":"ckznhkk7q0035ikub3vo5drj4"},{"post_id":"ckznhkk73000hikub4u2q9w2i","category_id":"ckznhkk7c001bikubgscdb22r","_id":"ckznhkk7u003bikub926bec8w"},{"post_id":"ckznhkk73000hikub4u2q9w2i","category_id":"ckznhkk7p002zikub9h9tfflb","_id":"ckznhkk7v003gikub4hky6ddw"},{"post_id":"ckznhkk7r003aikub1eak86go","category_id":"ckznhkk7r0036ikub7ym473i2","_id":"ckznhkk81003nikub0x2s1njw"},{"post_id":"ckznhkk7i0020ikubgfl40ktw","category_id":"ckznhkk7o002uikubaq8bhvru","_id":"ckznhkk83003yikubgstr8w4g"},{"post_id":"ckznhkk81003pikub0bkt18yl","category_id":"ckznhkk7c001bikubgscdb22r","_id":"ckznhkk840040ikubd7f90su6"},{"post_id":"ckznhkk81003pikub0bkt18yl","category_id":"ckznhkk7p002zikub9h9tfflb","_id":"ckznhkk840045ikub0uwb246u"},{"post_id":"ckznhkk7i0024ikub2aah4ina","category_id":"ckznhkk7o002uikubaq8bhvru","_id":"ckznhkk850047ikub6qd33yea"},{"post_id":"ckznhkk83003vikubeg8f12gq","category_id":"ckznhkk6y0004ikubgons9neb","_id":"ckznhkk86004cikub2poechwz"},{"post_id":"ckznhkk83003vikubeg8f12gq","category_id":"ckznhkk75000likubemr7ag68","_id":"ckznhkk86004eikub04zm6wqk"},{"post_id":"ckznhkk7j0027ikubcmolcfn3","category_id":"ckznhkk7o002uikubaq8bhvru","_id":"ckznhkk87004iikubdv58cg5m"},{"post_id":"ckznhkk840042ikub8p79g9i4","category_id":"ckznhkk73000fikubd9an4ou1","_id":"ckznhkk87004likub8wajgj7t"},{"post_id":"ckznhkk850046ikub3bol02e3","category_id":"ckznhkk73000fikubd9an4ou1","_id":"ckznhkk88004qikub5jjy5aps"},{"post_id":"ckznhkk7k002cikub7q6idg9h","category_id":"ckznhkk7o002uikubaq8bhvru","_id":"ckznhkk89004tikub1pvsa1p9"},{"post_id":"ckznhkk850049ikubbnkkd4rc","category_id":"ckznhkk73000fikubd9an4ou1","_id":"ckznhkk89004yikub5oyc08ce"},{"post_id":"ckznhkk86004dikubgrxt6h3f","category_id":"ckznhkk73000fikubd9an4ou1","_id":"ckznhkk8b0051ikub9nth8r9j"},{"post_id":"ckznhkk7l002eikuba9fvg9es","category_id":"ckznhkk7o002uikubaq8bhvru","_id":"ckznhkk8c0054ikub3c6912d0"},{"post_id":"ckznhkk86004gikubffi7fd6x","category_id":"ckznhkk73000fikubd9an4ou1","_id":"ckznhkk8d0059ikub370l0lu9"},{"post_id":"ckznhkk87004kikubgjv38i60","category_id":"ckznhkk73000fikubd9an4ou1","_id":"ckznhkk8d005cikub8ohtd4vc"},{"post_id":"ckznhkk7m002iikub97p72ld1","category_id":"ckznhkk7o002uikubaq8bhvru","_id":"ckznhkk8e005hikub6xj53wbx"},{"post_id":"ckznhkk87004oikubc2yw8bub","category_id":"ckznhkk73000fikubd9an4ou1","_id":"ckznhkk8e005kikubanuy7o7e"},{"post_id":"ckznhkk88004sikubgd7tbekk","category_id":"ckznhkk73000fikubd9an4ou1","_id":"ckznhkk8h005pikub8e3o3oox"},{"post_id":"ckznhkk7m002kikub9vskbmr5","category_id":"ckznhkk7o002uikubaq8bhvru","_id":"ckznhkk8h005sikube0nkh9dc"},{"post_id":"ckznhkk89004vikub6z299npe","category_id":"ckznhkk73000fikubd9an4ou1","_id":"ckznhkk8i005xikubbmwq3u4z"},{"post_id":"ckznhkk8a0050ikub4pvk4fgk","category_id":"ckznhkk73000fikubd9an4ou1","_id":"ckznhkk8i0060ikub7a2pe5bh"},{"post_id":"ckznhkk7n002pikub5cnnavii","category_id":"ckznhkk6y0004ikubgons9neb","_id":"ckznhkk8k0065ikub9qus5anq"},{"post_id":"ckznhkk7n002pikub5cnnavii","category_id":"ckznhkk89004xikub0pcwfp1b","_id":"ckznhkk8k0067ikubhadn3og2"},{"post_id":"ckznhkk8b0053ikubfq9h0dqo","category_id":"ckznhkk73000fikubd9an4ou1","_id":"ckznhkk8l006cikubc1ud1kyy"},{"post_id":"ckznhkk8c0058ikub8syc34cx","category_id":"ckznhkk73000fikubd9an4ou1","_id":"ckznhkk8l006fikubg2emco1a"},{"post_id":"ckznhkk7c001fikub5i43afm1","category_id":"ckznhkk7o002uikubaq8bhvru","_id":"ckznhkk8m006kikubd4995ksz"},{"post_id":"ckznhkk7c001fikub5i43afm1","category_id":"ckznhkk8d005eikubhhn5410x","_id":"ckznhkk8m006mikub1qzl3vnf"},{"post_id":"ckznhkk7o002wikub98x1hrlt","category_id":"ckznhkk6y0004ikubgons9neb","_id":"ckznhkk8n006qikubdpv048r5"},{"post_id":"ckznhkk7o002wikub98x1hrlt","category_id":"ckznhkk89004xikub0pcwfp1b","_id":"ckznhkk8o006tikubby035yn0"},{"post_id":"ckznhkk7o002wikub98x1hrlt","category_id":"ckznhkk6y0004ikubgons9neb","_id":"ckznhkk8o006xikub57vg8m2n"},{"post_id":"ckznhkk7o002wikub98x1hrlt","category_id":"ckznhkk89004xikub0pcwfp1b","_id":"ckznhkk8p0070ikub74yb4vku"},{"post_id":"ckznhkk7o002wikub98x1hrlt","category_id":"ckznhkk6y0004ikubgons9neb","_id":"ckznhkk8p0072ikubfftl9vzt"},{"post_id":"ckznhkk7o002wikub98x1hrlt","category_id":"ckznhkk89004xikub0pcwfp1b","_id":"ckznhkk8q0077ikubg096boi7"},{"post_id":"ckznhkk7p0030ikub6ztw308p","category_id":"ckznhkk6y0004ikubgons9neb","_id":"ckznhkk8r007aikub9bjlebva"},{"post_id":"ckznhkk7p0030ikub6ztw308p","category_id":"ckznhkk89004xikub0pcwfp1b","_id":"ckznhkk8r007fikubazavelw9"},{"post_id":"ckznhkk7q0033ikub2p07d91q","category_id":"ckznhkk6y0004ikubgons9neb","_id":"ckznhkk8s007iikub0pja527a"},{"post_id":"ckznhkk7q0033ikub2p07d91q","category_id":"ckznhkk8h005uikub0gq41axw","_id":"ckznhkk8s007nikub6s8z351d"},{"post_id":"ckznhkk8j0063ikub543ohjqy","category_id":"ckznhkk7k0028ikubag5ge8yu","_id":"ckznhkk8t007qikube93kdo1h"},{"post_id":"ckznhkk7r0038ikub3ppr34cs","category_id":"ckznhkk6y0004ikubgons9neb","_id":"ckznhkk8t007vikub93hw7s63"},{"post_id":"ckznhkk7r0038ikub3ppr34cs","category_id":"ckznhkk8h005uikub0gq41axw","_id":"ckznhkk8u007yikub4kbdgkxq"},{"post_id":"ckznhkk8m006iikub70p406e6","category_id":"ckznhkk6y0004ikubgons9neb","_id":"ckznhkk8v0083ikub6pfxhfw2"},{"post_id":"ckznhkk8m006iikub70p406e6","category_id":"ckznhkk75000likubemr7ag68","_id":"ckznhkk8v0085ikub403r7qun"},{"post_id":"ckznhkk8m006likub4nor5vxw","category_id":"ckznhkk6y0004ikubgons9neb","_id":"ckznhkk8w0089ikubhr0thbp9"},{"post_id":"ckznhkk7e001pikubbvyh4d48","category_id":"ckznhkk7r0036ikub7ym473i2","_id":"ckznhkk8w008bikub2gwubviu"},{"post_id":"ckznhkk7e001pikubbvyh4d48","category_id":"ckznhkk8m006jikub9ojpbxy2","_id":"ckznhkk8x008fikubch0xg650"},{"post_id":"ckznhkk8n006sikubfiq85fn6","category_id":"ckznhkk6y0004ikubgons9neb","_id":"ckznhkk8x008hikub417bhxuj"},{"post_id":"ckznhkk8n006sikubfiq85fn6","category_id":"ckznhkk75000likubemr7ag68","_id":"ckznhkk8x008likuba18kbyg1"},{"post_id":"ckznhkk7v003fikub1wxmg2eq","category_id":"ckznhkk7c001bikubgscdb22r","_id":"ckznhkk8x008nikubdxvyf621"},{"post_id":"ckznhkk7v003fikub1wxmg2eq","category_id":"ckznhkk8n006pikubc7ln7d3v","_id":"ckznhkk8x008qikub32n45hr9"},{"post_id":"ckznhkk8o006vikub3vib9425","category_id":"ckznhkk6y0004ikubgons9neb","_id":"ckznhkk8x008tikub1vezcj8z"},{"post_id":"ckznhkk8o006vikub3vib9425","category_id":"ckznhkk75000likubemr7ag68","_id":"ckznhkk8y008vikubh9zzgxo4"},{"post_id":"ckznhkk8o006zikubhan2ht1q","category_id":"ckznhkk6y0004ikubgons9neb","_id":"ckznhkk8z008yikub6opsdx5i"},{"post_id":"ckznhkk8o006zikubhan2ht1q","category_id":"ckznhkk75000likubemr7ag68","_id":"ckznhkk8z0090ikub1806c6z5"},{"post_id":"ckznhkk7h001wikub0m561tyd","category_id":"ckznhkk7o002uikubaq8bhvru","_id":"ckznhkk8z0094ikube9np2n3y"},{"post_id":"ckznhkk7h001wikub0m561tyd","category_id":"ckznhkk8d005eikubhhn5410x","_id":"ckznhkk8z0096ikub7nuk2nmf"},{"post_id":"ckznhkk8p0071ikubb83xg2wc","category_id":"ckznhkk6y0004ikubgons9neb","_id":"ckznhkk900099ikub7woy4vlm"},{"post_id":"ckznhkk8p0071ikubb83xg2wc","category_id":"ckznhkk75000likubemr7ag68","_id":"ckznhkk90009aikubd8892c9m"},{"post_id":"ckznhkk8q0076ikub1xl7djma","category_id":"ckznhkk6y0004ikubgons9neb","_id":"ckznhkk90009cikubad1m5zt1"},{"post_id":"ckznhkk7v003iikubf24h43ei","category_id":"ckznhkk7c001bikubgscdb22r","_id":"ckznhkk91009eikub9rajbygq"},{"post_id":"ckznhkk7v003iikubf24h43ei","category_id":"ckznhkk8p0074ikub5o2q9qct","_id":"ckznhkk91009gikubciq64cz7"},{"post_id":"ckznhkk8r007eikubg26r4pi0","category_id":"ckznhkk6y0004ikubgons9neb","_id":"ckznhkk91009iikubhjca4tc9"},{"post_id":"ckznhkk8r007eikubg26r4pi0","category_id":"ckznhkk75000likubemr7ag68","_id":"ckznhkk91009likubf41ehsyg"},{"post_id":"ckznhkk80003mikubddff7yfn","category_id":"ckznhkk7c001bikubgscdb22r","_id":"ckznhkk92009oikub6xmndchp"},{"post_id":"ckznhkk80003mikubddff7yfn","category_id":"ckznhkk8n006pikubc7ln7d3v","_id":"ckznhkk92009rikub2y6if407"},{"post_id":"ckznhkk8r007hikubdyaj5rct","category_id":"ckznhkk6y0004ikubgons9neb","_id":"ckznhkk92009uikub0iy7hjyk"},{"post_id":"ckznhkk8r007hikubdyaj5rct","category_id":"ckznhkk89004xikub0pcwfp1b","_id":"ckznhkk92009wikubfld560q7"},{"post_id":"ckznhkk8s007mikubb0xtfsbq","category_id":"ckznhkk6y0004ikubgons9neb","_id":"ckznhkk92009zikub77z019bl"},{"post_id":"ckznhkk8s007mikubb0xtfsbq","category_id":"ckznhkk75000likubemr7ag68","_id":"ckznhkk9200a2ikub4zow09c5"},{"post_id":"ckznhkk8s007pikubbjrh3968","category_id":"ckznhkk6y0004ikubgons9neb","_id":"ckznhkk9300a5ikubelbp2ept"},{"post_id":"ckznhkk8s007pikubbjrh3968","category_id":"ckznhkk75000likubemr7ag68","_id":"ckznhkk9300a8ikub1rxv54sw"},{"post_id":"ckznhkk8t007xikubf25f27y3","category_id":"ckznhkk7k0028ikubag5ge8yu","_id":"ckznhkk9300abikub5k920d9b"},{"post_id":"ckznhkk8d005bikub60fjebyi","category_id":"ckznhkk8t007uikub1fk5e9rc","_id":"ckznhkk9300aeikubg01ncrvr"},{"post_id":"ckznhkk8e005gikubhlpj9y4s","category_id":"ckznhkk8t007uikub1fk5e9rc","_id":"ckznhkk9300agikub2npy1t21"},{"post_id":"ckznhkk8e005jikubb1hj3z8w","category_id":"ckznhkk8t007uikub1fk5e9rc","_id":"ckznhkk9400ajikubhcpl1j7e"},{"post_id":"ckznhkk8g005oikub37gad84w","category_id":"ckznhkk8t007uikub1fk5e9rc","_id":"ckznhkk9400alikubh7q45e30"},{"post_id":"ckznhkk8h005rikub841q5bo9","category_id":"ckznhkk8t007uikub1fk5e9rc","_id":"ckznhkk9400anikub9wora3rf"},{"post_id":"ckznhkk8i005wikubedbffwit","category_id":"ckznhkk7c001bikubgscdb22r","_id":"ckznhkk9400apikubb0kharbg"},{"post_id":"ckznhkk8i005wikubedbffwit","category_id":"ckznhkk8x008pikub94we9map","_id":"ckznhkk9400asikub0cqy4qte"},{"post_id":"ckznhkk8i005zikubdlliemkp","category_id":"ckznhkk7c001bikubgscdb22r","_id":"ckznhkk9400auikub6fxv67yi"},{"post_id":"ckznhkk8i005zikubdlliemkp","category_id":"ckznhkk8x008pikub94we9map","_id":"ckznhkk9400axikub5c17hoj2"},{"post_id":"ckznhkk8k0066ikubacvabqtp","category_id":"ckznhkk7c001bikubgscdb22r","_id":"ckznhkk9400azikubcxic8kkn"},{"post_id":"ckznhkk8k0066ikubacvabqtp","category_id":"ckznhkk8x008pikub94we9map","_id":"ckznhkk9400b2ikubhvuy71sh"},{"post_id":"ckznhkk7q0034ikub3suddnho","category_id":"ckznhkk7r0036ikub7ym473i2","_id":"ckznhkk9500b4ikub019v0gwb"},{"post_id":"ckznhkk7q0034ikub3suddnho","category_id":"ckznhkk8m006jikub9ojpbxy2","_id":"ckznhkk9500b6ikub5l410p52"},{"post_id":"ckznhkk8k006aikubct7r2880","category_id":"ckznhkk7c001bikubgscdb22r","_id":"ckznhkk9500b9ikub2qti6159"},{"post_id":"ckznhkk8k006aikubct7r2880","category_id":"ckznhkk90009bikubg6p84k0l","_id":"ckznhkk9500bbikub35isfa3a"},{"post_id":"ckznhkk8l006eikubed07b7sj","category_id":"ckznhkk6y0004ikubgons9neb","_id":"ckznhkk9500bdikub1b08e09a"},{"post_id":"ckznhkk8l006eikubed07b7sj","category_id":"ckznhkk91009fikub8hsg1ezb","_id":"ckznhkk9500bfikuba5rgbmqi"},{"post_id":"ckznhkk8n006nikub0v73e8hn","category_id":"ckznhkk6y0004ikubgons9neb","_id":"ckznhkk9500biikub2ez7eo3s"},{"post_id":"ckznhkk8n006nikub0v73e8hn","category_id":"ckznhkk91009kikubey4n8rdb","_id":"ckznhkk9500bjikub1rj81z0q"},{"post_id":"ckznhkk8q0079ikub9abgdj7f","category_id":"ckznhkk6y0004ikubgons9neb","_id":"ckznhkk9500blikub07nbfijb"},{"post_id":"ckznhkk8q0079ikub9abgdj7f","category_id":"ckznhkk92009qikub3o6vh448","_id":"ckznhkk9500bnikub0s21d6fe"},{"post_id":"ckznhkk82003sikub3uedcn6s","category_id":"ckznhkk8s007likubczcj53gl","_id":"ckznhkk9500bpikub1l1v0dry"},{"post_id":"ckznhkk82003sikub3uedcn6s","category_id":"ckznhkk92009yikubbp5b0yb9","_id":"ckznhkk9600bsikubedis8v9k"},{"post_id":"ckznhkk8t007tikub5qwi8q23","category_id":"ckznhkk7c001bikubgscdb22r","_id":"ckznhkk9600buikubge66e3np"},{"post_id":"ckznhkk8t007tikub5qwi8q23","category_id":"ckznhkk90009bikubg6p84k0l","_id":"ckznhkk9600bxikub2dd9amxn"},{"post_id":"ckznhkk8u0081ikub4mwz7rns","category_id":"ckznhkk7c001bikubgscdb22r","_id":"ckznhkk9600byikub2kof29wv"},{"post_id":"ckznhkk8u0081ikub4mwz7rns","category_id":"ckznhkk90009bikubg6p84k0l","_id":"ckznhkk9600c0ikub9ef37q9r"}],"PostTag":[{"post_id":"ckznhkk6p0001ikub3yy5c6en","tag_id":"ckznhkk6y0005ikub1abhbcio","_id":"ckznhkk74000iikubhl6abgb6"},{"post_id":"ckznhkk6p0001ikub3yy5c6en","tag_id":"ckznhkk71000cikub6ulhfyen","_id":"ckznhkk75000kikub171v4332"},{"post_id":"ckznhkk6w0003ikubcq2s8ko9","tag_id":"ckznhkk73000gikub0zsg2fhv","_id":"ckznhkk77000tikubdc734c2w"},{"post_id":"ckznhkk6w0003ikubcq2s8ko9","tag_id":"ckznhkk75000mikubeeb8ay92","_id":"ckznhkk78000vikubdvtd3fs6"},{"post_id":"ckznhkk78000yikub494n5u9r","tag_id":"ckznhkk73000gikub0zsg2fhv","_id":"ckznhkk7a0012ikubb1ff53wu"},{"post_id":"ckznhkk790011ikub962w5fyu","tag_id":"ckznhkk6y0005ikub1abhbcio","_id":"ckznhkk7b0017ikub3jlc13j7"},{"post_id":"ckznhkk790011ikub962w5fyu","tag_id":"ckznhkk71000cikub6ulhfyen","_id":"ckznhkk7b0019ikub2ccm9k6r"},{"post_id":"ckznhkk6z0007ikub3zkt768q","tag_id":"ckznhkk76000rikub51as3sb0","_id":"ckznhkk7c001eikub2lco5bqd"},{"post_id":"ckznhkk6z0007ikub3zkt768q","tag_id":"ckznhkk79000zikub7vfz5ltp","_id":"ckznhkk7d001hikubb2np8u9m"},{"post_id":"ckznhkk7d001iikubec48ef7n","tag_id":"ckznhkk71000cikub6ulhfyen","_id":"ckznhkk7e001oikubcolygtrj"},{"post_id":"ckznhkk7e001mikub5fov2duw","tag_id":"ckznhkk71000cikub6ulhfyen","_id":"ckznhkk7g001sikube4xuf175"},{"post_id":"ckznhkk7g001uikub352zezws","tag_id":"ckznhkk71000cikub6ulhfyen","_id":"ckznhkk7h001yikub0t8v5bl1"},{"post_id":"ckznhkk700009ikubaf8j4l1v","tag_id":"ckznhkk71000cikub6ulhfyen","_id":"ckznhkk7i0023ikub6ri44h73"},{"post_id":"ckznhkk700009ikubaf8j4l1v","tag_id":"ckznhkk7c001dikubaayid7he","_id":"ckznhkk7j0026ikubepzegz38"},{"post_id":"ckznhkk700009ikubaf8j4l1v","tag_id":"ckznhkk7d001likub560e8oby","_id":"ckznhkk7k002bikub9e8f4zu8"},{"post_id":"ckznhkk700009ikubaf8j4l1v","tag_id":"ckznhkk7g001tikubfezbgm80","_id":"ckznhkk7l002dikubaevieyd1"},{"post_id":"ckznhkk70000aikubabygek2x","tag_id":"ckznhkk71000cikub6ulhfyen","_id":"ckznhkk7m002jikubdhxvfcou"},{"post_id":"ckznhkk70000aikubabygek2x","tag_id":"ckznhkk7k002aikubdeodhfiy","_id":"ckznhkk7m002likubajrv28q8"},{"post_id":"ckznhkk72000eikubgx2k8rzo","tag_id":"ckznhkk7l002hikubb9dm3gbf","_id":"ckznhkk7n002qikub9moxccm0"},{"post_id":"ckznhkk72000eikubgx2k8rzo","tag_id":"ckznhkk71000cikub6ulhfyen","_id":"ckznhkk7o002tikube5pn5p63"},{"post_id":"ckznhkk73000hikub4u2q9w2i","tag_id":"ckznhkk7n002oikubfgf339fe","_id":"ckznhkk7r0039ikub30tw5snf"},{"post_id":"ckznhkk73000hikub4u2q9w2i","tag_id":"ckznhkk7o002vikub7acy23ql","_id":"ckznhkk7u003cikubh7k1flsu"},{"post_id":"ckznhkk73000hikub4u2q9w2i","tag_id":"ckznhkk7q0031ikubgyjz3i1b","_id":"ckznhkk7v003hikubdarz45yt"},{"post_id":"ckznhkk74000jikub0kqgeivn","tag_id":"ckznhkk7r0037ikub8ptx5cty","_id":"ckznhkk7z003jikubfvsb2m9v"},{"post_id":"ckznhkk7v003fikub1wxmg2eq","tag_id":"ckznhkk7n002oikubfgf339fe","_id":"ckznhkk81003oikubg1fmcpfp"},{"post_id":"ckznhkk7v003fikub1wxmg2eq","tag_id":"ckznhkk71000cikub6ulhfyen","_id":"ckznhkk81003qikub9a4v730b"},{"post_id":"ckznhkk75000nikubcnbpetgy","tag_id":"ckznhkk7v003eikubhnux1snk","_id":"ckznhkk82003uikub00bu67c8"},{"post_id":"ckznhkk76000oikub7zujgra5","tag_id":"ckznhkk80003likub0a1ihqmp","_id":"ckznhkk83003wikubhhvv87vm"},{"post_id":"ckznhkk76000sikub433q0oku","tag_id":"ckznhkk82003tikub1qr11w8h","_id":"ckznhkk840043ikubfbje5cbn"},{"post_id":"ckznhkk78000uikubac8w7vkl","tag_id":"ckznhkk82003tikub1qr11w8h","_id":"ckznhkk85004aikubdof93qv9"},{"post_id":"ckznhkk7b0018ikubdy9c5czb","tag_id":"ckznhkk850048ikub4sd973ix","_id":"ckznhkk87004jikub2f0bcf1s"},{"post_id":"ckznhkk7b0018ikubdy9c5czb","tag_id":"ckznhkk71000cikub6ulhfyen","_id":"ckznhkk87004mikub0co4epfq"},{"post_id":"ckznhkk7b001aikubgermcg26","tag_id":"ckznhkk86004fikub6l292t6c","_id":"ckznhkk88004rikubf39t5k2t"},{"post_id":"ckznhkk7b001aikubgermcg26","tag_id":"ckznhkk71000cikub6ulhfyen","_id":"ckznhkk89004uikubbckxe2wl"},{"post_id":"ckznhkk7c001fikub5i43afm1","tag_id":"ckznhkk71000cikub6ulhfyen","_id":"ckznhkk89004zikub56ko6yuw"},{"post_id":"ckznhkk7c001fikub5i43afm1","tag_id":"ckznhkk87004nikubgkojbdn9","_id":"ckznhkk8b0052ikubblmy2btt"},{"post_id":"ckznhkk89004vikub6z299npe","tag_id":"ckznhkk71000cikub6ulhfyen","_id":"ckznhkk8c0057ikubdt636hv6"},{"post_id":"ckznhkk8a0050ikub4pvk4fgk","tag_id":"ckznhkk71000cikub6ulhfyen","_id":"ckznhkk8d005aikub038k6ice"},{"post_id":"ckznhkk7e001pikubbvyh4d48","tag_id":"ckznhkk89004wikub8amfdsui","_id":"ckznhkk8e005fikub3ldd2pbc"},{"post_id":"ckznhkk7e001pikubbvyh4d48","tag_id":"ckznhkk71000cikub6ulhfyen","_id":"ckznhkk8e005iikub8rnt1x8w"},{"post_id":"ckznhkk8b0053ikubfq9h0dqo","tag_id":"ckznhkk71000cikub6ulhfyen","_id":"ckznhkk8g005nikub4d27czf6"},{"post_id":"ckznhkk7h001wikub0m561tyd","tag_id":"ckznhkk87004nikubgkojbdn9","_id":"ckznhkk8h005qikubcm0hbniu"},{"post_id":"ckznhkk7h001wikub0m561tyd","tag_id":"ckznhkk71000cikub6ulhfyen","_id":"ckznhkk8h005vikubda51b6je"},{"post_id":"ckznhkk7i0020ikubgfl40ktw","tag_id":"ckznhkk87004nikubgkojbdn9","_id":"ckznhkk8i005yikubez2a44ih"},{"post_id":"ckznhkk7i0020ikubgfl40ktw","tag_id":"ckznhkk8e005likubc0hwabhb","_id":"ckznhkk8j0062ikubf672e4kc"},{"post_id":"ckznhkk8j0063ikub543ohjqy","tag_id":"ckznhkk82003tikub1qr11w8h","_id":"ckznhkk8k0068ikub093u8qkt"},{"post_id":"ckznhkk7i0024ikub2aah4ina","tag_id":"ckznhkk87004nikubgkojbdn9","_id":"ckznhkk8l006dikubhidj6mti"},{"post_id":"ckznhkk7i0024ikub2aah4ina","tag_id":"ckznhkk8i0061ikub8bif3m5i","_id":"ckznhkk8l006gikubhrx45kbt"},{"post_id":"ckznhkk7j0027ikubcmolcfn3","tag_id":"ckznhkk87004nikubgkojbdn9","_id":"ckznhkk8n006rikub7sqth6a8"},{"post_id":"ckznhkk7j0027ikubcmolcfn3","tag_id":"ckznhkk8l006hikub98ahgwb7","_id":"ckznhkk8o006uikub6nt5f4oy"},{"post_id":"ckznhkk8o006zikubhan2ht1q","tag_id":"ckznhkk6y0005ikub1abhbcio","_id":"ckznhkk8q0075ikubbgvz74ud"},{"post_id":"ckznhkk8o006zikubhan2ht1q","tag_id":"ckznhkk71000cikub6ulhfyen","_id":"ckznhkk8q0078ikub23ja7v98"},{"post_id":"ckznhkk7k002cikub7q6idg9h","tag_id":"ckznhkk87004nikubgkojbdn9","_id":"ckznhkk8r007cikub2cozaqig"},{"post_id":"ckznhkk7k002cikub7q6idg9h","tag_id":"ckznhkk8o006wikub3899cw8a","_id":"ckznhkk8r007gikub723obpev"},{"post_id":"ckznhkk8r007eikubg26r4pi0","tag_id":"ckznhkk6y0005ikub1abhbcio","_id":"ckznhkk8s007kikubbbva5vf8"},{"post_id":"ckznhkk8r007eikubg26r4pi0","tag_id":"ckznhkk71000cikub6ulhfyen","_id":"ckznhkk8s007oikub3nvs0nbl"},{"post_id":"ckznhkk7l002eikuba9fvg9es","tag_id":"ckznhkk87004nikubgkojbdn9","_id":"ckznhkk8t007sikubb6el97ie"},{"post_id":"ckznhkk7l002eikuba9fvg9es","tag_id":"ckznhkk8r007bikub7yzp2seh","_id":"ckznhkk8t007wikubgcct7puj"},{"post_id":"ckznhkk8s007mikubb0xtfsbq","tag_id":"ckznhkk71000cikub6ulhfyen","_id":"ckznhkk8u007zikub9voubhnr"},{"post_id":"ckznhkk8s007mikubb0xtfsbq","tag_id":"ckznhkk6y0005ikub1abhbcio","_id":"ckznhkk8v0084ikub43805k5j"},{"post_id":"ckznhkk8s007pikubbjrh3968","tag_id":"ckznhkk6y0005ikub1abhbcio","_id":"ckznhkk8v0086ikubecmhczcn"},{"post_id":"ckznhkk8s007pikubbjrh3968","tag_id":"ckznhkk71000cikub6ulhfyen","_id":"ckznhkk8w008aikub8gw98bno"},{"post_id":"ckznhkk7m002iikub97p72ld1","tag_id":"ckznhkk87004nikubgkojbdn9","_id":"ckznhkk8w008cikub552cgoye"},{"post_id":"ckznhkk7m002iikub97p72ld1","tag_id":"ckznhkk8t007rikubgb1zakvl","_id":"ckznhkk8x008gikubczb773te"},{"post_id":"ckznhkk8t007xikubf25f27y3","tag_id":"ckznhkk82003tikub1qr11w8h","_id":"ckznhkk8x008iikub4ykw520v"},{"post_id":"ckznhkk7m002kikub9vskbmr5","tag_id":"ckznhkk87004nikubgkojbdn9","_id":"ckznhkk8x008mikub948vdatr"},{"post_id":"ckznhkk7m002kikub9vskbmr5","tag_id":"ckznhkk89004wikub8amfdsui","_id":"ckznhkk8x008oikubfwfu6qou"},{"post_id":"ckznhkk7n002pikub5cnnavii","tag_id":"ckznhkk6y0005ikub1abhbcio","_id":"ckznhkk8x008sikubhlr79rwx"},{"post_id":"ckznhkk7n002pikub5cnnavii","tag_id":"ckznhkk8w008dikub08tc3tkd","_id":"ckznhkk8y008uikub76dd7z49"},{"post_id":"ckznhkk7o002rikub3jp03am5","tag_id":"ckznhkk6y0005ikub1abhbcio","_id":"ckznhkk8z008zikub2yw8ggpx"},{"post_id":"ckznhkk7o002rikub3jp03am5","tag_id":"ckznhkk8x008jikubfwngbo4x","_id":"ckznhkk8z0091ikub4ifudd3q"},{"post_id":"ckznhkk7o002rikub3jp03am5","tag_id":"ckznhkk8x008rikub0jiiggpv","_id":"ckznhkk8z0095ikubep1v64ta"},{"post_id":"ckznhkk7o002wikub98x1hrlt","tag_id":"ckznhkk6y0005ikub1abhbcio","_id":"ckznhkk91009jikub5zgb3aed"},{"post_id":"ckznhkk7o002wikub98x1hrlt","tag_id":"ckznhkk8y008xikub0rat38aa","_id":"ckznhkk91009mikub0kiwc9mg"},{"post_id":"ckznhkk7o002wikub98x1hrlt","tag_id":"ckznhkk8z0093ikub1nuu12w4","_id":"ckznhkk92009pikubfhxr9yvk"},{"post_id":"ckznhkk7o002wikub98x1hrlt","tag_id":"ckznhkk8z0098ikub4kbv75z1","_id":"ckznhkk92009sikubdym3cb1x"},{"post_id":"ckznhkk7o002wikub98x1hrlt","tag_id":"ckznhkk90009dikub1be43zs3","_id":"ckznhkk92009vikubdce09xzv"},{"post_id":"ckznhkk7p002xikubfy49ht31","tag_id":"ckznhkk6y0005ikub1abhbcio","_id":"ckznhkk92009xikubfn4z0p6m"},{"post_id":"ckznhkk7p002xikubfy49ht31","tag_id":"ckznhkk91009hikubbaxsetls","_id":"ckznhkk9200a1ikub6xzlb8ac"},{"post_id":"ckznhkk7p002xikubfy49ht31","tag_id":"ckznhkk71000cikub6ulhfyen","_id":"ckznhkk9200a3ikub1g6kdk1x"},{"post_id":"ckznhkk7p0030ikub6ztw308p","tag_id":"ckznhkk6y0005ikub1abhbcio","_id":"ckznhkk9300a7ikub714xajhn"},{"post_id":"ckznhkk7p0030ikub6ztw308p","tag_id":"ckznhkk91009nikub4sv09lz9","_id":"ckznhkk9300a9ikub56pe4qgf"},{"post_id":"ckznhkk7q0033ikub2p07d91q","tag_id":"ckznhkk6y0005ikub1abhbcio","_id":"ckznhkk9300adikubd8udemc5"},{"post_id":"ckznhkk7q0033ikub2p07d91q","tag_id":"ckznhkk92009tikub3pgkb4vy","_id":"ckznhkk9300afikub6h7rfno0"},{"post_id":"ckznhkk7q0034ikub3suddnho","tag_id":"ckznhkk71000cikub6ulhfyen","_id":"ckznhkk9300ahikub1kcnat3h"},{"post_id":"ckznhkk7q0034ikub3suddnho","tag_id":"ckznhkk89004wikub8amfdsui","_id":"ckznhkk9400akikubhaya6ikg"},{"post_id":"ckznhkk7r0038ikub3ppr34cs","tag_id":"ckznhkk6y0005ikub1abhbcio","_id":"ckznhkk9400aoikub52lfffit"},{"post_id":"ckznhkk7r0038ikub3ppr34cs","tag_id":"ckznhkk92009tikub3pgkb4vy","_id":"ckznhkk9400aqikub8daz4vde"},{"post_id":"ckznhkk7r0038ikub3ppr34cs","tag_id":"ckznhkk9300acikubb9oi2r04","_id":"ckznhkk9400atikubaloo0zlc"},{"post_id":"ckznhkk7r0038ikub3ppr34cs","tag_id":"ckznhkk90009dikub1be43zs3","_id":"ckznhkk9400avikub1bcy5eiv"},{"post_id":"ckznhkk7r003aikub1eak86go","tag_id":"ckznhkk89004wikub8amfdsui","_id":"ckznhkk9400ayikubaq7o47t5"},{"post_id":"ckznhkk7r003aikub1eak86go","tag_id":"ckznhkk9400arikub7pp57wwi","_id":"ckznhkk9400b0ikub9kjn9c3l"},{"post_id":"ckznhkk7v003iikubf24h43ei","tag_id":"ckznhkk7n002oikubfgf339fe","_id":"ckznhkk9500b3ikub66v3euyg"},{"post_id":"ckznhkk7v003iikubf24h43ei","tag_id":"ckznhkk9400awikub8fxk1x4x","_id":"ckznhkk9500b5ikubf9s03v6r"},{"post_id":"ckznhkk80003mikubddff7yfn","tag_id":"ckznhkk7n002oikubfgf339fe","_id":"ckznhkk9500b8ikub5r0la3h2"},{"post_id":"ckznhkk80003mikubddff7yfn","tag_id":"ckznhkk9400b1ikub3u9a3av5","_id":"ckznhkk9500baikub1l9j8wck"},{"post_id":"ckznhkk81003pikub0bkt18yl","tag_id":"ckznhkk7n002oikubfgf339fe","_id":"ckznhkk9500beikubf2lz65ps"},{"post_id":"ckznhkk81003pikub0bkt18yl","tag_id":"ckznhkk9500b7ikub4n9a5jj1","_id":"ckznhkk9500bgikub44uk4q9c"},{"post_id":"ckznhkk82003sikub3uedcn6s","tag_id":"ckznhkk9500bcikubc8961o13","_id":"ckznhkk9500bmikubegkobnd0"},{"post_id":"ckznhkk82003sikub3uedcn6s","tag_id":"ckznhkk9500bhikub55at9hsu","_id":"ckznhkk9500boikub8j3g8ugn"},{"post_id":"ckznhkk83003vikubeg8f12gq","tag_id":"ckznhkk6y0005ikub1abhbcio","_id":"ckznhkk9600brikub9856ah6i"},{"post_id":"ckznhkk83003vikubeg8f12gq","tag_id":"ckznhkk9500bkikub1vkpcnpe","_id":"ckznhkk9600btikubegzgb54p"},{"post_id":"ckznhkk83003vikubeg8f12gq","tag_id":"ckznhkk71000cikub6ulhfyen","_id":"ckznhkk9600bwikub27az0ofy"},{"post_id":"ckznhkk83003zikubab78bq7s","tag_id":"ckznhkk9500bqikub2bl07rks","_id":"ckznhkk9600c2ikub7ml2d1jn"},{"post_id":"ckznhkk83003zikubab78bq7s","tag_id":"ckznhkk9600bvikubfv6u61mz","_id":"ckznhkk9600c3ikubhi9u1puo"},{"post_id":"ckznhkk83003zikubab78bq7s","tag_id":"ckznhkk850048ikub4sd973ix","_id":"ckznhkk9600c5ikub1yhi2qrl"},{"post_id":"ckznhkk83003zikubab78bq7s","tag_id":"ckznhkk71000cikub6ulhfyen","_id":"ckznhkk9600c6ikub46mxe7t1"},{"post_id":"ckznhkk840042ikub8p79g9i4","tag_id":"ckznhkk71000cikub6ulhfyen","_id":"ckznhkk9700c9ikubad4t0ov7"},{"post_id":"ckznhkk840042ikub8p79g9i4","tag_id":"ckznhkk9600c1ikub5c9a6xhf","_id":"ckznhkk9700caikubdn2l4kxz"},{"post_id":"ckznhkk840042ikub8p79g9i4","tag_id":"ckznhkk9600c4ikub1w5e0k0n","_id":"ckznhkk9700ccikub0b3lgqf1"},{"post_id":"ckznhkk840042ikub8p79g9i4","tag_id":"ckznhkk9600c7ikubeoqv28ga","_id":"ckznhkk9700cdikubgq4a3815"},{"post_id":"ckznhkk850046ikub3bol02e3","tag_id":"ckznhkk9600c8ikubh4r519w1","_id":"ckznhkk9700cfikub8rig590h"},{"post_id":"ckznhkk850049ikubbnkkd4rc","tag_id":"ckznhkk9600c8ikubh4r519w1","_id":"ckznhkk9700cgikubazz3aivf"},{"post_id":"ckznhkk86004dikubgrxt6h3f","tag_id":"ckznhkk9700ceikub689p0otp","_id":"ckznhkk9700ciikubhimcaxur"},{"post_id":"ckznhkk86004gikubffi7fd6x","tag_id":"ckznhkk9700chikubht5wcyw8","_id":"ckznhkk9700ckikubaknwat9l"},{"post_id":"ckznhkk86004gikubffi7fd6x","tag_id":"ckznhkk71000cikub6ulhfyen","_id":"ckznhkk9700clikubc21t4rsz"},{"post_id":"ckznhkk87004kikubgjv38i60","tag_id":"ckznhkk9700cjikubdfpc8585","_id":"ckznhkk9700cnikub3x0n7pt4"},{"post_id":"ckznhkk87004kikubgjv38i60","tag_id":"ckznhkk71000cikub6ulhfyen","_id":"ckznhkk9700coikub9swghojl"},{"post_id":"ckznhkk87004oikubc2yw8bub","tag_id":"ckznhkk9700cmikub05slagb0","_id":"ckznhkk9800cqikubg4boeibi"},{"post_id":"ckznhkk87004oikubc2yw8bub","tag_id":"ckznhkk71000cikub6ulhfyen","_id":"ckznhkk9800crikubhx20hb1j"},{"post_id":"ckznhkk88004sikubgd7tbekk","tag_id":"ckznhkk9800cpikube0uxe7if","_id":"ckznhkk9800ctikub4q1ygcuy"},{"post_id":"ckznhkk88004sikubgd7tbekk","tag_id":"ckznhkk71000cikub6ulhfyen","_id":"ckznhkk9800cuikuba1pu7y6i"},{"post_id":"ckznhkk8c0058ikub8syc34cx","tag_id":"ckznhkk9800csikuba8ytb6fn","_id":"ckznhkk9800cxikub26c9cc9l"},{"post_id":"ckznhkk8c0058ikub8syc34cx","tag_id":"ckznhkk9800cvikubg874f2b1","_id":"ckznhkk9800cyikubgpom7u9c"},{"post_id":"ckznhkk8c0058ikub8syc34cx","tag_id":"ckznhkk71000cikub6ulhfyen","_id":"ckznhkk9800d0ikub52xv0pkb"},{"post_id":"ckznhkk8d005bikub60fjebyi","tag_id":"ckznhkk9800cwikubgbq4g5ey","_id":"ckznhkk9800d1ikub67kwfj8g"},{"post_id":"ckznhkk8e005gikubhlpj9y4s","tag_id":"ckznhkk9800cwikubgbq4g5ey","_id":"ckznhkk9900d3ikubb6bo001o"},{"post_id":"ckznhkk8e005jikubb1hj3z8w","tag_id":"ckznhkk9800cwikubgbq4g5ey","_id":"ckznhkk9900d5ikub8xq07q6b"},{"post_id":"ckznhkk8g005oikub37gad84w","tag_id":"ckznhkk9800cwikubgbq4g5ey","_id":"ckznhkk9900d7ikube04u39c2"},{"post_id":"ckznhkk8h005rikub841q5bo9","tag_id":"ckznhkk9800cwikubgbq4g5ey","_id":"ckznhkk9900d9ikub0afyb86m"},{"post_id":"ckznhkk8i005wikubedbffwit","tag_id":"ckznhkk7n002oikubfgf339fe","_id":"ckznhkk9a00dbikubhizpd6xe"},{"post_id":"ckznhkk8i005wikubedbffwit","tag_id":"ckznhkk9900d8ikub8kjw2lsv","_id":"ckznhkk9a00dcikub9y9816h9"},{"post_id":"ckznhkk8i005wikubedbffwit","tag_id":"ckznhkk7q0031ikubgyjz3i1b","_id":"ckznhkk9a00deikubgezt439v"},{"post_id":"ckznhkk8i005zikubdlliemkp","tag_id":"ckznhkk7n002oikubfgf339fe","_id":"ckznhkk9a00dfikub2cb1gfr2"},{"post_id":"ckznhkk8i005zikubdlliemkp","tag_id":"ckznhkk9900d8ikub8kjw2lsv","_id":"ckznhkk9a00dhikubfhjh7g8g"},{"post_id":"ckznhkk8i005zikubdlliemkp","tag_id":"ckznhkk7q0031ikubgyjz3i1b","_id":"ckznhkk9a00diikub00ub556f"},{"post_id":"ckznhkk8k0066ikubacvabqtp","tag_id":"ckznhkk7n002oikubfgf339fe","_id":"ckznhkk9a00dkikubhxqvdw80"},{"post_id":"ckznhkk8k0066ikubacvabqtp","tag_id":"ckznhkk9900d8ikub8kjw2lsv","_id":"ckznhkk9a00dlikubfv45aitv"},{"post_id":"ckznhkk8k0066ikubacvabqtp","tag_id":"ckznhkk7q0031ikubgyjz3i1b","_id":"ckznhkk9b00dnikub8dz17qmf"},{"post_id":"ckznhkk8k006aikubct7r2880","tag_id":"ckznhkk7n002oikubfgf339fe","_id":"ckznhkk9b00doikub0kli7rvu"},{"post_id":"ckznhkk8k006aikubct7r2880","tag_id":"ckznhkk9900d8ikub8kjw2lsv","_id":"ckznhkk9b00dqikubf0q89fs0"},{"post_id":"ckznhkk8k006aikubct7r2880","tag_id":"ckznhkk7q0031ikubgyjz3i1b","_id":"ckznhkk9b00drikub9k9xgbqp"},{"post_id":"ckznhkk8l006eikubed07b7sj","tag_id":"ckznhkk6y0005ikub1abhbcio","_id":"ckznhkk9b00dtikub4jn14lvh"},{"post_id":"ckznhkk8l006eikubed07b7sj","tag_id":"ckznhkk9a00djikubgd498ok3","_id":"ckznhkk9b00duikub2d09er85"},{"post_id":"ckznhkk8m006iikub70p406e6","tag_id":"ckznhkk6y0005ikub1abhbcio","_id":"ckznhkk9b00dvikub8n6ieuvx"},{"post_id":"ckznhkk8m006iikub70p406e6","tag_id":"ckznhkk71000cikub6ulhfyen","_id":"ckznhkk9b00dxikub5pq68k9l"},{"post_id":"ckznhkk8m006iikub70p406e6","tag_id":"ckznhkk9b00dmikub36998zhg","_id":"ckznhkk9b00dyikub39ub3dfy"},{"post_id":"ckznhkk8m006likub4nor5vxw","tag_id":"ckznhkk6y0005ikub1abhbcio","_id":"ckznhkk9b00e0ikub156m69go"},{"post_id":"ckznhkk8m006likub4nor5vxw","tag_id":"ckznhkk9b00dpikub5ikr369z","_id":"ckznhkk9b00e1ikubhc6beb78"},{"post_id":"ckznhkk8m006likub4nor5vxw","tag_id":"ckznhkk9b00dsikub6xyjddpa","_id":"ckznhkk9c00e3ikub192a3mj3"},{"post_id":"ckznhkk8m006likub4nor5vxw","tag_id":"ckznhkk9b00dwikub3o2o7bbv","_id":"ckznhkk9c00e4ikubf9s07cn9"},{"post_id":"ckznhkk8n006nikub0v73e8hn","tag_id":"ckznhkk6y0005ikub1abhbcio","_id":"ckznhkk9c00e6ikub6bwp7d8x"},{"post_id":"ckznhkk8n006nikub0v73e8hn","tag_id":"ckznhkk9b00dzikub2mbhcmqw","_id":"ckznhkk9c00e7ikubfy0ocr2u"},{"post_id":"ckznhkk8n006nikub0v73e8hn","tag_id":"ckznhkk9c00e2ikub4z05cqx9","_id":"ckznhkk9c00e9ikub1kfk1cko"},{"post_id":"ckznhkk8n006sikubfiq85fn6","tag_id":"ckznhkk6y0005ikub1abhbcio","_id":"ckznhkk9c00eaikubfuo65hve"},{"post_id":"ckznhkk8n006sikubfiq85fn6","tag_id":"ckznhkk9b00dzikub2mbhcmqw","_id":"ckznhkk9c00ecikubh6smhzvs"},{"post_id":"ckznhkk8n006sikubfiq85fn6","tag_id":"ckznhkk71000cikub6ulhfyen","_id":"ckznhkk9c00edikub234d8z7f"},{"post_id":"ckznhkk8o006vikub3vib9425","tag_id":"ckznhkk6y0005ikub1abhbcio","_id":"ckznhkk9d00efikub92i01hvt"},{"post_id":"ckznhkk8o006vikub3vib9425","tag_id":"ckznhkk9c00e8ikub1lhsc4k8","_id":"ckznhkk9d00egikubb93b1a81"},{"post_id":"ckznhkk8o006vikub3vib9425","tag_id":"ckznhkk71000cikub6ulhfyen","_id":"ckznhkk9d00eiikub84s7267c"},{"post_id":"ckznhkk8p0071ikubb83xg2wc","tag_id":"ckznhkk6y0005ikub1abhbcio","_id":"ckznhkk9d00ejikub0jzx84s4"},{"post_id":"ckznhkk8p0071ikubb83xg2wc","tag_id":"ckznhkk92009tikub3pgkb4vy","_id":"ckznhkk9d00elikub3l1s6amb"},{"post_id":"ckznhkk8p0071ikubb83xg2wc","tag_id":"ckznhkk71000cikub6ulhfyen","_id":"ckznhkk9d00emikubccpe1lvw"},{"post_id":"ckznhkk8q0076ikub1xl7djma","tag_id":"ckznhkk6y0005ikub1abhbcio","_id":"ckznhkk9d00enikubekc31bek"},{"post_id":"ckznhkk8q0076ikub1xl7djma","tag_id":"ckznhkk9c00eeikub3c1ne0ov","_id":"ckznhkk9d00epikub5cu09i6m"},{"post_id":"ckznhkk8q0079ikub9abgdj7f","tag_id":"ckznhkk6y0005ikub1abhbcio","_id":"ckznhkk9e00eqikub8wywgt7c"},{"post_id":"ckznhkk8q0079ikub9abgdj7f","tag_id":"ckznhkk9d00ehikub7bp8656b","_id":"ckznhkk9e00esikub2kig7kjz"},{"post_id":"ckznhkk8r007hikubdyaj5rct","tag_id":"ckznhkk6y0005ikub1abhbcio","_id":"ckznhkk9e00etikub9kxf06ms"},{"post_id":"ckznhkk8r007hikubdyaj5rct","tag_id":"ckznhkk9d00ekikub2xkbdrx9","_id":"ckznhkk9e00euikub81pyac1r"},{"post_id":"ckznhkk8t007tikub5qwi8q23","tag_id":"ckznhkk7n002oikubfgf339fe","_id":"ckznhkk9e00evikubcfoffby8"},{"post_id":"ckznhkk8t007tikub5qwi8q23","tag_id":"ckznhkk9900d8ikub8kjw2lsv","_id":"ckznhkk9e00ewikubf0yw8i6t"},{"post_id":"ckznhkk8t007tikub5qwi8q23","tag_id":"ckznhkk7q0031ikubgyjz3i1b","_id":"ckznhkk9e00exikub9kra38xf"},{"post_id":"ckznhkk8u0081ikub4mwz7rns","tag_id":"ckznhkk7n002oikubfgf339fe","_id":"ckznhkk9e00eyikub4p377zzh"},{"post_id":"ckznhkk8u0081ikub4mwz7rns","tag_id":"ckznhkk9900d8ikub8kjw2lsv","_id":"ckznhkk9e00ezikubbas2fexn"},{"post_id":"ckznhkk8u0081ikub4mwz7rns","tag_id":"ckznhkk7q0031ikubgyjz3i1b","_id":"ckznhkk9e00f0ikubgm5wbrhi"}],"Tag":[{"name":"JavaScript","_id":"ckznhkk6y0005ikub1abhbcio"},{"name":"随笔","_id":"ckznhkk71000cikub6ulhfyen"},{"name":"webpack","_id":"ckznhkk73000gikub0zsg2fhv"},{"name":"文件hash","_id":"ckznhkk75000mikubeeb8ay92"},{"name":"css","_id":"ckznhkk76000rikub51as3sb0"},{"name":"sass","_id":"ckznhkk79000zikub7vfz5ltp"},{"name":"项目","_id":"ckznhkk7c001dikubaayid7he"},{"name":"微信小程序","_id":"ckznhkk7d001likub560e8oby"},{"name":"uniapp","_id":"ckznhkk7g001tikubfezbgm80"},{"name":"性能优化","_id":"ckznhkk7k002aikubdeodhfiy"},{"name":"跨域","_id":"ckznhkk7l002hikubb9dm3gbf"},{"name":"Vue","_id":"ckznhkk7n002oikubfgf339fe"},{"name":"Vue3","_id":"ckznhkk7o002vikub7acy23ql"},{"name":"文档","_id":"ckznhkk7q0031ikubgyjz3i1b"},{"name":"JQuery","_id":"ckznhkk7r0037ikub8ptx5cty"},{"name":"React","_id":"ckznhkk7v003eikubhnux1snk"},{"name":"elementUI","_id":"ckznhkk80003likub0a1ihqmp"},{"name":"router","_id":"ckznhkk82003tikub1qr11w8h"},{"name":"npm","_id":"ckznhkk850048ikub4sd973ix"},{"name":"vue","_id":"ckznhkk86004fikub6l292t6c"},{"name":"CSS","_id":"ckznhkk87004nikubgkojbdn9"},{"name":"HTML","_id":"ckznhkk89004wikub8amfdsui"},{"name":"border-radius","_id":"ckznhkk8e005likubc0hwabhb"},{"name":"flex","_id":"ckznhkk8i0061ikub8bif3m5i"},{"name":"外边距合并","_id":"ckznhkk8l006hikub98ahgwb7"},{"name":"长度单位","_id":"ckznhkk8o006wikub3899cw8a"},{"name":"元素选择器","_id":"ckznhkk8r007bikub7yzp2seh"},{"name":"margin","_id":"ckznhkk8t007rikubgb1zakvl"},{"name":"parseInt","_id":"ckznhkk8w008dikub08tc3tkd"},{"name":"浅拷贝","_id":"ckznhkk8x008jikubfwngbo4x"},{"name":"深拷贝","_id":"ckznhkk8x008rikub0jiiggpv"},{"name":"call","_id":"ckznhkk8y008xikub0rat38aa"},{"name":"apply","_id":"ckznhkk8z0093ikub1nuu12w4"},{"name":"bind","_id":"ckznhkk8z0098ikub4kbv75z1"},{"name":"源码","_id":"ckznhkk90009dikub1be43zs3"},{"name":"WebWorker","_id":"ckznhkk91009hikubbaxsetls"},{"name":"eval","_id":"ckznhkk91009nikub4sv09lz9"},{"name":"Array","_id":"ckznhkk92009tikub3pgkb4vy"},{"name":"map函数","_id":"ckznhkk9300acikubb9oi2r04"},{"name":"BFC","_id":"ckznhkk9400arikub7pp57wwi"},{"name":"VueRouter","_id":"ckznhkk9400awikub8fxk1x4x"},{"name":"生命周期","_id":"ckznhkk9400b1ikub3u9a3av5"},{"name":"Vue3的不同","_id":"ckznhkk9500b7ikub4n9a5jj1"},{"name":"Node JS","_id":"ckznhkk9500bcikubc8961o13"},{"name":"fs","_id":"ckznhkk9500bhikub55at9hsu"},{"name":"事件循环","_id":"ckznhkk9500bkikub1vkpcnpe"},{"name":"安装教程","_id":"ckznhkk9500bqikub2bl07rks"},{"name":"NodeJS","_id":"ckznhkk9600bvikubfv6u61mz"},{"name":"Cookie","_id":"ckznhkk9600c1ikub5c9a6xhf"},{"name":"LocalStorage","_id":"ckznhkk9600c4ikub1w5e0k0n"},{"name":"SessionStorage","_id":"ckznhkk9600c7ikubeoqv28ga"},{"name":"HTTP","_id":"ckznhkk9600c8ikubh4r519w1"},{"name":"TCP","_id":"ckznhkk9700ceikub689p0otp"},{"name":"状态码","_id":"ckznhkk9700chikubht5wcyw8"},{"name":"缓存策略","_id":"ckznhkk9700cjikubdfpc8585"},{"name":"RESTful架构","_id":"ckznhkk9700cmikub05slagb0"},{"name":"Git","_id":"ckznhkk9800cpikube0uxe7if"},{"name":"回流和重绘","_id":"ckznhkk9800csikuba8ytb6fn"},{"name":"性能","_id":"ckznhkk9800cvikubg874f2b1"},{"name":"bug","_id":"ckznhkk9800cwikubgbq4g5ey"},{"name":"Vue2","_id":"ckznhkk9900d8ikub8kjw2lsv"},{"name":"Promise","_id":"ckznhkk9a00djikubgd498ok3"},{"name":"箭头函数","_id":"ckznhkk9b00dmikub36998zhg"},{"name":"冒泡","_id":"ckznhkk9b00dpikub5ikr369z"},{"name":"捕获","_id":"ckznhkk9b00dsikub6xyjddpa"},{"name":"事件委托","_id":"ckznhkk9b00dwikub3o2o7bbv"},{"name":"ES6","_id":"ckznhkk9b00dzikub2mbhcmqw"},{"name":"解构赋值","_id":"ckznhkk9c00e2ikub4z05cqx9"},{"name":"原型链","_id":"ckznhkk9c00e8ikub1lhsc4k8"},{"name":"数据类型判断","_id":"ckznhkk9c00eeikub3c1ne0ov"},{"name":"迭代器","_id":"ckznhkk9d00ehikub7bp8656b"},{"name":"类型转换","_id":"ckznhkk9d00ekikub2xkbdrx9"}]}}