---
title: 零钱兑换
tags:
  - 算法
  - 中等
categories:
  - 算法
  - 中等
date: 2023-08-17 14:14:00
---

# 零钱兑换

```
https://leetcode.cn/problems/coin-change/description/
```

## 描述

给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。

计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。

你可以认为每种硬币的数量是无限的。

 

示例 1：

输入：coins = [1, 2, 5], amount = 11
输出：3 
解释：11 = 5 + 5 + 1
示例 2：

输入：coins = [2], amount = 3
输出：-1
示例 3：

输入：coins = [1], amount = 0
输出：0
 

提示：

1 <= coins.length <= 12
1 <= coins[i] <= 231 - 1
0 <= amount <= 104


## 算法


### 递归

递归的思路比较简单，就是循环往下递归下去就行了

```JavaScript

/**
 * @param {number[]} coins
 * @param {number} amount
 * @return {number}
 */
var coinChange = function(coins, amount) {
  const len = coins.length;
  let min = Infinity;
  
  const recur = (value, number) => {
    if (value === amount) {
      min = Math.min(number, min);
      return;
    }
    if (value > amount) {
      return;
    }

    for (let i=0; i<len; i++) {
      recur(value+coins[i], number+1);
    }
  }

  recur(0, 0)
  return min === Infinity ? -1 : min;
};

```


### 递归+动态规划 = 记忆化搜索

递归是很容易出现超时的
但是里面是存在很多重复的计算的
所以使用记忆化搜索，解决这个问题


```JavaScript

/**
 * @param {number[]} coins
 * @param {number} amount
 * @return {number}
 */
var coinChange = function(coins, amount) {
  const len = coins.length;
  let min = Infinity;
  const dp = {};
  
  const recur = (value, number) => {
    if (value === amount) {
      min = Math.min(number, min);
      return;
    }
    if (value > amount) {
      return;
    }
    // 增加了一个存储计算情况
    dp[value] = dp[value] ? Math.min(dp[value], number) : number;
    for (let i=0; i<len; i++) {
      const resValue = amount - coins[1];
      if (resValue === value && dp[resValue]) {
        min = Math.min(dp[resValue] + number, min);
      } else {
        recur(value+coins[i], number+1);
      }
    }
  }

  recur(0, 0)
  return min === Infinity ? -1 : min;
};

```

### 动态规划

动态规划的思路就是，从低到高的计算每个值的最小次数
然后计算到n时就会存在结果了。

```JavaScript

/**
 * @param {number[]} coins
 * @param {number} amount
 * @return {number}
 */
var coinChange = function(coins, amount) {
  const len = coins.length;
  coins.sort((a, b) => a-b);
  const dp = new Array(amount+1).fill(Infinity);
  dp[0] = 0;
  for (let i=1; i<=amount; i++) {
    for (let j=0; j<len; j++) {
      const value = i-coins[j];
      // 因为前面排过序，所以 value<0 后面的值肯定只会小于零，所以提前break
      if (value < 0) {
        break;
      }
      // dp[i] 则更新最小值。
      dp[i] = Math.min(dp[value]+1, dp[i]);
    }
  }
  return dp[amount] === Infinity ? -1 : dp[amount];
};

```
