---
title: 长度最小的子数组
date: 2023-07-05 16:53:06
tags:
 - 算法
categories:
 - 算法
 - 中等
 - 滑动窗口
---


# 长度最小的子数组

```
https://leetcode.cn/problems/minimum-size-subarray-sum/description/
```

## 描述

给定一个含有 n 个正整数的数组和一个正整数 target 。

找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。

 

示例 1：

输入：target = 7, nums = [2,3,1,2,4,3]
输出：2
解释：子数组 [4,3] 是该条件下的长度最小的子数组。
示例 2：

输入：target = 4, nums = [1,4,4]
输出：1
示例 3：

输入：target = 11, nums = [1,1,1,1,1,1,1,1]
输出：0
 

提示：

1 <= target <= 109
1 <= nums.length <= 105
1 <= nums[i] <= 105


## 算法

首先所有的数都是正数。
这个其实一看就可以感觉得到，可以使用滑动窗口，就是从左往右添加值。
如果 >= ： 那么就是满足条件的，可以将其记录下来。
  然后 left++ 往后移动，查找是否会有可能存在更小的。
  如果此时刚好 left === right 那么直接 return 1，因为没有比 1更小了。
如果 < ：那么代表不满足条件，right++ 
如果 right>=length 代表循环已经结束，可以结束。

```

/**
 * @param {number} target
 * @param {number[]} nums
 * @return {number}
 */
var minSubArrayLen = function(target, nums) {
  let left = 0, right = 0;
  let res = 0;
  let resNum = Infinity;
  // 需要这个 flag 去判断是否需要加，因为在 刚刚移动了 left 之后，right不会移动，
  // 那么此时是不能加的，要过一次循环代表这次判断结束了，才能加
  let isAdd = true;

  while (right < nums.length) {
    if (!isAdd) {
      isAdd = true;
    } else {
      res += nums[right];
    }
    if (res >= target) {
      resNum = Math.min(resNum, right - left);
      if (left === right) {
        // 一定是最小的，没有其他可以被满足
        return 1;
      }

      res -= nums[left];
      isAdd = false;
      left++;
    } else if (res < target) {
      right++;
    }
  }

  
  return Infinity === resNum ? 0 : resNum + 1;
};

```


两个解法并没有什么不同，只是 一个是使用 add flag 去判断是否需要添加
另一个是直接用内部循环去计算完成。

```

/**
 * @param {number} target
 * @param {number[]} nums
 * @return {number}
 */
var minSubArrayLen = function(target, nums) {
  let left = 0, right = 0;
  let res = 0;
  let resNum = Infinity;

  while (right < nums.length) {
    res += nums[right];
    while (res >= target) {
      resNum = Math.min(resNum, right - left);
      if (left === right) {
        // 一定是最小的，没有其他可以被满足
        return 1;
      }

      res -= nums[left];
      left++;
    }
    right++;
  }
  
  return Infinity === resNum ? 0 : resNum + 1;
};

```
