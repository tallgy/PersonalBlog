---
title: 全排列
tags:
  - 算法
  - 中等
categories:
  - 算法
  - 中等
date: 2023-09-02 22:07:47
---

# 全排列

```
https://leetcode.cn/problems/permutations/description/
```

## 描述

给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。

 

示例 1：

输入：nums = [1,2,3]
输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
示例 2：

输入：nums = [0,1]
输出：[[0,1],[1,0]]
示例 3：

输入：nums = [1]
输出：[[1]]
 

提示：

1 <= nums.length <= 6
-10 <= nums[i] <= 10
nums 中的所有整数 互不相同

## 算法

### 递归

就是每次都全部循环递归，但是加一个对象存储判断是否有已经加入的数组，进行跳过。
当然也可以直接在循环里面创建一个新的数组，然后删除已经加入的，然后再作为参数递归下去。本质是一样的

```JavaScript
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var permute = function(nums) {
  const res = [];
  const len = nums.length;
  const obj = {};

  const recur = (arr) => {
    if (arr.length === len) {
      res.push(arr);
      return;
    }

    for (let i=0; i<len; i++) {
      const v = nums[i];
      if (obj[v]) {
        continue;
      }
      obj[v] = true;
      recur([...arr, v]);
      obj[v] = false;
    }
  }

  recur([]);

  return res;
};

```



### 回溯法

本质还是一样的，只是用的操作是将两个数组值进行交换
然后进入下一个递归，再次交换，然后一直到最后一个。

```JavaScript
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var permute = function(nums) {
  const res = [];
  const len = nums.length;

  const recur = (arr, index) => {
    if (index === len-1) {
      res.push([...arr]);
      return;
    }

    for (let i=index; i<len; i++) {
      [arr[i], arr[index]] = [arr[index], arr[i]];
      recur(arr, index+1);
      [arr[i], arr[index]] = [arr[index], arr[i]];
    }
  }

  recur(nums, 0);

  return res;
};

```
