---
title: 动态规划-最长回文子串
date: 2023-07-01 15:58:54
tags:
 - 算法
categories:
 - 算法
 - 中等
---

# 最长回文子串

```
https://leetcode.cn/problems/longest-palindromic-substring/description/
```

## 描述

给你一个字符串 s，找到 s 中最长的回文子串。

如果字符串的反序与原始字符串相同，则该字符串称为回文字符串。

 

示例 1：

输入：s = "babad"
输出："bab"
解释："aba" 同样是符合题意的答案。
示例 2：

输入：s = "cbbd"
输出："bb"
 

提示：

1 <= s.length <= 1000
s 仅由数字和英文字母组成


# 动态规划解法

    简单来说，回文串的特点就是，其去掉收尾也是回文串，
      所以: 如果 dp[i][j] 是回文串，那么 dp[i+1][j-1] 也应该是回文串。
      所以 判断 dp[i][j] 是否是回文串的方法
        1、s[i] === s[j] && dp[i+1][j-1] === true
        2、s[i] === s[j] && j-i<2 // 表明是串的长度小于2的回文。

```

/**
 * @param {string} s
 * @return {string}
 */
var longestPalindrome = function(s) {
  let n = s.length;
  let res = '';
  // 使用 from 方法 进行 赋值。因为 fill 方法对于引用类型，会直接引用过去。
  let dp = Array.from(new Array(n),() => new Array(n).fill(0));
  // 这里需要让 i 从 后面往前，
  //  因为我们的判断是判断 dp[i+1][j-1] 
  //  如果我们不先把下面的dp先算出来，那么就会出现 dp[i+1][j-1] 的结果是错误的
  for(let i = n-1;i >= 0;i--) {
      for(let j = i;j < n;j++) {
          // 判断逻辑
          dp[i][j] = s[i] == s[j] && (j - i < 2 || dp[i+1][j-1]);

          // 获取最长的子串
          if(dp[i][j] && j - i +1 > res.length) {
              res = s.substring(i,j+1);
          }
      }
  }

  return res;
};


```


## 中心扩散算法

    中心扩散的算法，大致的逻辑思想比动态规划算法要简单一点
    就是，如果这个子串是回文串，那么去掉收尾也是回文串。然后到最后会有一个临界值。
    所以我们反过来想。
    然后依次将每个串都当作临界值，然后依次首尾相加判断是否为回文串即可。
    注意，需要考虑到奇数和偶数个回文串问题，所以临界值是 当前的 i 和 后面的 i+1

```

/**
 * @param {string} s
 * @return {string}
 */
var longestPalindrome = function(s) {
  const len = s.length;
  let start = 0, end = 0;

  // 中心扩散算法
  const centerFn = (s, left, right) => {
    // 如果 left 和 right 相等， 且 处于字符串内，那么继续往外扩张
    while (s[left] === s[right] && left>=0 && right < s.length) {
      left--;
      right++;
    }
    // 结束，获取长度，使用 -1 是因为，此时的 right 和 left 已经是 溢出的。
    // 比如 assd 那么就会溢出到 a、d 两侧。
    return right-left-1;
  }

  for (let i=0; i<len; i++) {
    // 获取最长的 len
    const maxLen = Math.max(centerFn(s, i, i), centerFn(s, i, i+1));
    // 如果 maxLen 是超过了 以前 的最长值，那么更新
    if (maxLen > end - start + 1) {
      start = i - Math.floor((maxLen-1) / 2);
      end = i + Math.floor(maxLen / 2);
    }
  }

  return s.substring(start, end+1);
};

```
