---
title: 数据类型判断
tags:
  - JavaScript
  - 数据类型判断
date: 2021-10-17 15:08:23
---




# JavaScript判断数据的类型的方法



```
let a = 1,
    b = 'a',
    c = true,
    d = undefined,
    e = null,
    f = [1, 2, 3],
    g = ['1', '3'],
    h = new Number(3),
    i = new String('12'),
    j = new Boolean(false),
    k = new Object({ a: 3} ),
    l = { b: 4 },
    m = function () {},
    n = new Date(),
    o = new RegExp('sss'),
    p = /sss/,
    q = `sdcard`;
```

## typeof

```
https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/typeof
```

```
console.log('a ----     ' + typeof a);
console.log('b ----     ' + typeof b);
console.log('c ----     ' + typeof c);
console.log('d ----     ' + typeof d);
console.log('e ----     ' + typeof e);
console.log('f ----     ' + typeof f);
console.log('g ----     ' + typeof g);
console.log('h ----     ' + typeof h);
console.log('i ----     ' + typeof i);
console.log('j ----     ' + typeof j);
console.log('k ----     ' + typeof k);
console.log('l ----     ' + typeof l);
console.log('m ----     ' + typeof m);
console.log('n ----     ' + typeof n);
console.log('o ----     ' + typeof o);
console.log('p ----     ' + typeof p);
console.log('q ----     ' + typeof q);
```

```
a ----     number
b ----     string
c ----     boolean
d ----     undefined
e ----     object
f ----     object
g ----     object
h ----     object
i ----     object
j ----     object
k ----     object
l ----     object
m ----     function
n ----     object
o ----     object
p ----     object
q ----     string
```

这里的话，主要问题是在于一个 null  的 typeof 的值为 object，至于原因的话

```
https://2ality.com/2013/10/typeof-null.html
```

通过这篇文章我们可以知道原理，我这里就简单的说一下

```
首先，早期的JavaScript是通过值的低1位或3位来辨别类型的。
又下面所示
```

```
000：对象。数据是对对象的引用。
1：整数。数据是一个 31 位有符号整数。
010：双倍。数据是对双浮点数的引用。
100：字符串。数据是对字符串的引用。
110：布尔值。数据是一个布尔值。

undefined，用整数−2^30（负2的30次方，不在整型的范围内）
null，机器码空指针（C/C++ 宏定义），低三位也是000
```

```
所以就出现了这种 typeof null = 'object';
```



## instanceof

```
https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/instanceof
```

`instanceof` 运算符用于检测构造函数的 `prototype` 属性是否出现在某个实例对象的原型链上。

```
console.log('a ----     ' + a instanceof Number);
```

```
对于基本数据类型会返回false。
否则的话，就会先通过 Object.getPrototypeOf 获得参数的原型对象。然后判断这个和你要判断的对象是否相等，不想等则会继续向上，直到相等或者为 null 时。
```



## constructor

```
https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Classes/constructor
```

**`constructor `**是一种用于创建和初始化`class`创建的对象的特殊方法。

你可以这样理解，一个对象的constructor的指向的是他所 new 而指向的方法。

```
function O() {}
let o = new O();

o.constructor === O; //true
```

```
console.log('a ----     ' + (a.constructor === Number));
true
```

```
这里，在a调用constructor的时候，会在内部创建一个值为a的对象，然后再调用这个constructor方法，然后再将这个对象删除，所以这个是基本数据类型也可以进行判断的。
```

```
这个输出的值是 a的构造器所指向的一个函数。在这里就是指向的Number，
问题：这个因为是通过判断其构造器函数来进行的判断，所以如果我们将对其进行过修改则会判断错误。
```

```
function Fn() {}
let x = new Fn();
Fn.prototype = new Array();
console.log(x.constructor === Fn)		//true
console.log(x.constructor === Array)	//false
```

```
function Fn() {}
Fn.prototype = new Array();
let x = new Fn();
console.log(x.constructor === Fn)		//false
console.log(x.constructor === Array)	//ture
```

**这里不对，需要查看资料**

通过上面这个代码我们可以知道，

一个new方法，会调用的是他的那个原型的方法进行 `new` 方法的调用

```
第一个是先new，然后在修改的原型。
而第二个是先修改原型，然后再进行new方法的调用。
然后结果就不一样了，所以说明了这个new方法会调用的是原型。
所以其构造器会被修改。
```



## prototype

```
https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/toString
```

使用方法

```
Object.prototype.toString.call(a);
这里通过调用了call方法，转换了this的指向。
```

```
console.log('a ----     ' + Object.prototype.toString.call(a));
console.log('b ----     ' + Object.prototype.toString.call(b));
console.log('c ----     ' + Object.prototype.toString.call(c));
console.log('d ----     ' + Object.prototype.toString.call(d));
console.log('e ----     ' + Object.prototype.toString.call(e));
```

```
a ----     [object Number]
b ----     [object String]
c ----     [object Boolean]
d ----     [object Undefined]
e ----     [object Null]
```

