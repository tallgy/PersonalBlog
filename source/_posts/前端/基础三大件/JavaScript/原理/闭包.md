---
title: 闭包
date: 2023-07-08 17:01:13
tags:
 - JavaScript
categories:
 - JavaScript
---


# 闭包


# 什么是闭包

由于在 JavaScript 中，变量的作用域是 函数级作用域 ，所以在函数执行后，作用域会被清理，同时内存也会被销毁。 但是由于 JavaScript 中，内部作用域可以访问上级作用域的原因。 所以导致了，即使上级函数执行完，因为内部访问，所以作用域也不会被销毁， 这时，子函数就是一个闭包，拥有了访问上级作用域的变量的权限，即使，上级函数执行完成之后， 作用域的值也不会销毁。


# 闭包解决了什么问题

本质上，闭包就是将函数内部和函数外部连接起来的一个桥梁

```

由于闭包可以缓存上级作用域，那么就使得函数外部打破了“ 函数作用域 ”的束缚，可以访问函数内部的变量。
以平时使用的 AJAX 成功回调为例，这里其实就是个闭包，由于上述的特性，
回调就拥有了整个上级作用域的访问和操作能力，提高了极大的便利。
开发者不用去学钩子函数来操作上级函数作用域内部的变量了

```

## 好处

1） 一个是可以读取函数内部的变量；
2） 另一个就是让这些变量的值始终保存在内存中。


## 应用场景

回调函数（Ajax， 事件绑定），简而言之，无论使用何种方式对函数类型的值进行传递，当函数在别处被调用时，都有闭包的身影

## 特性 

1、函数内部嵌套函数
2、函数内部可以引用外部的变量
3、参数和变量不会被垃圾回收机制回收


# 闭包的问题


**代码维护**，特别是异步加上了闭包
**内存消耗大**：性能问题。**解决办法**：在退出函数之前，将不使用的局部变量全部删除。
**this指向**：指向的是window

在比如存在异步加各个函数嵌套的情况下，闭包会影响很多，我也遇到过好多次，当时都找不到问题原因在哪。。
  主要产生的原因就是异步加上了浏览器事件，所以就导致了每次取值其实都是用的闭包。


# 闭包深度理解

## 闭包是不回收引用的那个对象还是不回收外部整个作用域，你是怎么验证这一点的

```
https://www.iteye.com/blog/justjavac-1465169
```

对于不同的浏览器的js引擎可能会有不同，这个取决于gc，垃圾回收机制，我当时是使用的谷歌的v8引擎验证，发现对于不使用的会被回收，至于验证的方法，我是在浏览器里面通过断点调试，查看变量是否存在来判断的，当然还可以对代码执行以后强制进行一次垃圾回收，来查看内存的变化来判断回收的是对象还是整个作用域。


